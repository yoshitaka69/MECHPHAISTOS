"use strict";

exports.__esModule = true;
require("core-js/modules/es.error.cause.js");
var _object = require("../helpers/object");
var _localHooks = _interopRequireDefault(require("./../mixins/localHooks"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
/**
 * The Transformation class implements algorithms for transforming coordinates based on current settings
 * passed to the Handsontable. The class performs the calculations based on the renderable indexes.
 *
 * Transformation is always applied relative to the current selection.
 *
 * The class operates on a table size defined by the renderable indexes. If the `navigableHeaders`
 * option is enabled, the table size is increased by the number of row and/or column headers.
 * Because the headers are treated as cells as part of the table size (indexes always go from 0 to N),
 * the algorithm can be written as simply as possible (without new if's that distinguish the headers
 * logic).
 *
 * @class Transformation
 * @util
 */
var _range = /*#__PURE__*/new WeakMap();
var _options = /*#__PURE__*/new WeakMap();
var _offset = /*#__PURE__*/new WeakMap();
var _setOffsetSize = /*#__PURE__*/new WeakSet();
var _clampCoords = /*#__PURE__*/new WeakSet();
var _getTableSize = /*#__PURE__*/new WeakSet();
var _visualToZeroBasedCoords = /*#__PURE__*/new WeakSet();
var _zeroBasedToVisualCoords = /*#__PURE__*/new WeakSet();
class Transformation {
  constructor(range, options) {
    /**
     * Translates the zero-based coordinates to visual ones.
     *
     * @param {CellCoords} zeroBasedCoords The coordinates to process.
     * @returns {CellCoords}
     */
    _classPrivateMethodInitSpec(this, _zeroBasedToVisualCoords);
    /**
     * Translates the visual coordinates to zero-based ones.
     *
     * @param {CellCoords} visualCoords The visual coords to process.
     * @returns {CellCoords}
     */
    _classPrivateMethodInitSpec(this, _visualToZeroBasedCoords);
    /**
     * Gets the table size in number of rows with headers as "height" and number of columns with
     * headers as "width".
     *
     * @returns {{width: number, height: number}}
     */
    _classPrivateMethodInitSpec(this, _getTableSize);
    /**
     * Clamps the coords to make sure they points to the cell (or header) in the table range.
     *
     * @param {CellCoords} zeroBasedCoords The coords object to clamp.
     * @returns {{rowDir: 1|0|-1, colDir: 1|0|-1}}
     */
    _classPrivateMethodInitSpec(this, _clampCoords);
    /**
     * Sets the additional offset in table size that may occur when the `navigableHeaders` option
     * is enabled.
     *
     * @param {{x: number, y: number}} offset Offset as x and y properties.
     */
    _classPrivateMethodInitSpec(this, _setOffsetSize);
    /**
     * Instance of the SelectionRange, holder for visual coordinates applied to the table.
     *
     * @type {SelectionRange}
     */
    _classPrivateFieldInitSpec(this, _range, {
      writable: true,
      value: void 0
    });
    /**
     * Additional options which define the state of the settings which can infer transformation and
     * give the possibility to translate indexes.
     *
     * @type {object}
     */
    _classPrivateFieldInitSpec(this, _options, {
      writable: true,
      value: void 0
    });
    /**
     * Increases the table size by applying the offsets. The option is used by the `navigableHeaders`
     * option.
     *
     * @type {{ x: number, y: number }}
     */
    _classPrivateFieldInitSpec(this, _offset, {
      writable: true,
      value: {
        x: 0,
        y: 0
      }
    });
    _classPrivateFieldSet(this, _range, range);
    _classPrivateFieldSet(this, _options, options);
  }

  /**
   * Selects cell relative to the current cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will
   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.
   * @returns {CellCoords} Visual coordinates after transformation.
   */
  transformStart(rowDelta, colDelta) {
    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    _classPrivateMethodGet(this, _setOffsetSize, _setOffsetSize2).call(this, {
      x: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countRowHeaders() : 0,
      y: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countColHeaders() : 0
    });
    const delta = _classPrivateFieldGet(this, _options).createCellCoords(rowDelta, colDelta);
    let visualCoords = _classPrivateFieldGet(this, _range).current().highlight;
    const highlightRenderableCoords = _classPrivateFieldGet(this, _options).visualToRenderableCoords(visualCoords);
    let rowTransformDir = 0;
    let colTransformDir = 0;
    this.runLocalHooks('beforeTransformStart', delta);
    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {
      const {
        width,
        height
      } = _classPrivateMethodGet(this, _getTableSize, _getTableSize2).call(this);
      const {
        row,
        col
      } = _classPrivateMethodGet(this, _visualToZeroBasedCoords, _visualToZeroBasedCoords2).call(this, visualCoords);
      const fixedRowsBottom = _classPrivateFieldGet(this, _options).fixedRowsBottom();
      const minSpareRows = _classPrivateFieldGet(this, _options).minSpareRows();
      const minSpareCols = _classPrivateFieldGet(this, _options).minSpareCols();
      const autoWrapRow = _classPrivateFieldGet(this, _options).autoWrapRow();
      const autoWrapCol = _classPrivateFieldGet(this, _options).autoWrapCol();
      const zeroBasedCoords = _classPrivateFieldGet(this, _options).createCellCoords(row + delta.row, col + delta.col);
      if (zeroBasedCoords.row >= height) {
        const isActionInterrupted = (0, _object.createObjectPropListener)(createMissingRecords && minSpareRows > 0 && fixedRowsBottom === 0);
        const nextColumn = zeroBasedCoords.col + 1;
        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(zeroBasedCoords.row - height, nextColumn >= width ? nextColumn - width : nextColumn);
        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), nextColumn >= width);
        if (isActionInterrupted.value) {
          this.runLocalHooks('insertRowRequire', _classPrivateFieldGet(this, _options).countRenderableRows());
        } else if (autoWrapCol) {
          zeroBasedCoords.assign(newCoords);
        }
      } else if (zeroBasedCoords.row < 0) {
        const isActionInterrupted = (0, _object.createObjectPropListener)(autoWrapCol);
        const previousColumn = zeroBasedCoords.col - 1;
        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(height + zeroBasedCoords.row, previousColumn < 0 ? width + previousColumn : previousColumn);
        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), previousColumn < 0);
        if (autoWrapCol) {
          zeroBasedCoords.assign(newCoords);
        }
      }
      if (zeroBasedCoords.col >= width) {
        const isActionInterrupted = (0, _object.createObjectPropListener)(createMissingRecords && minSpareCols > 0);
        const nextRow = zeroBasedCoords.row + 1;
        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(nextRow >= height ? nextRow - height : nextRow, zeroBasedCoords.col - width);
        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), nextRow >= height);
        if (isActionInterrupted.value) {
          this.runLocalHooks('insertColRequire', _classPrivateFieldGet(this, _options).countRenderableColumns());
        } else if (autoWrapRow) {
          zeroBasedCoords.assign(newCoords);
        }
      } else if (zeroBasedCoords.col < 0) {
        const isActionInterrupted = (0, _object.createObjectPropListener)(autoWrapRow);
        const previousRow = zeroBasedCoords.row - 1;
        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(previousRow < 0 ? height + previousRow : previousRow, width + zeroBasedCoords.col);
        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), previousRow < 0);
        if (autoWrapRow) {
          zeroBasedCoords.assign(newCoords);
        }
      }
      const {
        rowDir,
        colDir
      } = _classPrivateMethodGet(this, _clampCoords, _clampCoords2).call(this, zeroBasedCoords);
      rowTransformDir = rowDir;
      colTransformDir = colDir;
      visualCoords = _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, zeroBasedCoords);
    }
    this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);
    return visualCoords;
  }

  /**
   * Sets selection end cell relative to the current selection end cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   * @returns {CellCoords} Visual coordinates after transformation.
   */
  transformEnd(rowDelta, colDelta) {
    _classPrivateMethodGet(this, _setOffsetSize, _setOffsetSize2).call(this, {
      x: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countRowHeaders() : 0,
      y: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countColHeaders() : 0
    });
    const delta = _classPrivateFieldGet(this, _options).createCellCoords(rowDelta, colDelta);
    const cellRange = _classPrivateFieldGet(this, _range).current();
    const highlightRenderableCoords = _classPrivateFieldGet(this, _options).visualToRenderableCoords(cellRange.highlight);
    const visualCoords = cellRange.to.clone();
    let rowTransformDir = 0;
    let colTransformDir = 0;
    this.runLocalHooks('beforeTransformEnd', delta);
    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {
      const {
        row,
        col
      } = _classPrivateMethodGet(this, _visualToZeroBasedCoords, _visualToZeroBasedCoords2).call(this, cellRange.to);
      const coords = _classPrivateFieldGet(this, _options).createCellCoords(row + delta.row, col + delta.col);
      const {
        rowDir,
        colDir
      } = _classPrivateMethodGet(this, _clampCoords, _clampCoords2).call(this, coords);
      rowTransformDir = rowDir;
      colTransformDir = colDir;
      const newVisualCoords = _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, coords);
      if (delta.row === 0 && delta.col !== 0) {
        visualCoords.col = newVisualCoords.col;
      } else if (delta.row !== 0 && delta.col === 0) {
        visualCoords.row = newVisualCoords.row;
      } else {
        visualCoords.row = newVisualCoords.row;
        visualCoords.col = newVisualCoords.col;
      }
    }
    this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);
    return visualCoords;
  }
}
function _setOffsetSize2(_ref) {
  let {
    x,
    y
  } = _ref;
  _classPrivateFieldSet(this, _offset, {
    x,
    y
  });
}
function _clampCoords2(zeroBasedCoords) {
  const {
    width,
    height
  } = _classPrivateMethodGet(this, _getTableSize, _getTableSize2).call(this);
  let rowDir = 0;
  let colDir = 0;
  if (zeroBasedCoords.row < 0) {
    rowDir = -1;
    zeroBasedCoords.row = 0;
  } else if (zeroBasedCoords.row > 0 && zeroBasedCoords.row >= height) {
    rowDir = 1;
    zeroBasedCoords.row = height - 1;
  }
  if (zeroBasedCoords.col < 0) {
    colDir = -1;
    zeroBasedCoords.col = 0;
  } else if (zeroBasedCoords.col > 0 && zeroBasedCoords.col >= width) {
    colDir = 1;
    zeroBasedCoords.col = width - 1;
  }
  return {
    rowDir,
    colDir
  };
}
function _getTableSize2() {
  return {
    width: _classPrivateFieldGet(this, _offset).x + _classPrivateFieldGet(this, _options).countRenderableColumns(),
    height: _classPrivateFieldGet(this, _offset).y + _classPrivateFieldGet(this, _options).countRenderableRows()
  };
}
function _visualToZeroBasedCoords2(visualCoords) {
  const {
    row,
    col
  } = _classPrivateFieldGet(this, _options).visualToRenderableCoords(visualCoords);
  return _classPrivateFieldGet(this, _options).createCellCoords(_classPrivateFieldGet(this, _offset).y + row, _classPrivateFieldGet(this, _offset).x + col);
}
function _zeroBasedToVisualCoords2(zeroBasedCoords) {
  const coords = zeroBasedCoords.clone();
  coords.col = zeroBasedCoords.col - _classPrivateFieldGet(this, _offset).x;
  coords.row = zeroBasedCoords.row - _classPrivateFieldGet(this, _offset).y;
  return _classPrivateFieldGet(this, _options).renderableToVisualCoords(coords);
}
(0, _object.mixin)(Transformation, _localHooks.default);
var _default = exports.default = Transformation;