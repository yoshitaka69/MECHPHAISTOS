import "core-js/modules/es.array.push.js";
import "core-js/modules/es.error.cause.js";
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
import { BasePlugin } from "../base/index.mjs";
import { addClass, closest, hasClass, removeClass, outerHeight, isDetached } from "../../helpers/dom/element.mjs";
import { arrayEach } from "../../helpers/array.mjs";
import { rangeEach } from "../../helpers/number.mjs";
import { PhysicalIndexToValueMap as IndexToValueMap } from "../../translations/index.mjs"; // Developer note! Whenever you make a change in this file, make an analogous change in manualRowResize.js
export const PLUGIN_KEY = 'manualColumnResize';
export const PLUGIN_PRIORITY = 130;
const PERSISTENT_STATE_KEY = 'manualColumnWidths';

/* eslint-disable jsdoc/require-description-complete-sentence */

/**
 * @plugin ManualColumnResize
 * @class ManualColumnResize
 *
 * @description
 * This plugin allows to change columns width. To make columns width persistent the {@link Options#persistentState}
 * plugin should be enabled.
 *
 * The plugin creates additional components to make resizing possibly using user interface:
 * - handle - the draggable element that sets the desired width of the column.
 * - guide - the helper guide that shows the desired width as a vertical guide.
 */
var _currentTH = /*#__PURE__*/new WeakMap();
var _currentCol = /*#__PURE__*/new WeakMap();
var _selectedCols = /*#__PURE__*/new WeakMap();
var _currentWidth = /*#__PURE__*/new WeakMap();
var _newSize = /*#__PURE__*/new WeakMap();
var _startY = /*#__PURE__*/new WeakMap();
var _startWidth = /*#__PURE__*/new WeakMap();
var _startOffset = /*#__PURE__*/new WeakMap();
var _handle = /*#__PURE__*/new WeakMap();
var _guide = /*#__PURE__*/new WeakMap();
var _pressed = /*#__PURE__*/new WeakMap();
var _isTriggeredByRMB = /*#__PURE__*/new WeakMap();
var _dblclick = /*#__PURE__*/new WeakMap();
var _autoresizeTimeout = /*#__PURE__*/new WeakMap();
var _columnWidthsMap = /*#__PURE__*/new WeakMap();
var _config = /*#__PURE__*/new WeakMap();
var _onMapInit = /*#__PURE__*/new WeakSet();
var _onMouseOver = /*#__PURE__*/new WeakSet();
var _onMouseDown = /*#__PURE__*/new WeakSet();
var _onMouseMove = /*#__PURE__*/new WeakSet();
var _onMouseUp = /*#__PURE__*/new WeakSet();
var _onContextMenu = /*#__PURE__*/new WeakSet();
var _onModifyColWidth = /*#__PURE__*/new WeakSet();
var _onBeforeStretchingColumnWidth = /*#__PURE__*/new WeakSet();
var _onBeforeColumnResize = /*#__PURE__*/new WeakSet();
export class ManualColumnResize extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY;
  }

  /**
   * @type {HTMLTableHeaderCellElement}
   */

  constructor(hotInstance) {
    super(hotInstance);
    /**
     * `beforeColumnResize` hook callback.
     */
    _classPrivateMethodInitSpec(this, _onBeforeColumnResize);
    /**
     * Modifies the provided column stretched width. This hook decides if specified column should be stretched or not.
     *
     * @param {number} stretchedWidth Stretched width.
     * @param {number} column Visual column index.
     * @returns {number}
     */
    _classPrivateMethodInitSpec(this, _onBeforeStretchingColumnWidth);
    /**
     * Modifies the provided column width, based on the plugin settings.
     *
     * @param {number} width Column width.
     * @param {number} column Visual column index.
     * @returns {number}
     */
    _classPrivateMethodInitSpec(this, _onModifyColWidth);
    /**
     * Callback for "contextmenu" event triggered on element showing move handle. It removes handle and guide elements.
     */
    _classPrivateMethodInitSpec(this, _onContextMenu);
    /**
     * 'mouseup' event callback - apply the column resizing.
     *
     * @fires Hooks#beforeColumnResize
     * @fires Hooks#afterColumnResize
     */
    _classPrivateMethodInitSpec(this, _onMouseUp);
    /**
     * 'mousemove' event callback - refresh the handle and guide positions, cache the new column width.
     *
     * @param {MouseEvent} event The mouse event.
     */
    _classPrivateMethodInitSpec(this, _onMouseMove);
    /**
     * 'mousedown' event callback.
     *
     * @param {MouseEvent} event The mouse event.
     */
    _classPrivateMethodInitSpec(this, _onMouseDown);
    /**
     * 'mouseover' event callback - set the handle position.
     *
     * @param {MouseEvent} event The mouse event.
     */
    _classPrivateMethodInitSpec(this, _onMouseOver);
    /**
     * Callback to call on map's `init` local hook.
     *
     * @private
     */
    _classPrivateMethodInitSpec(this, _onMapInit);
    _classPrivateFieldInitSpec(this, _currentTH, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _currentCol, {
      writable: true,
      value: null
    });
    /**
     * @type {number[]}
     */
    _classPrivateFieldInitSpec(this, _selectedCols, {
      writable: true,
      value: []
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _currentWidth, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _newSize, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _startY, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _startWidth, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _startOffset, {
      writable: true,
      value: null
    });
    /**
     * @type {HTMLElement}
     */
    _classPrivateFieldInitSpec(this, _handle, {
      writable: true,
      value: this.hot.rootDocument.createElement('DIV')
    });
    /**
     * @type {HTMLElement}
     */
    _classPrivateFieldInitSpec(this, _guide, {
      writable: true,
      value: this.hot.rootDocument.createElement('DIV')
    });
    /**
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _pressed, {
      writable: true,
      value: null
    });
    /**
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _isTriggeredByRMB, {
      writable: true,
      value: false
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _dblclick, {
      writable: true,
      value: 0
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _autoresizeTimeout, {
      writable: true,
      value: null
    });
    /**
     * PhysicalIndexToValueMap to keep and track widths for physical column indexes.
     *
     * @type {PhysicalIndexToValueMap}
     */
    _classPrivateFieldInitSpec(this, _columnWidthsMap, {
      writable: true,
      value: void 0
    });
    /**
     * Private pool to save configuration from updateSettings.
     *
     * @type {object}
     */
    _classPrivateFieldInitSpec(this, _config, {
      writable: true,
      value: void 0
    });
    addClass(_classPrivateFieldGet(this, _handle), 'manualColumnResizer');
    addClass(_classPrivateFieldGet(this, _guide), 'manualColumnResizerGuide');
  }

  /**
   * @private
   * @returns {string}
   */
  get inlineDir() {
    return this.hot.isRtl() ? 'right' : 'left';
  }

  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualColumnResize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY];
  }

  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    _classPrivateFieldSet(this, _columnWidthsMap, new IndexToValueMap());
    _classPrivateFieldGet(this, _columnWidthsMap).addLocalHook('init', () => _classPrivateMethodGet(this, _onMapInit, _onMapInit2).call(this));
    this.hot.columnIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet(this, _columnWidthsMap));
    this.addHook('modifyColWidth', (width, col) => _classPrivateMethodGet(this, _onModifyColWidth, _onModifyColWidth2).call(this, width, col));
    this.addHook('beforeStretchingColumnWidth', (stretchedWidth, column) => _classPrivateMethodGet(this, _onBeforeStretchingColumnWidth, _onBeforeStretchingColumnWidth2).call(this, stretchedWidth, column));
    this.addHook('beforeColumnResize', (newSize, column, isDoubleClick) => _classPrivateMethodGet(this, _onBeforeColumnResize, _onBeforeColumnResize2).call(this, newSize, column, isDoubleClick));
    this.bindEvents();
    super.enablePlugin();
  }

  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualColumnResize`](@/api/options.md#manualcolumnresize)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }

  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    _classPrivateFieldSet(this, _config, _classPrivateFieldGet(this, _columnWidthsMap).getValues());
    this.hot.columnIndexMapper.unregisterMap(this.pluginName);
    super.disablePlugin();
  }

  /**
   * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
   *
   * @fires Hooks#persistentStateSave
   */
  saveManualColumnWidths() {
    this.hot.runHooks('persistentStateSave', PERSISTENT_STATE_KEY, _classPrivateFieldGet(this, _columnWidthsMap).getValues());
  }

  /**
   * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
   *
   * @returns {Array}
   * @fires Hooks#persistentStateLoad
   */
  loadManualColumnWidths() {
    const storedState = {};
    this.hot.runHooks('persistentStateLoad', PERSISTENT_STATE_KEY, storedState);
    return storedState.value;
  }

  /**
   * Sets the new width for specified column index.
   *
   * @param {number} column Visual column index.
   * @param {number} width Column width (no less than 20px).
   * @returns {number} Returns new width.
   */
  setManualSize(column, width) {
    const newWidth = Math.max(width, 20);
    const physicalColumn = this.hot.toPhysicalColumn(column);
    _classPrivateFieldGet(this, _columnWidthsMap).setValueAtIndex(physicalColumn, newWidth);
    return newWidth;
  }

  /**
   * Clears the cache for the specified column index.
   *
   * @param {number} column Visual column index.
   */
  clearManualSize(column) {
    const physicalColumn = this.hot.toPhysicalColumn(column);
    _classPrivateFieldGet(this, _columnWidthsMap).setValueAtIndex(physicalColumn, null);
  }
  /**
   * Set the resize handle position.
   *
   * @private
   * @param {HTMLCellElement} TH TH HTML element.
   */
  setupHandlePosition(TH) {
    if (!TH.parentNode) {
      return;
    }
    _classPrivateFieldSet(this, _currentTH, TH);
    const {
      _wt: wt
    } = this.hot.view;
    const cellCoords = wt.wtTable.getCoords(_classPrivateFieldGet(this, _currentTH));
    const col = cellCoords.col;

    // Ignore column headers.
    if (col < 0) {
      return;
    }
    const headerHeight = outerHeight(_classPrivateFieldGet(this, _currentTH));
    const box = _classPrivateFieldGet(this, _currentTH).getBoundingClientRect();
    // Read "fixedColumnsStart" through the Walkontable as in that context, the fixed columns
    // are modified (reduced by the number of hidden columns) by TableView module.
    const fixedColumn = col < wt.getSetting('fixedColumnsStart');
    let relativeHeaderPosition;
    if (fixedColumn) {
      relativeHeaderPosition = wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(_classPrivateFieldGet(this, _currentTH), cellCoords.row, cellCoords.col);
    }

    // If the TH is not a child of the top-left overlay, recalculate using
    // the top overlay - as this overlay contains the rest of the headers.
    if (!relativeHeaderPosition) {
      relativeHeaderPosition = wt.wtOverlays.topOverlay.getRelativeCellPosition(_classPrivateFieldGet(this, _currentTH), cellCoords.row, cellCoords.col);
    }
    _classPrivateFieldSet(this, _currentCol, this.hot.columnIndexMapper.getVisualFromRenderableIndex(col));
    _classPrivateFieldSet(this, _selectedCols, []);
    const isFullColumnSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByColumnHeader();
    if (this.hot.selection.isSelected() && isFullColumnSelected) {
      const selectionRanges = this.hot.getSelectedRange();
      arrayEach(selectionRanges, selectionRange => {
        const fromColumn = selectionRange.getTopStartCorner().col;
        const toColumn = selectionRange.getBottomEndCorner().col;

        // Add every selected column for resize action.
        rangeEach(fromColumn, toColumn, columnIndex => {
          if (!_classPrivateFieldGet(this, _selectedCols).includes(columnIndex)) {
            _classPrivateFieldGet(this, _selectedCols).push(columnIndex);
          }
        });
      });
    }

    // Resizing element beyond the current selection (also when there is no selection).
    if (!_classPrivateFieldGet(this, _selectedCols).includes(_classPrivateFieldGet(this, _currentCol))) {
      _classPrivateFieldSet(this, _selectedCols, [_classPrivateFieldGet(this, _currentCol)]);
    }
    _classPrivateFieldSet(this, _startOffset, relativeHeaderPosition.start - 6);
    _classPrivateFieldSet(this, _startWidth, parseInt(box.width, 10));
    _classPrivateFieldGet(this, _handle).style.top = `${relativeHeaderPosition.top}px`;
    _classPrivateFieldGet(this, _handle).style[this.inlineDir] = `${_classPrivateFieldGet(this, _startOffset) + _classPrivateFieldGet(this, _startWidth)}px`;
    _classPrivateFieldGet(this, _handle).style.height = `${headerHeight}px`;
    this.hot.rootElement.appendChild(_classPrivateFieldGet(this, _handle));
  }

  /**
   * Refresh the resize handle position.
   *
   * @private
   */
  refreshHandlePosition() {
    _classPrivateFieldGet(this, _handle).style[this.inlineDir] = `${_classPrivateFieldGet(this, _startOffset) + _classPrivateFieldGet(this, _currentWidth)}px`;
  }

  /**
   * Sets the resize guide position.
   *
   * @private
   */
  setupGuidePosition() {
    const handleHeight = parseInt(outerHeight(_classPrivateFieldGet(this, _handle)), 10);
    const handleBottomPosition = parseInt(_classPrivateFieldGet(this, _handle).style.top, 10) + handleHeight;
    const maximumVisibleElementHeight = parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);
    addClass(_classPrivateFieldGet(this, _handle), 'active');
    addClass(_classPrivateFieldGet(this, _guide), 'active');
    _classPrivateFieldGet(this, _guide).style.top = `${handleBottomPosition}px`;
    this.refreshGuidePosition();
    _classPrivateFieldGet(this, _guide).style.height = `${maximumVisibleElementHeight - handleHeight}px`;
    this.hot.rootElement.appendChild(_classPrivateFieldGet(this, _guide));
  }

  /**
   * Refresh the resize guide position.
   *
   * @private
   */
  refreshGuidePosition() {
    _classPrivateFieldGet(this, _guide).style[this.inlineDir] = _classPrivateFieldGet(this, _handle).style[this.inlineDir];
  }

  /**
   * Hides both the resize handle and resize guide.
   *
   * @private
   */
  hideHandleAndGuide() {
    removeClass(_classPrivateFieldGet(this, _handle), 'active');
    removeClass(_classPrivateFieldGet(this, _guide), 'active');
  }

  /**
   * Checks if provided element is considered a column header.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {boolean}
   */
  checkIfColumnHeader(element) {
    return !!closest(element, ['THEAD'], this.hot.rootElement);
  }

  /**
   * Gets the TH element from the provided element.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {HTMLElement}
   */
  getClosestTHParent(element) {
    if (element.tagName !== 'TABLE') {
      if (element.tagName === 'TH') {
        return element;
      }
      return this.getClosestTHParent(element.parentNode);
    }
    return null;
  }
  /**
   * Auto-size row after doubleclick - callback.
   *
   * @private
   * @fires Hooks#beforeColumnResize
   * @fires Hooks#afterColumnResize
   */
  afterMouseDownTimeout() {
    const render = () => {
      this.hot.forceFullRender = true;
      this.hot.view.render(); // updates all
      this.hot.view.adjustElementsSize(true);
    };
    const resize = (column, forceRender) => {
      const hookNewSize = this.hot.runHooks('beforeColumnResize', _classPrivateFieldGet(this, _newSize), column, true);
      if (hookNewSize !== undefined) {
        _classPrivateFieldSet(this, _newSize, hookNewSize);
      }
      if (this.hot.getSettings().stretchH === 'all') {
        this.clearManualSize(column);
      } else {
        this.setManualSize(column, _classPrivateFieldGet(this, _newSize)); // double click sets by auto row size plugin
      }

      this.saveManualColumnWidths();
      this.hot.runHooks('afterColumnResize', _classPrivateFieldGet(this, _newSize), column, true);
      if (forceRender) {
        render();
      }
    };
    if (_classPrivateFieldGet(this, _dblclick) >= 2) {
      const selectedColsLength = _classPrivateFieldGet(this, _selectedCols).length;
      if (selectedColsLength > 1) {
        arrayEach(_classPrivateFieldGet(this, _selectedCols), selectedCol => {
          resize(selectedCol);
        });
        render();
      } else {
        arrayEach(_classPrivateFieldGet(this, _selectedCols), selectedCol => {
          resize(selectedCol, true);
        });
      }
    }
    _classPrivateFieldSet(this, _dblclick, 0);
    _classPrivateFieldSet(this, _autoresizeTimeout, null);
  }
  /**
   * Binds the mouse events.
   *
   * @private
   */
  bindEvents() {
    const {
      rootWindow,
      rootElement
    } = this.hot;
    this.eventManager.addEventListener(rootElement, 'mouseover', e => _classPrivateMethodGet(this, _onMouseOver, _onMouseOver2).call(this, e));
    this.eventManager.addEventListener(rootElement, 'mousedown', e => _classPrivateMethodGet(this, _onMouseDown, _onMouseDown2).call(this, e));
    this.eventManager.addEventListener(rootWindow, 'mousemove', e => _classPrivateMethodGet(this, _onMouseMove, _onMouseMove2).call(this, e));
    this.eventManager.addEventListener(rootWindow, 'mouseup', () => _classPrivateMethodGet(this, _onMouseUp, _onMouseUp2).call(this));
    this.eventManager.addEventListener(_classPrivateFieldGet(this, _handle), 'contextmenu', () => _classPrivateMethodGet(this, _onContextMenu, _onContextMenu2).call(this));
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
}
function _onMapInit2() {
  const initialSetting = this.hot.getSettings()[PLUGIN_KEY];
  const loadedManualColumnWidths = this.loadManualColumnWidths();
  if (typeof loadedManualColumnWidths !== 'undefined') {
    this.hot.batchExecution(() => {
      loadedManualColumnWidths.forEach((width, physicalIndex) => {
        _classPrivateFieldGet(this, _columnWidthsMap).setValueAtIndex(physicalIndex, width);
      });
    }, true);
  } else if (Array.isArray(initialSetting)) {
    this.hot.batchExecution(() => {
      initialSetting.forEach((width, physicalIndex) => {
        _classPrivateFieldGet(this, _columnWidthsMap).setValueAtIndex(physicalIndex, width);
      });
    }, true);
    _classPrivateFieldSet(this, _config, initialSetting);
  } else if (initialSetting === true && Array.isArray(_classPrivateFieldGet(this, _config))) {
    this.hot.batchExecution(() => {
      _classPrivateFieldGet(this, _config).forEach((width, physicalIndex) => {
        _classPrivateFieldGet(this, _columnWidthsMap).setValueAtIndex(physicalIndex, width);
      });
    }, true);
  }
}
function _onMouseOver2(event) {
  // Workaround for #6926 - if the `event.target` is temporarily detached, we can skip this callback and wait for
  // the next `onmouseover`.
  if (isDetached(event.target)) {
    return;
  }

  // A "mouseover" action is triggered right after executing "contextmenu" event. It should be ignored.
  if (_classPrivateFieldGet(this, _isTriggeredByRMB) === true) {
    return;
  }
  if (this.checkIfColumnHeader(event.target)) {
    const th = this.getClosestTHParent(event.target);
    if (!th) {
      return;
    }
    const colspan = th.getAttribute('colspan');
    if (th && (colspan === null || colspan === '1')) {
      if (!_classPrivateFieldGet(this, _pressed)) {
        this.setupHandlePosition(th);
      }
    }
  }
}
function _onMouseDown2(event) {
  if (hasClass(event.target, 'manualColumnResizer')) {
    this.setupHandlePosition(_classPrivateFieldGet(this, _currentTH));
    this.setupGuidePosition();
    _classPrivateFieldSet(this, _pressed, true);
    if (_classPrivateFieldGet(this, _autoresizeTimeout) === null) {
      _classPrivateFieldSet(this, _autoresizeTimeout, setTimeout(() => this.afterMouseDownTimeout(), 500));
      this.hot._registerTimeout(_classPrivateFieldGet(this, _autoresizeTimeout));
    }
    _classPrivateFieldSet(this, _dblclick, _classPrivateFieldGet(this, _dblclick) + 1);
    this.startX = event.pageX;
    _classPrivateFieldSet(this, _newSize, _classPrivateFieldGet(this, _startWidth));
  }
}
function _onMouseMove2(event) {
  if (_classPrivateFieldGet(this, _pressed)) {
    const change = (event.pageX - this.startX) * this.hot.getDirectionFactor();
    _classPrivateFieldSet(this, _currentWidth, _classPrivateFieldGet(this, _startWidth) + change);
    arrayEach(_classPrivateFieldGet(this, _selectedCols), selectedCol => {
      _classPrivateFieldSet(this, _newSize, this.setManualSize(selectedCol, _classPrivateFieldGet(this, _currentWidth)));
    });
    this.refreshHandlePosition();
    this.refreshGuidePosition();
  }
}
function _onMouseUp2() {
  const render = () => {
    this.hot.forceFullRender = true;
    this.hot.view.render(); // updates all
    this.hot.view.adjustElementsSize(true);
  };
  const resize = (column, forceRender) => {
    this.hot.runHooks('beforeColumnResize', _classPrivateFieldGet(this, _newSize), column, false);
    if (forceRender) {
      render();
    }
    this.saveManualColumnWidths();
    this.hot.runHooks('afterColumnResize', _classPrivateFieldGet(this, _newSize), column, false);
  };
  if (_classPrivateFieldGet(this, _pressed)) {
    this.hideHandleAndGuide();
    _classPrivateFieldSet(this, _pressed, false);
    if (_classPrivateFieldGet(this, _newSize) !== _classPrivateFieldGet(this, _startWidth)) {
      const selectedColsLength = _classPrivateFieldGet(this, _selectedCols).length;
      if (selectedColsLength > 1) {
        arrayEach(_classPrivateFieldGet(this, _selectedCols), selectedCol => {
          resize(selectedCol);
        });
        render();
      } else {
        arrayEach(_classPrivateFieldGet(this, _selectedCols), selectedCol => {
          resize(selectedCol, true);
        });
      }
    }
    this.setupHandlePosition(_classPrivateFieldGet(this, _currentTH));
  }
}
function _onContextMenu2() {
  this.hideHandleAndGuide();
  this.hot.rootElement.removeChild(_classPrivateFieldGet(this, _handle));
  this.hot.rootElement.removeChild(_classPrivateFieldGet(this, _guide));
  _classPrivateFieldSet(this, _pressed, false);
  _classPrivateFieldSet(this, _isTriggeredByRMB, true);

  // There is thrown "mouseover" event right after opening a context menu. This flag inform that handle
  // shouldn't be drawn just after removing it.
  this.hot._registerImmediate(() => {
    _classPrivateFieldSet(this, _isTriggeredByRMB, false);
  });
}
function _onModifyColWidth2(width, column) {
  let newWidth = width;
  if (this.enabled) {
    const physicalColumn = this.hot.toPhysicalColumn(column);
    const columnWidth = _classPrivateFieldGet(this, _columnWidthsMap).getValueAtIndex(physicalColumn);
    if (this.hot.getSettings()[PLUGIN_KEY] && columnWidth) {
      newWidth = columnWidth;
    }
  }
  return newWidth;
}
function _onBeforeStretchingColumnWidth2(stretchedWidth, column) {
  let width = _classPrivateFieldGet(this, _columnWidthsMap).getValueAtIndex(column);
  if (width === null) {
    width = stretchedWidth;
  }
  return width;
}
function _onBeforeColumnResize2() {
  // clear the header height cache information
  this.hot.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();
}