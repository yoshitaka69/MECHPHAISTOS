"use strict";

exports.__esModule = true;
require("core-js/modules/es.error.cause.js");
require("core-js/modules/es.array.push.js");
var _element = require("../../helpers/dom/element");
var _array = require("../../helpers/array");
var _base = require("../base");
var _feature = require("../../helpers/feature");
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
const PLUGIN_KEY = exports.PLUGIN_KEY = 'touchScroll';
const PLUGIN_PRIORITY = exports.PLUGIN_PRIORITY = 200;

/**
 * @private
 * @plugin TouchScroll
 * @class TouchScroll
 */
var _onAfterViewRender = /*#__PURE__*/new WeakSet();
var _onBeforeTouchScroll = /*#__PURE__*/new WeakSet();
var _onAfterMomentumScroll = /*#__PURE__*/new WeakSet();
class TouchScroll extends _base.BasePlugin {
  constructor() {
    super(...arguments);
    /**
     * After momentum scroll listener.
     */
    _classPrivateMethodInitSpec(this, _onAfterMomentumScroll);
    /**
     * Touch scroll listener.
     */
    _classPrivateMethodInitSpec(this, _onBeforeTouchScroll);
    /**
     * After view render listener.
     */
    _classPrivateMethodInitSpec(this, _onAfterViewRender);
    /**
     * Collection of scrollbars to update.
     *
     * @type {Array}
     */
    _defineProperty(this, "scrollbars", []);
    /**
     * Collection of overlays to update.
     *
     * @type {Array}
     */
    _defineProperty(this, "clones", []);
    /**
     * Flag which determines if collection of overlays should be refilled on every table render.
     *
     * @type {boolean}
     * @default false
     */
    _defineProperty(this, "lockedCollection", false);
    /**
     * Flag which determines if walkontable should freeze overlays while scrolling.
     *
     * @type {boolean}
     * @default false
     */
    _defineProperty(this, "freezeOverlays", false);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY;
  }
  static get SETTING_KEYS() {
    return true;
  }
  /**
   * Check if plugin is enabled.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return (0, _feature.isTouchSupported)();
  }

  /**
   * Enable the plugin.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook('afterViewRender', () => _classPrivateMethodGet(this, _onAfterViewRender, _onAfterViewRender2).call(this));
    this.registerEvents();
    super.enablePlugin();
  }

  /**
   * Updates the plugin to use the latest options you have specified.
   */
  updatePlugin() {
    this.lockedCollection = false;
    super.updatePlugin();
  }

  /**
   * Disable plugin for this Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
  }

  /**
   * Register all necessary events.
   *
   * @private
   */
  registerEvents() {
    this.addHook('beforeTouchScroll', () => _classPrivateMethodGet(this, _onBeforeTouchScroll, _onBeforeTouchScroll2).call(this));
    this.addHook('afterMomentumScroll', () => _classPrivateMethodGet(this, _onAfterMomentumScroll, _onAfterMomentumScroll2).call(this));
  }
}
exports.TouchScroll = TouchScroll;
function _onAfterViewRender2() {
  if (this.lockedCollection) {
    return;
  }
  const {
    topOverlay,
    bottomOverlay,
    inlineStartOverlay,
    topInlineStartCornerOverlay,
    bottomInlineStartCornerOverlay
  } = this.hot.view._wt.wtOverlays;
  this.lockedCollection = true;
  this.scrollbars.length = 0;
  this.scrollbars.push(topOverlay);
  if (bottomOverlay.clone) {
    this.scrollbars.push(bottomOverlay);
  }
  this.scrollbars.push(inlineStartOverlay);
  if (topInlineStartCornerOverlay) {
    this.scrollbars.push(topInlineStartCornerOverlay);
  }
  if (bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {
    this.scrollbars.push(bottomInlineStartCornerOverlay);
  }
  this.clones = [];
  if (topOverlay.needFullRender) {
    this.clones.push(topOverlay.clone.wtTable.holder.parentNode);
  }
  if (bottomOverlay.needFullRender) {
    this.clones.push(bottomOverlay.clone.wtTable.holder.parentNode);
  }
  if (inlineStartOverlay.needFullRender) {
    this.clones.push(inlineStartOverlay.clone.wtTable.holder.parentNode);
  }
  if (topInlineStartCornerOverlay) {
    this.clones.push(topInlineStartCornerOverlay.clone.wtTable.holder.parentNode);
  }
  if (bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {
    this.clones.push(bottomInlineStartCornerOverlay.clone.wtTable.holder.parentNode);
  }
}
function _onBeforeTouchScroll2() {
  this.freezeOverlays = true;
  (0, _array.arrayEach)(this.clones, clone => {
    (0, _element.addClass)(clone, 'hide-tween');
  });
}
function _onAfterMomentumScroll2() {
  this.freezeOverlays = false;
  (0, _array.arrayEach)(this.clones, clone => {
    (0, _element.removeClass)(clone, 'hide-tween');
    (0, _element.addClass)(clone, 'show-tween');
  });
  this.hot._registerTimeout(() => {
    (0, _array.arrayEach)(this.clones, clone => {
      (0, _element.removeClass)(clone, 'show-tween');
    });
  }, 400);
  (0, _array.arrayEach)(this.scrollbars, scrollbar => {
    scrollbar.refresh();
    scrollbar.resetFixedPosition();
  });
  this.hot.view._wt.wtOverlays.syncScrollWithMaster();
}