import "core-js/modules/es.error.cause.js";
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
import { addClass } from "../../../helpers/dom/element.mjs";
import { clone, extend } from "../../../helpers/object.mjs";
import { BaseUI } from "./_base.mjs";
/**
 * @private
 * @class InputUI
 */
var _input = /*#__PURE__*/new WeakMap();
var _onKeyup = /*#__PURE__*/new WeakSet();
export class InputUI extends BaseUI {
  static get DEFAULTS() {
    return clone({
      placeholder: '',
      type: 'text',
      tagName: 'input',
      tabIndex: -1
    });
  }

  /**
   * The reference to the input element.
   *
   * @type {HTMLInputElement}
   */

  constructor(hotInstance, options) {
    super(hotInstance, extend(InputUI.DEFAULTS, options));
    /**
     * OnKeyup listener.
     *
     * @param {Event} event The mouse event object.
     */
    _classPrivateMethodInitSpec(this, _onKeyup);
    _classPrivateFieldInitSpec(this, _input, {
      writable: true,
      value: void 0
    });
    this.registerHooks();
  }

  /**
   * Register all necessary hooks.
   */
  registerHooks() {
    this.addLocalHook('keyup', event => _classPrivateMethodGet(this, _onKeyup, _onKeyup2).call(this, event));
  }

  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    const icon = this.hot.rootDocument.createElement('div');
    _classPrivateFieldSet(this, _input, this._element.firstChild);
    addClass(this._element, 'htUIInput');
    addClass(icon, 'htUIInputIcon');
    this._element.appendChild(icon);
    this.update();
  }

  /**
   * Update element.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    _classPrivateFieldGet(this, _input).type = this.options.type;
    _classPrivateFieldGet(this, _input).placeholder = this.translateIfPossible(this.options.placeholder);
    _classPrivateFieldGet(this, _input).value = this.translateIfPossible(this.options.value);
  }

  /**
   * Focus element.
   */
  focus() {
    if (this.isBuilt()) {
      _classPrivateFieldGet(this, _input).focus();
    }
  }
}
function _onKeyup2(event) {
  this.options.value = event.target.value;
}