"use strict";

require("core-js/modules/es.error.cause.js");
exports.__esModule = true;
require("core-js/modules/es.array.push.js");
var _base = require("../base");
var _element = require("../../helpers/dom/element");
var _array = require("../../helpers/array");
var _number = require("../../helpers/number");
var _translations = require("../../translations");
var _src = require("../../3rdparty/walkontable/src");
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
// Developer note! Whenever you make a change in this file, make an analogous change in manualColumnResize.js

const PLUGIN_KEY = exports.PLUGIN_KEY = 'manualRowResize';
const PLUGIN_PRIORITY = exports.PLUGIN_PRIORITY = 30;
const PERSISTENT_STATE_KEY = 'manualRowHeights';

/* eslint-disable jsdoc/require-description-complete-sentence */

/**
 * @plugin ManualRowResize
 * @class ManualRowResize
 *
 * @description
 * This plugin allows to change rows height. To make rows height persistent the {@link Options#persistentState}
 * plugin should be enabled.
 *
 * The plugin creates additional components to make resizing possibly using user interface:
 * - handle - the draggable element that sets the desired height of the row.
 * - guide - the helper guide that shows the desired height as a horizontal guide.
 */
var _currentTH = /*#__PURE__*/new WeakMap();
var _currentRow = /*#__PURE__*/new WeakMap();
var _selectedRows = /*#__PURE__*/new WeakMap();
var _currentHeight = /*#__PURE__*/new WeakMap();
var _newSize = /*#__PURE__*/new WeakMap();
var _startY = /*#__PURE__*/new WeakMap();
var _startHeight = /*#__PURE__*/new WeakMap();
var _startOffset = /*#__PURE__*/new WeakMap();
var _handle = /*#__PURE__*/new WeakMap();
var _guide = /*#__PURE__*/new WeakMap();
var _pressed = /*#__PURE__*/new WeakMap();
var _isTriggeredByRMB = /*#__PURE__*/new WeakMap();
var _dblclick = /*#__PURE__*/new WeakMap();
var _autoresizeTimeout = /*#__PURE__*/new WeakMap();
var _rowHeightsMap = /*#__PURE__*/new WeakMap();
var _config = /*#__PURE__*/new WeakMap();
var _onMouseOver = /*#__PURE__*/new WeakSet();
var _onMouseDown = /*#__PURE__*/new WeakSet();
var _onMouseMove = /*#__PURE__*/new WeakSet();
var _onMouseUp = /*#__PURE__*/new WeakSet();
var _onContextMenu = /*#__PURE__*/new WeakSet();
var _onModifyRowHeight = /*#__PURE__*/new WeakSet();
var _onMapInit = /*#__PURE__*/new WeakSet();
class ManualRowResize extends _base.BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY;
  }

  /**
   * @type {HTMLTableCellElement}
   */

  constructor(hotInstance) {
    super(hotInstance);
    /**
     * Callback to call on map's `init` local hook.
     */
    _classPrivateMethodInitSpec(this, _onMapInit);
    /**
     * Modifies the provided row height, based on the plugin settings.
     *
     * @param {number} height Row height.
     * @param {number} row Visual row index.
     * @returns {number}
     */
    _classPrivateMethodInitSpec(this, _onModifyRowHeight);
    /**
     * Callback for "contextmenu" event triggered on element showing move handle. It removes handle and guide elements.
     */
    _classPrivateMethodInitSpec(this, _onContextMenu);
    /**
     * 'mouseup' event callback - apply the row resizing.
     *
     * @fires Hooks#beforeRowResize
     * @fires Hooks#afterRowResize
     */
    _classPrivateMethodInitSpec(this, _onMouseUp);
    /**
     * 'mousemove' event callback - refresh the handle and guide positions, cache the new row height.
     *
     * @param {MouseEvent} event The mouse event.
     */
    _classPrivateMethodInitSpec(this, _onMouseMove);
    /**
     * 'mousedown' event callback.
     *
     * @param {MouseEvent} event The mouse event.
     */
    _classPrivateMethodInitSpec(this, _onMouseDown);
    /**
     * 'mouseover' event callback - set the handle position.
     *
     * @param {MouseEvent} event The mouse event.
     */
    _classPrivateMethodInitSpec(this, _onMouseOver);
    _classPrivateFieldInitSpec(this, _currentTH, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _currentRow, {
      writable: true,
      value: null
    });
    /**
     * @type {number[]}
     */
    _classPrivateFieldInitSpec(this, _selectedRows, {
      writable: true,
      value: []
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _currentHeight, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _newSize, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _startY, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _startHeight, {
      writable: true,
      value: null
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _startOffset, {
      writable: true,
      value: null
    });
    /**
     * @type {HTMLElement}
     */
    _classPrivateFieldInitSpec(this, _handle, {
      writable: true,
      value: this.hot.rootDocument.createElement('DIV')
    });
    /**
     * @type {HTMLElement}
     */
    _classPrivateFieldInitSpec(this, _guide, {
      writable: true,
      value: this.hot.rootDocument.createElement('DIV')
    });
    /**
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _pressed, {
      writable: true,
      value: false
    });
    /**
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _isTriggeredByRMB, {
      writable: true,
      value: false
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _dblclick, {
      writable: true,
      value: 0
    });
    /**
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _autoresizeTimeout, {
      writable: true,
      value: null
    });
    /**
     * PhysicalIndexToValueMap to keep and track widths for physical row indexes.
     *
     * @type {PhysicalIndexToValueMap}
     */
    _classPrivateFieldInitSpec(this, _rowHeightsMap, {
      writable: true,
      value: void 0
    });
    /**
     * Private pool to save configuration from updateSettings.
     *
     * @type {object}
     */
    _classPrivateFieldInitSpec(this, _config, {
      writable: true,
      value: void 0
    });
    (0, _element.addClass)(_classPrivateFieldGet(this, _handle), 'manualRowResizer');
    (0, _element.addClass)(_classPrivateFieldGet(this, _guide), 'manualRowResizerGuide');
  }

  /**
   * @private
   * @returns {string}
   */
  get inlineDir() {
    return this.hot.isRtl() ? 'right' : 'left';
  }

  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualRowResize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY];
  }

  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    _classPrivateFieldSet(this, _rowHeightsMap, new _translations.PhysicalIndexToValueMap());
    _classPrivateFieldGet(this, _rowHeightsMap).addLocalHook('init', () => _classPrivateMethodGet(this, _onMapInit, _onMapInit2).call(this));
    this.hot.rowIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet(this, _rowHeightsMap));
    this.addHook('modifyRowHeight', (height, row) => _classPrivateMethodGet(this, _onModifyRowHeight, _onModifyRowHeight2).call(this, height, row));
    this.bindEvents();
    super.enablePlugin();
  }

  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualRowResize`](@/api/options.md#manualrowresize)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }

  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    _classPrivateFieldSet(this, _config, _classPrivateFieldGet(this, _rowHeightsMap).getValues());
    this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    super.disablePlugin();
  }

  /**
   * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be
   * enabled).
   *
   * @fires Hooks#persistentStateSave
   */
  saveManualRowHeights() {
    this.hot.runHooks('persistentStateSave', PERSISTENT_STATE_KEY, _classPrivateFieldGet(this, _rowHeightsMap).getValues());
  }

  /**
   * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option
   * has be enabled).
   *
   * @returns {Array}
   * @fires Hooks#persistentStateLoad
   */
  loadManualRowHeights() {
    const storedState = {};
    this.hot.runHooks('persistentStateLoad', PERSISTENT_STATE_KEY, storedState);
    return storedState.value;
  }

  /**
   * Sets the new height for specified row index.
   *
   * @param {number} row Visual row index.
   * @param {number} height Row height.
   * @returns {number} Returns new height.
   */
  setManualSize(row, height) {
    const physicalRow = this.hot.toPhysicalRow(row);
    const newHeight = Math.max(height, _src.ViewportRowsCalculator.DEFAULT_HEIGHT);
    _classPrivateFieldGet(this, _rowHeightsMap).setValueAtIndex(physicalRow, newHeight);
    return newHeight;
  }

  /**
   * Sets the resize handle position.
   *
   * @private
   * @param {HTMLCellElement} TH TH HTML element.
   */
  setupHandlePosition(TH) {
    _classPrivateFieldSet(this, _currentTH, TH);
    const {
      view
    } = this.hot;
    const {
      _wt: wt
    } = view;
    const cellCoords = wt.wtTable.getCoords(_classPrivateFieldGet(this, _currentTH));
    const row = cellCoords.row;

    // Ignore row headers.
    if (row < 0) {
      return;
    }
    const headerWidth = (0, _element.outerWidth)(_classPrivateFieldGet(this, _currentTH));
    const box = _classPrivateFieldGet(this, _currentTH).getBoundingClientRect();
    // Read "fixedRowsTop" and "fixedRowsBottom" through the Walkontable as in that context, the fixed
    // rows are modified (reduced by the number of hidden rows) by TableView module.
    const fixedRowTop = row < wt.getSetting('fixedRowsTop');
    const fixedRowBottom = row >= view.countNotHiddenRowIndexes(0, 1) - wt.getSetting('fixedRowsBottom');
    let relativeHeaderPosition;
    if (fixedRowTop) {
      relativeHeaderPosition = wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(_classPrivateFieldGet(this, _currentTH), cellCoords.row, cellCoords.col);
    } else if (fixedRowBottom) {
      relativeHeaderPosition = wt.wtOverlays.bottomInlineStartCornerOverlay.getRelativeCellPosition(_classPrivateFieldGet(this, _currentTH), cellCoords.row, cellCoords.col);
    }

    // If the TH is not a child of the top-left/bottom-left overlay, recalculate using
    // the left overlay - as this overlay contains the rest of the headers.
    if (!relativeHeaderPosition) {
      relativeHeaderPosition = wt.wtOverlays.inlineStartOverlay.getRelativeCellPosition(_classPrivateFieldGet(this, _currentTH), cellCoords.row, cellCoords.col);
    }
    _classPrivateFieldSet(this, _currentRow, this.hot.rowIndexMapper.getVisualFromRenderableIndex(row));
    _classPrivateFieldSet(this, _selectedRows, []);
    const isFullRowSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByRowHeader();
    if (this.hot.selection.isSelected() && isFullRowSelected) {
      const selectionRanges = this.hot.getSelectedRange();
      (0, _array.arrayEach)(selectionRanges, selectionRange => {
        const fromRow = selectionRange.getTopStartCorner().row;
        const toRow = selectionRange.getBottomStartCorner().row;

        // Add every selected row for resize action.
        (0, _number.rangeEach)(fromRow, toRow, rowIndex => {
          if (!_classPrivateFieldGet(this, _selectedRows).includes(rowIndex)) {
            _classPrivateFieldGet(this, _selectedRows).push(rowIndex);
          }
        });
      });
    }

    // Resizing element beyond the current selection (also when there is no selection).
    if (!_classPrivateFieldGet(this, _selectedRows).includes(_classPrivateFieldGet(this, _currentRow))) {
      _classPrivateFieldSet(this, _selectedRows, [_classPrivateFieldGet(this, _currentRow)]);
    }
    _classPrivateFieldSet(this, _startOffset, relativeHeaderPosition.top - 6);
    _classPrivateFieldSet(this, _startHeight, parseInt(box.height, 10));
    _classPrivateFieldGet(this, _handle).style.top = `${_classPrivateFieldGet(this, _startOffset) + _classPrivateFieldGet(this, _startHeight)}px`;
    _classPrivateFieldGet(this, _handle).style[this.inlineDir] = `${relativeHeaderPosition.start}px`;
    _classPrivateFieldGet(this, _handle).style.width = `${headerWidth}px`;
    this.hot.rootElement.appendChild(_classPrivateFieldGet(this, _handle));
  }

  /**
   * Refresh the resize handle position.
   *
   * @private
   */
  refreshHandlePosition() {
    _classPrivateFieldGet(this, _handle).style.top = `${_classPrivateFieldGet(this, _startOffset) + _classPrivateFieldGet(this, _currentHeight)}px`;
  }

  /**
   * Sets the resize guide position.
   *
   * @private
   */
  setupGuidePosition() {
    const handleWidth = parseInt((0, _element.outerWidth)(_classPrivateFieldGet(this, _handle)), 10);
    const handleEndPosition = parseInt(_classPrivateFieldGet(this, _handle).style[this.inlineDir], 10) + handleWidth;
    const maximumVisibleElementWidth = parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);
    (0, _element.addClass)(_classPrivateFieldGet(this, _handle), 'active');
    (0, _element.addClass)(_classPrivateFieldGet(this, _guide), 'active');
    _classPrivateFieldGet(this, _guide).style.top = _classPrivateFieldGet(this, _handle).style.top;
    _classPrivateFieldGet(this, _guide).style[this.inlineDir] = `${handleEndPosition}px`;
    _classPrivateFieldGet(this, _guide).style.width = `${maximumVisibleElementWidth - handleWidth}px`;
    this.hot.rootElement.appendChild(_classPrivateFieldGet(this, _guide));
  }

  /**
   * Refresh the resize guide position.
   *
   * @private
   */
  refreshGuidePosition() {
    _classPrivateFieldGet(this, _guide).style.top = _classPrivateFieldGet(this, _handle).style.top;
  }

  /**
   * Hides both the resize handle and resize guide.
   *
   * @private
   */
  hideHandleAndGuide() {
    (0, _element.removeClass)(_classPrivateFieldGet(this, _handle), 'active');
    (0, _element.removeClass)(_classPrivateFieldGet(this, _guide), 'active');
  }

  /**
   * Checks if provided element is considered as a row header.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {boolean}
   */
  checkIfRowHeader(element) {
    var _element$parentNode;
    const thElement = (0, _element.closest)(element, ['TH'], this.hot.rootElement);
    return thElement && ((_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 || (_element$parentNode = _element$parentNode.parentNode) === null || _element$parentNode === void 0 ? void 0 : _element$parentNode.tagName) === 'TBODY';
  }

  /**
   * Gets the TH element from the provided element.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {HTMLElement}
   */
  getClosestTHParent(element) {
    if (element.tagName !== 'TABLE') {
      if (element.tagName === 'TH') {
        return element;
      }
      return this.getClosestTHParent(element.parentNode);
    }
    return null;
  }

  /**
   * Returns the actual height for the provided row index.
   *
   * @private
   * @param {number} row Visual row index.
   * @returns {number} Actual row height.
   */
  getActualRowHeight(row) {
    // TODO: this should utilize `this.hot.getRowHeight` after it's fixed and working properly.
    const walkontableHeight = this.hot.view._wt.wtTable.getRowHeight(row);
    if (walkontableHeight !== undefined && _classPrivateFieldGet(this, _newSize) < walkontableHeight) {
      return walkontableHeight;
    }
    return _classPrivateFieldGet(this, _newSize);
  }
  /**
   * Auto-size row after doubleclick - callback.
   *
   * @private
   * @fires Hooks#beforeRowResize
   * @fires Hooks#afterRowResize
   */
  afterMouseDownTimeout() {
    const render = () => {
      this.hot.forceFullRender = true;
      this.hot.view.render(); // updates all
      this.hot.view.adjustElementsSize(true);
    };
    const resize = (row, forceRender) => {
      const hookNewSize = this.hot.runHooks('beforeRowResize', this.getActualRowHeight(row), row, true);
      if (hookNewSize !== undefined) {
        _classPrivateFieldSet(this, _newSize, hookNewSize);
      }
      this.setManualSize(row, _classPrivateFieldGet(this, _newSize)); // double click sets auto row size

      this.hot.runHooks('afterRowResize', this.getActualRowHeight(row), row, true);
      if (forceRender) {
        render();
      }
    };
    if (_classPrivateFieldGet(this, _dblclick) >= 2) {
      const selectedRowsLength = _classPrivateFieldGet(this, _selectedRows).length;
      if (selectedRowsLength > 1) {
        (0, _array.arrayEach)(_classPrivateFieldGet(this, _selectedRows), selectedRow => {
          resize(selectedRow);
        });
        render();
      } else {
        (0, _array.arrayEach)(_classPrivateFieldGet(this, _selectedRows), selectedRow => {
          resize(selectedRow, true);
        });
      }
    }
    _classPrivateFieldSet(this, _dblclick, 0);
    _classPrivateFieldSet(this, _autoresizeTimeout, null);
  }
  /**
   * Binds the mouse events.
   *
   * @private
   */
  bindEvents() {
    const {
      rootElement,
      rootWindow
    } = this.hot;
    this.eventManager.addEventListener(rootElement, 'mouseover', e => _classPrivateMethodGet(this, _onMouseOver, _onMouseOver2).call(this, e));
    this.eventManager.addEventListener(rootElement, 'mousedown', e => _classPrivateMethodGet(this, _onMouseDown, _onMouseDown2).call(this, e));
    this.eventManager.addEventListener(rootWindow, 'mousemove', e => _classPrivateMethodGet(this, _onMouseMove, _onMouseMove2).call(this, e));
    this.eventManager.addEventListener(rootWindow, 'mouseup', () => _classPrivateMethodGet(this, _onMouseUp, _onMouseUp2).call(this));
    this.eventManager.addEventListener(_classPrivateFieldGet(this, _handle), 'contextmenu', () => _classPrivateMethodGet(this, _onContextMenu, _onContextMenu2).call(this));
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
}
exports.ManualRowResize = ManualRowResize;
function _onMouseOver2(event) {
  // Workaround for #6926 - if the `event.target` is temporarily detached, we can skip this callback and wait for
  // the next `onmouseover`.
  if ((0, _element.isDetached)(event.target)) {
    return;
  }

  // A "mouseover" action is triggered right after executing "contextmenu" event. It should be ignored.
  if (_classPrivateFieldGet(this, _isTriggeredByRMB) === true) {
    return;
  }
  if (this.checkIfRowHeader(event.target)) {
    const th = this.getClosestTHParent(event.target);
    if (th) {
      if (!_classPrivateFieldGet(this, _pressed)) {
        this.setupHandlePosition(th);
      }
    }
  }
}
function _onMouseDown2(event) {
  if ((0, _element.hasClass)(event.target, 'manualRowResizer')) {
    this.setupHandlePosition(_classPrivateFieldGet(this, _currentTH));
    this.setupGuidePosition();
    _classPrivateFieldSet(this, _pressed, true);
    if (_classPrivateFieldGet(this, _autoresizeTimeout) === null) {
      _classPrivateFieldSet(this, _autoresizeTimeout, setTimeout(() => this.afterMouseDownTimeout(), 500));
      this.hot._registerTimeout(_classPrivateFieldGet(this, _autoresizeTimeout));
    }
    _classPrivateFieldSet(this, _dblclick, _classPrivateFieldGet(this, _dblclick) + 1);
    _classPrivateFieldSet(this, _startY, event.pageY);
    _classPrivateFieldSet(this, _newSize, _classPrivateFieldGet(this, _startHeight));
  }
}
function _onMouseMove2(event) {
  if (_classPrivateFieldGet(this, _pressed)) {
    _classPrivateFieldSet(this, _currentHeight, _classPrivateFieldGet(this, _startHeight) + (event.pageY - _classPrivateFieldGet(this, _startY)));
    (0, _array.arrayEach)(_classPrivateFieldGet(this, _selectedRows), selectedRow => {
      _classPrivateFieldSet(this, _newSize, this.setManualSize(selectedRow, _classPrivateFieldGet(this, _currentHeight)));
    });
    this.refreshHandlePosition();
    this.refreshGuidePosition();
  }
}
function _onMouseUp2() {
  const render = () => {
    this.hot.forceFullRender = true;
    this.hot.view.render(); // updates all
    this.hot.view.adjustElementsSize(true);
  };
  const runHooks = (row, forceRender) => {
    this.hot.runHooks('beforeRowResize', this.getActualRowHeight(row), row, false);
    if (forceRender) {
      render();
    }
    this.saveManualRowHeights();
    this.hot.runHooks('afterRowResize', this.getActualRowHeight(row), row, false);
  };
  if (_classPrivateFieldGet(this, _pressed)) {
    this.hideHandleAndGuide();
    _classPrivateFieldSet(this, _pressed, false);
    if (_classPrivateFieldGet(this, _newSize) !== _classPrivateFieldGet(this, _startHeight)) {
      const selectedRowsLength = _classPrivateFieldGet(this, _selectedRows).length;
      if (selectedRowsLength > 1) {
        (0, _array.arrayEach)(_classPrivateFieldGet(this, _selectedRows), selectedRow => {
          runHooks(selectedRow);
        });
        render();
      } else {
        (0, _array.arrayEach)(_classPrivateFieldGet(this, _selectedRows), selectedRow => {
          runHooks(selectedRow, true);
        });
      }
    }
    this.setupHandlePosition(_classPrivateFieldGet(this, _currentTH));
  }
}
function _onContextMenu2() {
  this.hideHandleAndGuide();
  this.hot.rootElement.removeChild(_classPrivateFieldGet(this, _handle));
  this.hot.rootElement.removeChild(_classPrivateFieldGet(this, _guide));
  _classPrivateFieldSet(this, _pressed, false);
  _classPrivateFieldSet(this, _isTriggeredByRMB, true);

  // There is thrown "mouseover" event right after opening a context menu. This flag inform that handle
  // shouldn't be drawn just after removing it.
  this.hot._registerImmediate(() => {
    _classPrivateFieldSet(this, _isTriggeredByRMB, false);
  });
}
function _onModifyRowHeight2(height, row) {
  let newHeight = height;
  if (this.enabled) {
    const physicalRow = this.hot.toPhysicalRow(row);
    const rowHeight = _classPrivateFieldGet(this, _rowHeightsMap).getValueAtIndex(physicalRow);
    if (this.hot.getSettings()[PLUGIN_KEY] && rowHeight) {
      newHeight = rowHeight;
    }
  }
  return newHeight;
}
function _onMapInit2() {
  const initialSetting = this.hot.getSettings()[PLUGIN_KEY];
  const loadedManualRowHeights = this.loadManualRowHeights();
  this.hot.batchExecution(() => {
    if (typeof loadedManualRowHeights !== 'undefined') {
      loadedManualRowHeights.forEach((height, index) => {
        _classPrivateFieldGet(this, _rowHeightsMap).setValueAtIndex(index, height);
      });
    } else if (Array.isArray(initialSetting)) {
      initialSetting.forEach((height, index) => {
        _classPrivateFieldGet(this, _rowHeightsMap).setValueAtIndex(index, height);
      });
      _classPrivateFieldSet(this, _config, initialSetting);
    } else if (initialSetting === true && Array.isArray(_classPrivateFieldGet(this, _config))) {
      _classPrivateFieldGet(this, _config).forEach((height, index) => {
        _classPrivateFieldGet(this, _rowHeightsMap).setValueAtIndex(index, height);
      });
    }
  }, true);
}