import {
  EDITOR_TYPE
} from "./chunk-5ITNPUB6.js";
import {
  _getEditorInstance
} from "./chunk-ZLUG3KRD.js";
import {
  init_moment,
  isNumeric,
  moment_default
} from "./chunk-ESOZBQXP.js";
import {
  __export
} from "./chunk-AUZ3RYOM.js";

// node_modules/handsontable/validators/autocompleteValidator/autocompleteValidator.mjs
var VALIDATOR_TYPE = "autocomplete";
function autocompleteValidator(value, callback) {
  let valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
    return;
  }
  if (this.strict && this.source) {
    if (typeof this.source === "function") {
      this.source(valueToValidate, process(valueToValidate, callback));
    } else {
      process(valueToValidate, callback)(this.source);
    }
  } else {
    callback(true);
  }
}
autocompleteValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;
function process(value, callback) {
  const originalVal = value;
  return function(source) {
    let found = false;
    for (let s = 0, slen = source.length; s < slen; s++) {
      if (originalVal === source[s]) {
        found = true;
        break;
      }
    }
    callback(found);
  };
}

// node_modules/handsontable/helpers/date.mjs
var date_exports = {};
__export(date_exports, {
  getNormalizedDate: () => getNormalizedDate
});
function getNormalizedDate(dateString) {
  const nativeDate = new Date(dateString);
  if (!isNaN((/* @__PURE__ */ new Date(`${dateString}T00:00`)).getDate())) {
    return new Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 6e4);
  }
  return nativeDate;
}

// node_modules/handsontable/validators/dateValidator/dateValidator.mjs
init_moment();
var VALIDATOR_TYPE2 = "date";
function dateValidator(value, callback) {
  const dateEditor = _getEditorInstance(EDITOR_TYPE, this.instance);
  let valueToValidate = value;
  let valid = true;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  let isValidFormat = moment_default(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
  let isValidDate = moment_default(new Date(valueToValidate)).isValid() || isValidFormat;
  if (this.allowEmpty && valueToValidate === "") {
    isValidDate = true;
    isValidFormat = true;
  }
  if (!isValidDate) {
    valid = false;
  }
  if (!isValidDate && isValidFormat) {
    valid = true;
  }
  if (isValidDate && !isValidFormat) {
    if (this.correctFormat === true) {
      const correctedValue = correctFormat(valueToValidate, this.dateFormat);
      const row = this.instance.toVisualRow(this.row);
      const column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "dateValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
dateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE2;
function correctFormat(value, dateFormat) {
  const dateFromDate = moment_default(getNormalizedDate(value));
  const dateFromMoment = moment_default(value, dateFormat);
  const isAlphanumeric = value.search(/[A-z]/g) > -1;
  let date;
  if (dateFromDate.isValid() && dateFromDate.format("x") === dateFromMoment.format("x") || !dateFromMoment.isValid() || isAlphanumeric) {
    date = dateFromDate;
  } else {
    date = dateFromMoment;
  }
  return date.format(dateFormat);
}

// node_modules/handsontable/validators/numericValidator/numericValidator.mjs
var VALIDATOR_TYPE3 = "numeric";
function numericValidator(value, callback) {
  let valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
  } else if (valueToValidate === "") {
    callback(false);
  } else {
    callback(isNumeric(value));
  }
}
numericValidator.VALIDATOR_TYPE = VALIDATOR_TYPE3;

// node_modules/handsontable/validators/timeValidator/timeValidator.mjs
init_moment();
var STRICT_FORMATS = [
  "YYYY-MM-DDTHH:mm:ss.SSSZ",
  "X",
  // Unix timestamp
  "x"
  // Unix ms timestamp
];
var VALIDATOR_TYPE4 = "time";
function timeValidator(value, callback) {
  const timeFormat = this.timeFormat || "h:mm:ss a";
  let valid = true;
  let valueToValidate = value;
  if (valueToValidate === null) {
    valueToValidate = "";
  }
  valueToValidate = /^\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;
  const twoDigitValue = /^\d{1,2}$/.test(valueToValidate);
  if (twoDigitValue) {
    valueToValidate += ":00";
  }
  const date = moment_default(valueToValidate, STRICT_FORMATS, true).isValid() ? moment_default(valueToValidate) : moment_default(valueToValidate, timeFormat);
  let isValidTime = date.isValid();
  let isValidFormat = moment_default(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;
  if (this.allowEmpty && valueToValidate === "") {
    isValidTime = true;
    isValidFormat = true;
  }
  if (!isValidTime) {
    valid = false;
  }
  if (!isValidTime && isValidFormat) {
    valid = true;
  }
  if (isValidTime && !isValidFormat) {
    if (this.correctFormat === true) {
      const correctedValue = date.format(timeFormat);
      const row = this.instance.toVisualRow(this.row);
      const column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "timeValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
timeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE4;

export {
  VALIDATOR_TYPE,
  autocompleteValidator,
  date_exports,
  VALIDATOR_TYPE2,
  dateValidator,
  VALIDATOR_TYPE3,
  numericValidator,
  VALIDATOR_TYPE4,
  timeValidator
};
//# sourceMappingURL=chunk-GWNI762B.js.map
