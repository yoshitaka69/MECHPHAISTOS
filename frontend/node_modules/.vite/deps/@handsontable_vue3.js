import {
  base_default
} from "./chunk-EPGL6C5M.js";
import "./chunk-RJXTGVOS.js";
import "./chunk-H3XAWK2W.js";
import "./chunk-GGDNQRPA.js";
import "./chunk-YLDM3EMW.js";
import "./chunk-3R2TYAQQ.js";
import "./chunk-7PZCNP7Y.js";
import "./chunk-VPHRZUP4.js";
import "./chunk-KYJUC2GR.js";
import "./chunk-ZLUG3KRD.js";
import "./chunk-ESOZBQXP.js";
import {
  createElementBlock,
  defineComponent,
  markRaw,
  openBlock,
  renderSlot
} from "./chunk-PBWN42R4.js";
import "./chunk-AUZ3RYOM.js";

// node_modules/@handsontable/vue3/es/vue-handsontable.mjs
var unassignedPropSymbol = Symbol("unassigned");
var HOT_DESTROYED_WARNING = "The Handsontable instance bound to this component was destroyed and cannot be used properly.";
function hasOwnProperty(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}
function propFactory(source) {
  var registeredHooks = base_default.hooks.getRegistered();
  var propSchema = {};
  Object.assign(propSchema, base_default.DefaultSettings);
  for (var prop in propSchema) {
    propSchema[prop] = {
      "default": unassignedPropSymbol
    };
  }
  for (var i = 0; i < registeredHooks.length; i++) {
    propSchema[registeredHooks[i]] = {
      "default": unassignedPropSymbol
    };
  }
  propSchema.settings = {
    "default": unassignedPropSymbol
  };
  if (source === "HotTable") {
    propSchema.id = {
      type: String,
      "default": "hot-".concat(Math.random().toString(36).substring(5))
    };
  }
  return propSchema;
}
function filterPassedProps(props) {
  var filteredProps = {};
  var columnSettingsProp = props.settings;
  if (columnSettingsProp !== unassignedPropSymbol) {
    for (var propName in columnSettingsProp) {
      if (hasOwnProperty(columnSettingsProp, propName) && columnSettingsProp[propName] !== unassignedPropSymbol) {
        filteredProps[propName] = columnSettingsProp[propName];
      }
    }
  }
  for (var _propName in props) {
    if (hasOwnProperty(props, _propName) && _propName !== "settings" && props[_propName] !== unassignedPropSymbol) {
      filteredProps[_propName] = props[_propName];
    }
  }
  return filteredProps;
}
function prepareSettings(props, currentSettings) {
  var assignedProps = filterPassedProps(props);
  var hotSettingsInProps = props.settings ? props.settings : assignedProps;
  var additionalHotSettingsInProps = props.settings ? assignedProps : null;
  var newSettings = {};
  for (var key in hotSettingsInProps) {
    if (hasOwnProperty(hotSettingsInProps, key) && hotSettingsInProps[key] !== void 0 && (currentSettings && key !== "data" ? !simpleEqual(currentSettings[key], hotSettingsInProps[key]) : true)) {
      newSettings[key] = hotSettingsInProps[key];
    }
  }
  for (var _key in additionalHotSettingsInProps) {
    if (hasOwnProperty(additionalHotSettingsInProps, _key) && _key !== "id" && _key !== "settings" && additionalHotSettingsInProps[_key] !== void 0 && (currentSettings && _key !== "data" ? !simpleEqual(currentSettings[_key], additionalHotSettingsInProps[_key]) : true)) {
      newSettings[_key] = additionalHotSettingsInProps[_key];
    }
  }
  return newSettings;
}
function simpleEqual(objectA, objectB) {
  return JSON.stringify(objectA) === JSON.stringify(objectB);
}
var version = "14.0.0";
var HotTable = defineComponent({
  name: "HotTable",
  props: propFactory("HotTable"),
  provide: function provide() {
    return {
      columnsCache: this.columnsCache
    };
  },
  watch: {
    $props: {
      handler: function handler(props) {
        var settings = prepareSettings(props, this.hotInstance ? this.hotInstance.getSettings() : void 0);
        if (!this.hotInstance || settings === void 0) {
          return;
        }
        if (settings.data) {
          if (this.hotInstance.isColumnModificationAllowed() || !this.hotInstance.isColumnModificationAllowed() && this.hotInstance.countSourceCols() === this.miscCache.currentSourceColumns) {
            this.matchHotMappersSize();
            delete settings.data;
          }
        }
        if (Object.keys(settings).length) {
          this.hotInstance.updateSettings(settings);
        } else {
          this.hotInstance.render();
        }
        this.miscCache.currentSourceColumns = this.hotInstance.countSourceCols();
      },
      deep: true,
      immediate: true
    }
  },
  data: function data() {
    return {
      /* eslint-disable vue/no-reserved-keys */
      __hotInstance: null,
      /* eslint-enable vue/no-reserved-keys */
      miscCache: {
        currentSourceColumns: null
      },
      columnSettings: null,
      columnsCache: /* @__PURE__ */ new Map(),
      get hotInstance() {
        if (!this.__hotInstance || this.__hotInstance && !this.__hotInstance.isDestroyed) {
          return this.__hotInstance;
        } else {
          console.warn(HOT_DESTROYED_WARNING);
          return null;
        }
      },
      set hotInstance(hotInstance) {
        this.__hotInstance = hotInstance;
      }
    };
  },
  methods: {
    /**
     * Initialize Handsontable.
     */
    hotInit: function hotInit() {
      var newSettings = prepareSettings(this.$props);
      newSettings.columns = this.columnSettings ? this.columnSettings : newSettings.columns;
      this.hotInstance = markRaw(new base_default.Core(this.$el, newSettings));
      this.hotInstance.init();
      this.miscCache.currentSourceColumns = this.hotInstance.countSourceCols();
    },
    matchHotMappersSize: function matchHotMappersSize() {
      var _this = this;
      if (!this.hotInstance) {
        return;
      }
      var data2 = this.hotInstance.getSourceData();
      var rowsToRemove = [];
      var columnsToRemove = [];
      var indexMapperRowCount = this.hotInstance.rowIndexMapper.getNumberOfIndexes();
      var isColumnModificationAllowed = this.hotInstance.isColumnModificationAllowed();
      var indexMapperColumnCount = 0;
      if (data2 && data2.length !== indexMapperRowCount) {
        if (data2.length < indexMapperRowCount) {
          for (var r = data2.length; r < indexMapperRowCount; r++) {
            rowsToRemove.push(r);
          }
        }
      }
      if (isColumnModificationAllowed) {
        var _data$;
        indexMapperColumnCount = this.hotInstance.columnIndexMapper.getNumberOfIndexes();
        if (data2 && data2[0] && ((_data$ = data2[0]) === null || _data$ === void 0 ? void 0 : _data$.length) !== indexMapperColumnCount) {
          if (data2[0].length < indexMapperColumnCount) {
            for (var c = data2[0].length; c < indexMapperColumnCount; c++) {
              columnsToRemove.push(c);
            }
          }
        }
      }
      this.hotInstance.batch(function() {
        if (rowsToRemove.length > 0) {
          _this.hotInstance.rowIndexMapper.removeIndexes(rowsToRemove);
        } else {
          _this.hotInstance.rowIndexMapper.insertIndexes(indexMapperRowCount - 1, data2.length - indexMapperRowCount);
        }
        if (isColumnModificationAllowed && data2.length !== 0) {
          if (columnsToRemove.length > 0) {
            _this.hotInstance.columnIndexMapper.removeIndexes(columnsToRemove);
          } else {
            _this.hotInstance.columnIndexMapper.insertIndexes(indexMapperColumnCount - 1, data2[0].length - indexMapperColumnCount);
          }
        }
      });
    },
    /**
     * Get settings for the columns provided in the `hot-column` components.
     *
     * @returns {HotTableProps[] | undefined}
     */
    getColumnSettings: function getColumnSettings() {
      var columnSettings = Array.from(this.columnsCache.values());
      return columnSettings.length ? columnSettings : void 0;
    }
  },
  mounted: function mounted() {
    this.columnSettings = this.getColumnSettings();
    this.hotInit();
  },
  beforeUnmount: function beforeUnmount() {
    if (this.hotInstance) {
      this.hotInstance.destroy();
    }
  },
  version
});
var _hoisted_1 = ["id"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    id: _ctx.id
  }, [renderSlot(_ctx.$slots, "default")], 8, _hoisted_1);
}
HotTable.render = render;
HotTable.__file = "src/HotTable.vue";
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var HotColumn = defineComponent({
  name: "HotColumn",
  props: propFactory("HotColumn"),
  inject: ["columnsCache"],
  methods: {
    /**
     * Create the column settings based on the data provided to the `hot-column`
     * component and it's child components.
     */
    createColumnSettings: function createColumnSettings() {
      var assignedProps = filterPassedProps(this.$props);
      var columnSettings = _objectSpread2({}, assignedProps);
      if (assignedProps.renderer) {
        columnSettings.renderer = assignedProps.renderer;
      }
      if (assignedProps.editor) {
        columnSettings.editor = assignedProps.editor;
      }
      this.columnsCache.set(this, columnSettings);
    }
  },
  mounted: function mounted2() {
    this.createColumnSettings();
  },
  unmounted: function unmounted() {
    this.columnsCache["delete"](this);
  },
  render: function render2() {
    return null;
  }
});
HotColumn.__file = "src/HotColumn.vue";
export {
  HotColumn,
  HotTable,
  HotTable as default
};
//# sourceMappingURL=@handsontable_vue3.js.map
