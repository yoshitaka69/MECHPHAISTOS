{
  "version": 3,
  "sources": ["../../handsontable/validators/autocompleteValidator/autocompleteValidator.mjs", "../../handsontable/validators/dateValidator/dateValidator.mjs", "../../handsontable/helpers/date.mjs", "../../handsontable/validators/numericValidator/numericValidator.mjs", "../../handsontable/validators/timeValidator/timeValidator.mjs"],
  "sourcesContent": ["export const VALIDATOR_TYPE = 'autocomplete';\n\n/**\n * The Autocomplete cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\nexport function autocompleteValidator(value, callback) {\n  let valueToValidate = value;\n  if (valueToValidate === null || valueToValidate === undefined) {\n    valueToValidate = '';\n  }\n  if (this.allowEmpty && valueToValidate === '') {\n    callback(true);\n    return;\n  }\n  if (this.strict && this.source) {\n    if (typeof this.source === 'function') {\n      this.source(valueToValidate, process(valueToValidate, callback));\n    } else {\n      process(valueToValidate, callback)(this.source);\n    }\n  } else {\n    callback(true);\n  }\n}\nautocompleteValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;\n\n/**\n * Function responsible for validation of autocomplete value.\n *\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n * @returns {Function}\n */\nfunction process(value, callback) {\n  const originalVal = value;\n  return function (source) {\n    let found = false;\n    for (let s = 0, slen = source.length; s < slen; s++) {\n      if (originalVal === source[s]) {\n        found = true; // perfect match\n        break;\n      }\n    }\n    callback(found);\n  };\n}", "import moment from 'moment';\nimport { getEditorInstance } from \"../../editors/registry.mjs\";\nimport { EDITOR_TYPE as DATE_EDITOR_TYPE } from \"../../editors/dateEditor/index.mjs\";\nimport { getNormalizedDate } from \"../../helpers/date.mjs\";\nexport const VALIDATOR_TYPE = 'date';\n\n/**\n * The Date cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\nexport function dateValidator(value, callback) {\n  const dateEditor = getEditorInstance(DATE_EDITOR_TYPE, this.instance);\n  let valueToValidate = value;\n  let valid = true;\n  if (valueToValidate === null || valueToValidate === undefined) {\n    valueToValidate = '';\n  }\n  let isValidFormat = moment(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();\n  let isValidDate = moment(new Date(valueToValidate)).isValid() || isValidFormat;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidDate = true;\n    isValidFormat = true;\n  }\n  if (!isValidDate) {\n    valid = false;\n  }\n  if (!isValidDate && isValidFormat) {\n    valid = true;\n  }\n  if (isValidDate && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      const correctedValue = correctFormat(valueToValidate, this.dateFormat);\n      const row = this.instance.toVisualRow(this.row);\n      const column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'dateValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}\ndateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;\n\n/**\n * Format the given string using moment.js' format feature.\n *\n * @param {string} value The value to format.\n * @param {string} dateFormat The date pattern to format to.\n * @returns {string}\n */\nexport function correctFormat(value, dateFormat) {\n  const dateFromDate = moment(getNormalizedDate(value));\n  const dateFromMoment = moment(value, dateFormat);\n  const isAlphanumeric = value.search(/[A-z]/g) > -1;\n  let date;\n  if (dateFromDate.isValid() && dateFromDate.format('x') === dateFromMoment.format('x') || !dateFromMoment.isValid() || isAlphanumeric) {\n    date = dateFromDate;\n  } else {\n    date = dateFromMoment;\n  }\n  return date.format(dateFormat);\n}", "/**\n * Get normalized Date object for the ISO formatted date strings.\n * Natively, the date object parsed from a ISO 8601 string will be offsetted by the timezone difference, which may result in returning a wrong date.\n * See: Github issue #3338.\n *\n * @param {string} dateString String representing the date.\n * @returns {Date} The proper Date object.\n */\nexport function getNormalizedDate(dateString) {\n  const nativeDate = new Date(dateString);\n\n  // NaN if dateString is not in ISO format\n  if (!isNaN(new Date(`${dateString}T00:00`).getDate())) {\n    // Compensate timezone offset\n    return new Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 60000);\n  }\n  return nativeDate;\n}", "import { isNumeric } from \"../../helpers/number.mjs\";\nexport const VALIDATOR_TYPE = 'numeric';\n\n/**\n * The Numeric cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\nexport function numericValidator(value, callback) {\n  let valueToValidate = value;\n  if (valueToValidate === null || valueToValidate === undefined) {\n    valueToValidate = '';\n  }\n  if (this.allowEmpty && valueToValidate === '') {\n    callback(true);\n  } else if (valueToValidate === '') {\n    callback(false);\n  } else {\n    callback(isNumeric(value));\n  }\n}\nnumericValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;", "import moment from 'moment';\n\n// Formats which are correctly parsed to time (supported by momentjs)\nconst STRICT_FORMATS = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'X',\n// Unix timestamp\n'x' // Unix ms timestamp\n];\n\nexport const VALIDATOR_TYPE = 'time';\n\n/**\n * The Time cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\nexport function timeValidator(value, callback) {\n  const timeFormat = this.timeFormat || 'h:mm:ss a';\n  let valid = true;\n  let valueToValidate = value;\n  if (valueToValidate === null) {\n    valueToValidate = '';\n  }\n  valueToValidate = /^\\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;\n  const twoDigitValue = /^\\d{1,2}$/.test(valueToValidate);\n  if (twoDigitValue) {\n    valueToValidate += ':00';\n  }\n  const date = moment(valueToValidate, STRICT_FORMATS, true).isValid() ? moment(valueToValidate) : moment(valueToValidate, timeFormat);\n  let isValidTime = date.isValid();\n\n  // is it in the specified format\n  let isValidFormat = moment(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidTime = true;\n    isValidFormat = true;\n  }\n  if (!isValidTime) {\n    valid = false;\n  }\n  if (!isValidTime && isValidFormat) {\n    valid = true;\n  }\n  if (isValidTime && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      const correctedValue = date.format(timeFormat);\n      const row = this.instance.toVisualRow(this.row);\n      const column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'timeValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}\ntimeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;"],
  "mappings": ";;;;;;;;;;;;;;;AAAO,IAAM,iBAAiB;AASvB,SAAS,sBAAsB,OAAO,UAAU;AACrD,MAAI,kBAAkB;AACtB,MAAI,oBAAoB,QAAQ,oBAAoB,QAAW;AAC7D,sBAAkB;AAAA,EACpB;AACA,MAAI,KAAK,cAAc,oBAAoB,IAAI;AAC7C,aAAS,IAAI;AACb;AAAA,EACF;AACA,MAAI,KAAK,UAAU,KAAK,QAAQ;AAC9B,QAAI,OAAO,KAAK,WAAW,YAAY;AACrC,WAAK,OAAO,iBAAiB,QAAQ,iBAAiB,QAAQ,CAAC;AAAA,IACjE,OAAO;AACL,cAAQ,iBAAiB,QAAQ,EAAE,KAAK,MAAM;AAAA,IAChD;AAAA,EACF,OAAO;AACL,aAAS,IAAI;AAAA,EACf;AACF;AACA,sBAAsB,iBAAiB;AASvC,SAAS,QAAQ,OAAO,UAAU;AAChC,QAAM,cAAc;AACpB,SAAO,SAAU,QAAQ;AACvB,QAAI,QAAQ;AACZ,aAAS,IAAI,GAAG,OAAO,OAAO,QAAQ,IAAI,MAAM,KAAK;AACnD,UAAI,gBAAgB,OAAO,CAAC,GAAG;AAC7B,gBAAQ;AACR;AAAA,MACF;AAAA,IACF;AACA,aAAS,KAAK;AAAA,EAChB;AACF;;;ACjDA;;;ACQO,SAAS,kBAAkB,YAAY;AAC5C,QAAM,aAAa,IAAI,KAAK,UAAU;AAGtC,MAAI,CAAC,OAAM,oBAAI,KAAK,GAAG,UAAU,QAAQ,GAAE,QAAQ,CAAC,GAAG;AAErD,WAAO,IAAI,KAAK,WAAW,QAAQ,IAAI,WAAW,kBAAkB,IAAI,GAAK;AAAA,EAC/E;AACA,SAAO;AACT;;;ADbO,IAAMA,kBAAiB;AASvB,SAAS,cAAc,OAAO,UAAU;AAC7C,QAAM,aAAa,mBAAkB,aAAkB,KAAK,QAAQ;AACpE,MAAI,kBAAkB;AACtB,MAAI,QAAQ;AACZ,MAAI,oBAAoB,QAAQ,oBAAoB,QAAW;AAC7D,sBAAkB;AAAA,EACpB;AACA,MAAI,gBAAgB,eAAO,iBAAiB,KAAK,cAAc,WAAW,mBAAmB,IAAI,EAAE,QAAQ;AAC3G,MAAI,cAAc,eAAO,IAAI,KAAK,eAAe,CAAC,EAAE,QAAQ,KAAK;AACjE,MAAI,KAAK,cAAc,oBAAoB,IAAI;AAC7C,kBAAc;AACd,oBAAgB;AAAA,EAClB;AACA,MAAI,CAAC,aAAa;AAChB,YAAQ;AAAA,EACV;AACA,MAAI,CAAC,eAAe,eAAe;AACjC,YAAQ;AAAA,EACV;AACA,MAAI,eAAe,CAAC,eAAe;AACjC,QAAI,KAAK,kBAAkB,MAAM;AAE/B,YAAM,iBAAiB,cAAc,iBAAiB,KAAK,UAAU;AACrE,YAAM,MAAM,KAAK,SAAS,YAAY,KAAK,GAAG;AAC9C,YAAM,SAAS,KAAK,SAAS,eAAe,KAAK,GAAG;AACpD,WAAK,SAAS,cAAc,KAAK,QAAQ,gBAAgB,eAAe;AACxE,cAAQ;AAAA,IACV,OAAO;AACL,cAAQ;AAAA,IACV;AAAA,EACF;AACA,WAAS,KAAK;AAChB;AACA,cAAc,iBAAiBA;AASxB,SAAS,cAAc,OAAO,YAAY;AAC/C,QAAM,eAAe,eAAO,kBAAkB,KAAK,CAAC;AACpD,QAAM,iBAAiB,eAAO,OAAO,UAAU;AAC/C,QAAM,iBAAiB,MAAM,OAAO,QAAQ,IAAI;AAChD,MAAI;AACJ,MAAI,aAAa,QAAQ,KAAK,aAAa,OAAO,GAAG,MAAM,eAAe,OAAO,GAAG,KAAK,CAAC,eAAe,QAAQ,KAAK,gBAAgB;AACpI,WAAO;AAAA,EACT,OAAO;AACL,WAAO;AAAA,EACT;AACA,SAAO,KAAK,OAAO,UAAU;AAC/B;;;AEjEO,IAAMC,kBAAiB;AASvB,SAAS,iBAAiB,OAAO,UAAU;AAChD,MAAI,kBAAkB;AACtB,MAAI,oBAAoB,QAAQ,oBAAoB,QAAW;AAC7D,sBAAkB;AAAA,EACpB;AACA,MAAI,KAAK,cAAc,oBAAoB,IAAI;AAC7C,aAAS,IAAI;AAAA,EACf,WAAW,oBAAoB,IAAI;AACjC,aAAS,KAAK;AAAA,EAChB,OAAO;AACL,aAAS,UAAU,KAAK,CAAC;AAAA,EAC3B;AACF;AACA,iBAAiB,iBAAiBA;;;ACvBlC;AAGA,IAAM,iBAAiB;AAAA,EAAC;AAAA,EAA4B;AAAA;AAAA,EAEpD;AAAA;AACA;AAEO,IAAMC,kBAAiB;AASvB,SAAS,cAAc,OAAO,UAAU;AAC7C,QAAM,aAAa,KAAK,cAAc;AACtC,MAAI,QAAQ;AACZ,MAAI,kBAAkB;AACtB,MAAI,oBAAoB,MAAM;AAC5B,sBAAkB;AAAA,EACpB;AACA,oBAAkB,WAAW,KAAK,eAAe,IAAI,SAAS,iBAAiB,EAAE,IAAI;AACrF,QAAM,gBAAgB,YAAY,KAAK,eAAe;AACtD,MAAI,eAAe;AACjB,uBAAmB;AAAA,EACrB;AACA,QAAM,OAAO,eAAO,iBAAiB,gBAAgB,IAAI,EAAE,QAAQ,IAAI,eAAO,eAAe,IAAI,eAAO,iBAAiB,UAAU;AACnI,MAAI,cAAc,KAAK,QAAQ;AAG/B,MAAI,gBAAgB,eAAO,iBAAiB,YAAY,IAAI,EAAE,QAAQ,KAAK,CAAC;AAC5E,MAAI,KAAK,cAAc,oBAAoB,IAAI;AAC7C,kBAAc;AACd,oBAAgB;AAAA,EAClB;AACA,MAAI,CAAC,aAAa;AAChB,YAAQ;AAAA,EACV;AACA,MAAI,CAAC,eAAe,eAAe;AACjC,YAAQ;AAAA,EACV;AACA,MAAI,eAAe,CAAC,eAAe;AACjC,QAAI,KAAK,kBAAkB,MAAM;AAE/B,YAAM,iBAAiB,KAAK,OAAO,UAAU;AAC7C,YAAM,MAAM,KAAK,SAAS,YAAY,KAAK,GAAG;AAC9C,YAAM,SAAS,KAAK,SAAS,eAAe,KAAK,GAAG;AACpD,WAAK,SAAS,cAAc,KAAK,QAAQ,gBAAgB,eAAe;AACxE,cAAQ;AAAA,IACV,OAAO;AACL,cAAQ;AAAA,IACV;AAAA,EACF;AACA,WAAS,KAAK;AAChB;AACA,cAAc,iBAAiBA;",
  "names": ["VALIDATOR_TYPE", "VALIDATOR_TYPE", "VALIDATOR_TYPE"]
}
