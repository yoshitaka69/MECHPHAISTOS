import {
  stopImmediatePropagation
} from "./chunk-IWTULMLB.js";
import {
  isDefined
} from "./chunk-DSUKSR6K.js";

// node_modules/handsontable/shortcutContexts/constants.mjs
var GRID_GROUP = "gridDefault";
var EDITOR_EDIT_GROUP = "editorManager.handlingEditor";

// node_modules/handsontable/shortcutContexts/commands/editor/closeAndSave.mjs
var command = {
  name: "editorCloseAndSave",
  callback(hot, event, keys) {
    const editorManager = hot._getEditorManager();
    editorManager.closeEditorAndSaveChanges(event.ctrlKey || event.metaKey);
    editorManager.moveSelectionAfterEnter(keys.includes("shift"));
  }
};

// node_modules/handsontable/shortcutContexts/commands/editor/closeWithoutSaving.mjs
var command2 = {
  name: "editorCloseWithoutSaving",
  callback(hot) {
    const editorManager = hot._getEditorManager();
    editorManager.closeEditorAndRestoreOriginalValue(hot.getShortcutManager().isCtrlPressed());
    editorManager.activeEditor.focus();
  }
};

// node_modules/handsontable/shortcutContexts/commands/editor/fastOpen.mjs
var command3 = {
  name: "editorFastOpen",
  callback(hot, event) {
    const {
      highlight
    } = hot.getSelectedRangeLast();
    if (highlight.isHeader()) {
      return;
    }
    hot._getEditorManager().openEditor(null, event, true);
  }
};

// node_modules/handsontable/shortcutContexts/commands/editor/open.mjs
var command4 = {
  name: "editorOpen",
  callback(hot, event, keys) {
    const editorManager = hot._getEditorManager();
    const {
      highlight
    } = hot.getSelectedRangeLast();
    if (highlight.isHeader()) {
      return;
    }
    if (hot.getSettings().enterBeginsEditing) {
      if (editorManager.cellProperties.readOnly) {
        editorManager.moveSelectionAfterEnter();
      } else {
        editorManager.openEditor(null, event, true);
      }
    } else {
      editorManager.moveSelectionAfterEnter(keys.includes("shift"));
    }
    stopImmediatePropagation(event);
  }
};

// node_modules/handsontable/shortcutContexts/commands/editor/index.mjs
function getAllCommands() {
  return [command, command2, command3, command4];
}

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/down.mjs
var command5 = {
  name: "extendCellsSelectionDown",
  callback(hot) {
    const {
      highlight
    } = hot.getSelectedRangeLast();
    if (highlight.isCell() || highlight.isHeader() && hot.selection.isSelectedByRowHeader()) {
      hot.selection.transformEnd(1, 0);
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/downByViewportHeight.mjs
var command6 = {
  name: "extendCellsSelectionDownByViewportHeight",
  callback(hot) {
    const {
      to
    } = hot.getSelectedRangeLast();
    const nextRowIndexToSelect = Math.min(to.row + hot.countVisibleRows(), hot.countRows() - 1);
    const row = hot.rowIndexMapper.getNearestNotHiddenIndex(nextRowIndexToSelect, -1);
    if (row !== null) {
      const coords = hot._createCellCoords(row, to.col);
      const scrollPadding = to.row - hot.view.getFirstFullyVisibleRow();
      const nextVerticalScroll = Math.min(coords.row - scrollPadding, hot.countRows() - 1);
      hot.selection.setRangeEnd(coords);
      hot.scrollViewportTo({
        row: nextVerticalScroll,
        verticalSnap: "top",
        horizontalSnap: "start"
      });
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/left.mjs
var command7 = {
  name: "extendCellsSelectionLeft",
  callback(hot) {
    const {
      highlight
    } = hot.getSelectedRangeLast();
    if (highlight.isCell() || highlight.isHeader() && hot.selection.isSelectedByColumnHeader()) {
      hot.selection.transformEnd(0, -1 * hot.getDirectionFactor());
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/right.mjs
var command8 = {
  name: "extendCellsSelectionRight",
  callback(hot) {
    const {
      highlight
    } = hot.getSelectedRangeLast();
    if (highlight.isCell() || highlight.isHeader() && hot.selection.isSelectedByColumnHeader()) {
      hot.selection.transformEnd(0, hot.getDirectionFactor());
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/toColumns.mjs
var command9 = {
  name: "extendCellsSelectionToColumns",
  callback(hot) {
    const {
      highlight,
      from,
      to
    } = hot.getSelectedRangeLast();
    if (hot.selection.isSelectedByRowHeader()) {
      hot.selection.selectAll(true, true);
    } else {
      hot.selectColumns(from.col, to.col, highlight.row);
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/toMostBottom.mjs
var command10 = {
  name: "extendCellsSelectionToMostBottom",
  callback(hot) {
    const {
      selection,
      rowIndexMapper
    } = hot;
    const {
      highlight,
      from,
      to
    } = hot.getSelectedRangeLast();
    const isFocusHighlightedByHeader = highlight.isHeader() && hot.selection.isSelectedByRowHeader();
    if (highlight.isCell() || isFocusHighlightedByHeader) {
      const row = rowIndexMapper.getNearestNotHiddenIndex(hot.countRows() - 1, -1);
      selection.setRangeStart(from.clone());
      if (isFocusHighlightedByHeader) {
        selection.selectedByRowHeader.add(selection.getLayerLevel());
      }
      selection.setRangeEnd(hot._createCellCoords(row, to.col));
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/toMostInlineEnd.mjs
var command11 = {
  name: "extendCellsSelectionToMostInlineEnd",
  callback(hot) {
    const {
      selection,
      columnIndexMapper
    } = hot;
    const {
      highlight
    } = hot.getSelectedRangeLast();
    if (highlight.isCell()) {
      selection.setRangeEnd(hot._createCellCoords(selection.selectedRange.current().from.row, columnIndexMapper.getNearestNotHiddenIndex(hot.countCols() - 1, -1)));
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/toMostInlineStart.mjs
var command12 = {
  name: "extendCellsSelectionToMostInlineStart",
  callback(hot) {
    const {
      selection,
      columnIndexMapper
    } = hot;
    const {
      highlight
    } = hot.getSelectedRangeLast();
    if (highlight.isCell()) {
      selection.setRangeEnd(hot._createCellCoords(selection.selectedRange.current().from.row, columnIndexMapper.getNearestNotHiddenIndex(0, 1)));
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/toMostLeft.mjs
var command13 = {
  name: "extendCellsSelectionToMostLeft",
  callback(hot) {
    const {
      selection,
      columnIndexMapper
    } = hot;
    const {
      highlight,
      from,
      to
    } = hot.getSelectedRangeLast();
    const isFocusHighlightedByHeader = highlight.isHeader() && hot.selection.isSelectedByColumnHeader();
    if (highlight.isCell() || isFocusHighlightedByHeader) {
      const column = columnIndexMapper.getNearestNotHiddenIndex(...hot.isRtl() ? [hot.countCols() - 1, -1] : [0, 1]);
      selection.setRangeStart(from.clone());
      if (isFocusHighlightedByHeader) {
        selection.selectedByColumnHeader.add(selection.getLayerLevel());
      }
      selection.setRangeEnd(hot._createCellCoords(to.row, column));
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/toMostRight.mjs
var command14 = {
  name: "extendCellsSelectionToMostRight",
  callback(hot) {
    const {
      selection,
      columnIndexMapper
    } = hot;
    const {
      highlight,
      from,
      to
    } = hot.getSelectedRangeLast();
    const isFocusHighlightedByHeader = highlight.isHeader() && hot.selection.isSelectedByColumnHeader();
    if (highlight.isCell() || isFocusHighlightedByHeader) {
      const column = columnIndexMapper.getNearestNotHiddenIndex(...hot.isRtl() ? [0, 1] : [hot.countCols() - 1, -1]);
      selection.setRangeStart(from.clone());
      if (isFocusHighlightedByHeader) {
        selection.selectedByColumnHeader.add(selection.getLayerLevel());
      }
      selection.setRangeEnd(hot._createCellCoords(to.row, column));
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/toMostTop.mjs
var command15 = {
  name: "extendCellsSelectionToMostTop",
  callback(hot) {
    const {
      selection,
      rowIndexMapper
    } = hot;
    const {
      highlight,
      from,
      to
    } = hot.getSelectedRangeLast();
    const isFocusHighlightedByHeader = highlight.isHeader() && hot.selection.isSelectedByRowHeader();
    if (highlight.isCell() || isFocusHighlightedByHeader) {
      const row = rowIndexMapper.getNearestNotHiddenIndex(0, 1);
      selection.setRangeStart(from.clone());
      if (isFocusHighlightedByHeader) {
        selection.selectedByRowHeader.add(selection.getLayerLevel());
      }
      selection.setRangeEnd(hot._createCellCoords(row, to.col));
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/toRows.mjs
var command16 = {
  name: "extendCellsSelectionToRows",
  callback(hot) {
    const {
      highlight,
      from,
      to
    } = hot.getSelectedRangeLast();
    if (hot.selection.isSelectedByColumnHeader()) {
      hot.selection.selectAll(true, true);
    } else {
      hot.selectRows(from.row, to.row, highlight.col);
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/up.mjs
var command17 = {
  name: "extendCellsSelectionUp",
  callback(hot) {
    const {
      highlight
    } = hot.getSelectedRangeLast();
    if (highlight.isCell() || highlight.isHeader() && hot.selection.isSelectedByRowHeader()) {
      hot.selection.transformEnd(-1, 0);
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/upByViewportHeight.mjs
var command18 = {
  name: "extendCellsSelectionUpByViewportHeight",
  callback(hot) {
    const {
      to
    } = hot.getSelectedRangeLast();
    const nextRowIndexToSelect = Math.max(to.row - hot.countVisibleRows(), 0);
    const row = hot.rowIndexMapper.getNearestNotHiddenIndex(nextRowIndexToSelect, 1);
    if (row !== null) {
      const coords = hot._createCellCoords(row, to.col);
      const scrollPadding = to.row - hot.view.getFirstFullyVisibleRow();
      const nextVerticalScroll = Math.max(coords.row - scrollPadding, 0);
      hot.selection.setRangeEnd(coords);
      hot.scrollViewportTo({
        row: nextVerticalScroll,
        verticalSnap: "top",
        horizontalSnap: "start"
      });
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/extendCellsSelection/index.mjs
function getAllCommands2() {
  return [command5, command6, command7, command8, command9, command10, command11, command12, command13, command14, command15, command16, command17, command18];
}

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/down.mjs
var command19 = {
  name: "moveCellSelectionDown",
  callback(_ref) {
    let {
      selection
    } = _ref;
    selection.transformStart(1, 0);
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/downByViewportHeight.mjs
var command20 = {
  name: "moveCellSelectionDownByViewportHeight",
  callback(hot) {
    const {
      navigableHeaders
    } = hot.getSettings();
    const columnHeadersCount = navigableHeaders ? hot.countColHeaders() : 0;
    const {
      row
    } = hot.getSelectedRangeLast().highlight;
    let rowsStep = hot.countVisibleRows() + columnHeadersCount;
    if (row === hot.countRows() - 1) {
      rowsStep = 1;
    } else if (row + rowsStep > hot.countRows()) {
      rowsStep = hot.countRows() - row - 1;
    }
    hot.selection.transformStart(rowsStep, 0);
    if (hot.getSelectedRangeLast().highlight.row < 0) {
      hot.scrollViewportTo({
        row: 0
      });
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/inlineEnd.mjs
var command21 = {
  name: "moveCellSelectionInlineEnd",
  callback(hot, event) {
    const settings = hot.getSettings();
    const tabMoves = typeof settings.tabMoves === "function" ? settings.tabMoves(event) : settings.tabMoves;
    hot.selection.transformStart(-tabMoves.row, -tabMoves.col);
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/inlineStart.mjs
var command22 = {
  name: "moveCellSelectionInlineStart",
  callback(hot, event) {
    const settings = hot.getSettings();
    const tabMoves = typeof settings.tabMoves === "function" ? settings.tabMoves(event) : settings.tabMoves;
    hot.selection.transformStart(tabMoves.row, tabMoves.col);
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/left.mjs
var command23 = {
  name: "moveCellSelectionLeft",
  callback(hot) {
    hot.selection.transformStart(0, -1 * hot.getDirectionFactor());
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/right.mjs
var command24 = {
  name: "moveCellSelectionRight",
  callback(hot) {
    hot.selection.transformStart(0, hot.getDirectionFactor());
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/toMostBottom.mjs
var command25 = {
  name: "moveCellSelectionToMostBottom",
  callback(hot) {
    const {
      col
    } = hot.getSelectedRangeLast().highlight;
    let row = hot.rowIndexMapper.getNearestNotHiddenIndex(hot.countRows() - 1, -1);
    if (row === null) {
      row = -1;
    }
    hot.selection.setRangeStart(hot._createCellCoords(row, col));
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/toMostBottomInlineEnd.mjs
var command26 = {
  name: "moveCellSelectionToMostBottomInlineEnd",
  callback(hot) {
    const {
      selection,
      rowIndexMapper,
      columnIndexMapper
    } = hot;
    const fixedRows = parseInt(hot.getSettings().fixedRowsBottom, 10);
    const row = rowIndexMapper.getNearestNotHiddenIndex(hot.countRows() - fixedRows - 1, -1);
    const column = columnIndexMapper.getNearestNotHiddenIndex(hot.countCols() - 1, -1);
    selection.setRangeStart(hot._createCellCoords(row, column));
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/toMostInlineEnd.mjs
var command27 = {
  name: "moveCellSelectionToMostInlineEnd",
  callback(hot) {
    const {
      selection,
      columnIndexMapper
    } = hot;
    selection.setRangeStart(hot._createCellCoords(hot.getSelectedRangeLast().highlight.row, columnIndexMapper.getNearestNotHiddenIndex(hot.countCols() - 1, -1)));
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/toMostInlineStart.mjs
var command28 = {
  name: "moveCellSelectionToMostInlineStart",
  callback(hot) {
    const {
      selection,
      columnIndexMapper
    } = hot;
    const fixedColumns = parseInt(hot.getSettings().fixedColumnsStart, 10);
    const row = hot.getSelectedRangeLast().highlight.row;
    const column = columnIndexMapper.getNearestNotHiddenIndex(fixedColumns, 1);
    selection.setRangeStart(hot._createCellCoords(row, column));
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/toMostLeft.mjs
var command29 = {
  name: "moveCellSelectionToMostLeft",
  callback(hot) {
    const {
      selection,
      columnIndexMapper
    } = hot;
    const row = hot.getSelectedRangeLast().highlight.row;
    let column = columnIndexMapper.getNearestNotHiddenIndex(...hot.isRtl() ? [hot.countCols() - 1, -1] : [0, 1]);
    if (column === null) {
      column = hot.isRtl() ? -1 : -hot.countRowHeaders();
    }
    selection.setRangeStart(hot._createCellCoords(row, column));
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/toMostRight.mjs
var command30 = {
  name: "moveCellSelectionToMostRight",
  callback(hot) {
    const {
      selection,
      columnIndexMapper
    } = hot;
    const {
      row
    } = hot.getSelectedRangeLast().highlight;
    let column = columnIndexMapper.getNearestNotHiddenIndex(...hot.isRtl() ? [0, 1] : [hot.countCols() - 1, -1]);
    if (column === null) {
      column = hot.isRtl() ? -hot.countRowHeaders() : -1;
    }
    selection.setRangeStart(hot._createCellCoords(row, column));
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/toMostTop.mjs
var command31 = {
  name: "moveCellSelectionToMostTop",
  callback(hot) {
    const {
      col
    } = hot.getSelectedRangeLast().highlight;
    let row = hot.rowIndexMapper.getNearestNotHiddenIndex(0, 1);
    if (row === null) {
      row = -hot.countColHeaders();
    }
    hot.selection.setRangeStart(hot._createCellCoords(row, col));
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/toMostTopInlineStart.mjs
var command32 = {
  name: "moveCellSelectionToMostTopInlineStart",
  callback(hot) {
    const {
      selection,
      rowIndexMapper,
      columnIndexMapper
    } = hot;
    const fixedRows = parseInt(hot.getSettings().fixedRowsTop, 10);
    const fixedColumns = parseInt(hot.getSettings().fixedColumnsStart, 10);
    const row = rowIndexMapper.getNearestNotHiddenIndex(fixedRows, 1);
    const column = columnIndexMapper.getNearestNotHiddenIndex(fixedColumns, 1);
    selection.setRangeStart(hot._createCellCoords(row, column));
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/up.mjs
var command33 = {
  name: "moveCellSelectionUp",
  callback(_ref) {
    let {
      selection
    } = _ref;
    selection.transformStart(-1, 0);
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/upByViewportHeight.mjs
var command34 = {
  name: "moveCellSelectionUpByViewportHight",
  callback(hot) {
    const {
      navigableHeaders
    } = hot.getSettings();
    const columnHeadersCount = navigableHeaders ? hot.countColHeaders() : 0;
    const {
      row
    } = hot.getSelectedRangeLast().highlight;
    let rowsStep = -(hot.countVisibleRows() + columnHeadersCount);
    if (row === -columnHeadersCount) {
      rowsStep = -1;
    } else if (row + rowsStep < columnHeadersCount) {
      rowsStep = -(row + columnHeadersCount);
    }
    hot.selection.transformStart(rowsStep, 0);
    if (hot.getSelectedRangeLast().highlight.row < 0) {
      hot.scrollViewportTo({
        row: 0
      });
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/moveCellSelection/index.mjs
function getAllCommands3() {
  return [command19, command20, command21, command22, command23, command24, command25, command26, command27, command28, command29, command30, command31, command32, command33, command34];
}

// node_modules/handsontable/shortcutContexts/commands/emptySelectedCells.mjs
var command35 = {
  name: "emptySelectedCells",
  callback(hot) {
    hot.emptySelectedCells();
    hot._getEditorManager().prepareEditor();
  }
};

// node_modules/handsontable/shortcutContexts/commands/scrollToFocusedCell.mjs
var command36 = {
  name: "scrollToFocusedCell",
  callback(hot) {
    const {
      highlight
    } = hot.getSelectedRangeLast();
    const firstVisibleRow = hot.view.getFirstFullyVisibleRow() - 1;
    const firstVisibleColumn = hot.view.getFirstFullyVisibleColumn() - 1;
    const lastVisibleRow = hot.view.getLastFullyVisibleRow() + 1;
    const lastVisibleColumn = hot.view.getLastFullyVisibleColumn() + 1;
    const visibleCoordsFrom = hot._createCellCoords(firstVisibleRow, firstVisibleColumn);
    const visibleCoordsTo = hot._createCellCoords(lastVisibleRow, lastVisibleColumn);
    const visibleRange = hot._createCellRange(visibleCoordsFrom, visibleCoordsFrom, visibleCoordsTo);
    if (!visibleRange.includes(highlight) && (highlight.row >= 0 || highlight.col >= 0)) {
      const scrollCoords = {};
      if (highlight.col >= 0) {
        const offsetColumns = Math.floor(hot.countVisibleCols() / 2);
        scrollCoords.col = Math.max(highlight.col - offsetColumns, 0);
      }
      if (highlight.row >= 0) {
        const offsetRows = Math.floor(hot.countVisibleRows() / 2);
        scrollCoords.row = Math.max(highlight.row - offsetRows, 0);
      }
      hot.scrollViewportTo({
        ...scrollCoords,
        verticalSnap: "top",
        horizontalSnap: "start"
      });
    }
  }
};

// node_modules/handsontable/shortcutContexts/commands/selectAllCells.mjs
var command37 = {
  name: "selectAllCells",
  callback(hot) {
    hot.selection.selectAll(true, true, {
      disableHeadersHighlight: true
    });
  }
};

// node_modules/handsontable/shortcutContexts/commands/selectAllCellsAndHeaders.mjs
var command38 = {
  name: "selectAllCellsAndHeaders",
  callback(hot) {
    hot.selection.selectAll(true, true, {
      disableHeadersHighlight: false
    });
  }
};

// node_modules/handsontable/shortcutContexts/commands/populateSelectedCellsData.mjs
var command39 = {
  name: "populateSelectedCellsData",
  callback(hot) {
    const selectedRange = hot.getSelectedRange();
    const {
      row: highlightRow,
      col: highlightColumn
    } = selectedRange[selectedRange.length - 1].highlight.normalize();
    const valueToPopulate = hot.getDataAtCell(highlightRow, highlightColumn);
    const cellValues = /* @__PURE__ */ new Map();
    for (let i = 0; i < selectedRange.length; i++) {
      selectedRange[i].forAll((row, column) => {
        if (row >= 0 && column >= 0 && (row !== highlightRow || column !== highlightColumn)) {
          const {
            readOnly
          } = hot.getCellMeta(row, column);
          if (!readOnly) {
            cellValues.set(`${row}x${column}`, [row, column, valueToPopulate]);
          }
        }
      });
    }
    hot.setDataAtCell(Array.from(cellValues.values()));
  }
};

// node_modules/handsontable/shortcutContexts/commands/index.mjs
var allCommands = [...getAllCommands(), ...getAllCommands2(), ...getAllCommands3(), command35, command36, command37, command38, command39];
function createKeyboardShortcutCommandsPool(hot) {
  const commands = {};
  allCommands.forEach((_ref) => {
    let {
      name,
      callback
    } = _ref;
    commands[name] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return callback(hot, ...args);
    };
  });
  return commands;
}

// node_modules/handsontable/shortcutContexts/editor.mjs
function shortcutsEditorContext(hot) {
  const context = hot.getShortcutManager().addContext("editor");
  const commandsPool = createKeyboardShortcutCommandsPool(hot);
  const config = {
    group: EDITOR_EDIT_GROUP
  };
  context.addShortcuts([{
    keys: [["Enter"], ["Enter", "Shift"]],
    callback: (event, keys) => commandsPool.editorCloseAndSave(event, keys)
  }, {
    keys: [["Enter", "Control/Meta"], ["Enter", "Control/Meta", "Shift"]],
    captureCtrl: true,
    callback: (event, keys) => commandsPool.editorCloseAndSave(event, keys)
  }, {
    keys: [["Escape"], ["Escape", "Control/Meta"]],
    callback: () => commandsPool.editorCloseWithoutSaving()
  }], config);
}

// node_modules/handsontable/shortcutContexts/grid.mjs
function shortcutsGridContext(hot) {
  const context = hot.getShortcutManager().addContext("grid");
  const commandsPool = createKeyboardShortcutCommandsPool(hot);
  const config = {
    runOnlyIf: () => {
      const {
        navigableHeaders
      } = hot.getSettings();
      return isDefined(hot.getSelected()) && (navigableHeaders || !navigableHeaders && hot.countRenderedRows() > 0 && hot.countRenderedCols() > 0);
    },
    group: GRID_GROUP
  };
  context.addShortcuts([{
    keys: [["F2"]],
    callback: (event) => commandsPool.editorFastOpen(event)
  }, {
    keys: [["Enter"], ["Enter", "Shift"]],
    callback: (event, keys) => commandsPool.editorOpen(event, keys)
  }, {
    keys: [["Backspace"], ["Delete"]],
    callback: () => commandsPool.emptySelectedCells()
  }], {
    group: EDITOR_EDIT_GROUP,
    runOnlyIf: () => isDefined(hot.getSelected())
  });
  context.addShortcuts([{
    keys: [["Control/Meta", "A"]],
    callback: () => commandsPool.selectAllCells()
  }, {
    keys: [["Control/Meta", "Shift", "Space"]],
    callback: () => commandsPool.selectAllCellsAndHeaders()
  }, {
    keys: [["Control/Meta", "Enter"]],
    callback: () => commandsPool.populateSelectedCellsData(),
    runOnlyIf: () => {
      return !hot.getSelectedRangeLast().highlight.isHeader() && hot.getSelectedRangeLast().getCellsCount() > 1;
    }
  }, {
    keys: [["Control", "Space"]],
    captureCtrl: true,
    callback: () => commandsPool.extendCellsSelectionToColumns()
  }, {
    keys: [["Shift", "Space"]],
    stopPropagation: true,
    callback: () => commandsPool.extendCellsSelectionToRows()
  }, {
    keys: [["ArrowUp"]],
    callback: () => commandsPool.moveCellSelectionUp()
  }, {
    keys: [["ArrowUp", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.moveCellSelectionToMostTop()
  }, {
    keys: [["ArrowUp", "Shift"]],
    callback: () => commandsPool.extendCellsSelectionUp()
  }, {
    keys: [["ArrowUp", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.extendCellsSelectionToMostTop(),
    runOnlyIf: () => !(hot.selection.isSelectedByCorner() || hot.selection.isSelectedByColumnHeader())
  }, {
    keys: [["ArrowDown"]],
    callback: () => commandsPool.moveCellSelectionDown()
  }, {
    keys: [["ArrowDown", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.moveCellSelectionToMostBottom()
  }, {
    keys: [["ArrowDown", "Shift"]],
    callback: () => commandsPool.extendCellsSelectionDown()
  }, {
    keys: [["ArrowDown", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.extendCellsSelectionToMostBottom(),
    runOnlyIf: () => !(hot.selection.isSelectedByCorner() || hot.selection.isSelectedByColumnHeader())
  }, {
    keys: [["ArrowLeft"]],
    callback: () => commandsPool.moveCellSelectionLeft()
  }, {
    keys: [["ArrowLeft", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.moveCellSelectionToMostLeft()
  }, {
    keys: [["ArrowLeft", "Shift"]],
    callback: () => commandsPool.extendCellsSelectionLeft()
  }, {
    keys: [["ArrowLeft", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.extendCellsSelectionToMostLeft(),
    runOnlyIf: () => !(hot.selection.isSelectedByCorner() || hot.selection.isSelectedByRowHeader())
  }, {
    keys: [["ArrowRight"]],
    callback: () => commandsPool.moveCellSelectionRight()
  }, {
    keys: [["ArrowRight", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.moveCellSelectionToMostRight()
  }, {
    keys: [["ArrowRight", "Shift"]],
    callback: () => commandsPool.extendCellsSelectionRight()
  }, {
    keys: [["ArrowRight", "Shift", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.extendCellsSelectionToMostRight(),
    runOnlyIf: () => !(hot.selection.isSelectedByCorner() || hot.selection.isSelectedByRowHeader())
  }, {
    keys: [["Home"]],
    captureCtrl: true,
    callback: () => commandsPool.moveCellSelectionToMostInlineStart(),
    runOnlyIf: () => hot.view.isMainTableNotFullyCoveredByOverlays()
  }, {
    keys: [["Home", "Shift"]],
    callback: () => commandsPool.extendCellsSelectionToMostInlineStart()
  }, {
    keys: [["Home", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.moveCellSelectionToMostTopInlineStart(),
    runOnlyIf: () => hot.view.isMainTableNotFullyCoveredByOverlays()
  }, {
    keys: [["End"]],
    captureCtrl: true,
    callback: () => commandsPool.moveCellSelectionToMostInlineEnd(),
    runOnlyIf: () => hot.view.isMainTableNotFullyCoveredByOverlays()
  }, {
    keys: [["End", "Shift"]],
    callback: () => commandsPool.extendCellsSelectionToMostInlineEnd()
  }, {
    keys: [["End", "Control/Meta"]],
    captureCtrl: true,
    callback: () => commandsPool.moveCellSelectionToMostBottomInlineEnd(),
    runOnlyIf: () => hot.view.isMainTableNotFullyCoveredByOverlays()
  }, {
    keys: [["PageUp"]],
    callback: () => commandsPool.moveCellSelectionUpByViewportHight()
  }, {
    keys: [["PageUp", "Shift"]],
    callback: () => commandsPool.extendCellsSelectionUpByViewportHeight()
  }, {
    keys: [["PageDown"]],
    callback: () => commandsPool.moveCellSelectionDownByViewportHeight()
  }, {
    keys: [["PageDown", "Shift"]],
    callback: () => commandsPool.extendCellsSelectionDownByViewportHeight()
  }, {
    keys: [["Tab"]],
    // The property value is controlled by focusCatcher module (https://github.com/handsontable/handsontable/blob/master/handsontable/src/core/focusCatcher/index.js)
    preventDefault: false,
    callback: () => commandsPool.moveCellSelectionInlineStart()
  }, {
    keys: [["Shift", "Tab"]],
    // The property value is controlled by focusCatcher module (https://github.com/handsontable/handsontable/blob/master/handsontable/src/core/focusCatcher/index.js)
    preventDefault: false,
    callback: () => commandsPool.moveCellSelectionInlineEnd()
  }, {
    keys: [["Control/Meta", "Backspace"]],
    callback: () => commandsPool.scrollToFocusedCell()
  }], config);
}

// node_modules/handsontable/shortcutContexts/index.mjs
function registerAllShortcutContexts(hotInstance) {
  [shortcutsEditorContext, shortcutsGridContext].forEach((context) => context(hotInstance));
}

export {
  GRID_GROUP,
  EDITOR_EDIT_GROUP,
  registerAllShortcutContexts
};
//# sourceMappingURL=chunk-MEYEZWNA.js.map
