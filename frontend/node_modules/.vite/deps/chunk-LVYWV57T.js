import {
  BaseEditor,
  EDITOR_EDIT_GROUP,
  EDITOR_STATE,
  SHORTCUTS_GROUP_NAVIGATION,
  TextCellType,
  TextEditor,
  baseRenderer,
  textRenderer
} from "./chunk-WMMQK7ZR.js";
import {
  A11Y_ACTIVEDESCENDANT,
  A11Y_AUTOCOMPLETE,
  A11Y_CHECKBOX,
  A11Y_CHECKED,
  A11Y_COMBOBOX,
  A11Y_CONTROLS,
  A11Y_EXPANDED,
  A11Y_HASPOPUP,
  A11Y_HIDDEN,
  A11Y_LABEL,
  A11Y_LISTBOX,
  A11Y_LIVE,
  A11Y_OPTION,
  A11Y_POSINSET,
  A11Y_PRESENTATION,
  A11Y_RELEVANT,
  A11Y_SELECTED,
  A11Y_SETSIZE,
  A11Y_TEXT,
  CHECKBOX_CHECKED,
  CHECKBOX_UNCHECKED,
  KEY_CODES,
  _getEditorInstance,
  _register4 as _register,
  addClass,
  arrayMap,
  deepExtend,
  empty,
  eventManager_default,
  extend,
  fastInnerHTML,
  getCaretPosition,
  getScrollbarWidth,
  getSelectionEndPosition,
  getTrimmingContainer,
  hasClass,
  init_moment,
  isDefined,
  isEmpty,
  isFunctionKey,
  isMacOS,
  isNumeric,
  isPrintableChar,
  moment_default,
  moment_exports,
  objectEach,
  offset,
  outerHeight,
  outerWidth,
  pivot,
  pluginHooks_default,
  rangeEach,
  removeClass,
  setAttribute,
  setCaretPosition,
  stopImmediatePropagation,
  stringify,
  stripTags
} from "./chunk-62K4XLGW.js";
import {
  __commonJS,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/pikaday/pikaday.js
var require_pikaday = __commonJS({
  "node_modules/pikaday/pikaday.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      var moment;
      if (typeof exports === "object") {
        try {
          moment = (init_moment(), __toCommonJS(moment_exports));
        } catch (e) {
        }
        module.exports = factory(moment);
      } else if (typeof define === "function" && define.amd) {
        define(function(req) {
          var id = "moment";
          try {
            moment = req(id);
          } catch (e) {
          }
          return factory(moment);
        });
      } else {
        root.Pikaday = factory(root.moment);
      }
    })(exports, function(moment) {
      "use strict";
      var hasMoment = typeof moment === "function", hasEventListeners = !!window.addEventListener, document = window.document, sto = window.setTimeout, addEvent = function(el, e, callback, capture) {
        if (hasEventListeners) {
          el.addEventListener(e, callback, !!capture);
        } else {
          el.attachEvent("on" + e, callback);
        }
      }, removeEvent = function(el, e, callback, capture) {
        if (hasEventListeners) {
          el.removeEventListener(e, callback, !!capture);
        } else {
          el.detachEvent("on" + e, callback);
        }
      }, trim = function(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }, hasClass2 = function(el, cn) {
        return (" " + el.className + " ").indexOf(" " + cn + " ") !== -1;
      }, addClass2 = function(el, cn) {
        if (!hasClass2(el, cn)) {
          el.className = el.className === "" ? cn : el.className + " " + cn;
        }
      }, removeClass2 = function(el, cn) {
        el.className = trim((" " + el.className + " ").replace(" " + cn + " ", " "));
      }, isArray = function(obj) {
        return /Array/.test(Object.prototype.toString.call(obj));
      }, isDate = function(obj) {
        return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
      }, isWeekend = function(date) {
        var day = date.getDay();
        return day === 0 || day === 6;
      }, isLeapYear = function(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }, getDaysInMonth = function(year, month) {
        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
      }, setToStartOfDay = function(date) {
        if (isDate(date))
          date.setHours(0, 0, 0, 0);
      }, compareDates = function(a, b) {
        return a.getTime() === b.getTime();
      }, extend2 = function(to, from, overwrite) {
        var prop, hasProp;
        for (prop in from) {
          hasProp = to[prop] !== void 0;
          if (hasProp && typeof from[prop] === "object" && from[prop] !== null && from[prop].nodeName === void 0) {
            if (isDate(from[prop])) {
              if (overwrite) {
                to[prop] = new Date(from[prop].getTime());
              }
            } else if (isArray(from[prop])) {
              if (overwrite) {
                to[prop] = from[prop].slice(0);
              }
            } else {
              to[prop] = extend2({}, from[prop], overwrite);
            }
          } else if (overwrite || !hasProp) {
            to[prop] = from[prop];
          }
        }
        return to;
      }, fireEvent = function(el, eventName, data) {
        var ev;
        if (document.createEvent) {
          ev = document.createEvent("HTMLEvents");
          ev.initEvent(eventName, true, false);
          ev = extend2(ev, data);
          el.dispatchEvent(ev);
        } else if (document.createEventObject) {
          ev = document.createEventObject();
          ev = extend2(ev, data);
          el.fireEvent("on" + eventName, ev);
        }
      }, adjustCalendar = function(calendar) {
        if (calendar.month < 0) {
          calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
          calendar.month += 12;
        }
        if (calendar.month > 11) {
          calendar.year += Math.floor(Math.abs(calendar.month) / 12);
          calendar.month -= 12;
        }
        return calendar;
      }, defaults = {
        // bind the picker to a form field
        field: null,
        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: void 0,
        // data-attribute on the input field with an aria assistance text (only applied when `bound` is set)
        ariaLabel: "Use the arrow keys to pick a date",
        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: "bottom left",
        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,
        // the default output format for `.toString()` and `field` value
        format: "YYYY-MM-DD",
        // the toString function which gets passed a current date object and format
        // and returns a string
        toString: null,
        // used to create date object from current input string
        parse: null,
        // the initial date to view when first opened
        defaultDate: null,
        // make the `defaultDate` the initial selected value
        setDefaultDate: false,
        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,
        // minimum number of days in the week that gets week number one
        // default ISO 8601, week 01 is the week with the first Thursday (4)
        firstWeekOfYearMinDays: 4,
        // the default flag for moment's strict date parsing
        formatStrict: false,
        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,
        // number of years either side, or array of upper/lower range
        yearRange: 10,
        // show week numbers at head of row
        showWeekNumber: false,
        // Week picker mode
        pickWholeWeek: false,
        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: void 0,
        maxMonth: void 0,
        startRange: null,
        endRange: null,
        isRTL: false,
        // Additional text to append to the year in the calendar title
        yearSuffix: "",
        // Render the month after year in the calendar title
        showMonthAfterYear: false,
        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,
        // Allows user to select days that fall in the next or previous month
        enableSelectionDaysInNextAndPreviousMonths: false,
        // how many months are visible
        numberOfMonths: 1,
        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: "left",
        // Specify a DOM element to render the calendar in
        container: void 0,
        // Blur field when date is selected
        blurFieldOnSelect: true,
        // internationalization
        i18n: {
          previousMonth: "Previous Month",
          nextMonth: "Next Month",
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        },
        // Theme Classname
        theme: null,
        // events array
        events: [],
        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null,
        // Enable keyboard input
        keyboardInput: true
      }, renderDayName = function(opts, day, abbr) {
        day += opts.firstDay;
        while (day >= 7) {
          day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
      }, renderDay = function(opts) {
        var arr = [];
        var ariaSelected = "false";
        if (opts.isEmpty) {
          if (opts.showDaysInNextAndPreviousMonths) {
            arr.push("is-outside-current-month");
            if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
              arr.push("is-selection-disabled");
            }
          } else {
            return '<td class="is-empty"></td>';
          }
        }
        if (opts.isDisabled) {
          arr.push("is-disabled");
        }
        if (opts.isToday) {
          arr.push("is-today");
        }
        if (opts.isSelected) {
          arr.push("is-selected");
          ariaSelected = "true";
        }
        if (opts.hasEvent) {
          arr.push("has-event");
        }
        if (opts.isInRange) {
          arr.push("is-inrange");
        }
        if (opts.isStartRange) {
          arr.push("is-startrange");
        }
        if (opts.isEndRange) {
          arr.push("is-endrange");
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(" ") + '" aria-selected="' + ariaSelected + '"><button class="pika-button pika-day" type="button" data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + "</button></td>";
      }, isoWeek = function(date, firstWeekOfYearMinDays) {
        date.setHours(0, 0, 0, 0);
        var yearDay = date.getDate(), weekDay = date.getDay(), dayInFirstWeek = firstWeekOfYearMinDays, dayShift = dayInFirstWeek - 1, daysPerWeek = 7, prevWeekDay = function(day) {
          return (day + daysPerWeek - 1) % daysPerWeek;
        };
        date.setDate(yearDay + dayShift - prevWeekDay(weekDay));
        var jan4th = new Date(date.getFullYear(), 0, dayInFirstWeek), msPerDay = 24 * 60 * 60 * 1e3, daysBetween = (date.getTime() - jan4th.getTime()) / msPerDay, weekNum = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);
        return weekNum;
      }, renderWeek = function(d, m, y, firstWeekOfYearMinDays) {
        var date = new Date(y, m, d), week = hasMoment ? moment(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);
        return '<td class="pika-week">' + week + "</td>";
      }, renderRow = function(days, isRTL, pickWholeWeek, isRowSelected) {
        return '<tr class="pika-row' + (pickWholeWeek ? " pick-whole-week" : "") + (isRowSelected ? " is-selected" : "") + '">' + (isRTL ? days.reverse() : days).join("") + "</tr>";
      }, renderBody = function(rows) {
        return "<tbody>" + rows.join("") + "</tbody>";
      }, renderHead = function(opts) {
        var i, arr = [];
        if (opts.showWeekNumber) {
          arr.push("<th></th>");
        }
        for (i = 0; i < 7; i++) {
          arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + "</abbr></th>");
        }
        return "<thead><tr>" + (opts.isRTL ? arr.reverse() : arr).join("") + "</tr></thead>";
      }, renderTitle = function(instance, c, year, month, refYear, randId) {
        var i, j, arr, opts = instance._o, isMinYear = year === opts.minYear, isMaxYear = year === opts.maxYear, html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">', monthHtml, yearHtml, prev = true, next = true;
        for (arr = [], i = 0; i < 12; i++) {
          arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : "") + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? ' disabled="disabled"' : "") + ">" + opts.i18n.months[i] + "</option>");
        }
        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join("") + "</select></div>";
        if (isArray(opts.yearRange)) {
          i = opts.yearRange[0];
          j = opts.yearRange[1] + 1;
        } else {
          i = year - opts.yearRange;
          j = 1 + year + opts.yearRange;
        }
        for (arr = []; i < j && i <= opts.maxYear; i++) {
          if (i >= opts.minYear) {
            arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : "") + ">" + i + "</option>");
          }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join("") + "</select></div>";
        if (opts.showMonthAfterYear) {
          html += yearHtml + monthHtml;
        } else {
          html += monthHtml + yearHtml;
        }
        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
          prev = false;
        }
        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
          next = false;
        }
        if (c === 0) {
          html += '<button class="pika-prev' + (prev ? "" : " is-disabled") + '" type="button">' + opts.i18n.previousMonth + "</button>";
        }
        if (c === instance._o.numberOfMonths - 1) {
          html += '<button class="pika-next' + (next ? "" : " is-disabled") + '" type="button">' + opts.i18n.nextMonth + "</button>";
        }
        return html += "</div>";
      }, renderTable = function(opts, data, randId) {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + "</table>";
      }, Pikaday2 = function(options) {
        var self2 = this, opts = self2.config(options);
        self2._onMouseDown = function(e) {
          if (!self2._v) {
            return;
          }
          e = e || window.event;
          var target = e.target || e.srcElement;
          if (!target) {
            return;
          }
          if (!hasClass2(target, "is-disabled")) {
            if (hasClass2(target, "pika-button") && !hasClass2(target, "is-empty") && !hasClass2(target.parentNode, "is-disabled")) {
              self2.setDate(new Date(target.getAttribute("data-pika-year"), target.getAttribute("data-pika-month"), target.getAttribute("data-pika-day")));
              if (opts.bound) {
                sto(function() {
                  self2.hide();
                  if (opts.blurFieldOnSelect && opts.field) {
                    opts.field.blur();
                  }
                }, 100);
              }
            } else if (hasClass2(target, "pika-prev")) {
              self2.prevMonth();
            } else if (hasClass2(target, "pika-next")) {
              self2.nextMonth();
            }
          }
          if (!hasClass2(target, "pika-select")) {
            if (e.preventDefault) {
              e.preventDefault();
            } else {
              e.returnValue = false;
              return false;
            }
          } else {
            self2._c = true;
          }
        };
        self2._onChange = function(e) {
          e = e || window.event;
          var target = e.target || e.srcElement;
          if (!target) {
            return;
          }
          if (hasClass2(target, "pika-select-month")) {
            self2.gotoMonth(target.value);
          } else if (hasClass2(target, "pika-select-year")) {
            self2.gotoYear(target.value);
          }
        };
        self2._onKeyChange = function(e) {
          e = e || window.event;
          if (self2.isVisible()) {
            switch (e.keyCode) {
              case 13:
              case 27:
                if (opts.field) {
                  opts.field.blur();
                }
                break;
              case 37:
                self2.adjustDate("subtract", 1);
                break;
              case 38:
                self2.adjustDate("subtract", 7);
                break;
              case 39:
                self2.adjustDate("add", 1);
                break;
              case 40:
                self2.adjustDate("add", 7);
                break;
              case 8:
              case 46:
                self2.setDate(null);
                break;
            }
          }
        };
        self2._parseFieldValue = function() {
          if (opts.parse) {
            return opts.parse(opts.field.value, opts.format);
          } else if (hasMoment) {
            var date = moment(opts.field.value, opts.format, opts.formatStrict);
            return date && date.isValid() ? date.toDate() : null;
          } else {
            return new Date(Date.parse(opts.field.value));
          }
        };
        self2._onInputChange = function(e) {
          var date;
          if (e.firedBy === self2) {
            return;
          }
          date = self2._parseFieldValue();
          if (isDate(date)) {
            self2.setDate(date);
          }
          if (!self2._v) {
            self2.show();
          }
        };
        self2._onInputFocus = function() {
          self2.show();
        };
        self2._onInputClick = function() {
          self2.show();
        };
        self2._onInputBlur = function() {
          var pEl = document.activeElement;
          do {
            if (hasClass2(pEl, "pika-single")) {
              return;
            }
          } while (pEl = pEl.parentNode);
          if (!self2._c) {
            self2._b = sto(function() {
              self2.hide();
            }, 50);
          }
          self2._c = false;
        };
        self2._onClick = function(e) {
          e = e || window.event;
          var target = e.target || e.srcElement, pEl = target;
          if (!target) {
            return;
          }
          if (!hasEventListeners && hasClass2(target, "pika-select")) {
            if (!target.onchange) {
              target.setAttribute("onchange", "return;");
              addEvent(target, "change", self2._onChange);
            }
          }
          do {
            if (hasClass2(pEl, "pika-single") || pEl === opts.trigger) {
              return;
            }
          } while (pEl = pEl.parentNode);
          if (self2._v && target !== opts.trigger && pEl !== opts.trigger) {
            self2.hide();
          }
        };
        self2.el = document.createElement("div");
        self2.el.className = "pika-single" + (opts.isRTL ? " is-rtl" : "") + (opts.theme ? " " + opts.theme : "");
        addEvent(self2.el, "mousedown", self2._onMouseDown, true);
        addEvent(self2.el, "touchend", self2._onMouseDown, true);
        addEvent(self2.el, "change", self2._onChange);
        if (opts.keyboardInput) {
          addEvent(document, "keydown", self2._onKeyChange);
        }
        if (opts.field) {
          if (opts.container) {
            opts.container.appendChild(self2.el);
          } else if (opts.bound) {
            document.body.appendChild(self2.el);
          } else {
            opts.field.parentNode.insertBefore(self2.el, opts.field.nextSibling);
          }
          addEvent(opts.field, "change", self2._onInputChange);
          if (!opts.defaultDate) {
            opts.defaultDate = self2._parseFieldValue();
            opts.setDefaultDate = true;
          }
        }
        var defDate = opts.defaultDate;
        if (isDate(defDate)) {
          if (opts.setDefaultDate) {
            self2.setDate(defDate, true);
          } else {
            self2.gotoDate(defDate);
          }
        } else {
          self2.gotoDate(/* @__PURE__ */ new Date());
        }
        if (opts.bound) {
          this.hide();
          self2.el.className += " is-bound";
          addEvent(opts.trigger, "click", self2._onInputClick);
          addEvent(opts.trigger, "focus", self2._onInputFocus);
          addEvent(opts.trigger, "blur", self2._onInputBlur);
        } else {
          this.show();
        }
      };
      Pikaday2.prototype = {
        /**
         * configure functionality
         */
        config: function(options) {
          if (!this._o) {
            this._o = extend2({}, defaults, true);
          }
          var opts = extend2(this._o, options, true);
          opts.isRTL = !!opts.isRTL;
          opts.field = opts.field && opts.field.nodeName ? opts.field : null;
          opts.theme = typeof opts.theme === "string" && opts.theme ? opts.theme : null;
          opts.bound = !!(opts.bound !== void 0 ? opts.field && opts.bound : opts.field);
          opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
          opts.disableWeekends = !!opts.disableWeekends;
          opts.disableDayFn = typeof opts.disableDayFn === "function" ? opts.disableDayFn : null;
          var nom = parseInt(opts.numberOfMonths, 10) || 1;
          opts.numberOfMonths = nom > 4 ? 4 : nom;
          if (!isDate(opts.minDate)) {
            opts.minDate = false;
          }
          if (!isDate(opts.maxDate)) {
            opts.maxDate = false;
          }
          if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
            opts.maxDate = opts.minDate = false;
          }
          if (opts.minDate) {
            this.setMinDate(opts.minDate);
          }
          if (opts.maxDate) {
            this.setMaxDate(opts.maxDate);
          }
          if (isArray(opts.yearRange)) {
            var fallback = (/* @__PURE__ */ new Date()).getFullYear() - 10;
            opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
            opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
          } else {
            opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
            if (opts.yearRange > 100) {
              opts.yearRange = 100;
            }
          }
          return opts;
        },
        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format) {
          format = format || this._o.format;
          if (!isDate(this._d)) {
            return "";
          }
          if (this._o.toString) {
            return this._o.toString(this._d, format);
          }
          if (hasMoment) {
            return moment(this._d).format(format);
          }
          return this._d.toDateString();
        },
        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function() {
          return hasMoment ? moment(this._d) : null;
        },
        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect) {
          if (hasMoment && moment.isMoment(date)) {
            this.setDate(date.toDate(), preventOnSelect);
          }
        },
        /**
         * return a Date object of the current selection
         */
        getDate: function() {
          return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },
        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect) {
          if (!date) {
            this._d = null;
            if (this._o.field) {
              this._o.field.value = "";
              fireEvent(this._o.field, "change", { firedBy: this });
            }
            return this.draw();
          }
          if (typeof date === "string") {
            date = new Date(Date.parse(date));
          }
          if (!isDate(date)) {
            return;
          }
          var min = this._o.minDate, max = this._o.maxDate;
          if (isDate(min) && date < min) {
            date = min;
          } else if (isDate(max) && date > max) {
            date = max;
          }
          this._d = new Date(date.getTime());
          setToStartOfDay(this._d);
          this.gotoDate(this._d);
          if (this._o.field) {
            this._o.field.value = this.toString();
            fireEvent(this._o.field, "change", { firedBy: this });
          }
          if (!preventOnSelect && typeof this._o.onSelect === "function") {
            this._o.onSelect.call(this, this.getDate());
          }
        },
        /**
         * clear and reset the date
         */
        clear: function() {
          this.setDate(null);
        },
        /**
         * change view to a specific date
         */
        gotoDate: function(date) {
          var newCalendar = true;
          if (!isDate(date)) {
            return;
          }
          if (this.calendars) {
            var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1), lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1), visibleDate = date.getTime();
            lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
            lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
            newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
          }
          if (newCalendar) {
            this.calendars = [{
              month: date.getMonth(),
              year: date.getFullYear()
            }];
            if (this._o.mainCalendar === "right") {
              this.calendars[0].month += 1 - this._o.numberOfMonths;
            }
          }
          this.adjustCalendars();
        },
        adjustDate: function(sign, days) {
          var day = this.getDate() || /* @__PURE__ */ new Date();
          var difference = parseInt(days) * 24 * 60 * 60 * 1e3;
          var newDay;
          if (sign === "add") {
            newDay = new Date(day.valueOf() + difference);
          } else if (sign === "subtract") {
            newDay = new Date(day.valueOf() - difference);
          }
          this.setDate(newDay);
        },
        adjustCalendars: function() {
          this.calendars[0] = adjustCalendar(this.calendars[0]);
          for (var c = 1; c < this._o.numberOfMonths; c++) {
            this.calendars[c] = adjustCalendar({
              month: this.calendars[0].month + c,
              year: this.calendars[0].year
            });
          }
          this.draw();
        },
        gotoToday: function() {
          this.gotoDate(/* @__PURE__ */ new Date());
        },
        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month) {
          if (!isNaN(month)) {
            this.calendars[0].month = parseInt(month, 10);
            this.adjustCalendars();
          }
        },
        nextMonth: function() {
          this.calendars[0].month++;
          this.adjustCalendars();
        },
        prevMonth: function() {
          this.calendars[0].month--;
          this.adjustCalendars();
        },
        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year) {
          if (!isNaN(year)) {
            this.calendars[0].year = parseInt(year, 10);
            this.adjustCalendars();
          }
        },
        /**
         * change the minDate
         */
        setMinDate: function(value) {
          if (value instanceof Date) {
            setToStartOfDay(value);
            this._o.minDate = value;
            this._o.minYear = value.getFullYear();
            this._o.minMonth = value.getMonth();
          } else {
            this._o.minDate = defaults.minDate;
            this._o.minYear = defaults.minYear;
            this._o.minMonth = defaults.minMonth;
            this._o.startRange = defaults.startRange;
          }
          this.draw();
        },
        /**
         * change the maxDate
         */
        setMaxDate: function(value) {
          if (value instanceof Date) {
            setToStartOfDay(value);
            this._o.maxDate = value;
            this._o.maxYear = value.getFullYear();
            this._o.maxMonth = value.getMonth();
          } else {
            this._o.maxDate = defaults.maxDate;
            this._o.maxYear = defaults.maxYear;
            this._o.maxMonth = defaults.maxMonth;
            this._o.endRange = defaults.endRange;
          }
          this.draw();
        },
        setStartRange: function(value) {
          this._o.startRange = value;
        },
        setEndRange: function(value) {
          this._o.endRange = value;
        },
        /**
         * refresh the HTML
         */
        draw: function(force) {
          if (!this._v && !force) {
            return;
          }
          var opts = this._o, minYear = opts.minYear, maxYear = opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html = "", randId;
          if (this._y <= minYear) {
            this._y = minYear;
            if (!isNaN(minMonth) && this._m < minMonth) {
              this._m = minMonth;
            }
          }
          if (this._y >= maxYear) {
            this._y = maxYear;
            if (!isNaN(maxMonth) && this._m > maxMonth) {
              this._m = maxMonth;
            }
          }
          for (var c = 0; c < opts.numberOfMonths; c++) {
            randId = "pika-title-" + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 2);
            html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + "</div>";
          }
          this.el.innerHTML = html;
          if (opts.bound) {
            if (opts.field.type !== "hidden") {
              sto(function() {
                opts.trigger.focus();
              }, 1);
            }
          }
          if (typeof this._o.onDraw === "function") {
            this._o.onDraw(this);
          }
          if (opts.bound) {
            opts.field.setAttribute("aria-label", opts.ariaLabel);
          }
        },
        adjustPosition: function() {
          var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect, leftAligned, bottomAligned;
          if (this._o.container)
            return;
          this.el.style.position = "absolute";
          field = this._o.trigger;
          pEl = field;
          width = this.el.offsetWidth;
          height = this.el.offsetHeight;
          viewportWidth = window.innerWidth || document.documentElement.clientWidth;
          viewportHeight = window.innerHeight || document.documentElement.clientHeight;
          scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
          leftAligned = true;
          bottomAligned = true;
          if (typeof field.getBoundingClientRect === "function") {
            clientRect = field.getBoundingClientRect();
            left = clientRect.left + window.pageXOffset;
            top = clientRect.bottom + window.pageYOffset;
          } else {
            left = pEl.offsetLeft;
            top = pEl.offsetTop + pEl.offsetHeight;
            while (pEl = pEl.offsetParent) {
              left += pEl.offsetLeft;
              top += pEl.offsetTop;
            }
          }
          if (this._o.reposition && left + width > viewportWidth || this._o.position.indexOf("right") > -1 && left - width + field.offsetWidth > 0) {
            left = left - width + field.offsetWidth;
            leftAligned = false;
          }
          if (this._o.reposition && top + height > viewportHeight + scrollTop || this._o.position.indexOf("top") > -1 && top - height - field.offsetHeight > 0) {
            top = top - height - field.offsetHeight;
            bottomAligned = false;
          }
          this.el.style.left = left + "px";
          this.el.style.top = top + "px";
          addClass2(this.el, leftAligned ? "left-aligned" : "right-aligned");
          addClass2(this.el, bottomAligned ? "bottom-aligned" : "top-aligned");
          removeClass2(this.el, !leftAligned ? "left-aligned" : "right-aligned");
          removeClass2(this.el, !bottomAligned ? "bottom-aligned" : "top-aligned");
        },
        /**
         * render HTML for a particular month
         */
        render: function(year, month, randId) {
          var opts = this._o, now = /* @__PURE__ */ new Date(), days = getDaysInMonth(year, month), before = new Date(year, month, 1).getDay(), data = [], row = [];
          setToStartOfDay(now);
          if (opts.firstDay > 0) {
            before -= opts.firstDay;
            if (before < 0) {
              before += 7;
            }
          }
          var previousMonth = month === 0 ? 11 : month - 1, nextMonth = month === 11 ? 0 : month + 1, yearOfPreviousMonth = month === 0 ? year - 1 : year, yearOfNextMonth = month === 11 ? year + 1 : year, daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
          var cells = days + before, after = cells;
          while (after > 7) {
            after -= 7;
          }
          cells += 7 - after;
          var isWeekSelected = false;
          for (var i = 0, r = 0; i < cells; i++) {
            var day = new Date(year, month, 1 + (i - before)), isSelected = isDate(this._d) ? compareDates(day, this._d) : false, isToday = compareDates(day, now), hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false, isEmpty2 = i < before || i >= days + before, dayNumber = 1 + (i - before), monthNumber = month, yearNumber = year, isStartRange = opts.startRange && compareDates(opts.startRange, day), isEndRange = opts.endRange && compareDates(opts.endRange, day), isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange, isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);
            if (isEmpty2) {
              if (i < before) {
                dayNumber = daysInPreviousMonth + dayNumber;
                monthNumber = previousMonth;
                yearNumber = yearOfPreviousMonth;
              } else {
                dayNumber = dayNumber - days;
                monthNumber = nextMonth;
                yearNumber = yearOfNextMonth;
              }
            }
            var dayConfig = {
              day: dayNumber,
              month: monthNumber,
              year: yearNumber,
              hasEvent,
              isSelected,
              isToday,
              isDisabled,
              isEmpty: isEmpty2,
              isStartRange,
              isEndRange,
              isInRange,
              showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
              enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
            };
            if (opts.pickWholeWeek && isSelected) {
              isWeekSelected = true;
            }
            row.push(renderDay(dayConfig));
            if (++r === 7) {
              if (opts.showWeekNumber) {
                row.unshift(renderWeek(i - before, month, year, opts.firstWeekOfYearMinDays));
              }
              data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
              row = [];
              r = 0;
              isWeekSelected = false;
            }
          }
          return renderTable(opts, data, randId);
        },
        isVisible: function() {
          return this._v;
        },
        show: function() {
          if (!this.isVisible()) {
            this._v = true;
            this.draw();
            removeClass2(this.el, "is-hidden");
            if (this._o.bound) {
              addEvent(document, "click", this._onClick);
              this.adjustPosition();
            }
            if (typeof this._o.onOpen === "function") {
              this._o.onOpen.call(this);
            }
          }
        },
        hide: function() {
          var v = this._v;
          if (v !== false) {
            if (this._o.bound) {
              removeEvent(document, "click", this._onClick);
            }
            if (!this._o.container) {
              this.el.style.position = "static";
              this.el.style.left = "auto";
              this.el.style.top = "auto";
            }
            addClass2(this.el, "is-hidden");
            this._v = false;
            if (v !== void 0 && typeof this._o.onClose === "function") {
              this._o.onClose.call(this);
            }
          }
        },
        /**
         * GAME OVER
         */
        destroy: function() {
          var opts = this._o;
          this.hide();
          removeEvent(this.el, "mousedown", this._onMouseDown, true);
          removeEvent(this.el, "touchend", this._onMouseDown, true);
          removeEvent(this.el, "change", this._onChange);
          if (opts.keyboardInput) {
            removeEvent(document, "keydown", this._onKeyChange);
          }
          if (opts.field) {
            removeEvent(opts.field, "change", this._onInputChange);
            if (opts.bound) {
              removeEvent(opts.trigger, "click", this._onInputClick);
              removeEvent(opts.trigger, "focus", this._onInputFocus);
              removeEvent(opts.trigger, "blur", this._onInputBlur);
            }
          }
          if (this.el.parentNode) {
            this.el.parentNode.removeChild(this.el);
          }
        }
      };
      return Pikaday2;
    });
  }
});

// node_modules/numbro/dist/numbro.min.js
var require_numbro_min = __commonJS({
  "node_modules/numbro/dist/numbro.min.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).numbro = e();
      }
    }(function() {
      return function a(o, u, c) {
        function s(t, e2) {
          if (!u[t]) {
            if (!o[t]) {
              var r = "function" == typeof __require && __require;
              if (!e2 && r)
                return r(t, true);
              if (l)
                return l(t, true);
              var n = new Error("Cannot find module '" + t + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = u[t] = { exports: {} };
            o[t][0].call(i.exports, function(e3) {
              return s(o[t][1][e3] || e3);
            }, i, i.exports, a, o, u, c);
          }
          return u[t].exports;
        }
        for (var l = "function" == typeof __require && __require, e = 0; e < c.length; e++)
          s(c[e]);
        return s;
      }({ 1: [function(e, r, t) {
        !function(e2) {
          "use strict";
          var t2, k = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, _ = Math.ceil, L = Math.floor, T = "[BigNumber Error] ", P = T + "Number primitive has more than 15 significant digits: ", U = 1e14, j = 14, C = 9007199254740991, R = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], I = 1e7, $ = 1e9;
          function G(e3) {
            var t3 = 0 | e3;
            return 0 < e3 || e3 === t3 ? t3 : t3 - 1;
          }
          function V(e3) {
            for (var t3, r2, n = 1, i = e3.length, a = e3[0] + ""; n < i; ) {
              for (t3 = e3[n++] + "", r2 = j - t3.length; r2--; t3 = "0" + t3)
                ;
              a += t3;
            }
            for (i = a.length; 48 === a.charCodeAt(--i); )
              ;
            return a.slice(0, i + 1 || 1);
          }
          function q(e3, t3) {
            var r2, n, i = e3.c, a = t3.c, o = e3.s, u = t3.s, c = e3.e, s = t3.e;
            if (!o || !u)
              return null;
            if (r2 = i && !i[0], n = a && !a[0], r2 || n)
              return r2 ? n ? 0 : -u : o;
            if (o != u)
              return o;
            if (r2 = o < 0, n = c == s, !i || !a)
              return n ? 0 : !i ^ r2 ? 1 : -1;
            if (!n)
              return s < c ^ r2 ? 1 : -1;
            for (u = (c = i.length) < (s = a.length) ? c : s, o = 0; o < u; o++)
              if (i[o] != a[o])
                return i[o] > a[o] ^ r2 ? 1 : -1;
            return c == s ? 0 : s < c ^ r2 ? 1 : -1;
          }
          function Z(e3, t3, r2, n) {
            if (e3 < t3 || r2 < e3 || e3 !== (e3 < 0 ? _(e3) : L(e3)))
              throw Error(T + (n || "Argument") + ("number" == typeof e3 ? e3 < t3 || r2 < e3 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e3));
          }
          function z(e3) {
            var t3 = e3.c.length - 1;
            return G(e3.e / j) == t3 && e3.c[t3] % 2 != 0;
          }
          function W(e3, t3) {
            return (1 < e3.length ? e3.charAt(0) + "." + e3.slice(1) : e3) + (t3 < 0 ? "e" : "e+") + t3;
          }
          function H(e3, t3, r2) {
            var n, i;
            if (t3 < 0) {
              for (i = r2 + "."; ++t3; i += r2)
                ;
              e3 = i + e3;
            } else if (++t3 > (n = e3.length)) {
              for (i = r2, t3 -= n; --t3; i += r2)
                ;
              e3 += i;
            } else
              t3 < n && (e3 = e3.slice(0, t3) + "." + e3.slice(t3));
            return e3;
          }
          (t2 = function e3(t3) {
            var y, f, p, r2, s, o, u, c, l, g, n = A.prototype = { constructor: A, toString: null, valueOf: null }, d = new A(1), b = 20, w = 4, h = -7, v = 21, m = -1e7, O = 1e7, x = false, a = 1, S = 0, N = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "Â ", suffix: "" }, M = "0123456789abcdefghijklmnopqrstuvwxyz";
            function A(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2 = this;
              if (!(l2 instanceof A))
                return new A(e4, t4);
              if (null == t4) {
                if (e4 instanceof A)
                  return l2.s = e4.s, l2.e = e4.e, void (l2.c = (e4 = e4.c) ? e4.slice() : e4);
                if ((u2 = "number" == typeof e4) && 0 * e4 == 0) {
                  if (l2.s = 1 / e4 < 0 ? (e4 = -e4, -1) : 1, e4 === ~~e4) {
                    for (a2 = 0, o2 = e4; 10 <= o2; o2 /= 10, a2++)
                      ;
                    return l2.e = a2, void (l2.c = [e4]);
                  }
                  s2 = String(e4);
                } else {
                  if (s2 = String(e4), !k.test(s2))
                    return p(l2, s2, u2);
                  l2.s = 45 == s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;
                }
                -1 < (a2 = s2.indexOf(".")) && (s2 = s2.replace(".", "")), 0 < (o2 = s2.search(/e/i)) ? (a2 < 0 && (a2 = o2), a2 += +s2.slice(o2 + 1), s2 = s2.substring(0, o2)) : a2 < 0 && (a2 = s2.length);
              } else {
                if (Z(t4, 2, M.length, "Base"), s2 = String(e4), 10 == t4)
                  return E(l2 = new A(e4 instanceof A ? e4 : s2), b + l2.e + 1, w);
                if (u2 = "number" == typeof e4) {
                  if (0 * e4 != 0)
                    return p(l2, s2, u2, t4);
                  if (l2.s = 1 / e4 < 0 ? (s2 = s2.slice(1), -1) : 1, A.DEBUG && 15 < s2.replace(/^0\.0*|\./, "").length)
                    throw Error(P + e4);
                  u2 = false;
                } else
                  l2.s = 45 === s2.charCodeAt(0) ? (s2 = s2.slice(1), -1) : 1;
                for (r3 = M.slice(0, t4), a2 = o2 = 0, c2 = s2.length; o2 < c2; o2++)
                  if (r3.indexOf(n2 = s2.charAt(o2)) < 0) {
                    if ("." == n2) {
                      if (a2 < o2) {
                        a2 = c2;
                        continue;
                      }
                    } else if (!i2 && (s2 == s2.toUpperCase() && (s2 = s2.toLowerCase()) || s2 == s2.toLowerCase() && (s2 = s2.toUpperCase()))) {
                      i2 = true, o2 = -1, a2 = 0;
                      continue;
                    }
                    return p(l2, String(e4), u2, t4);
                  }
                -1 < (a2 = (s2 = f(s2, t4, 10, l2.s)).indexOf(".")) ? s2 = s2.replace(".", "") : a2 = s2.length;
              }
              for (o2 = 0; 48 === s2.charCodeAt(o2); o2++)
                ;
              for (c2 = s2.length; 48 === s2.charCodeAt(--c2); )
                ;
              if (s2 = s2.slice(o2, ++c2)) {
                if (c2 -= o2, u2 && A.DEBUG && 15 < c2 && (C < e4 || e4 !== L(e4)))
                  throw Error(P + l2.s * e4);
                if (O < (a2 = a2 - o2 - 1))
                  l2.c = l2.e = null;
                else if (a2 < m)
                  l2.c = [l2.e = 0];
                else {
                  if (l2.e = a2, l2.c = [], o2 = (a2 + 1) % j, a2 < 0 && (o2 += j), o2 < c2) {
                    for (o2 && l2.c.push(+s2.slice(0, o2)), c2 -= j; o2 < c2; )
                      l2.c.push(+s2.slice(o2, o2 += j));
                    s2 = s2.slice(o2), o2 = j - s2.length;
                  } else
                    o2 -= c2;
                  for (; o2--; s2 += "0")
                    ;
                  l2.c.push(+s2);
                }
              } else
                l2.c = [l2.e = 0];
            }
            function i(e4, t4, r3, n2) {
              var i2, a2, o2, u2, c2;
              if (null == r3 ? r3 = w : Z(r3, 0, 8), !e4.c)
                return e4.toString();
              if (i2 = e4.c[0], o2 = e4.e, null == t4)
                c2 = V(e4.c), c2 = 1 == n2 || 2 == n2 && (o2 <= h || v <= o2) ? W(c2, o2) : H(c2, o2, "0");
              else if (a2 = (e4 = E(new A(e4), t4, r3)).e, u2 = (c2 = V(e4.c)).length, 1 == n2 || 2 == n2 && (t4 <= a2 || a2 <= h)) {
                for (; u2 < t4; c2 += "0", u2++)
                  ;
                c2 = W(c2, a2);
              } else if (t4 -= o2, c2 = H(c2, a2, "0"), u2 < a2 + 1) {
                if (0 < --t4)
                  for (c2 += "."; t4--; c2 += "0")
                    ;
              } else if (0 < (t4 += a2 - u2))
                for (a2 + 1 == u2 && (c2 += "."); t4--; c2 += "0")
                  ;
              return e4.s < 0 && i2 ? "-" + c2 : c2;
            }
            function B(e4, t4) {
              for (var r3, n2 = 1, i2 = new A(e4[0]); n2 < e4.length; n2++) {
                if (!(r3 = new A(e4[n2])).s) {
                  i2 = r3;
                  break;
                }
                t4.call(i2, r3) && (i2 = r3);
              }
              return i2;
            }
            function D(e4, t4, r3) {
              for (var n2 = 1, i2 = t4.length; !t4[--i2]; t4.pop())
                ;
              for (i2 = t4[0]; 10 <= i2; i2 /= 10, n2++)
                ;
              return (r3 = n2 + r3 * j - 1) > O ? e4.c = e4.e = null : e4.c = r3 < m ? [e4.e = 0] : (e4.e = r3, t4), e4;
            }
            function E(e4, t4, r3, n2) {
              var i2, a2, o2, u2, c2, s2, l2, f2 = e4.c, p2 = R;
              if (f2) {
                e: {
                  for (i2 = 1, u2 = f2[0]; 10 <= u2; u2 /= 10, i2++)
                    ;
                  if ((a2 = t4 - i2) < 0)
                    a2 += j, o2 = t4, l2 = (c2 = f2[s2 = 0]) / p2[i2 - o2 - 1] % 10 | 0;
                  else if ((s2 = _((a2 + 1) / j)) >= f2.length) {
                    if (!n2)
                      break e;
                    for (; f2.length <= s2; f2.push(0))
                      ;
                    c2 = l2 = 0, o2 = (a2 %= j) - j + (i2 = 1);
                  } else {
                    for (c2 = u2 = f2[s2], i2 = 1; 10 <= u2; u2 /= 10, i2++)
                      ;
                    l2 = (o2 = (a2 %= j) - j + i2) < 0 ? 0 : c2 / p2[i2 - o2 - 1] % 10 | 0;
                  }
                  if (n2 = n2 || t4 < 0 || null != f2[s2 + 1] || (o2 < 0 ? c2 : c2 % p2[i2 - o2 - 1]), n2 = r3 < 4 ? (l2 || n2) && (0 == r3 || r3 == (e4.s < 0 ? 3 : 2)) : 5 < l2 || 5 == l2 && (4 == r3 || n2 || 6 == r3 && (0 < a2 ? 0 < o2 ? c2 / p2[i2 - o2] : 0 : f2[s2 - 1]) % 10 & 1 || r3 == (e4.s < 0 ? 8 : 7)), t4 < 1 || !f2[0])
                    return f2.length = 0, n2 ? (t4 -= e4.e + 1, f2[0] = p2[(j - t4 % j) % j], e4.e = -t4 || 0) : f2[0] = e4.e = 0, e4;
                  if (0 == a2 ? (f2.length = s2, u2 = 1, s2--) : (f2.length = s2 + 1, u2 = p2[j - a2], f2[s2] = 0 < o2 ? L(c2 / p2[i2 - o2] % p2[o2]) * u2 : 0), n2)
                    for (; ; ) {
                      if (0 == s2) {
                        for (a2 = 1, o2 = f2[0]; 10 <= o2; o2 /= 10, a2++)
                          ;
                        for (o2 = f2[0] += u2, u2 = 1; 10 <= o2; o2 /= 10, u2++)
                          ;
                        a2 != u2 && (e4.e++, f2[0] == U && (f2[0] = 1));
                        break;
                      }
                      if (f2[s2] += u2, f2[s2] != U)
                        break;
                      f2[s2--] = 0, u2 = 1;
                    }
                  for (a2 = f2.length; 0 === f2[--a2]; f2.pop())
                    ;
                }
                e4.e > O ? e4.c = e4.e = null : e4.e < m && (e4.c = [e4.e = 0]);
              }
              return e4;
            }
            function F(e4) {
              var t4, r3 = e4.e;
              return null === r3 ? e4.toString() : (t4 = V(e4.c), t4 = r3 <= h || v <= r3 ? W(t4, r3) : H(t4, r3, "0"), e4.s < 0 ? "-" + t4 : t4);
            }
            return A.clone = e3, A.ROUND_UP = 0, A.ROUND_DOWN = 1, A.ROUND_CEIL = 2, A.ROUND_FLOOR = 3, A.ROUND_HALF_UP = 4, A.ROUND_HALF_DOWN = 5, A.ROUND_HALF_EVEN = 6, A.ROUND_HALF_CEIL = 7, A.ROUND_HALF_FLOOR = 8, A.EUCLID = 9, A.config = A.set = function(e4) {
              var t4, r3;
              if (null != e4) {
                if ("object" != typeof e4)
                  throw Error(T + "Object expected: " + e4);
                if (e4.hasOwnProperty(t4 = "DECIMAL_PLACES") && (Z(r3 = e4[t4], 0, $, t4), b = r3), e4.hasOwnProperty(t4 = "ROUNDING_MODE") && (Z(r3 = e4[t4], 0, 8, t4), w = r3), e4.hasOwnProperty(t4 = "EXPONENTIAL_AT") && ((r3 = e4[t4]) && r3.pop ? (Z(r3[0], -$, 0, t4), Z(r3[1], 0, $, t4), h = r3[0], v = r3[1]) : (Z(r3, -$, $, t4), h = -(v = r3 < 0 ? -r3 : r3))), e4.hasOwnProperty(t4 = "RANGE"))
                  if ((r3 = e4[t4]) && r3.pop)
                    Z(r3[0], -$, -1, t4), Z(r3[1], 1, $, t4), m = r3[0], O = r3[1];
                  else {
                    if (Z(r3, -$, $, t4), !r3)
                      throw Error(T + t4 + " cannot be zero: " + r3);
                    m = -(O = r3 < 0 ? -r3 : r3);
                  }
                if (e4.hasOwnProperty(t4 = "CRYPTO")) {
                  if ((r3 = e4[t4]) !== !!r3)
                    throw Error(T + t4 + " not true or false: " + r3);
                  if (r3) {
                    if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                      throw x = !r3, Error(T + "crypto unavailable");
                    x = r3;
                  } else
                    x = r3;
                }
                if (e4.hasOwnProperty(t4 = "MODULO_MODE") && (Z(r3 = e4[t4], 0, 9, t4), a = r3), e4.hasOwnProperty(t4 = "POW_PRECISION") && (Z(r3 = e4[t4], 0, $, t4), S = r3), e4.hasOwnProperty(t4 = "FORMAT")) {
                  if ("object" != typeof (r3 = e4[t4]))
                    throw Error(T + t4 + " not an object: " + r3);
                  N = r3;
                }
                if (e4.hasOwnProperty(t4 = "ALPHABET")) {
                  if ("string" != typeof (r3 = e4[t4]) || /^.$|[+-.\s]|(.).*\1/.test(r3))
                    throw Error(T + t4 + " invalid: " + r3);
                  M = r3;
                }
              }
              return { DECIMAL_PLACES: b, ROUNDING_MODE: w, EXPONENTIAL_AT: [h, v], RANGE: [m, O], CRYPTO: x, MODULO_MODE: a, POW_PRECISION: S, FORMAT: N, ALPHABET: M };
            }, A.isBigNumber = function(e4) {
              return e4 instanceof A || e4 && true === e4._isBigNumber || false;
            }, A.maximum = A.max = function() {
              return B(arguments, n.lt);
            }, A.minimum = A.min = function() {
              return B(arguments, n.gt);
            }, A.random = (r2 = 9007199254740992, s = Math.random() * r2 & 2097151 ? function() {
              return L(Math.random() * r2);
            } : function() {
              return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
            }, function(e4) {
              var t4, r3, n2, i2, a2, o2 = 0, u2 = [], c2 = new A(d);
              if (null == e4 ? e4 = b : Z(e4, 0, $), i2 = _(e4 / j), x)
                if (crypto.getRandomValues) {
                  for (t4 = crypto.getRandomValues(new Uint32Array(i2 *= 2)); o2 < i2; )
                    9e15 <= (a2 = 131072 * t4[o2] + (t4[o2 + 1] >>> 11)) ? (r3 = crypto.getRandomValues(new Uint32Array(2)), t4[o2] = r3[0], t4[o2 + 1] = r3[1]) : (u2.push(a2 % 1e14), o2 += 2);
                  o2 = i2 / 2;
                } else {
                  if (!crypto.randomBytes)
                    throw x = false, Error(T + "crypto unavailable");
                  for (t4 = crypto.randomBytes(i2 *= 7); o2 < i2; )
                    9e15 <= (a2 = 281474976710656 * (31 & t4[o2]) + 1099511627776 * t4[o2 + 1] + 4294967296 * t4[o2 + 2] + 16777216 * t4[o2 + 3] + (t4[o2 + 4] << 16) + (t4[o2 + 5] << 8) + t4[o2 + 6]) ? crypto.randomBytes(7).copy(t4, o2) : (u2.push(a2 % 1e14), o2 += 7);
                  o2 = i2 / 7;
                }
              if (!x)
                for (; o2 < i2; )
                  (a2 = s()) < 9e15 && (u2[o2++] = a2 % 1e14);
              for (i2 = u2[--o2], e4 %= j, i2 && e4 && (a2 = R[j - e4], u2[o2] = L(i2 / a2) * a2); 0 === u2[o2]; u2.pop(), o2--)
                ;
              if (o2 < 0)
                u2 = [n2 = 0];
              else {
                for (n2 = -1; 0 === u2[0]; u2.splice(0, 1), n2 -= j)
                  ;
                for (o2 = 1, a2 = u2[0]; 10 <= a2; a2 /= 10, o2++)
                  ;
                o2 < j && (n2 -= j - o2);
              }
              return c2.e = n2, c2.c = u2, c2;
            }), A.sum = function() {
              for (var e4 = 1, t4 = arguments, r3 = new A(t4[0]); e4 < t4.length; )
                r3 = r3.plus(t4[e4++]);
              return r3;
            }, f = function() {
              var v2 = "0123456789";
              function m2(e4, t4, r3, n2) {
                for (var i2, a2, o2 = [0], u2 = 0, c2 = e4.length; u2 < c2; ) {
                  for (a2 = o2.length; a2--; o2[a2] *= t4)
                    ;
                  for (o2[0] += n2.indexOf(e4.charAt(u2++)), i2 = 0; i2 < o2.length; i2++)
                    o2[i2] > r3 - 1 && (null == o2[i2 + 1] && (o2[i2 + 1] = 0), o2[i2 + 1] += o2[i2] / r3 | 0, o2[i2] %= r3);
                }
                return o2.reverse();
              }
              return function(e4, t4, r3, n2, i2) {
                var a2, o2, u2, c2, s2, l2, f2, p2, g2 = e4.indexOf("."), h2 = b, d2 = w;
                for (0 <= g2 && (c2 = S, S = 0, e4 = e4.replace(".", ""), l2 = (p2 = new A(t4)).pow(e4.length - g2), S = c2, p2.c = m2(H(V(l2.c), l2.e, "0"), 10, r3, v2), p2.e = p2.c.length), u2 = c2 = (f2 = m2(e4, t4, r3, i2 ? (a2 = M, v2) : (a2 = v2, M))).length; 0 == f2[--c2]; f2.pop())
                  ;
                if (!f2[0])
                  return a2.charAt(0);
                if (g2 < 0 ? --u2 : (l2.c = f2, l2.e = u2, l2.s = n2, f2 = (l2 = y(l2, p2, h2, d2, r3)).c, s2 = l2.r, u2 = l2.e), g2 = f2[o2 = u2 + h2 + 1], c2 = r3 / 2, s2 = s2 || o2 < 0 || null != f2[o2 + 1], s2 = d2 < 4 ? (null != g2 || s2) && (0 == d2 || d2 == (l2.s < 0 ? 3 : 2)) : c2 < g2 || g2 == c2 && (4 == d2 || s2 || 6 == d2 && 1 & f2[o2 - 1] || d2 == (l2.s < 0 ? 8 : 7)), o2 < 1 || !f2[0])
                  e4 = s2 ? H(a2.charAt(1), -h2, a2.charAt(0)) : a2.charAt(0);
                else {
                  if (f2.length = o2, s2)
                    for (--r3; ++f2[--o2] > r3; )
                      f2[o2] = 0, o2 || (++u2, f2 = [1].concat(f2));
                  for (c2 = f2.length; !f2[--c2]; )
                    ;
                  for (g2 = 0, e4 = ""; g2 <= c2; e4 += a2.charAt(f2[g2++]))
                    ;
                  e4 = H(e4, u2, a2.charAt(0));
                }
                return e4;
              };
            }(), y = function() {
              function M2(e4, t4, r3) {
                var n2, i2, a2, o2, u2 = 0, c2 = e4.length, s2 = t4 % I, l2 = t4 / I | 0;
                for (e4 = e4.slice(); c2--; )
                  u2 = ((i2 = s2 * (a2 = e4[c2] % I) + (n2 = l2 * a2 + (o2 = e4[c2] / I | 0) * s2) % I * I + u2) / r3 | 0) + (n2 / I | 0) + l2 * o2, e4[c2] = i2 % r3;
                return u2 && (e4 = [u2].concat(e4)), e4;
              }
              function B2(e4, t4, r3, n2) {
                var i2, a2;
                if (r3 != n2)
                  a2 = n2 < r3 ? 1 : -1;
                else
                  for (i2 = a2 = 0; i2 < r3; i2++)
                    if (e4[i2] != t4[i2]) {
                      a2 = e4[i2] > t4[i2] ? 1 : -1;
                      break;
                    }
                return a2;
              }
              function D2(e4, t4, r3, n2) {
                for (var i2 = 0; r3--; )
                  e4[r3] -= i2, i2 = e4[r3] < t4[r3] ? 1 : 0, e4[r3] = i2 * n2 + e4[r3] - t4[r3];
                for (; !e4[0] && 1 < e4.length; e4.splice(0, 1))
                  ;
              }
              return function(e4, t4, r3, n2, i2) {
                var a2, o2, u2, c2, s2, l2, f2, p2, g2, h2, d2, v2, m2, y2, b2, w2, O2, x2 = e4.s == t4.s ? 1 : -1, S2 = e4.c, N2 = t4.c;
                if (!(S2 && S2[0] && N2 && N2[0]))
                  return new A(e4.s && t4.s && (S2 ? !N2 || S2[0] != N2[0] : N2) ? S2 && 0 == S2[0] || !N2 ? 0 * x2 : x2 / 0 : NaN);
                for (g2 = (p2 = new A(x2)).c = [], x2 = r3 + (o2 = e4.e - t4.e) + 1, i2 || (i2 = U, o2 = G(e4.e / j) - G(t4.e / j), x2 = x2 / j | 0), u2 = 0; N2[u2] == (S2[u2] || 0); u2++)
                  ;
                if (N2[u2] > (S2[u2] || 0) && o2--, x2 < 0)
                  g2.push(1), c2 = true;
                else {
                  for (y2 = S2.length, w2 = N2.length, x2 += 2, 1 < (s2 = L(i2 / (N2[u2 = 0] + 1))) && (N2 = M2(N2, s2, i2), S2 = M2(S2, s2, i2), w2 = N2.length, y2 = S2.length), m2 = w2, d2 = (h2 = S2.slice(0, w2)).length; d2 < w2; h2[d2++] = 0)
                    ;
                  O2 = N2.slice(), O2 = [0].concat(O2), b2 = N2[0], N2[1] >= i2 / 2 && b2++;
                  do {
                    if (s2 = 0, (a2 = B2(N2, h2, w2, d2)) < 0) {
                      if (v2 = h2[0], w2 != d2 && (v2 = v2 * i2 + (h2[1] || 0)), 1 < (s2 = L(v2 / b2)))
                        for (i2 <= s2 && (s2 = i2 - 1), f2 = (l2 = M2(N2, s2, i2)).length, d2 = h2.length; 1 == B2(l2, h2, f2, d2); )
                          s2--, D2(l2, w2 < f2 ? O2 : N2, f2, i2), f2 = l2.length, a2 = 1;
                      else
                        0 == s2 && (a2 = s2 = 1), f2 = (l2 = N2.slice()).length;
                      if (f2 < d2 && (l2 = [0].concat(l2)), D2(h2, l2, d2, i2), d2 = h2.length, -1 == a2)
                        for (; B2(N2, h2, w2, d2) < 1; )
                          s2++, D2(h2, w2 < d2 ? O2 : N2, d2, i2), d2 = h2.length;
                    } else
                      0 === a2 && (s2++, h2 = [0]);
                    g2[u2++] = s2, h2[0] ? h2[d2++] = S2[m2] || 0 : (h2 = [S2[m2]], d2 = 1);
                  } while ((m2++ < y2 || null != h2[0]) && x2--);
                  c2 = null != h2[0], g2[0] || g2.splice(0, 1);
                }
                if (i2 == U) {
                  for (u2 = 1, x2 = g2[0]; 10 <= x2; x2 /= 10, u2++)
                    ;
                  E(p2, r3 + (p2.e = u2 + o2 * j - 1) + 1, n2, c2);
                } else
                  p2.e = o2, p2.r = +c2;
                return p2;
              };
            }(), o = /^(-?)0([xbo])(?=\w[\w.]*$)/i, u = /^([^.]+)\.$/, c = /^\.([^.]+)$/, l = /^-?(Infinity|NaN)$/, g = /^\s*\+(?=[\w.])|^\s+|\s+$/g, p = function(e4, t4, r3, n2) {
              var i2, a2 = r3 ? t4 : t4.replace(g, "");
              if (l.test(a2))
                e4.s = isNaN(a2) ? null : a2 < 0 ? -1 : 1, e4.c = e4.e = null;
              else {
                if (!r3 && (a2 = a2.replace(o, function(e5, t5, r4) {
                  return i2 = "x" == (r4 = r4.toLowerCase()) ? 16 : "b" == r4 ? 2 : 8, n2 && n2 != i2 ? e5 : t5;
                }), n2 && (i2 = n2, a2 = a2.replace(u, "$1").replace(c, "0.$1")), t4 != a2))
                  return new A(a2, i2);
                if (A.DEBUG)
                  throw Error(T + "Not a" + (n2 ? " base " + n2 : "") + " number: " + t4);
                e4.c = e4.e = e4.s = null;
              }
            }, n.absoluteValue = n.abs = function() {
              var e4 = new A(this);
              return e4.s < 0 && (e4.s = 1), e4;
            }, n.comparedTo = function(e4, t4) {
              return q(this, new A(e4, t4));
            }, n.decimalPlaces = n.dp = function(e4, t4) {
              var r3, n2, i2;
              if (null != e4)
                return Z(e4, 0, $), null == t4 ? t4 = w : Z(t4, 0, 8), E(new A(this), e4 + this.e + 1, t4);
              if (!(r3 = this.c))
                return null;
              if (n2 = ((i2 = r3.length - 1) - G(this.e / j)) * j, i2 = r3[i2])
                for (; i2 % 10 == 0; i2 /= 10, n2--)
                  ;
              return n2 < 0 && (n2 = 0), n2;
            }, n.dividedBy = n.div = function(e4, t4) {
              return y(this, new A(e4, t4), b, w);
            }, n.dividedToIntegerBy = n.idiv = function(e4, t4) {
              return y(this, new A(e4, t4), 0, 1);
            }, n.exponentiatedBy = n.pow = function(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2 = this;
              if ((e4 = new A(e4)).c && !e4.isInteger())
                throw Error(T + "Exponent not an integer: " + F(e4));
              if (null != t4 && (t4 = new A(t4)), o2 = 14 < e4.e, !l2.c || !l2.c[0] || 1 == l2.c[0] && !l2.e && 1 == l2.c.length || !e4.c || !e4.c[0])
                return s2 = new A(Math.pow(+F(l2), o2 ? 2 - z(e4) : +F(e4))), t4 ? s2.mod(t4) : s2;
              if (u2 = e4.s < 0, t4) {
                if (t4.c ? !t4.c[0] : !t4.s)
                  return new A(NaN);
                (n2 = !u2 && l2.isInteger() && t4.isInteger()) && (l2 = l2.mod(t4));
              } else {
                if (9 < e4.e && (0 < l2.e || l2.e < -1 || (0 == l2.e ? 1 < l2.c[0] || o2 && 24e7 <= l2.c[1] : l2.c[0] < 8e13 || o2 && l2.c[0] <= 9999975e7)))
                  return a2 = l2.s < 0 && z(e4) ? -0 : 0, -1 < l2.e && (a2 = 1 / a2), new A(u2 ? 1 / a2 : a2);
                S && (a2 = _(S / j + 2));
              }
              for (c2 = o2 ? (r3 = new A(0.5), u2 && (e4.s = 1), z(e4)) : (i2 = Math.abs(+F(e4))) % 2, s2 = new A(d); ; ) {
                if (c2) {
                  if (!(s2 = s2.times(l2)).c)
                    break;
                  a2 ? s2.c.length > a2 && (s2.c.length = a2) : n2 && (s2 = s2.mod(t4));
                }
                if (i2) {
                  if (0 === (i2 = L(i2 / 2)))
                    break;
                  c2 = i2 % 2;
                } else if (E(e4 = e4.times(r3), e4.e + 1, 1), 14 < e4.e)
                  c2 = z(e4);
                else {
                  if (0 == (i2 = +F(e4)))
                    break;
                  c2 = i2 % 2;
                }
                l2 = l2.times(l2), a2 ? l2.c && l2.c.length > a2 && (l2.c.length = a2) : n2 && (l2 = l2.mod(t4));
              }
              return n2 ? s2 : (u2 && (s2 = d.div(s2)), t4 ? s2.mod(t4) : a2 ? E(s2, S, w, void 0) : s2);
            }, n.integerValue = function(e4) {
              var t4 = new A(this);
              return null == e4 ? e4 = w : Z(e4, 0, 8), E(t4, t4.e + 1, e4);
            }, n.isEqualTo = n.eq = function(e4, t4) {
              return 0 === q(this, new A(e4, t4));
            }, n.isFinite = function() {
              return !!this.c;
            }, n.isGreaterThan = n.gt = function(e4, t4) {
              return 0 < q(this, new A(e4, t4));
            }, n.isGreaterThanOrEqualTo = n.gte = function(e4, t4) {
              return 1 === (t4 = q(this, new A(e4, t4))) || 0 === t4;
            }, n.isInteger = function() {
              return !!this.c && G(this.e / j) > this.c.length - 2;
            }, n.isLessThan = n.lt = function(e4, t4) {
              return q(this, new A(e4, t4)) < 0;
            }, n.isLessThanOrEqualTo = n.lte = function(e4, t4) {
              return -1 === (t4 = q(this, new A(e4, t4))) || 0 === t4;
            }, n.isNaN = function() {
              return !this.s;
            }, n.isNegative = function() {
              return this.s < 0;
            }, n.isPositive = function() {
              return 0 < this.s;
            }, n.isZero = function() {
              return !!this.c && 0 == this.c[0];
            }, n.minus = function(e4, t4) {
              var r3, n2, i2, a2, o2 = this, u2 = o2.s;
              if (t4 = (e4 = new A(e4, t4)).s, !u2 || !t4)
                return new A(NaN);
              if (u2 != t4)
                return e4.s = -t4, o2.plus(e4);
              var c2 = o2.e / j, s2 = e4.e / j, l2 = o2.c, f2 = e4.c;
              if (!c2 || !s2) {
                if (!l2 || !f2)
                  return l2 ? (e4.s = -t4, e4) : new A(f2 ? o2 : NaN);
                if (!l2[0] || !f2[0])
                  return f2[0] ? (e4.s = -t4, e4) : new A(l2[0] ? o2 : 3 == w ? -0 : 0);
              }
              if (c2 = G(c2), s2 = G(s2), l2 = l2.slice(), u2 = c2 - s2) {
                for ((i2 = (a2 = u2 < 0) ? (u2 = -u2, l2) : (s2 = c2, f2)).reverse(), t4 = u2; t4--; i2.push(0))
                  ;
                i2.reverse();
              } else
                for (n2 = (a2 = (u2 = l2.length) < (t4 = f2.length)) ? u2 : t4, u2 = t4 = 0; t4 < n2; t4++)
                  if (l2[t4] != f2[t4]) {
                    a2 = l2[t4] < f2[t4];
                    break;
                  }
              if (a2 && (i2 = l2, l2 = f2, f2 = i2, e4.s = -e4.s), 0 < (t4 = (n2 = f2.length) - (r3 = l2.length)))
                for (; t4--; l2[r3++] = 0)
                  ;
              for (t4 = U - 1; u2 < n2; ) {
                if (l2[--n2] < f2[n2]) {
                  for (r3 = n2; r3 && !l2[--r3]; l2[r3] = t4)
                    ;
                  --l2[r3], l2[n2] += U;
                }
                l2[n2] -= f2[n2];
              }
              for (; 0 == l2[0]; l2.splice(0, 1), --s2)
                ;
              return l2[0] ? D(e4, l2, s2) : (e4.s = 3 == w ? -1 : 1, e4.c = [e4.e = 0], e4);
            }, n.modulo = n.mod = function(e4, t4) {
              var r3, n2, i2 = this;
              return e4 = new A(e4, t4), !i2.c || !e4.s || e4.c && !e4.c[0] ? new A(NaN) : !e4.c || i2.c && !i2.c[0] ? new A(i2) : (9 == a ? (n2 = e4.s, e4.s = 1, r3 = y(i2, e4, 0, 3), e4.s = n2, r3.s *= n2) : r3 = y(i2, e4, 0, a), (e4 = i2.minus(r3.times(e4))).c[0] || 1 != a || (e4.s = i2.s), e4);
            }, n.multipliedBy = n.times = function(e4, t4) {
              var r3, n2, i2, a2, o2, u2, c2, s2, l2, f2, p2, g2, h2, d2, v2, m2 = this, y2 = m2.c, b2 = (e4 = new A(e4, t4)).c;
              if (!(y2 && b2 && y2[0] && b2[0]))
                return !m2.s || !e4.s || y2 && !y2[0] && !b2 || b2 && !b2[0] && !y2 ? e4.c = e4.e = e4.s = null : (e4.s *= m2.s, y2 && b2 ? (e4.c = [0], e4.e = 0) : e4.c = e4.e = null), e4;
              for (n2 = G(m2.e / j) + G(e4.e / j), e4.s *= m2.s, (c2 = y2.length) < (f2 = b2.length) && (h2 = y2, y2 = b2, b2 = h2, i2 = c2, c2 = f2, f2 = i2), i2 = c2 + f2, h2 = []; i2--; h2.push(0))
                ;
              for (d2 = U, v2 = I, i2 = f2; 0 <= --i2; ) {
                for (r3 = 0, p2 = b2[i2] % v2, g2 = b2[i2] / v2 | 0, a2 = i2 + (o2 = c2); i2 < a2; )
                  r3 = ((s2 = p2 * (s2 = y2[--o2] % v2) + (u2 = g2 * s2 + (l2 = y2[o2] / v2 | 0) * p2) % v2 * v2 + h2[a2] + r3) / d2 | 0) + (u2 / v2 | 0) + g2 * l2, h2[a2--] = s2 % d2;
                h2[a2] = r3;
              }
              return r3 ? ++n2 : h2.splice(0, 1), D(e4, h2, n2);
            }, n.negated = function() {
              var e4 = new A(this);
              return e4.s = -e4.s || null, e4;
            }, n.plus = function(e4, t4) {
              var r3, n2 = this, i2 = n2.s;
              if (t4 = (e4 = new A(e4, t4)).s, !i2 || !t4)
                return new A(NaN);
              if (i2 != t4)
                return e4.s = -t4, n2.minus(e4);
              var a2 = n2.e / j, o2 = e4.e / j, u2 = n2.c, c2 = e4.c;
              if (!a2 || !o2) {
                if (!u2 || !c2)
                  return new A(i2 / 0);
                if (!u2[0] || !c2[0])
                  return c2[0] ? e4 : new A(u2[0] ? n2 : 0 * i2);
              }
              if (a2 = G(a2), o2 = G(o2), u2 = u2.slice(), i2 = a2 - o2) {
                for ((r3 = 0 < i2 ? (o2 = a2, c2) : (i2 = -i2, u2)).reverse(); i2--; r3.push(0))
                  ;
                r3.reverse();
              }
              for ((i2 = u2.length) - (t4 = c2.length) < 0 && (r3 = c2, c2 = u2, u2 = r3, t4 = i2), i2 = 0; t4; )
                i2 = (u2[--t4] = u2[t4] + c2[t4] + i2) / U | 0, u2[t4] = U === u2[t4] ? 0 : u2[t4] % U;
              return i2 && (u2 = [i2].concat(u2), ++o2), D(e4, u2, o2);
            }, n.precision = n.sd = function(e4, t4) {
              var r3, n2, i2;
              if (null != e4 && e4 !== !!e4)
                return Z(e4, 1, $), null == t4 ? t4 = w : Z(t4, 0, 8), E(new A(this), e4, t4);
              if (!(r3 = this.c))
                return null;
              if (n2 = (i2 = r3.length - 1) * j + 1, i2 = r3[i2]) {
                for (; i2 % 10 == 0; i2 /= 10, n2--)
                  ;
                for (i2 = r3[0]; 10 <= i2; i2 /= 10, n2++)
                  ;
              }
              return e4 && this.e + 1 > n2 && (n2 = this.e + 1), n2;
            }, n.shiftedBy = function(e4) {
              return Z(e4, -C, C), this.times("1e" + e4);
            }, n.squareRoot = n.sqrt = function() {
              var e4, t4, r3, n2, i2, a2 = this, o2 = a2.c, u2 = a2.s, c2 = a2.e, s2 = b + 4, l2 = new A("0.5");
              if (1 !== u2 || !o2 || !o2[0])
                return new A(!u2 || u2 < 0 && (!o2 || o2[0]) ? NaN : o2 ? a2 : 1 / 0);
              if ((r3 = 0 == (u2 = Math.sqrt(+F(a2))) || u2 == 1 / 0 ? (((t4 = V(o2)).length + c2) % 2 == 0 && (t4 += "0"), u2 = Math.sqrt(+t4), c2 = G((c2 + 1) / 2) - (c2 < 0 || c2 % 2), new A(t4 = u2 == 1 / 0 ? "1e" + c2 : (t4 = u2.toExponential()).slice(0, t4.indexOf("e") + 1) + c2)) : new A(u2 + "")).c[0]) {
                for ((u2 = (c2 = r3.e) + s2) < 3 && (u2 = 0); ; )
                  if (i2 = r3, r3 = l2.times(i2.plus(y(a2, i2, s2, 1))), V(i2.c).slice(0, u2) === (t4 = V(r3.c)).slice(0, u2)) {
                    if (r3.e < c2 && --u2, "9999" != (t4 = t4.slice(u2 - 3, u2 + 1)) && (n2 || "4999" != t4)) {
                      +t4 && (+t4.slice(1) || "5" != t4.charAt(0)) || (E(r3, r3.e + b + 2, 1), e4 = !r3.times(r3).eq(a2));
                      break;
                    }
                    if (!n2 && (E(i2, i2.e + b + 2, 0), i2.times(i2).eq(a2))) {
                      r3 = i2;
                      break;
                    }
                    s2 += 4, u2 += 4, n2 = 1;
                  }
              }
              return E(r3, r3.e + b + 1, w, e4);
            }, n.toExponential = function(e4, t4) {
              return null != e4 && (Z(e4, 0, $), e4++), i(this, e4, t4, 1);
            }, n.toFixed = function(e4, t4) {
              return null != e4 && (Z(e4, 0, $), e4 = e4 + this.e + 1), i(this, e4, t4);
            }, n.toFormat = function(e4, t4, r3) {
              var n2;
              if (null == r3)
                null != e4 && t4 && "object" == typeof t4 ? (r3 = t4, t4 = null) : e4 && "object" == typeof e4 ? (r3 = e4, e4 = t4 = null) : r3 = N;
              else if ("object" != typeof r3)
                throw Error(T + "Argument not an object: " + r3);
              if (n2 = this.toFixed(e4, t4), this.c) {
                var i2, a2 = n2.split("."), o2 = +r3.groupSize, u2 = +r3.secondaryGroupSize, c2 = r3.groupSeparator || "", s2 = a2[0], l2 = a2[1], f2 = this.s < 0, p2 = f2 ? s2.slice(1) : s2, g2 = p2.length;
                if (u2 && (i2 = o2, o2 = u2, g2 -= u2 = i2), 0 < o2 && 0 < g2) {
                  for (i2 = g2 % o2 || o2, s2 = p2.substr(0, i2); i2 < g2; i2 += o2)
                    s2 += c2 + p2.substr(i2, o2);
                  0 < u2 && (s2 += c2 + p2.slice(i2)), f2 && (s2 = "-" + s2);
                }
                n2 = l2 ? s2 + (r3.decimalSeparator || "") + ((u2 = +r3.fractionGroupSize) ? l2.replace(new RegExp("\\d{" + u2 + "}\\B", "g"), "$&" + (r3.fractionGroupSeparator || "")) : l2) : s2;
              }
              return (r3.prefix || "") + n2 + (r3.suffix || "");
            }, n.toFraction = function(e4) {
              var t4, r3, n2, i2, a2, o2, u2, c2, s2, l2, f2, p2, g2 = this, h2 = g2.c;
              if (null != e4 && (!(u2 = new A(e4)).isInteger() && (u2.c || 1 !== u2.s) || u2.lt(d)))
                throw Error(T + "Argument " + (u2.isInteger() ? "out of range: " : "not an integer: ") + F(u2));
              if (!h2)
                return new A(g2);
              for (t4 = new A(d), s2 = r3 = new A(d), n2 = c2 = new A(d), p2 = V(h2), a2 = t4.e = p2.length - g2.e - 1, t4.c[0] = R[(o2 = a2 % j) < 0 ? j + o2 : o2], e4 = !e4 || 0 < u2.comparedTo(t4) ? 0 < a2 ? t4 : s2 : u2, o2 = O, O = 1 / 0, u2 = new A(p2), c2.c[0] = 0; l2 = y(u2, t4, 0, 1), 1 != (i2 = r3.plus(l2.times(n2))).comparedTo(e4); )
                r3 = n2, n2 = i2, s2 = c2.plus(l2.times(i2 = s2)), c2 = i2, t4 = u2.minus(l2.times(i2 = t4)), u2 = i2;
              return i2 = y(e4.minus(r3), n2, 0, 1), c2 = c2.plus(i2.times(s2)), r3 = r3.plus(i2.times(n2)), c2.s = s2.s = g2.s, f2 = y(s2, n2, a2 *= 2, w).minus(g2).abs().comparedTo(y(c2, r3, a2, w).minus(g2).abs()) < 1 ? [s2, n2] : [c2, r3], O = o2, f2;
            }, n.toNumber = function() {
              return +F(this);
            }, n.toPrecision = function(e4, t4) {
              return null != e4 && Z(e4, 1, $), i(this, e4, t4, 2);
            }, n.toString = function(e4) {
              var t4, r3 = this, n2 = r3.s, i2 = r3.e;
              return null === i2 ? n2 ? (t4 = "Infinity", n2 < 0 && (t4 = "-" + t4)) : t4 = "NaN" : (t4 = null == e4 ? i2 <= h || v <= i2 ? W(V(r3.c), i2) : H(V(r3.c), i2, "0") : 10 === e4 ? H(V((r3 = E(new A(r3), b + i2 + 1, w)).c), r3.e, "0") : (Z(e4, 2, M.length, "Base"), f(H(V(r3.c), i2, "0"), 10, e4, n2, true)), n2 < 0 && r3.c[0] && (t4 = "-" + t4)), t4;
            }, n.valueOf = n.toJSON = function() {
              return F(this);
            }, n._isBigNumber = true, "function" == typeof Symbol && "symbol" == typeof Symbol.iterator && (n[Symbol.toStringTag] = "BigNumber", n[Symbol.for("nodejs.util.inspect.custom")] = n.valueOf), null != t3 && A.set(t3), A;
          }()).default = t2.BigNumber = t2, void 0 !== r && r.exports ? r.exports = t2 : (e2 || (e2 = "undefined" != typeof self && self ? self : window), e2.BigNumber = t2);
        }(this);
      }, {}], 2: [function(e, t, r) {
        "use strict";
        t.exports = { languageTag: "en-US", delimiters: { thousands: ",", decimal: "." }, abbreviations: { thousand: "k", million: "m", billion: "b", trillion: "t" }, spaceSeparated: false, ordinal: function(e2) {
          var t2 = e2 % 10;
          return 1 == ~~(e2 % 100 / 10) ? "th" : 1 === t2 ? "st" : 2 === t2 ? "nd" : 3 === t2 ? "rd" : "th";
        }, currency: { symbol: "$", position: "prefix", code: "USD" }, currencyFormat: { thousandSeparated: true, totalLength: 4, spaceSeparated: true }, formats: { fourDigits: { totalLength: 4, spaceSeparated: true }, fullWithTwoDecimals: { output: "currency", thousandSeparated: true, mantissa: 2 }, fullWithTwoDecimalsNoCurrency: { thousandSeparated: true, mantissa: 2 }, fullWithNoDecimals: { output: "currency", thousandSeparated: true, mantissa: 0 } } };
      }, {}], 3: [function(e, t, r) {
        "use strict";
        function C(e2, t2) {
          return function(e3) {
            if (Array.isArray(e3))
              return e3;
          }(e2) || function(e3, t3) {
            var r2 = [], n2 = true, i2 = false, a = void 0;
            try {
              for (var o2, u2 = e3[Symbol.iterator](); !(n2 = (o2 = u2.next()).done) && (r2.push(o2.value), !t3 || r2.length !== t3); n2 = true)
                ;
            } catch (e4) {
              i2 = true, a = e4;
            } finally {
              try {
                n2 || null == u2.return || u2.return();
              } finally {
                if (i2)
                  throw a;
              }
            }
            return r2;
          }(e2, t2) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        var R = e("./globalState"), o = e("./validating"), u = e("./parsing"), n = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], M = { general: { scale: 1024, suffixes: n, marker: "bd" }, binary: { scale: 1024, suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], marker: "b" }, decimal: { scale: 1e3, suffixes: n, marker: "d" } }, I = { totalLength: 0, characteristic: 0, forceAverage: false, average: false, mantissa: -1, optionalMantissa: true, thousandSeparated: false, spaceSeparated: false, negative: "sign", forceSign: false };
        function i(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, r2 = 2 < arguments.length ? arguments[2] : void 0;
          if ("string" == typeof t2 && (t2 = u.parseFormat(t2)), !o.validateFormat(t2))
            return "ERROR: invalid format";
          var n2 = t2.prefix || "", i2 = t2.postfix || "", a = function(e3, t3, r3) {
            switch (t3.output) {
              case "currency":
                return t3 = A(t3, R.currentCurrencyDefaultFormat()), function(e4, t4, r4) {
                  var n4 = r4.currentCurrency(), i4 = Object.assign({}, I, t4), a3 = void 0, o3 = "", u3 = !!i4.totalLength || !!i4.forceAverage || i4.average, c2 = t4.currencyPosition || n4.position, s2 = t4.currencySymbol || n4.symbol;
                  i4.spaceSeparated && (o3 = " ");
                  "infix" === c2 && (a3 = o3 + s2 + o3);
                  var l2 = D({ instance: e4, providedFormat: t4, state: r4, decimalSeparator: a3 });
                  "prefix" === c2 && (l2 = e4._value < 0 && "sign" === i4.negative ? "-".concat(o3).concat(s2).concat(l2.slice(1)) : s2 + o3 + l2);
                  c2 && "postfix" !== c2 || (l2 = l2 + (o3 = u3 ? "" : o3) + s2);
                  return l2;
                }(e3, t3, R);
              case "percent":
                return t3 = A(t3, R.currentPercentageDefaultFormat()), function(e4, t4, r4, n4) {
                  var i4 = t4.prefixSymbol, a3 = D({ instance: n4(100 * e4._value), providedFormat: t4, state: r4 }), o3 = Object.assign({}, I, t4);
                  if (i4)
                    return "%".concat(o3.spaceSeparated ? " " : "").concat(a3);
                  return "".concat(a3).concat(o3.spaceSeparated ? " " : "", "%");
                }(e3, t3, R, r3);
              case "byte":
                return t3 = A(t3, R.currentByteDefaultFormat()), h = e3, v = R, m = r3, y = (d = t3).base || "binary", b = M[y], w = B(h._value, b.suffixes, b.scale), O = w.value, x = w.suffix, S = D({ instance: m(O), providedFormat: d, state: v, defaults: v.currentByteDefaultFormat() }), N = v.currentAbbreviations(), "".concat(S).concat(N.spaced ? " " : "").concat(x);
              case "time":
                return t3 = A(t3, R.currentTimeDefaultFormat()), l = e3, f = Math.floor(l._value / 60 / 60), p2 = Math.floor((l._value - 60 * f * 60) / 60), g = Math.round(l._value - 60 * f * 60 - 60 * p2), "".concat(f, ":").concat(p2 < 10 ? "0" : "").concat(p2, ":").concat(g < 10 ? "0" : "").concat(g);
              case "ordinal":
                return t3 = A(t3, R.currentOrdinalDefaultFormat()), n3 = e3, i3 = t3, o2 = (a2 = R).currentOrdinal(), u2 = Object.assign({}, I, i3), c = D({ instance: n3, providedFormat: i3, state: a2 }), s = o2(n3._value), "".concat(c).concat(u2.spaceSeparated ? " " : "").concat(s);
              case "number":
              default:
                return D({ instance: e3, providedFormat: t3, numbro: r3 });
            }
            var n3, i3, a2, o2, u2, c, s;
            var l, f, p2, g;
            var h, d, v, m, y, b, w, O, x, S, N;
          }(e2, t2, r2);
          return a = (a = n2 + a) + i2;
        }
        function B(e2, t2, r2) {
          var n2 = t2[0], i2 = Math.abs(e2);
          if (r2 <= i2) {
            for (var a = 1; a < t2.length; ++a) {
              var o2 = Math.pow(r2, a), u2 = Math.pow(r2, a + 1);
              if (o2 <= i2 && i2 < u2) {
                n2 = t2[a], e2 /= o2;
                break;
              }
            }
            n2 === t2[0] && (e2 /= Math.pow(r2, t2.length - 1), n2 = t2[t2.length - 1]);
          }
          return { value: e2, suffix: n2 };
        }
        function p(e2) {
          for (var t2 = "", r2 = 0; r2 < e2; r2++)
            t2 += "0";
          return t2;
        }
        function $(e2, t2) {
          return -1 !== e2.toString().indexOf("e") ? function(e3, t3) {
            var r2 = e3.toString(), n2 = C(r2.split("e"), 2), i2 = n2[0], a = n2[1], o2 = C(i2.split("."), 2), u2 = o2[0], c = o2[1], s = void 0 === c ? "" : c;
            if (0 < +a)
              r2 = u2 + s + p(a - s.length);
            else {
              var l = ".";
              l = +u2 < 0 ? "-0".concat(l) : "0".concat(l);
              var f = (p(-a - 1) + Math.abs(u2) + s).substr(0, t3);
              f.length < t3 && (f += p(t3 - f.length)), r2 = l + f;
            }
            return 0 < +a && 0 < t3 && (r2 += ".".concat(p(t3))), r2;
          }(e2, t2) : (Math.round(+"".concat(e2, "e+").concat(t2)) / Math.pow(10, t2)).toFixed(t2);
        }
        function D(e2) {
          var t2 = e2.instance, r2 = e2.providedFormat, n2 = e2.state, i2 = void 0 === n2 ? R : n2, a = e2.decimalSeparator, o2 = e2.defaults, u2 = void 0 === o2 ? i2.currentDefaults() : o2, c = t2._value;
          if (0 === c && i2.hasZeroFormat())
            return i2.getZeroFormat();
          if (!isFinite(c))
            return c.toString();
          var s, l, f, p2, g, h, d, v, m = Object.assign({}, I, u2, r2), y = m.totalLength, b = y ? 0 : m.characteristic, w = m.optionalCharacteristic, O = m.forceAverage, x = !!y || !!O || m.average, S = y ? -1 : x && void 0 === r2.mantissa ? 0 : m.mantissa, N = !y && (void 0 === r2.optionalMantissa ? -1 === S : m.optionalMantissa), M2 = m.trimMantissa, B2 = m.thousandSeparated, D2 = m.spaceSeparated, A2 = m.negative, E = m.forceSign, F = m.exponential, k = "";
          if (x) {
            var _ = function(e3) {
              var t3 = e3.value, r3 = e3.forceAverage, n3 = e3.abbreviations, i3 = e3.spaceSeparated, a2 = void 0 !== i3 && i3, o3 = e3.totalLength, u3 = void 0 === o3 ? 0 : o3, c2 = "", s2 = Math.abs(t3), l2 = -1;
              if (s2 >= Math.pow(10, 12) && !r3 || "trillion" === r3 ? (c2 = n3.trillion, t3 /= Math.pow(10, 12)) : s2 < Math.pow(10, 12) && s2 >= Math.pow(10, 9) && !r3 || "billion" === r3 ? (c2 = n3.billion, t3 /= Math.pow(10, 9)) : s2 < Math.pow(10, 9) && s2 >= Math.pow(10, 6) && !r3 || "million" === r3 ? (c2 = n3.million, t3 /= Math.pow(10, 6)) : (s2 < Math.pow(10, 6) && s2 >= Math.pow(10, 3) && !r3 || "thousand" === r3) && (c2 = n3.thousand, t3 /= Math.pow(10, 3)), c2 && (c2 = (a2 ? " " : "") + c2), u3) {
                var f2 = t3.toString().split(".")[0];
                l2 = Math.max(u3 - f2.length, 0);
              }
              return { value: t3, abbreviation: c2, mantissaPrecision: l2 };
            }({ value: c, forceAverage: O, abbreviations: i2.currentAbbreviations(), spaceSeparated: D2, totalLength: y });
            c = _.value, k += _.abbreviation, y && (S = _.mantissaPrecision);
          }
          if (F) {
            var L = (l = (s = { value: c, characteristicPrecision: b }).value, f = s.characteristicPrecision, p2 = void 0 === f ? 0 : f, g = C(l.toExponential().split("e"), 2), h = g[0], d = g[1], v = +h, p2 && 1 < p2 && (v *= Math.pow(10, p2 - 1), d = 0 <= (d = +d - (p2 - 1)) ? "+".concat(d) : d), { value: v, abbreviation: "e".concat(d) });
            c = L.value, k = L.abbreviation + k;
          }
          var T, P, U, j = function(e3, t3, r3, n3, i3) {
            if (-1 === n3)
              return e3;
            var a2 = $(t3, n3), o3 = C(a2.toString().split("."), 2), u3 = o3[0], c2 = o3[1], s2 = void 0 === c2 ? "" : c2;
            if (s2.match(/^0+$/) && (r3 || i3))
              return u3;
            var l2 = s2.match(/0+$/);
            return i3 && l2 ? "".concat(u3, ".").concat(s2.toString().slice(0, l2.index)) : a2.toString();
          }(c.toString(), c, N, S, M2);
          return j = function(e3, t3, r3, n3, i3) {
            var a2 = n3.currentDelimiters(), o3 = a2.thousands;
            i3 = i3 || a2.decimal;
            var u3 = a2.thousandsSize || 3, c2 = e3.toString(), s2 = c2.split(".")[0], l2 = c2.split(".")[1];
            return r3 && (t3 < 0 && (s2 = s2.slice(1)), function(e4, t4) {
              for (var r4 = [], n4 = 0, i4 = e4; 0 < i4; i4--)
                n4 === t4 && (r4.unshift(i4), n4 = 0), n4++;
              return r4;
            }(s2.length, u3).forEach(function(e4, t4) {
              s2 = s2.slice(0, e4 + t4) + o3 + s2.slice(e4 + t4);
            }), t3 < 0 && (s2 = "-".concat(s2))), c2 = l2 ? s2 + i3 + l2 : s2;
          }(j = function(e3, t3, r3, n3) {
            var i3 = e3, a2 = C(i3.toString().split("."), 2), o3 = a2[0], u3 = a2[1];
            if (o3.match(/^-?0$/) && r3)
              return u3 ? "".concat(o3.replace("0", ""), ".").concat(u3) : o3.replace("0", "");
            if (o3.length < n3)
              for (var c2 = n3 - o3.length, s2 = 0; s2 < c2; s2++)
                i3 = "0".concat(i3);
            return i3.toString();
          }(j, 0, w, b), c, B2, i2, a), (x || F) && (j = j + k), (E || c < 0) && (T = j, U = A2, j = 0 === (P = c) ? T : 0 == +T ? T.replace("-", "") : 0 < P ? "+".concat(T) : "sign" === U ? T : "(".concat(T.replace("-", ""), ")")), j;
        }
        function A(e2, t2) {
          if (!e2)
            return t2;
          var r2 = Object.keys(e2);
          return 1 === r2.length && "output" === r2[0] ? t2 : e2;
        }
        t.exports = function(n2) {
          return { format: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return i.apply(void 0, t2.concat([n2]));
          }, getByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = M.general;
              return B(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, getBinaryByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = M.binary;
              return B(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, getDecimalByteUnit: function() {
            for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
              t2[r2] = arguments[r2];
            return (function(e3) {
              var t3 = M.decimal;
              return B(e3._value, t3.suffixes, t3.scale).suffix;
            }).apply(void 0, t2.concat([n2]));
          }, formatOrDefault: A };
        };
      }, { "./globalState": 4, "./parsing": 8, "./validating": 10 }], 4: [function(e, t, r) {
        "use strict";
        var i = e("./en-US"), n = e("./validating"), a = e("./parsing"), o = {}, u = void 0, c = {}, s = null, l = {};
        function f(e2) {
          u = e2;
        }
        function p() {
          return c[u];
        }
        o.languages = function() {
          return Object.assign({}, c);
        }, o.currentLanguage = function() {
          return u;
        }, o.currentCurrency = function() {
          return p().currency;
        }, o.currentAbbreviations = function() {
          return p().abbreviations;
        }, o.currentDelimiters = function() {
          return p().delimiters;
        }, o.currentOrdinal = function() {
          return p().ordinal;
        }, o.currentDefaults = function() {
          return Object.assign({}, p().defaults, l);
        }, o.currentOrdinalDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().ordinalFormat);
        }, o.currentByteDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().byteFormat);
        }, o.currentPercentageDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().percentageFormat);
        }, o.currentCurrencyDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().currencyFormat);
        }, o.currentTimeDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), p().timeFormat);
        }, o.setDefaults = function(e2) {
          e2 = a.parseFormat(e2), n.validateFormat(e2) && (l = e2);
        }, o.getZeroFormat = function() {
          return s;
        }, o.setZeroFormat = function(e2) {
          return s = "string" == typeof e2 ? e2 : null;
        }, o.hasZeroFormat = function() {
          return null !== s;
        }, o.languageData = function(e2) {
          if (e2) {
            if (c[e2])
              return c[e2];
            throw new Error('Unknown tag "'.concat(e2, '"'));
          }
          return p();
        }, o.registerLanguage = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
          if (!n.validateLanguage(e2))
            throw new Error("Invalid language data");
          c[e2.languageTag] = e2, t2 && f(e2.languageTag);
        }, o.setLanguage = function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : i.languageTag;
          if (!c[e2]) {
            var r2 = e2.split("-")[0], n2 = Object.keys(c).find(function(e3) {
              return e3.split("-")[0] === r2;
            });
            return c[n2] ? void f(n2) : void f(t2);
          }
          f(e2);
        }, o.registerLanguage(i), u = i.languageTag, t.exports = o;
      }, { "./en-US": 2, "./parsing": 8, "./validating": 10 }], 5: [function(n, e, t) {
        "use strict";
        e.exports = function(t2) {
          return { loadLanguagesInNode: function(e2) {
            return r = t2, void e2.forEach(function(t3) {
              var e3 = void 0;
              try {
                e3 = n("../languages/".concat(t3));
              } catch (e4) {
                console.error('Unable to load "'.concat(t3, '". No matching language file found.'));
              }
              e3 && r.registerLanguage(e3);
            });
            var r;
          } };
        };
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var c = e("bignumber.js");
        function a(e2, t2, r2) {
          var n = new c(e2._value), i = t2;
          return r2.isNumbro(t2) && (i = t2._value), i = new c(i), e2._value = n.minus(i).toNumber(), e2;
        }
        t.exports = function(u) {
          return { add: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.plus(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, subtract: function(e2, t2) {
            return a(e2, t2, u);
          }, multiply: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.times(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, divide: function(e2, t2) {
            return n = t2, i = u, a2 = new c((r2 = e2)._value), o = n, i.isNumbro(n) && (o = n._value), o = new c(o), r2._value = a2.dividedBy(o).toNumber(), r2;
            var r2, n, i, a2, o;
          }, set: function(e2, t2) {
            return r2 = e2, i = n = t2, u.isNumbro(n) && (i = n._value), r2._value = i, r2;
            var r2, n, i;
          }, difference: function(e2, t2) {
            return r2 = t2, a(i = (n = u)(e2._value), r2, n), Math.abs(i._value);
            var r2, n, i;
          } };
        };
      }, { "bignumber.js": 1 }], 7: [function(e, t, r) {
        "use strict";
        function i(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        var a = e("./globalState"), n = e("./validating"), o = e("./loading")(g), u = e("./unformatting"), c = e("./formatting")(g), s = e("./manipulating")(g), l = e("./parsing"), f = function() {
          function t2(e3) {
            !function(e4, t3) {
              if (!(e4 instanceof t3))
                throw new TypeError("Cannot call a class as a function");
            }(this, t2), this._value = e3;
          }
          var e2, r2, n2;
          return e2 = t2, (r2 = [{ key: "clone", value: function() {
            return g(this._value);
          } }, { key: "format", value: function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            return c.format(this, e3);
          } }, { key: "formatCurrency", value: function(e3) {
            return "string" == typeof e3 && (e3 = l.parseFormat(e3)), (e3 = c.formatOrDefault(e3, a.currentCurrencyDefaultFormat())).output = "currency", c.format(this, e3);
          } }, { key: "formatTime", value: function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            return e3.output = "time", c.format(this, e3);
          } }, { key: "binaryByteUnits", value: function() {
            return c.getBinaryByteUnit(this);
          } }, { key: "decimalByteUnits", value: function() {
            return c.getDecimalByteUnit(this);
          } }, { key: "byteUnits", value: function() {
            return c.getByteUnit(this);
          } }, { key: "difference", value: function(e3) {
            return s.difference(this, e3);
          } }, { key: "add", value: function(e3) {
            return s.add(this, e3);
          } }, { key: "subtract", value: function(e3) {
            return s.subtract(this, e3);
          } }, { key: "multiply", value: function(e3) {
            return s.multiply(this, e3);
          } }, { key: "divide", value: function(e3) {
            return s.divide(this, e3);
          } }, { key: "set", value: function(e3) {
            return s.set(this, p(e3));
          } }, { key: "value", value: function() {
            return this._value;
          } }, { key: "valueOf", value: function() {
            return this._value;
          } }]) && i(e2.prototype, r2), n2 && i(e2, n2), t2;
        }();
        function p(e2) {
          var t2 = e2;
          return g.isNumbro(e2) ? t2 = e2._value : "string" == typeof e2 ? t2 = g.unformat(e2) : isNaN(e2) && (t2 = NaN), t2;
        }
        function g(e2) {
          return new f(p(e2));
        }
        g.version = "2.1.2", g.isNumbro = function(e2) {
          return e2 instanceof f;
        }, g.language = a.currentLanguage, g.registerLanguage = a.registerLanguage, g.setLanguage = a.setLanguage, g.languages = a.languages, g.languageData = a.languageData, g.zeroFormat = a.setZeroFormat, g.defaultFormat = a.currentDefaults, g.setDefaults = a.setDefaults, g.defaultCurrencyFormat = a.currentCurrencyDefaultFormat, g.validate = n.validate, g.loadLanguagesInNode = o.loadLanguagesInNode, g.unformat = u.unformat, t.exports = g;
      }, { "./formatting": 3, "./globalState": 4, "./loading": 5, "./manipulating": 6, "./parsing": 8, "./unformatting": 9, "./validating": 10 }], 8: [function(e, t, r) {
        "use strict";
        t.exports = { parseFormat: function(e2) {
          var t2, r2, n, i, a, o, u, c, s, l, f, p, g, h, d, v, m, y, b, w, O = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
          return "string" != typeof e2 ? e2 : (r2 = O, e2 = (n = (t2 = e2).match(/^{([^}]*)}/)) ? (r2.prefix = n[1], t2.slice(n[0].length)) : t2, a = O, function(e3, t3) {
            if (-1 === e3.indexOf("$")) {
              if (-1 === e3.indexOf("%"))
                return -1 !== e3.indexOf("bd") ? (t3.output = "byte", t3.base = "general") : -1 !== e3.indexOf("b") ? (t3.output = "byte", t3.base = "binary") : -1 !== e3.indexOf("d") ? (t3.output = "byte", t3.base = "decimal") : -1 === e3.indexOf(":") ? -1 !== e3.indexOf("o") && (t3.output = "ordinal") : t3.output = "time";
              t3.output = "percent";
            } else
              t3.output = "currency";
          }(e2 = (o = (i = e2).match(/{([^}]*)}$/)) ? (a.postfix = o[1], i.slice(0, -o[0].length)) : i, O), u = O, (c = e2.match(/[1-9]+[0-9]*/)) && (u.totalLength = +c[0]), s = O, (l = e2.split(".")[0].match(/0+/)) && (s.characteristic = l[0].length), function(e3, t3) {
            if (-1 !== e3.indexOf(".")) {
              var r3 = e3.split(".")[0];
              t3.optionalCharacteristic = -1 === r3.indexOf("0");
            }
          }(e2, O), f = O, -1 !== e2.indexOf("a") && (f.average = true), g = O, -1 !== (p = e2).indexOf("K") ? g.forceAverage = "thousand" : -1 !== p.indexOf("M") ? g.forceAverage = "million" : -1 !== p.indexOf("B") ? g.forceAverage = "billion" : -1 !== p.indexOf("T") && (g.forceAverage = "trillion"), function(e3, t3) {
            var r3 = e3.split(".")[1];
            if (r3) {
              var n2 = r3.match(/0+/);
              n2 && (t3.mantissa = n2[0].length);
            }
          }(e2, O), d = O, (h = e2).match(/\[\.]/) ? d.optionalMantissa = true : h.match(/\./) && (d.optionalMantissa = false), v = O, -1 !== e2.indexOf(",") && (v.thousandSeparated = true), m = O, -1 !== e2.indexOf(" ") && (m.spaceSeparated = true), b = O, (y = e2).match(/^\+?\([^)]*\)$/) && (b.negative = "parenthesis"), y.match(/^\+?-/) && (b.negative = "sign"), w = O, e2.match(/^\+/) && (w.forceSign = true), O);
        } };
      }, {}], 9: [function(p, e, t) {
        "use strict";
        var O = [{ key: "ZiB", factor: Math.pow(1024, 7) }, { key: "ZB", factor: Math.pow(1e3, 7) }, { key: "YiB", factor: Math.pow(1024, 8) }, { key: "YB", factor: Math.pow(1e3, 8) }, { key: "TiB", factor: Math.pow(1024, 4) }, { key: "TB", factor: Math.pow(1e3, 4) }, { key: "PiB", factor: Math.pow(1024, 5) }, { key: "PB", factor: Math.pow(1e3, 5) }, { key: "MiB", factor: Math.pow(1024, 2) }, { key: "MB", factor: Math.pow(1e3, 2) }, { key: "KiB", factor: Math.pow(1024, 1) }, { key: "KB", factor: Math.pow(1e3, 1) }, { key: "GiB", factor: Math.pow(1024, 3) }, { key: "GB", factor: Math.pow(1e3, 3) }, { key: "EiB", factor: Math.pow(1024, 6) }, { key: "EB", factor: Math.pow(1e3, 6) }, { key: "B", factor: 1 }];
        function x(e2) {
          return e2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function g(e2, t2) {
          var r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", n = 3 < arguments.length ? arguments[3] : void 0, i = 4 < arguments.length ? arguments[4] : void 0, a = 5 < arguments.length ? arguments[5] : void 0, o = 6 < arguments.length ? arguments[6] : void 0;
          if ("" !== e2)
            return e2 === i ? 0 : function e3(t3, r2) {
              var n2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", i2 = 3 < arguments.length ? arguments[3] : void 0, a2 = 4 < arguments.length ? arguments[4] : void 0, o2 = 5 < arguments.length ? arguments[5] : void 0, u = 6 < arguments.length ? arguments[6] : void 0;
              if (!isNaN(+t3))
                return +t3;
              var c = "", s = t3.replace(/(^[^(]*)\((.*)\)([^)]*$)/, "$1$2$3");
              if (s !== t3)
                return -1 * e3(s, r2, n2, i2, a2, o2, u);
              for (var l = 0; l < O.length; l++) {
                var f = O[l];
                if ((c = t3.replace(f.key, "")) !== t3)
                  return e3(c, r2, n2, i2, a2, o2, u) * f.factor;
              }
              if ((c = t3.replace("%", "")) !== t3)
                return e3(c, r2, n2, i2, a2, o2, u) / 100;
              var p2 = parseFloat(t3);
              if (!isNaN(p2)) {
                var g2 = i2(p2);
                if (g2 && "." !== g2 && (c = t3.replace(new RegExp("".concat(x(g2), "$")), "")) !== t3)
                  return e3(c, r2, n2, i2, a2, o2, u);
                var h = {};
                Object.keys(o2).forEach(function(e4) {
                  h[o2[e4]] = e4;
                });
                for (var d = Object.keys(h).sort().reverse(), v = d.length, m = 0; m < v; m++) {
                  var y = d[m], b = h[y];
                  if ((c = t3.replace(y, "")) !== t3) {
                    var w = void 0;
                    switch (b) {
                      case "thousand":
                        w = Math.pow(10, 3);
                        break;
                      case "million":
                        w = Math.pow(10, 6);
                        break;
                      case "billion":
                        w = Math.pow(10, 9);
                        break;
                      case "trillion":
                        w = Math.pow(10, 12);
                    }
                    return e3(c, r2, n2, i2, a2, o2, u) * w;
                  }
                }
              }
            }(function(e3, t3) {
              var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "", n2 = e3.replace(r2, "");
              return n2 = (n2 = n2.replace(new RegExp("([0-9])".concat(x(t3.thousands), "([0-9])"), "g"), "$1$2")).replace(t3.decimal, ".");
            }(e2, t2, r), t2, r, n, i, a, o);
        }
        e.exports = { unformat: function(e2, t2) {
          var r, n, i, a = p("./globalState"), o = a.currentDelimiters(), u = a.currentCurrency().symbol, c = a.currentOrdinal(), s = a.getZeroFormat(), l = a.currentAbbreviations(), f = void 0;
          if ("string" == typeof e2)
            f = function(e3, t3) {
              if (!e3.indexOf(":") || ":" === t3.thousands)
                return false;
              var r2 = e3.split(":");
              if (3 !== r2.length)
                return false;
              var n2 = +r2[0], i2 = +r2[1], a2 = +r2[2];
              return !isNaN(n2) && !isNaN(i2) && !isNaN(a2);
            }(e2, o) ? (r = e2.split(":"), n = +r[0], i = +r[1], +r[2] + 60 * i + 3600 * n) : g(e2, o, u, c, s, l, t2);
          else {
            if ("number" != typeof e2)
              return;
            f = e2;
          }
          if (void 0 !== f)
            return f;
        } };
      }, { "./globalState": 4 }], 10: [function(e, t, r) {
        "use strict";
        function n(e2) {
          return function(e3) {
            if (Array.isArray(e3)) {
              for (var t2 = 0, r2 = new Array(e3.length); t2 < e3.length; t2++)
                r2[t2] = e3[t2];
              return r2;
            }
          }(e2) || function(e3) {
            if (Symbol.iterator in Object(e3) || "[object Arguments]" === Object.prototype.toString.call(e3))
              return Array.from(e3);
          }(e2) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
          }();
        }
        function f(e2) {
          return (f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
          })(e2);
        }
        var i = e("./unformatting"), a = /^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/, p = { output: { type: "string", validValues: ["currency", "percent", "byte", "time", "ordinal", "number"] }, base: { type: "string", validValues: ["decimal", "binary", "general"], restriction: function(e2, t2) {
          return "byte" === t2.output;
        }, message: "`base` must be provided only when the output is `byte`", mandatory: function(e2) {
          return "byte" === e2.output;
        } }, characteristic: { type: "number", restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, prefix: "string", postfix: "string", forceAverage: { type: "string", validValues: ["trillion", "billion", "million", "thousand"] }, average: "boolean", currencyPosition: { type: "string", validValues: ["prefix", "infix", "postfix"] }, currencySymbol: "string", totalLength: { type: "number", restrictions: [{ restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, { restriction: function(e2, t2) {
          return !t2.exponential;
        }, message: "`totalLength` is incompatible with `exponential`" }] }, mantissa: { type: "number", restriction: function(e2) {
          return 0 <= e2;
        }, message: "value must be positive" }, optionalMantissa: "boolean", trimMantissa: "boolean", optionalCharacteristic: "boolean", thousandSeparated: "boolean", spaceSeparated: "boolean", abbreviations: { type: "object", children: { thousand: "string", million: "string", billion: "string", trillion: "string" } }, negative: { type: "string", validValues: ["sign", "parenthesis"] }, forceSign: "boolean", exponential: { type: "boolean" }, prefixSymbol: { type: "boolean", restriction: function(e2, t2) {
          return "percent" === t2.output;
        }, message: "`prefixSymbol` can be provided only when the output is `percent`" } }, o = { languageTag: { type: "string", mandatory: true, restriction: function(e2) {
          return e2.match(a);
        }, message: "the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)" }, delimiters: { type: "object", children: { thousands: "string", decimal: "string", thousandsSize: "number" }, mandatory: true }, abbreviations: { type: "object", children: { thousand: { type: "string", mandatory: true }, million: { type: "string", mandatory: true }, billion: { type: "string", mandatory: true }, trillion: { type: "string", mandatory: true } }, mandatory: true }, spaceSeparated: "boolean", ordinal: { type: "function", mandatory: true }, currency: { type: "object", children: { symbol: "string", position: "string", code: "string" }, mandatory: true }, defaults: "format", ordinalFormat: "format", byteFormat: "format", percentageFormat: "format", currencyFormat: "format", timeDefaults: "format", formats: { type: "object", children: { fourDigits: { type: "format", mandatory: true }, fullWithTwoDecimals: { type: "format", mandatory: true }, fullWithTwoDecimalsNoCurrency: { type: "format", mandatory: true }, fullWithNoDecimals: { type: "format", mandatory: true } } } };
        function u(e2) {
          return !!i.unformat(e2);
        }
        function g(c2, s, l) {
          var e2 = 3 < arguments.length && void 0 !== arguments[3] && arguments[3], t2 = Object.keys(c2).map(function(e3) {
            if (!s[e3])
              return console.error("".concat(l, " Invalid key: ").concat(e3)), false;
            var t3 = c2[e3], r2 = s[e3];
            if ("string" == typeof r2 && (r2 = { type: r2 }), "format" === r2.type) {
              if (!g(t3, p, "[Validate ".concat(e3, "]"), true))
                return false;
            } else if (f(t3) !== r2.type)
              return console.error("".concat(l, " ").concat(e3, ' type mismatched: "').concat(r2.type, '" expected, "').concat(f(t3), '" provided')), false;
            if (r2.restrictions && r2.restrictions.length)
              for (var n2 = r2.restrictions.length, i2 = 0; i2 < n2; i2++) {
                var a2 = r2.restrictions[i2], o2 = a2.restriction, u2 = a2.message;
                if (!o2(t3, c2))
                  return console.error("".concat(l, " ").concat(e3, " invalid value: ").concat(u2)), false;
              }
            if (r2.restriction && !r2.restriction(t3, c2))
              return console.error("".concat(l, " ").concat(e3, " invalid value: ").concat(r2.message)), false;
            if (r2.validValues && -1 === r2.validValues.indexOf(t3))
              return console.error("".concat(l, " ").concat(e3, " invalid value: must be among ").concat(JSON.stringify(r2.validValues), ', "').concat(t3, '" provided')), false;
            if (r2.children && !g(t3, r2.children, "[Validate ".concat(e3, "]")))
              return false;
            return true;
          });
          return e2 || t2.push.apply(t2, n(Object.keys(s).map(function(e3) {
            var t3 = s[e3];
            if ("string" == typeof t3 && (t3 = { type: t3 }), t3.mandatory) {
              var r2 = t3.mandatory;
              if ("function" == typeof r2 && (r2 = r2(c2)), r2 && void 0 === c2[e3])
                return console.error("".concat(l, ' Missing mandatory key "').concat(e3, '"')), false;
            }
            return true;
          }))), t2.reduce(function(e3, t3) {
            return e3 && t3;
          }, true);
        }
        function c(e2) {
          return g(e2, p, "[Validate format]");
        }
        t.exports = { validate: function(e2, t2) {
          var r2 = u(e2), n2 = c(t2);
          return r2 && n2;
        }, validateFormat: c, validateInput: u, validateLanguage: function(e2) {
          return g(e2, o, "[Validate language]");
        } };
      }, { "./unformatting": 9 }] }, {}, [7])(7);
    });
  }
});

// node_modules/handsontable/editors/handsontableEditor/handsontableEditor.mjs
var SHORTCUTS_GROUP = "handsontableEditor";
var EDITOR_TYPE = "handsontable";
var HandsontableEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE;
  }
  /**
   * Opens the editor and adjust its size.
   */
  open() {
    super.open();
    if (this.htEditor) {
      this.htEditor.destroy();
    }
    if (this.htContainer.style.display === "none") {
      this.htContainer.style.display = "";
    }
    this.htEditor = new this.hot.constructor(this.htContainer, this.htOptions);
    this.htEditor.init();
    this.htEditor.rootElement.style.display = "";
    if (this.cellProperties.strict) {
      this.htEditor.selectCell(0, 0);
    } else {
      this.htEditor.deselectCell();
    }
    setCaretPosition(this.TEXTAREA, 0, this.TEXTAREA.value.length);
    this.refreshDimensions();
  }
  /**
   * Closes the editor.
   */
  close() {
    if (this.htEditor) {
      this.htEditor.rootElement.style.display = "none";
    }
    this.removeHooksByKey("beforeKeyDown");
    super.close();
  }
  /**
   * Prepares editor's meta data and configuration of the internal Handsontable's instance.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    const parent = this;
    const options = {
      startRows: 0,
      startCols: 0,
      minRows: 0,
      minCols: 0,
      className: "listbox",
      copyPaste: false,
      autoColumnSize: false,
      autoRowSize: false,
      readOnly: true,
      fillHandle: false,
      autoWrapCol: false,
      autoWrapRow: false,
      ariaTags: false,
      afterOnCellMouseDown(_, coords) {
        const sourceValue = this.getSourceData(coords.row, coords.col);
        if (sourceValue !== void 0) {
          parent.setValue(sourceValue);
        }
        parent.hot.destroyEditor();
      },
      preventWheel: true,
      layoutDirection: this.hot.isRtl() ? "rtl" : "ltr"
    };
    if (this.cellProperties.handsontable) {
      extend(options, cellProperties.handsontable);
    }
    this.htOptions = options;
  }
  /**
   * Begins editing on a highlighted cell and hides fillHandle corner if was present.
   *
   * @param {*} newInitialValue The editor initial value.
   * @param {*} event The keyboard event object.
   */
  beginEditing(newInitialValue, event) {
    const onBeginEditing = this.hot.getSettings().onBeginEditing;
    if (onBeginEditing && onBeginEditing() === false) {
      return;
    }
    super.beginEditing(newInitialValue, event);
  }
  /**
   * Creates an editor's elements and adds necessary CSS classnames.
   */
  createElements() {
    super.createElements();
    const DIV = this.hot.rootDocument.createElement("DIV");
    DIV.className = "handsontableEditor";
    this.TEXTAREA_PARENT.appendChild(DIV);
    this.htContainer = DIV;
    this.assignHooks();
  }
  /**
   * Finishes editing and start saving or restoring process for editing cell or last selected range.
   *
   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
   * @param {Function} callback The callback function, fired after editor closing.
   */
  finishEditing(restoreOriginalValue, ctrlDown, callback) {
    if (this.htEditor && this.htEditor.isListening()) {
      this.hot.listen();
    }
    if (this.htEditor && this.htEditor.getSelectedLast()) {
      const value = this.htEditor.getValue();
      if (value !== void 0) {
        this.setValue(value);
      }
    }
    super.finishEditing(restoreOriginalValue, ctrlDown, callback);
  }
  /**
   * Assigns afterDestroy callback to prevent memory leaks.
   *
   * @private
   */
  assignHooks() {
    this.hot.addHook("afterDestroy", () => {
      if (this.htEditor) {
        this.htEditor.destroy();
      }
    });
  }
  /**
   * Register shortcuts responsible for handling editor.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    super.registerShortcuts();
    const contextConfig = {
      group: SHORTCUTS_GROUP,
      relativeToGroup: SHORTCUTS_GROUP_NAVIGATION,
      position: "before"
    };
    const action = (rowToSelect, event) => {
      const innerHOT = this.htEditor;
      if (rowToSelect !== void 0) {
        if (rowToSelect < 0 || innerHOT.flipped && rowToSelect > innerHOT.countRows() - 1) {
          innerHOT.deselectCell();
        } else {
          innerHOT.selectCell(rowToSelect, 0);
        }
        if (innerHOT.getData().length) {
          event.preventDefault();
          stopImmediatePropagation(event);
          this.hot.listen();
          this.TEXTAREA.focus();
          return false;
        }
      }
    };
    editorContext.addShortcuts([{
      keys: [["ArrowUp"]],
      callback: (event) => {
        const innerHOT = this.htEditor;
        let rowToSelect;
        let selectedRow;
        if (!innerHOT.getSelectedLast() && innerHOT.flipped) {
          rowToSelect = innerHOT.countRows() - 1;
        } else if (innerHOT.getSelectedLast()) {
          if (innerHOT.flipped) {
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = Math.max(0, selectedRow - 1);
          } else {
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = selectedRow - 1;
          }
        }
        return action(rowToSelect, event);
      },
      preventDefault: false
      // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.
    }, {
      keys: [["ArrowDown"]],
      callback: (event) => {
        const innerHOT = this.htEditor;
        let rowToSelect;
        let selectedRow;
        if (!innerHOT.getSelectedLast() && !innerHOT.flipped) {
          rowToSelect = 0;
        } else if (innerHOT.getSelectedLast()) {
          if (innerHOT.flipped) {
            rowToSelect = innerHOT.getSelectedLast()[0] + 1;
          } else if (!innerHOT.flipped) {
            const lastRow = innerHOT.countRows() - 1;
            selectedRow = innerHOT.getSelectedLast()[0];
            rowToSelect = Math.min(lastRow, selectedRow + 1);
          }
        }
        return action(rowToSelect, event);
      },
      preventDefault: false
      // Doesn't block default behaviour (navigation) for a `textArea` HTMLElement.
    }], contextConfig);
  }
  /**
   * Unregister shortcuts responsible for handling editor.
   *
   * @private
   */
  unregisterShortcuts() {
    super.unregisterShortcuts();
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);
  }
};

// node_modules/handsontable/editors/autocompleteEditor/autocompleteEditor.mjs
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var EDITOR_TYPE2 = "autocomplete";
var _idPrefix = /* @__PURE__ */ new WeakMap();
var AutocompleteEditor = class extends HandsontableEditor {
  constructor() {
    super(...arguments);
    _defineProperty(this, "query", null);
    _defineProperty(this, "strippedChoices", []);
    _defineProperty(this, "rawChoices", []);
    _classPrivateFieldInitSpec(this, _idPrefix, {
      writable: true,
      value: this.hot.guid.slice(0, 9)
    });
    _defineProperty(this, "sortByRelevance", function(value, choices, caseSensitive) {
      const choicesRelevance = [];
      const result = [];
      const valueLength = value.length;
      let choicesCount = choices.length;
      let charsLeft;
      let currentItem;
      let i;
      let valueIndex;
      if (valueLength === 0) {
        for (i = 0; i < choicesCount; i++) {
          result.push(i);
        }
        return result;
      }
      for (i = 0; i < choicesCount; i++) {
        currentItem = stripTags(stringify(choices[i]));
        if (caseSensitive) {
          valueIndex = currentItem.indexOf(value);
        } else {
          const locale = this.cellProperties.locale;
          valueIndex = currentItem.toLocaleLowerCase(locale).indexOf(value.toLocaleLowerCase(locale));
        }
        if (valueIndex !== -1) {
          charsLeft = currentItem.length - valueIndex - valueLength;
          choicesRelevance.push({
            baseIndex: i,
            index: valueIndex,
            charsLeft,
            value: currentItem
          });
        }
      }
      choicesRelevance.sort((a, b) => {
        if (b.index === -1) {
          return -1;
        }
        if (a.index === -1) {
          return 1;
        }
        if (a.index < b.index) {
          return -1;
        } else if (b.index < a.index) {
          return 1;
        } else if (a.index === b.index) {
          if (a.charsLeft < b.charsLeft) {
            return -1;
          } else if (a.charsLeft > b.charsLeft) {
            return 1;
          }
        }
        return 0;
      });
      for (i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {
        result.push(choicesRelevance[i].baseIndex);
      }
      return result;
    });
  }
  static get EDITOR_TYPE() {
    return EDITOR_TYPE2;
  }
  /**
   * Gets current value from editable element.
   *
   * @returns {string}
   */
  getValue() {
    const selectedValue = this.rawChoices.find((value) => {
      const strippedValue = this.stripValueIfNeeded(value);
      return strippedValue === this.TEXTAREA.value;
    });
    if (isDefined(selectedValue)) {
      return selectedValue;
    }
    return this.TEXTAREA.value;
  }
  /**
   * Creates an editor's elements and adds necessary CSS classnames.
   */
  createElements() {
    super.createElements();
    addClass(this.htContainer, "autocompleteEditor");
    addClass(this.htContainer, this.hot.rootWindow.navigator.platform.indexOf("Mac") === -1 ? "" : "htMacScroll");
    if (this.hot.getSettings().ariaTags) {
      setAttribute(this.TEXTAREA, [A11Y_TEXT(), A11Y_COMBOBOX(), A11Y_HASPOPUP("listbox"), A11Y_AUTOCOMPLETE()]);
    }
  }
  /**
   * Prepares editor's metadata and configuration of the internal Handsontable's instance.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    if (this.hot.getSettings().ariaTags) {
      setAttribute(this.TEXTAREA, [A11Y_EXPANDED("false"), A11Y_CONTROLS(`${_classPrivateFieldGet(this, _idPrefix)}-listbox-${row}-${col}`)]);
    }
  }
  /**
   * Opens the editor and adjust its size and internal Handsontable's instance.
   */
  open() {
    super.open();
    const trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;
    const rootInstanceAriaTagsEnabled = this.hot.getSettings().ariaTags;
    const sourceArray = Array.isArray(this.cellProperties.source) ? this.cellProperties.source : null;
    const sourceSize = sourceArray === null || sourceArray === void 0 ? void 0 : sourceArray.length;
    const {
      row: rowIndex,
      col: colIndex
    } = this;
    this.showEditableElement();
    this.focus();
    let scrollbarWidth = getScrollbarWidth();
    if (scrollbarWidth === 0 && isMacOS()) {
      scrollbarWidth += 15;
    }
    this.addHook("beforeKeyDown", (event) => this.onBeforeKeyDown(event));
    this.htEditor.updateSettings({
      colWidths: trimDropdown ? [outerWidth(this.TEXTAREA) - 2] : void 0,
      width: trimDropdown ? outerWidth(this.TEXTAREA) + scrollbarWidth : void 0,
      autoColumnSize: true,
      renderer: (hotInstance, TD, row, col, prop, value, cellProperties) => {
        textRenderer(hotInstance, TD, row, col, prop, value, cellProperties);
        const {
          filteringCaseSensitive,
          allowHtml,
          locale
        } = this.cellProperties;
        const query = this.query;
        let cellValue = stringify(value);
        let indexOfMatch;
        let match;
        if (cellValue && !allowHtml) {
          indexOfMatch = filteringCaseSensitive === true ? cellValue.indexOf(query) : cellValue.toLocaleLowerCase(locale).indexOf(query.toLocaleLowerCase(locale));
          if (indexOfMatch !== -1) {
            match = cellValue.substr(indexOfMatch, query.length);
            cellValue = cellValue.replace(match, `<strong>${match}</strong>`);
          }
        }
        if (rootInstanceAriaTagsEnabled) {
          setAttribute(TD, [
            A11Y_OPTION(),
            // Add `setsize` and `posinset` only if the source is an array.
            ...sourceArray ? [A11Y_SETSIZE(sourceSize)] : [],
            ...sourceArray ? [A11Y_POSINSET(sourceArray.indexOf(value) + 1)] : [],
            ["id", `${this.htEditor.rootElement.id}_${row}-${col}`]
          ]);
        }
        TD.innerHTML = cellValue;
      },
      afterSelection: (startRow, startCol) => {
        if (rootInstanceAriaTagsEnabled) {
          const TD = this.htEditor.getCell(startRow, startCol, true);
          setAttribute(TD, [A11Y_SELECTED()]);
          setAttribute(this.TEXTAREA, ...A11Y_ACTIVEDESCENDANT(TD.id));
        }
      }
    });
    if (rootInstanceAriaTagsEnabled) {
      setAttribute(this.htEditor.view._wt.wtOverlays.wtTable.TABLE, ...A11Y_PRESENTATION());
      setAttribute(this.htEditor.rootElement, [A11Y_LISTBOX(), A11Y_LIVE("polite"), A11Y_RELEVANT("text"), ["id", `${_classPrivateFieldGet(this, _idPrefix)}-listbox-${rowIndex}-${colIndex}`]]);
      setAttribute(this.TEXTAREA, ...A11Y_EXPANDED("true"));
    }
    this.hot._registerTimeout(() => {
      this.queryChoices(this.TEXTAREA.value);
    });
  }
  /**
   * Closes the editor.
   */
  close() {
    this.removeHooksByKey("beforeKeyDown");
    super.close();
    if (this.hot.getSettings().ariaTags) {
      setAttribute(this.TEXTAREA, [A11Y_EXPANDED("false")]);
    }
  }
  /**
   * Verifies result of validation or closes editor if user's cancelled changes.
   *
   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,
   *                                   then an editor won't be closed until validation is passed.
   */
  discardEditor(result) {
    super.discardEditor(result);
    this.hot.view.render();
  }
  /**
   * Prepares choices list based on applied argument.
   *
   * @private
   * @param {string} query The query.
   */
  queryChoices(query) {
    const source = this.cellProperties.source;
    this.query = query;
    if (typeof source === "function") {
      source.call(this.cellProperties, query, (choices) => {
        this.rawChoices = choices;
        this.updateChoicesList(this.stripValuesIfNeeded(choices));
      });
    } else if (Array.isArray(source)) {
      this.rawChoices = source;
      this.updateChoicesList(this.stripValuesIfNeeded(source));
    } else {
      this.updateChoicesList([]);
    }
  }
  /**
   * Updates list of the possible completions to choose.
   *
   * @private
   * @param {Array} choicesList The choices list to process.
   */
  updateChoicesList(choicesList) {
    const pos = getCaretPosition(this.TEXTAREA);
    const endPos = getSelectionEndPosition(this.TEXTAREA);
    const sortByRelevanceSetting = this.cellProperties.sortByRelevance;
    const filterSetting = this.cellProperties.filter;
    let orderByRelevance = null;
    let highlightIndex = null;
    let choices = choicesList;
    if (sortByRelevanceSetting) {
      orderByRelevance = this.sortByRelevance(this.stripValueIfNeeded(this.getValue()), choices, this.cellProperties.filteringCaseSensitive);
    }
    const orderByRelevanceLength = Array.isArray(orderByRelevance) ? orderByRelevance.length : 0;
    if (filterSetting === false) {
      if (orderByRelevanceLength) {
        highlightIndex = orderByRelevance[0];
      }
    } else {
      const sorted = [];
      for (let i = 0, choicesCount = choices.length; i < choicesCount; i++) {
        if (sortByRelevanceSetting && orderByRelevanceLength <= i) {
          break;
        }
        if (orderByRelevanceLength) {
          sorted.push(choices[orderByRelevance[i]]);
        } else {
          sorted.push(choices[i]);
        }
      }
      highlightIndex = 0;
      choices = sorted;
    }
    this.strippedChoices = choices;
    this.htEditor.loadData(pivot([choices]));
    if (choices.length === 0) {
      this.htEditor.rootElement.style.display = "none";
    } else {
      this.htEditor.rootElement.style.display = "";
      this.updateDropdownHeight();
      this.flipDropdownIfNeeded();
      if (this.cellProperties.strict === true) {
        this.highlightBestMatchingChoice(highlightIndex);
      }
    }
    this.hot.listen();
    setCaretPosition(this.TEXTAREA, pos, pos === endPos ? void 0 : endPos);
  }
  /**
   * Checks where is enough place to open editor.
   *
   * @private
   * @returns {boolean}
   */
  flipDropdownIfNeeded() {
    const trimmingContainer = getTrimmingContainer(this.hot.view._wt.wtTable.TABLE);
    const isWindowAsScrollableElement = trimmingContainer === this.hot.rootWindow;
    const preventOverflow = this.cellProperties.preventOverflow;
    if (isWindowAsScrollableElement || !isWindowAsScrollableElement && (preventOverflow || preventOverflow === "horizontal")) {
      return false;
    }
    const textareaOffset = offset(this.TEXTAREA);
    const textareaHeight = outerHeight(this.TEXTAREA);
    const dropdownHeight = this.getDropdownHeight();
    const trimmingContainerScrollTop = trimmingContainer.scrollTop;
    const headersHeight = outerHeight(this.hot.view._wt.wtTable.THEAD);
    const containerOffset = offset(trimmingContainer);
    const spaceAbove = textareaOffset.top - containerOffset.top - headersHeight + trimmingContainerScrollTop;
    const spaceBelow = trimmingContainer.scrollHeight - spaceAbove - headersHeight - textareaHeight;
    const flipNeeded = dropdownHeight > spaceBelow && spaceAbove > spaceBelow;
    if (flipNeeded) {
      this.flipDropdown(dropdownHeight);
    } else {
      this.unflipDropdown();
    }
    this.limitDropdownIfNeeded(flipNeeded ? spaceAbove : spaceBelow, dropdownHeight);
    return flipNeeded;
  }
  /**
   * Checks if the internal table should generate scrollbar or could be rendered without it.
   *
   * @private
   * @param {number} spaceAvailable The free space as height defined in px available for dropdown list.
   * @param {number} dropdownHeight The dropdown height.
   */
  limitDropdownIfNeeded(spaceAvailable, dropdownHeight) {
    if (dropdownHeight > spaceAvailable) {
      let tempHeight = 0;
      let i = 0;
      let lastRowHeight = 0;
      let height = null;
      do {
        lastRowHeight = this.htEditor.getRowHeight(i) || this.htEditor.view._wt.getSetting("defaultRowHeight");
        tempHeight += lastRowHeight;
        i += 1;
      } while (tempHeight < spaceAvailable);
      height = tempHeight - lastRowHeight;
      if (this.htEditor.flipped) {
        this.htEditor.rootElement.style.top = `${parseInt(this.htEditor.rootElement.style.top, 10) + dropdownHeight - height}px`;
      }
      this.setDropdownHeight(tempHeight - lastRowHeight);
    }
  }
  /**
   * Configures editor to open it at the top.
   *
   * @private
   * @param {number} dropdownHeight The dropdown height.
   */
  flipDropdown(dropdownHeight) {
    const dropdownStyle = this.htEditor.rootElement.style;
    dropdownStyle.position = "absolute";
    dropdownStyle.top = `${-dropdownHeight}px`;
    this.htEditor.flipped = true;
  }
  /**
   * Configures editor to open it at the bottom.
   *
   * @private
   */
  unflipDropdown() {
    const dropdownStyle = this.htEditor.rootElement.style;
    dropdownStyle.position = "absolute";
    dropdownStyle.top = "";
    this.htEditor.flipped = void 0;
  }
  /**
   * Updates width and height of the internal Handsontable's instance.
   *
   * @private
   */
  updateDropdownHeight() {
    const currentDropdownWidth = this.htEditor.getColWidth(0) + getScrollbarWidth(this.hot.rootDocument) + 2;
    const trimDropdown = this.cellProperties.trimDropdown;
    this.htEditor.updateSettings({
      height: this.getDropdownHeight(),
      width: trimDropdown ? void 0 : currentDropdownWidth
    });
    this.htEditor.view._wt.wtTable.alignOverlaysWithTrimmingContainer();
  }
  /**
   * Sets new height of the internal Handsontable's instance.
   *
   * @private
   * @param {number} height The new dropdown height.
   */
  setDropdownHeight(height) {
    this.htEditor.updateSettings({
      height
    });
  }
  /**
   * Creates new selection on specified row index, or deselects selected cells.
   *
   * @private
   * @param {number|undefined} index The visual row index.
   */
  highlightBestMatchingChoice(index) {
    if (typeof index === "number") {
      this.htEditor.selectCell(index, 0, void 0, void 0, void 0, false);
    } else {
      this.htEditor.deselectCell();
    }
  }
  /**
   * Calculates and return the internal Handsontable's height.
   *
   * @private
   * @returns {number}
   */
  getDropdownHeight() {
    const firstRowHeight = this.htEditor.getRowHeight(0) || 23;
    const visibleRows = this.cellProperties.visibleRows;
    return this.strippedChoices.length >= visibleRows ? visibleRows * firstRowHeight : this.strippedChoices.length * firstRowHeight + 8;
  }
  /**
   * Sanitizes value from potential dangerous tags.
   *
   * @private
   * @param {string} value The value to sanitize.
   * @returns {string}
   */
  stripValueIfNeeded(value) {
    return this.stripValuesIfNeeded([value])[0];
  }
  /**
   * Sanitizes an array of the values from potential dangerous tags.
   *
   * @private
   * @param {string[]} values The value to sanitize.
   * @returns {string[]}
   */
  stripValuesIfNeeded(values) {
    const {
      allowHtml
    } = this.cellProperties;
    const stringifiedValues = arrayMap(values, (value) => stringify(value));
    const strippedValues = arrayMap(stringifiedValues, (value) => allowHtml ? value : stripTags(value));
    return strippedValues;
  }
  /**
   * Captures use of arrow down and up to control their behaviour.
   *
   * @private
   * @param {number} keyCode The keyboard keycode.
   * @returns {boolean}
   */
  allowKeyEventPropagation(keyCode) {
    const selectedRange = this.htEditor.getSelectedRangeLast();
    const selected = {
      row: selectedRange ? selectedRange.from.row : -1
    };
    let allowed = false;
    if (keyCode === KEY_CODES.ARROW_DOWN && selected.row > 0 && selected.row < this.htEditor.countRows() - 1) {
      allowed = true;
    }
    if (keyCode === KEY_CODES.ARROW_UP && selected.row > -1) {
      allowed = true;
    }
    return allowed;
  }
  /**
   * OnBeforeKeyDown callback.
   *
   * @private
   * @param {KeyboardEvent} event The keyboard event object.
   */
  onBeforeKeyDown(event) {
    if (isPrintableChar(event.keyCode) || event.keyCode === KEY_CODES.BACKSPACE || event.keyCode === KEY_CODES.DELETE || event.keyCode === KEY_CODES.INSERT) {
      let timeOffset = 10;
      if (event.keyCode === KEY_CODES.C && (event.ctrlKey || event.metaKey)) {
        return;
      }
      if (!this.isOpened()) {
        timeOffset += 10;
      }
      if (this.htEditor) {
        this.hot._registerTimeout(() => {
          this.queryChoices(this.TEXTAREA.value);
        }, timeOffset);
      }
    }
  }
};

// node_modules/handsontable/renderers/htmlRenderer/htmlRenderer.mjs
var RENDERER_TYPE = "html";
function htmlRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  baseRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);
  fastInnerHTML(TD, value === null || value === void 0 ? "" : value, false);
}
htmlRenderer.RENDERER_TYPE = RENDERER_TYPE;

// node_modules/handsontable/renderers/autocompleteRenderer/autocompleteRenderer.mjs
var RENDERER_TYPE2 = "autocomplete";
function autocompleteRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  const {
    rootDocument
  } = hotInstance;
  const rendererFunc = cellProperties.allowHtml ? htmlRenderer : textRenderer;
  const ARROW = rootDocument.createElement("DIV");
  const isAriaEnabled = hotInstance.getSettings().ariaTags;
  ARROW.className = "htAutocompleteArrow";
  if (isAriaEnabled) {
    ARROW.setAttribute(...A11Y_HIDDEN());
  }
  ARROW.appendChild(rootDocument.createTextNode(String.fromCharCode(9660)));
  rendererFunc.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);
  if (!TD.firstChild) {
    TD.appendChild(rootDocument.createTextNode(String.fromCharCode(160)));
  }
  TD.insertBefore(ARROW, TD.firstChild);
  addClass(TD, "htAutocomplete");
  if (!hotInstance.acArrowListener) {
    const eventManager = new eventManager_default(hotInstance);
    hotInstance.acArrowListener = function(event) {
      if (hasClass(event.target, "htAutocompleteArrow")) {
        hotInstance.view._wt.getSetting("onCellDblClick", null, hotInstance._createCellCoords(row, col), TD);
      }
    };
    eventManager.addEventListener(hotInstance.rootElement, "mousedown", hotInstance.acArrowListener);
    hotInstance.addHookOnce("afterDestroy", () => {
      eventManager.destroy();
    });
  }
}
autocompleteRenderer.RENDERER_TYPE = RENDERER_TYPE2;

// node_modules/handsontable/validators/autocompleteValidator/autocompleteValidator.mjs
var VALIDATOR_TYPE = "autocomplete";
function autocompleteValidator(value, callback) {
  let valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
    return;
  }
  if (this.strict && this.source) {
    if (typeof this.source === "function") {
      this.source(valueToValidate, process(valueToValidate, callback));
    } else {
      process(valueToValidate, callback)(this.source);
    }
  } else {
    callback(true);
  }
}
autocompleteValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;
function process(value, callback) {
  const originalVal = value;
  return function(source) {
    let found = false;
    for (let s = 0, slen = source.length; s < slen; s++) {
      if (originalVal === source[s]) {
        found = true;
        break;
      }
    }
    callback(found);
  };
}

// node_modules/handsontable/cellTypes/autocompleteType/autocompleteType.mjs
var CELL_TYPE = "autocomplete";
var AutocompleteCellType = {
  CELL_TYPE,
  editor: AutocompleteEditor,
  renderer: autocompleteRenderer,
  validator: autocompleteValidator
};

// node_modules/handsontable/editors/checkboxEditor/checkboxEditor.mjs
var EDITOR_TYPE3 = "checkbox";
var CheckboxEditor = class extends BaseEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE3;
  }
  beginEditing(initialValue, event) {
    if (event && event.type === "mouseup") {
      const checkbox = this.TD.querySelector('input[type="checkbox"]');
      if (!hasClass(checkbox, "htBadValue")) {
        checkbox.click();
      }
    }
  }
  finishEditing() {
  }
  init() {
  }
  open() {
  }
  close() {
  }
  getValue() {
  }
  setValue() {
  }
  focus() {
  }
};

// node_modules/handsontable/renderers/checkboxRenderer/checkboxRenderer.mjs
var isListeningKeyDownEvent = /* @__PURE__ */ new WeakMap();
var isCheckboxListenerAdded = /* @__PURE__ */ new WeakMap();
var BAD_VALUE_CLASS = "htBadValue";
var ATTR_ROW = "data-row";
var ATTR_COLUMN = "data-col";
var SHORTCUTS_GROUP2 = "checkboxRenderer";
var RENDERER_TYPE3 = "checkbox";
pluginHooks_default.getSingleton().add("modifyAutoColumnSizeSeed", function(bundleSeed, cellMeta, cellValue) {
  const {
    label,
    type,
    row,
    column,
    prop
  } = cellMeta;
  if (type !== RENDERER_TYPE3) {
    return;
  }
  if (label) {
    const {
      value: labelValue,
      property: labelProperty
    } = label;
    let labelText = cellValue;
    if (labelValue) {
      labelText = typeof labelValue === "function" ? labelValue(row, column, prop, cellValue) : labelValue;
    } else if (labelProperty) {
      const labelData = this.getDataAtRowProp(row, labelProperty);
      labelText = labelData !== null ? labelData : cellValue;
    }
    bundleSeed = labelText;
  }
  return bundleSeed;
});
function checkboxRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  const {
    rootDocument
  } = hotInstance;
  const ariaEnabled = hotInstance.getSettings().ariaTags;
  baseRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);
  registerEvents(hotInstance);
  let input = createInput(rootDocument);
  const labelOptions = cellProperties.label;
  let badValue = false;
  if (typeof cellProperties.checkedTemplate === "undefined") {
    cellProperties.checkedTemplate = true;
  }
  if (typeof cellProperties.uncheckedTemplate === "undefined") {
    cellProperties.uncheckedTemplate = false;
  }
  empty(TD);
  if (value === cellProperties.checkedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.checkedTemplate).toLocaleLowerCase(cellProperties.locale)) {
    input.checked = true;
  } else if (value === cellProperties.uncheckedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.uncheckedTemplate).toLocaleLowerCase(cellProperties.locale)) {
    input.checked = false;
  } else if (isEmpty(value)) {
    addClass(input, "noValue");
  } else {
    input.style.display = "none";
    addClass(input, BAD_VALUE_CLASS);
    badValue = true;
  }
  setAttribute(input, [[ATTR_ROW, row], [ATTR_COLUMN, col]]);
  if (ariaEnabled) {
    setAttribute(input, [A11Y_LABEL(input.checked ? hotInstance.getTranslatedPhrase(CHECKBOX_CHECKED) : hotInstance.getTranslatedPhrase(CHECKBOX_UNCHECKED)), A11Y_CHECKED(input.checked), A11Y_CHECKBOX()]);
  }
  if (!badValue && labelOptions) {
    let labelText = "";
    if (labelOptions.value) {
      labelText = typeof labelOptions.value === "function" ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;
    } else if (labelOptions.property) {
      const labelValue = hotInstance.getDataAtRowProp(row, labelOptions.property);
      labelText = labelValue !== null ? labelValue : "";
    }
    const label = createLabel(rootDocument, labelText, labelOptions.separated !== true);
    if (labelOptions.position === "before") {
      if (labelOptions.separated) {
        TD.appendChild(label);
        TD.appendChild(input);
      } else {
        label.appendChild(input);
        input = label;
      }
    } else if (!labelOptions.position || labelOptions.position === "after") {
      if (labelOptions.separated) {
        TD.appendChild(input);
        TD.appendChild(label);
      } else {
        label.insertBefore(input, label.firstChild);
        input = label;
      }
    }
  }
  if (!labelOptions || labelOptions && !labelOptions.separated) {
    TD.appendChild(input);
  }
  if (badValue) {
    TD.appendChild(rootDocument.createTextNode("#bad-value#"));
  }
  if (!isListeningKeyDownEvent.has(hotInstance)) {
    isListeningKeyDownEvent.set(hotInstance, true);
    registerShortcuts();
  }
  function registerShortcuts() {
    const shortcutManager = hotInstance.getShortcutManager();
    const gridContext = shortcutManager.getContext("grid");
    const config = {
      group: SHORTCUTS_GROUP2
    };
    gridContext.addShortcuts([{
      keys: [["space"]],
      callback: () => {
        changeSelectedCheckboxesState();
        return !areSelectedCheckboxCells();
      }
    }, {
      keys: [["enter"]],
      callback: () => {
        changeSelectedCheckboxesState();
        return !areSelectedCheckboxCells();
      },
      runOnlyIf: () => hotInstance.getSettings().enterBeginsEditing
    }, {
      keys: [["delete"], ["backspace"]],
      callback: () => {
        changeSelectedCheckboxesState(true);
        return !areSelectedCheckboxCells();
      },
      relativeToGroup: EDITOR_EDIT_GROUP,
      position: "before"
    }], config);
  }
  function changeSelectedCheckboxesState() {
    let uncheckCheckbox = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const selRange = hotInstance.getSelectedRange();
    if (!selRange) {
      return;
    }
    for (let key = 0; key < selRange.length; key++) {
      const {
        row: startRow,
        col: startColumn
      } = selRange[key].getTopStartCorner();
      const {
        row: endRow,
        col: endColumn
      } = selRange[key].getBottomEndCorner();
      const changes = [];
      for (let visualRow = startRow; visualRow <= endRow; visualRow += 1) {
        for (let visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {
          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);
          if (cachedCellProperties.type !== "checkbox") {
            return;
          }
          if (cachedCellProperties.readOnly === true) {
            continue;
          }
          if (typeof cachedCellProperties.checkedTemplate === "undefined") {
            cachedCellProperties.checkedTemplate = true;
          }
          if (typeof cachedCellProperties.uncheckedTemplate === "undefined") {
            cachedCellProperties.uncheckedTemplate = false;
          }
          const dataAtCell = hotInstance.getDataAtCell(visualRow, visualColumn);
          if (uncheckCheckbox === false) {
            if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {
              changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
            } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, void 0].includes(dataAtCell)) {
              changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate]);
            }
          } else {
            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate]);
          }
        }
      }
      if (changes.length > 0) {
        hotInstance.setDataAtCell(changes);
      }
    }
  }
  function areSelectedCheckboxCells() {
    const selRange = hotInstance.getSelectedRange();
    if (!selRange) {
      return;
    }
    for (let key = 0; key < selRange.length; key++) {
      const topLeft = selRange[key].getTopStartCorner();
      const bottomRight = selRange[key].getBottomEndCorner();
      for (let visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {
        for (let visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {
          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);
          if (cachedCellProperties.type !== "checkbox") {
            return false;
          }
          const cell = hotInstance.getCell(visualRow, visualColumn);
          if (cell === null || cell === void 0) {
            return true;
          } else {
            const checkboxes = cell.querySelectorAll("input[type=checkbox]");
            if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
}
checkboxRenderer.RENDERER_TYPE = RENDERER_TYPE3;
function registerEvents(instance) {
  let eventManager = isCheckboxListenerAdded.get(instance);
  if (!eventManager) {
    const {
      rootElement
    } = instance;
    eventManager = new eventManager_default(instance);
    eventManager.addEventListener(rootElement, "click", (event) => onClick(event, instance));
    eventManager.addEventListener(rootElement, "mouseup", (event) => onMouseUp(event, instance));
    eventManager.addEventListener(rootElement, "change", (event) => onChange(event, instance));
    isCheckboxListenerAdded.set(instance, eventManager);
  }
  return eventManager;
}
function createInput(rootDocument) {
  const input = rootDocument.createElement("input");
  input.className = "htCheckboxRendererInput";
  input.type = "checkbox";
  input.setAttribute("tabindex", "-1");
  return input.cloneNode(false);
}
function createLabel(rootDocument, text, fullWidth) {
  const label = rootDocument.createElement("label");
  label.className = `htCheckboxRendererLabel ${fullWidth ? "fullWidth" : ""}`;
  label.appendChild(rootDocument.createTextNode(text));
  return label.cloneNode(true);
}
function onMouseUp(event, instance) {
  const {
    target
  } = event;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  setTimeout(instance.listen, 10);
}
function onClick(event, instance) {
  const {
    target
  } = event;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  const row = parseInt(target.getAttribute(ATTR_ROW), 10);
  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);
  const cellProperties = instance.getCellMeta(row, col);
  if (cellProperties.readOnly) {
    event.preventDefault();
  }
}
function onChange(event, instance) {
  const {
    target
  } = event;
  if (!isCheckboxInput(target)) {
    return;
  }
  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {
    return;
  }
  const row = parseInt(target.getAttribute(ATTR_ROW), 10);
  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);
  const cellProperties = instance.getCellMeta(row, col);
  if (!cellProperties.readOnly) {
    let newCheckboxValue = null;
    if (event.target.checked) {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? true : cellProperties.checkedTemplate;
    } else {
      newCheckboxValue = cellProperties.uncheckedTemplate === void 0 ? false : cellProperties.uncheckedTemplate;
    }
    instance.setDataAtCell(row, col, newCheckboxValue);
  }
}
function isCheckboxInput(element) {
  return element.tagName === "INPUT" && element.getAttribute("type") === "checkbox";
}

// node_modules/handsontable/cellTypes/checkboxType/checkboxType.mjs
var CELL_TYPE2 = "checkbox";
var CheckboxCellType = {
  CELL_TYPE: CELL_TYPE2,
  editor: CheckboxEditor,
  renderer: checkboxRenderer
};

// node_modules/handsontable/editors/dateEditor/dateEditor.mjs
init_moment();
var import_pikaday = __toESM(require_pikaday(), 1);
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var EDITOR_TYPE4 = "date";
var SHORTCUTS_GROUP_EDITOR = "dateEditor";
var DateEditor = class extends TextEditor {
  constructor() {
    super(...arguments);
    _defineProperty2(this, "defaultDateFormat", "DD/MM/YYYY");
    _defineProperty2(this, "isCellEdited", false);
    _defineProperty2(this, "parentDestroyed", false);
    _defineProperty2(this, "$datePicker", null);
  }
  static get EDITOR_TYPE() {
    return EDITOR_TYPE4;
  }
  init() {
    if (typeof moment_default !== "function") {
      throw new Error("You need to include moment.js to your project.");
    }
    if (typeof import_pikaday.default !== "function") {
      throw new Error("You need to include Pikaday to your project.");
    }
    super.init();
    this.hot.addHook("afterDestroy", () => {
      this.parentDestroyed = true;
      this.destroyElements();
    });
  }
  /**
   * Create data picker instance.
   */
  createElements() {
    super.createElements();
    this.datePicker = this.hot.rootDocument.createElement("DIV");
    this.datePickerStyle = this.datePicker.style;
    this.datePickerStyle.position = "absolute";
    this.datePickerStyle.top = 0;
    this.datePickerStyle.left = 0;
    this.datePickerStyle.zIndex = 9999;
    this.datePicker.setAttribute("dir", this.hot.isRtl() ? "rtl" : "ltr");
    addClass(this.datePicker, "htDatepickerHolder");
    this.hot.rootDocument.body.appendChild(this.datePicker);
    const eventManager = new eventManager_default(this);
    eventManager.addEventListener(this.datePicker, "mousedown", (event) => {
      if (hasClass(event.target, "pika-day")) {
        this.hideDatepicker();
      }
      event.stopPropagation();
    });
    eventManager.addEventListener(this.TEXTAREA, "keydown", (event) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.code)) {
        event.preventDefault();
      }
    });
  }
  /**
   * Destroy data picker instance.
   */
  destroyElements() {
    const datePickerParentElement = this.datePicker.parentNode;
    if (this.$datePicker) {
      this.$datePicker.destroy();
    }
    if (datePickerParentElement) {
      datePickerParentElement.removeChild(this.datePicker);
    }
  }
  /**
   * Prepare editor to appear.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
  }
  /**
   * Open editor.
   *
   * @param {Event} [event=null] The event object.
   */
  open() {
    let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    super.open();
    this.showDatepicker(event);
    editorContext.addShortcut({
      keys: [["Enter"]],
      callback: (keyboardEvent) => {
        keyboardEvent.stopPropagation();
      },
      group: SHORTCUTS_GROUP_EDITOR
    });
  }
  /**
   * Close editor.
   */
  close() {
    var _this$$datePicker;
    this._opened = false;
    if ((_this$$datePicker = this.$datePicker) !== null && _this$$datePicker !== void 0 && _this$$datePicker.destroy) {
      this.$datePicker.destroy();
    }
    this.hot._registerTimeout(() => {
      this.hot._refreshBorders();
    });
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);
    super.close();
  }
  /**
   * Finishes editing and start saving or restoring process for editing cell or last selected range.
   *
   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
   */
  finishEditing() {
    let restoreOriginalValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let ctrlDown = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (restoreOriginalValue) {
      const value = this.originalValue;
      if (value !== void 0) {
        this.setValue(value);
      }
    }
    super.finishEditing(restoreOriginalValue, ctrlDown);
  }
  /**
   * Show data picker.
   *
   * @param {Event} event The event object.
   */
  showDatepicker(event) {
    const offset2 = this.TD.getBoundingClientRect();
    const dateFormat = this.cellProperties.dateFormat || this.defaultDateFormat;
    const isMouseDown = this.hot.view.isMouseDown();
    const isMeta = event ? isFunctionKey(event.keyCode) : false;
    let dateStr;
    this.datePicker.style.display = "block";
    this.$datePicker = new import_pikaday.default(this.getDatePickerConfig());
    this.$datePicker._onInputFocus = function() {
    };
    this.datePickerStyle.top = `${this.hot.rootWindow.pageYOffset + offset2.top + outerHeight(this.TD)}px`;
    let pickerLeftPosition = this.hot.rootWindow.pageXOffset;
    if (this.hot.isRtl()) {
      pickerLeftPosition = offset2.right - outerWidth(this.datePicker);
    } else {
      pickerLeftPosition = offset2.left;
    }
    this.datePickerStyle.left = `${pickerLeftPosition}px`;
    if (this.originalValue) {
      dateStr = this.originalValue;
      if (moment_default(dateStr, dateFormat, true).isValid()) {
        this.$datePicker.setMoment(moment_default(dateStr, dateFormat), true);
      }
      if (this.getValue() !== this.originalValue) {
        this.setValue(this.originalValue);
      }
      if (!isMeta && !isMouseDown) {
        this.setValue("");
      }
    } else if (this.cellProperties.defaultDate) {
      dateStr = this.cellProperties.defaultDate;
      if (moment_default(dateStr, dateFormat, true).isValid()) {
        this.$datePicker.setMoment(moment_default(dateStr, dateFormat), true);
      }
      if (!isMeta && !isMouseDown) {
        this.setValue("");
      }
    } else {
      this.$datePicker.gotoToday();
    }
  }
  /**
   * Hide data picker.
   */
  hideDatepicker() {
    this.datePickerStyle.display = "none";
    this.$datePicker.hide();
  }
  /**
   * Get date picker options.
   *
   * @returns {object}
   */
  getDatePickerConfig() {
    const htInput = this.TEXTAREA;
    const options = {};
    if (this.cellProperties && this.cellProperties.datePickerConfig) {
      deepExtend(options, this.cellProperties.datePickerConfig);
    }
    const origOnSelect = options.onSelect;
    const origOnClose = options.onClose;
    options.field = htInput;
    options.trigger = htInput;
    options.container = this.datePicker;
    options.bound = false;
    options.format = options.format || this.defaultDateFormat;
    options.reposition = options.reposition || false;
    options.isRTL = false;
    options.onSelect = (value) => {
      let dateStr = value;
      if (!isNaN(dateStr.getTime())) {
        dateStr = moment_default(dateStr).format(this.cellProperties.dateFormat || this.defaultDateFormat);
      }
      this.setValue(dateStr);
      if (origOnSelect) {
        origOnSelect();
      }
    };
    options.onClose = () => {
      if (!this.parentDestroyed) {
        this.finishEditing(false);
      }
      if (origOnClose) {
        origOnClose();
      }
    };
    return options;
  }
};

// node_modules/handsontable/renderers/dateRenderer/dateRenderer.mjs
var RENDERER_TYPE4 = "date";
function dateRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  autocompleteRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);
}
dateRenderer.RENDERER_TYPE = RENDERER_TYPE4;

// node_modules/handsontable/validators/dateValidator/dateValidator.mjs
init_moment();

// node_modules/handsontable/helpers/date.mjs
function getNormalizedDate(dateString) {
  const nativeDate = new Date(dateString);
  if (!isNaN((/* @__PURE__ */ new Date(`${dateString}T00:00`)).getDate())) {
    return new Date(nativeDate.getTime() + nativeDate.getTimezoneOffset() * 6e4);
  }
  return nativeDate;
}

// node_modules/handsontable/validators/dateValidator/dateValidator.mjs
var VALIDATOR_TYPE2 = "date";
function dateValidator(value, callback) {
  const dateEditor = _getEditorInstance(EDITOR_TYPE4, this.instance);
  let valueToValidate = value;
  let valid = true;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  let isValidFormat = moment_default(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();
  let isValidDate = moment_default(new Date(valueToValidate)).isValid() || isValidFormat;
  if (this.allowEmpty && valueToValidate === "") {
    isValidDate = true;
    isValidFormat = true;
  }
  if (!isValidDate) {
    valid = false;
  }
  if (!isValidDate && isValidFormat) {
    valid = true;
  }
  if (isValidDate && !isValidFormat) {
    if (this.correctFormat === true) {
      const correctedValue = correctFormat(valueToValidate, this.dateFormat);
      const row = this.instance.toVisualRow(this.row);
      const column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "dateValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
dateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE2;
function correctFormat(value, dateFormat) {
  const dateFromDate = moment_default(getNormalizedDate(value));
  const dateFromMoment = moment_default(value, dateFormat);
  const isAlphanumeric = value.search(/[A-z]/g) > -1;
  let date;
  if (dateFromDate.isValid() && dateFromDate.format("x") === dateFromMoment.format("x") || !dateFromMoment.isValid() || isAlphanumeric) {
    date = dateFromDate;
  } else {
    date = dateFromMoment;
  }
  return date.format(dateFormat);
}

// node_modules/handsontable/cellTypes/dateType/dateType.mjs
var CELL_TYPE3 = "date";
var DateCellType = {
  CELL_TYPE: CELL_TYPE3,
  editor: DateEditor,
  // displays small gray arrow on right side of the cell
  renderer: dateRenderer,
  validator: dateValidator
};

// node_modules/handsontable/editors/dropdownEditor/dropdownEditor.mjs
var EDITOR_TYPE5 = "dropdown";
var DropdownEditor = class extends AutocompleteEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE5;
  }
  /**
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    this.cellProperties.filter = false;
    this.cellProperties.strict = true;
  }
};
pluginHooks_default.getSingleton().add("beforeValidate", function(value, row, col) {
  const cellMeta = this.getCellMeta(row, this.propToCol(col));
  if (cellMeta.editor === DropdownEditor) {
    if (cellMeta.strict === void 0) {
      cellMeta.filter = false;
      cellMeta.strict = true;
    }
  }
});

// node_modules/handsontable/cellTypes/dropdownType/dropdownType.mjs
var CELL_TYPE4 = "dropdown";
var DropdownCellType = {
  CELL_TYPE: CELL_TYPE4,
  editor: DropdownEditor,
  // displays small gray arrow on right side of the cell
  renderer: autocompleteRenderer,
  validator: autocompleteValidator
};

// node_modules/handsontable/renderers/handsontableRenderer/handsontableRenderer.mjs
var RENDERER_TYPE5 = "handsontable";
function handsontableRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  autocompleteRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);
}
handsontableRenderer.RENDERER_TYPE = RENDERER_TYPE5;

// node_modules/handsontable/cellTypes/handsontableType/handsontableType.mjs
var CELL_TYPE5 = "handsontable";
var HandsontableCellType = {
  CELL_TYPE: CELL_TYPE5,
  editor: HandsontableEditor,
  // displays small gray arrow on right side of the cell
  renderer: handsontableRenderer
};

// node_modules/handsontable/editors/numericEditor/numericEditor.mjs
var EDITOR_TYPE6 = "numeric";
var NumericEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE6;
  }
};

// node_modules/handsontable/renderers/numericRenderer/numericRenderer.mjs
var import_numbro = __toESM(require_numbro_min(), 1);
var RENDERER_TYPE6 = "numeric";
function numericRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  let newValue = value;
  if (isNumeric(newValue)) {
    const numericFormat = cellProperties.numericFormat;
    const cellCulture = numericFormat && numericFormat.culture || "-";
    const cellFormatPattern = numericFormat && numericFormat.pattern;
    const className = cellProperties.className || "";
    const classArr = className.length ? className.split(" ") : [];
    if (typeof cellCulture !== "undefined" && !import_numbro.default.languages()[cellCulture]) {
      const shortTag = cellCulture.replace("-", "");
      const langData = import_numbro.default.allLanguages ? import_numbro.default.allLanguages[cellCulture] : import_numbro.default[shortTag];
      if (langData) {
        import_numbro.default.registerLanguage(langData);
      }
    }
    import_numbro.default.setLanguage(cellCulture);
    newValue = (0, import_numbro.default)(newValue).format(cellFormatPattern || "0");
    if (classArr.indexOf("htLeft") < 0 && classArr.indexOf("htCenter") < 0 && classArr.indexOf("htRight") < 0 && classArr.indexOf("htJustify") < 0) {
      classArr.push("htRight");
    }
    if (classArr.indexOf("htNumeric") < 0) {
      classArr.push("htNumeric");
    }
    cellProperties.className = classArr.join(" ");
    TD.dir = "ltr";
  }
  textRenderer(hotInstance, TD, row, col, prop, newValue, cellProperties);
}
numericRenderer.RENDERER_TYPE = RENDERER_TYPE6;

// node_modules/handsontable/validators/numericValidator/numericValidator.mjs
var VALIDATOR_TYPE3 = "numeric";
function numericValidator(value, callback) {
  let valueToValidate = value;
  if (valueToValidate === null || valueToValidate === void 0) {
    valueToValidate = "";
  }
  if (this.allowEmpty && valueToValidate === "") {
    callback(true);
  } else if (valueToValidate === "") {
    callback(false);
  } else {
    callback(isNumeric(value));
  }
}
numericValidator.VALIDATOR_TYPE = VALIDATOR_TYPE3;

// node_modules/handsontable/cellTypes/numericType/numericType.mjs
var CELL_TYPE6 = "numeric";
var NumericCellType = {
  CELL_TYPE: CELL_TYPE6,
  editor: NumericEditor,
  renderer: numericRenderer,
  validator: numericValidator,
  dataType: "number"
};

// node_modules/handsontable/editors/passwordEditor/passwordEditor.mjs
var EDITOR_TYPE7 = "password";
var PasswordEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE7;
  }
  createElements() {
    super.createElements();
    this.TEXTAREA = this.hot.rootDocument.createElement("input");
    this.TEXTAREA.setAttribute("type", "password");
    this.TEXTAREA.setAttribute("data-hot-input", "");
    this.TEXTAREA.className = "handsontableInput";
    this.textareaStyle = this.TEXTAREA.style;
    this.textareaStyle.width = 0;
    this.textareaStyle.height = 0;
    if (this.hot.getSettings().ariaTags) {
      setAttribute(this.TEXTAREA, [A11Y_HIDDEN()]);
    }
    empty(this.TEXTAREA_PARENT);
    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
  }
};

// node_modules/handsontable/renderers/passwordRenderer/passwordRenderer.mjs
var RENDERER_TYPE7 = "password";
function passwordRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  textRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);
  const hashLength = cellProperties.hashLength || TD.innerHTML.length;
  const hashSymbol = cellProperties.hashSymbol || "*";
  let hash = "";
  rangeEach(hashLength - 1, () => {
    hash += hashSymbol;
  });
  fastInnerHTML(TD, hash);
}
passwordRenderer.RENDERER_TYPE = RENDERER_TYPE7;

// node_modules/handsontable/cellTypes/passwordType/passwordType.mjs
var CELL_TYPE7 = "password";
var PasswordCellType = {
  CELL_TYPE: CELL_TYPE7,
  editor: PasswordEditor,
  renderer: passwordRenderer,
  copyable: false
};

// node_modules/handsontable/editors/selectEditor/selectEditor.mjs
var EDITOR_VISIBLE_CLASS_NAME = "ht_editor_visible";
var SHORTCUTS_GROUP3 = "selectEditor";
var EDITOR_TYPE8 = "select";
var SelectEditor = class extends BaseEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE8;
  }
  /**
   * Initializes editor instance, DOM Element and mount hooks.
   */
  init() {
    this.select = this.hot.rootDocument.createElement("SELECT");
    addClass(this.select, "htSelectEditor");
    this.select.style.display = "none";
    this.hot.rootElement.appendChild(this.select);
    this.registerHooks();
  }
  /**
   * Returns select's value.
   *
   * @returns {*}
   */
  getValue() {
    return this.select.value;
  }
  /**
   * Sets value in the select element.
   *
   * @param {*} value A new select's value.
   */
  setValue(value) {
    this.select.value = value;
  }
  /**
   * Opens the editor and adjust its size.
   */
  open() {
    this._opened = true;
    this.refreshDimensions();
    this.select.style.display = "";
    const shortcutManager = this.hot.getShortcutManager();
    shortcutManager.setActiveContextName("editor");
    this.registerShortcuts();
  }
  /**
   * Closes the editor.
   */
  close() {
    this._opened = false;
    this.select.style.display = "none";
    if (hasClass(this.select, EDITOR_VISIBLE_CLASS_NAME)) {
      removeClass(this.select, EDITOR_VISIBLE_CLASS_NAME);
    }
    this.unregisterShortcuts();
    this.clearHooks();
  }
  /**
   * Sets focus state on the select element.
   */
  focus() {
    this.select.focus();
  }
  /**
   * Binds hooks to refresh editor's size after scrolling of the viewport or resizing of columns/rows.
   *
   * @private
   */
  registerHooks() {
    this.addHook("afterScrollHorizontally", () => this.refreshDimensions());
    this.addHook("afterScrollVertically", () => this.refreshDimensions());
    this.addHook("afterColumnResize", () => this.refreshDimensions());
    this.addHook("afterRowResize", () => this.refreshDimensions());
  }
  /**
   * Prepares editor's meta data and a list of available options.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    const selectOptions = this.cellProperties.selectOptions;
    let options;
    if (typeof selectOptions === "function") {
      options = this.prepareOptions(selectOptions(this.row, this.col, this.prop));
    } else {
      options = this.prepareOptions(selectOptions);
    }
    empty(this.select);
    objectEach(options, (optionValue, key) => {
      const optionElement = this.hot.rootDocument.createElement("OPTION");
      optionElement.value = key;
      fastInnerHTML(optionElement, optionValue);
      this.select.appendChild(optionElement);
    });
  }
  /**
   * Creates consistent list of available options.
   *
   * @private
   * @param {Array|object} optionsToPrepare The list of the values to render in the select eleemnt.
   * @returns {object}
   */
  prepareOptions(optionsToPrepare) {
    let preparedOptions = {};
    if (Array.isArray(optionsToPrepare)) {
      for (let i = 0, len = optionsToPrepare.length; i < len; i++) {
        preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
      }
    } else if (typeof optionsToPrepare === "object") {
      preparedOptions = optionsToPrepare;
    }
    return preparedOptions;
  }
  /**
   * Refreshes editor's value using source data.
   *
   * @private
   */
  refreshValue() {
    const sourceData = this.hot.getSourceDataAtCell(this.row, this.prop);
    this.originalValue = sourceData;
    this.setValue(sourceData);
    this.refreshDimensions();
  }
  /**
   * Refreshes editor's size and position.
   *
   * @private
   */
  refreshDimensions() {
    if (this.state !== EDITOR_STATE.EDITING) {
      return;
    }
    this.TD = this.getEditedCell();
    if (!this.TD) {
      this.close();
      return;
    }
    const {
      top,
      start,
      width,
      height
    } = this.getEditedCellRect();
    const selectStyle = this.select.style;
    selectStyle.height = `${height}px`;
    selectStyle.width = `${width}px`;
    selectStyle.top = `${top}px`;
    selectStyle[this.hot.isRtl() ? "right" : "left"] = `${start}px`;
    selectStyle.margin = "0px";
    addClass(this.select, EDITOR_VISIBLE_CLASS_NAME);
  }
  /**
   * Register shortcuts responsible for handling editor.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    const contextConfig = {
      group: SHORTCUTS_GROUP3
    };
    if (this.isInFullEditMode() === false) {
      return;
    }
    editorContext.addShortcuts([{
      keys: [["ArrowUp"]],
      callback: () => {
        const previousOptionIndex = this.select.selectedIndex - 1;
        if (previousOptionIndex >= 0) {
          this.select[previousOptionIndex].selected = true;
        }
      }
    }, {
      keys: [["ArrowDown"]],
      callback: () => {
        const nextOptionIndex = this.select.selectedIndex + 1;
        if (nextOptionIndex <= this.select.length - 1) {
          this.select[nextOptionIndex].selected = true;
        }
      }
    }], contextConfig);
  }
  /**
   * Unregister shortcuts responsible for handling editor.
   *
   * @private
   */
  unregisterShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP3);
  }
};

// node_modules/handsontable/renderers/selectRenderer/selectRenderer.mjs
var RENDERER_TYPE8 = "select";
function selectRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  textRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);
}
selectRenderer.RENDERER_TYPE = RENDERER_TYPE8;

// node_modules/handsontable/cellTypes/selectType/selectType.mjs
var CELL_TYPE8 = "select";
var SelectCellType = {
  CELL_TYPE: CELL_TYPE8,
  editor: SelectEditor,
  renderer: selectRenderer
};

// node_modules/handsontable/editors/timeEditor/timeEditor.mjs
var EDITOR_TYPE9 = "time";
var TimeEditor = class extends TextEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE9;
  }
  /**
   * Prepares editor's meta data.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    super.prepare(row, col, prop, td, value, cellProperties);
    this.TEXTAREA.dir = "ltr";
  }
};

// node_modules/handsontable/renderers/timeRenderer/timeRenderer.mjs
var RENDERER_TYPE9 = "time";
function timeRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {
  textRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);
  TD.dir = "ltr";
}
timeRenderer.RENDERER_TYPE = RENDERER_TYPE9;

// node_modules/handsontable/validators/timeValidator/timeValidator.mjs
init_moment();
var STRICT_FORMATS = [
  "YYYY-MM-DDTHH:mm:ss.SSSZ",
  "X",
  // Unix timestamp
  "x"
  // Unix ms timestamp
];
var VALIDATOR_TYPE4 = "time";
function timeValidator(value, callback) {
  const timeFormat = this.timeFormat || "h:mm:ss a";
  let valid = true;
  let valueToValidate = value;
  if (valueToValidate === null) {
    valueToValidate = "";
  }
  valueToValidate = /^\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;
  const twoDigitValue = /^\d{1,2}$/.test(valueToValidate);
  if (twoDigitValue) {
    valueToValidate += ":00";
  }
  const date = moment_default(valueToValidate, STRICT_FORMATS, true).isValid() ? moment_default(valueToValidate) : moment_default(valueToValidate, timeFormat);
  let isValidTime = date.isValid();
  let isValidFormat = moment_default(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;
  if (this.allowEmpty && valueToValidate === "") {
    isValidTime = true;
    isValidFormat = true;
  }
  if (!isValidTime) {
    valid = false;
  }
  if (!isValidTime && isValidFormat) {
    valid = true;
  }
  if (isValidTime && !isValidFormat) {
    if (this.correctFormat === true) {
      const correctedValue = date.format(timeFormat);
      const row = this.instance.toVisualRow(this.row);
      const column = this.instance.toVisualColumn(this.col);
      this.instance.setDataAtCell(row, column, correctedValue, "timeValidator");
      valid = true;
    } else {
      valid = false;
    }
  }
  callback(valid);
}
timeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE4;

// node_modules/handsontable/cellTypes/timeType/timeType.mjs
var CELL_TYPE9 = "time";
var TimeCellType = {
  CELL_TYPE: CELL_TYPE9,
  editor: TimeEditor,
  renderer: timeRenderer,
  validator: timeValidator
};

// node_modules/handsontable/cellTypes/index.mjs
function registerAllCellTypes() {
  _register(AutocompleteCellType);
  _register(CheckboxCellType);
  _register(DateCellType);
  _register(DropdownCellType);
  _register(HandsontableCellType);
  _register(NumericCellType);
  _register(PasswordCellType);
  _register(SelectCellType);
  _register(TextCellType);
  _register(TimeCellType);
}

export {
  HandsontableEditor,
  AutocompleteEditor,
  htmlRenderer,
  autocompleteRenderer,
  autocompleteValidator,
  CELL_TYPE,
  AutocompleteCellType,
  CheckboxEditor,
  checkboxRenderer,
  CELL_TYPE2,
  CheckboxCellType,
  DateEditor,
  dateValidator,
  CELL_TYPE3,
  DateCellType,
  DropdownEditor,
  CELL_TYPE4,
  DropdownCellType,
  CELL_TYPE5,
  HandsontableCellType,
  NumericEditor,
  numericRenderer,
  numericValidator,
  CELL_TYPE6,
  NumericCellType,
  PasswordEditor,
  passwordRenderer,
  CELL_TYPE7,
  PasswordCellType,
  SelectEditor,
  CELL_TYPE8,
  SelectCellType,
  TimeEditor,
  timeRenderer,
  timeValidator,
  CELL_TYPE9,
  TimeCellType,
  registerAllCellTypes
};
/*! Bundled license information:

pikaday/pikaday.js:
  (*!
   * Pikaday
   *
   * Copyright Â© 2014 David Bushell | BSD & MIT license | https://github.com/Pikaday/Pikaday
   *)
*/
//# sourceMappingURL=chunk-LVYWV57T.js.map
