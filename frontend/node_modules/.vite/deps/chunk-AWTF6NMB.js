import {
  getPluginsNames,
  hasPlugin,
  localHooks_default,
  transformSelectionToColumnDistance,
  transformSelectionToRowDistance
} from "./chunk-HDXMOYW4.js";
import {
  hasItem as hasItem4
} from "./chunk-34RLSBPA.js";
import {
  hasItem as hasItem3
} from "./chunk-4KUBBSOM.js";
import {
  hasItem,
  isIpadOS,
  isMobileBrowser,
  isWindowsOS
} from "./chunk-PJRC6Q4Z.js";
import {
  hasItem as hasItem2
} from "./chunk-FW2LINYA.js";
import {
  CONTEXTMENU_ITEMS_ALIGNMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM,
  CONTEXTMENU_ITEMS_ALIGNMENT_CENTER,
  CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY,
  CONTEXTMENU_ITEMS_ALIGNMENT_LEFT,
  CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE,
  CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT,
  CONTEXTMENU_ITEMS_ALIGNMENT_TOP,
  CONTEXTMENU_ITEMS_CLEAR_COLUMN,
  CONTEXTMENU_ITEMS_INSERT_LEFT,
  CONTEXTMENU_ITEMS_INSERT_RIGHT,
  CONTEXTMENU_ITEMS_NO_ITEMS,
  CONTEXTMENU_ITEMS_READ_ONLY,
  CONTEXTMENU_ITEMS_REDO,
  CONTEXTMENU_ITEMS_REMOVE_COLUMN,
  CONTEXTMENU_ITEMS_REMOVE_ROW,
  CONTEXTMENU_ITEMS_ROW_ABOVE,
  CONTEXTMENU_ITEMS_ROW_BELOW,
  CONTEXTMENU_ITEMS_UNDO
} from "./chunk-WNOSTPTO.js";
import {
  A11Y_DISABLED,
  A11Y_EXPANDED,
  A11Y_LABEL,
  A11Y_MENU,
  A11Y_MENU_ITEM,
  A11Y_TABINDEX,
  addClass,
  clamp,
  debounce,
  empty,
  eventManager_default,
  fastInnerHTML,
  getParentWindow,
  hasClass,
  isChildOf,
  isFunction,
  isRightClick,
  pluginHooks_default,
  setAttribute
} from "./chunk-IWTULMLB.js";
import {
  arrayEach,
  arrayFilter,
  arrayMap,
  arrayReduce,
  defineGetter,
  extend,
  hasOwnProperty,
  isDefined,
  isObject,
  isUndefined,
  mixin,
  objectEach,
  require_array_set_length,
  require_does_not_exceed_safe_integer,
  require_export,
  require_length_of_array_like,
  require_to_object,
  require_try_to_string
} from "./chunk-DSUKSR6K.js";
import {
  __commonJS
} from "./chunk-AUZ3RYOM.js";

// node_modules/core-js/internals/delete-property-or-throw.js
var require_delete_property_or_throw = __commonJS({
  "node_modules/core-js/internals/delete-property-or-throw.js"(exports, module) {
    "use strict";
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(O, P) {
      if (!delete O[P])
        throw new $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
    };
  }
});

// node_modules/handsontable/plugins/base/base.mjs
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var DEPS_TYPE_CHECKERS = /* @__PURE__ */ new Map([["plugin", hasPlugin], ["cell-type", hasItem4], ["editor", hasItem], ["renderer", hasItem2], ["validator", hasItem3]]);
var PLUGIN_KEY = "base";
var missingDepsMsgs = [];
var initializedPlugins = null;
var _hooks = /* @__PURE__ */ new WeakMap();
var _isRelevantToSettings = /* @__PURE__ */ new WeakSet();
var BasePlugin = class {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY;
  }
  /**
   * The `SETTING_KEYS` getter defines the keys that, when present in the config object, trigger the plugin update
   * after the `updateSettings` calls.
   * - When it returns `true`, the plugin updates after all `updateSettings` calls, regardless of the contents of the
   * config object.
   * - When it returns `false`, the plugin never updates on `updateSettings` calls.
   *
   * @returns {string[] | boolean}
   */
  static get SETTING_KEYS() {
    return [this.PLUGIN_KEY];
  }
  /**
   * The instance of the {@link EventManager} class.
   *
   * @type {EventManager}
   */
  /**
   * @param {object} hotInstance Handsontable instance.
   */
  constructor(hotInstance) {
    _classPrivateMethodInitSpec(this, _isRelevantToSettings);
    _defineProperty(this, "eventManager", new eventManager_default(this));
    _defineProperty(this, "pluginName", null);
    _defineProperty(this, "pluginsInitializedCallbacks", []);
    _defineProperty(this, "isPluginsReady", false);
    _defineProperty(this, "enabled", false);
    _defineProperty(this, "initialized", false);
    _classPrivateFieldInitSpec(this, _hooks, {
      writable: true,
      value: {}
    });
    defineGetter(this, "hot", hotInstance, {
      writable: false
    });
    initializedPlugins = null;
    this.hot.addHook("afterPluginsInitialized", () => this.onAfterPluginsInitialized());
    this.hot.addHook("afterUpdateSettings", (newSettings) => this.onUpdateSettings(newSettings));
    this.hot.addHook("beforeInit", () => this.init());
  }
  init() {
    this.pluginName = this.hot.getPluginName(this);
    const pluginDeps = this.constructor.PLUGIN_DEPS;
    const deps = Array.isArray(pluginDeps) ? pluginDeps : [];
    if (deps.length > 0) {
      const missingDependencies = [];
      deps.forEach((dependency) => {
        const [type, moduleName] = dependency.split(":");
        if (!DEPS_TYPE_CHECKERS.has(type)) {
          throw new Error(`Unknown plugin dependency type "${type}" was found.`);
        }
        if (!DEPS_TYPE_CHECKERS.get(type)(moduleName)) {
          missingDependencies.push(` - ${moduleName} (${type})`);
        }
      });
      if (missingDependencies.length > 0) {
        const errorMsg = [`The ${this.pluginName} plugin requires the following modules:
`, `${missingDependencies.join("\n")}
`].join("");
        missingDepsMsgs.push(errorMsg);
      }
    }
    if (!initializedPlugins) {
      initializedPlugins = getPluginsNames();
    }
    if (initializedPlugins.indexOf("UndoRedo") >= 0) {
      initializedPlugins.splice(initializedPlugins.indexOf("UndoRedo"), 1);
    }
    if (initializedPlugins.indexOf(this.pluginName) >= 0) {
      initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);
    }
    this.hot.addHookOnce("afterPluginsInitialized", () => {
      if (this.isEnabled && this.isEnabled()) {
        this.enablePlugin();
      }
    });
    const isAllPluginsAreInitialized = initializedPlugins.length === 0;
    if (isAllPluginsAreInitialized) {
      if (missingDepsMsgs.length > 0) {
        const errorMsg = [`${missingDepsMsgs.join("\n")}
`, "You have to import and register them manually."].join("");
        throw new Error(errorMsg);
      }
      this.hot.runHooks("afterPluginsInitialized");
    }
    this.initialized = true;
  }
  /**
   * Enable plugin for this Handsontable instance.
   */
  enablePlugin() {
    this.enabled = true;
  }
  /**
   * Disable plugin for this Handsontable instance.
   */
  disablePlugin() {
    var _this$eventManager;
    (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 || _this$eventManager.clear();
    this.clearHooks();
    this.enabled = false;
  }
  /**
   * Add listener to plugin hooks system.
   *
   * @param {string} name The hook name.
   * @param {Function} callback The listener function to add.
   */
  addHook(name, callback) {
    _classPrivateFieldGet(this, _hooks)[name] = _classPrivateFieldGet(this, _hooks)[name] || [];
    const hooks = _classPrivateFieldGet(this, _hooks)[name];
    this.hot.addHook(name, callback);
    hooks.push(callback);
    _classPrivateFieldGet(this, _hooks)[name] = hooks;
  }
  /**
   * Remove all hooks listeners by hook name.
   *
   * @param {string} name The hook name.
   */
  removeHooks(name) {
    arrayEach(_classPrivateFieldGet(this, _hooks)[name] || [], (callback) => {
      this.hot.removeHook(name, callback);
    });
  }
  /**
   * Clear all hooks.
   */
  clearHooks() {
    const hooks = _classPrivateFieldGet(this, _hooks);
    objectEach(hooks, (callbacks, name) => this.removeHooks(name));
    hooks.length = 0;
  }
  /**
   * Register function which will be immediately called after all plugins initialized.
   *
   * @param {Function} callback The listener function to call.
   */
  callOnPluginsReady(callback) {
    if (this.isPluginsReady) {
      callback();
    } else {
      this.pluginsInitializedCallbacks.push(callback);
    }
  }
  /**
   * On after plugins initialized listener.
   *
   * @private
   */
  onAfterPluginsInitialized() {
    arrayEach(this.pluginsInitializedCallbacks, (callback) => callback());
    this.pluginsInitializedCallbacks.length = 0;
    this.isPluginsReady = true;
  }
  /**
   * On update settings listener.
   *
   * @private
   * @param {object} newSettings New set of settings passed to the `updateSettings` method.
   */
  onUpdateSettings(newSettings) {
    const relevantToSettings = _classPrivateMethodGet(this, _isRelevantToSettings, _isRelevantToSettings2).call(this, newSettings);
    if (this.isEnabled) {
      if (this.enabled && !this.isEnabled()) {
        this.disablePlugin();
      }
      if (!this.enabled && this.isEnabled()) {
        this.enablePlugin();
      }
      if (this.enabled && this.isEnabled() && relevantToSettings) {
        this.updatePlugin(newSettings);
      }
    }
  }
  /**
   * Updates the plugin to use the latest options you have specified.
   *
   * @private
   */
  updatePlugin() {
  }
  /**
   * Destroy plugin.
   */
  destroy() {
    var _this$eventManager2;
    (_this$eventManager2 = this.eventManager) === null || _this$eventManager2 === void 0 || _this$eventManager2.destroy();
    this.clearHooks();
    objectEach(this, (value, property) => {
      if (property !== "hot") {
        this[property] = null;
      }
    });
    delete this.t;
    delete this.hot;
  }
};
function _isRelevantToSettings2(settings) {
  if (!settings) {
    return false;
  }
  const settingKeys = this.constructor.SETTING_KEYS;
  if (typeof settingKeys === "boolean") {
    return settingKeys;
  }
  for (let i = 0; i < settingKeys.length; i++) {
    if (settings[settingKeys[i]] !== void 0) {
      return true;
    }
  }
  return false;
}

// node_modules/core-js/modules/es.array.unshift.js
var $ = require_export();
var toObject = require_to_object();
var lengthOfArrayLike = require_length_of_array_like();
var setArrayLength = require_array_set_length();
var deletePropertyOrThrow = require_delete_property_or_throw();
var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
var INCORRECT_RESULT = [].unshift(0) !== 1;
var properErrorOnNonWritableLength = function() {
  try {
    Object.defineProperty([], "length", { writable: false }).unshift();
  } catch (error) {
    return error instanceof TypeError;
  }
};
var FORCED = INCORRECT_RESULT || !properErrorOnNonWritableLength();
$({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  unshift: function unshift(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    if (argCount) {
      doesNotExceedSafeInteger(len + argCount);
      var k = len;
      while (k--) {
        var to = k + argCount;
        if (k in O)
          O[to] = O[k];
        else
          deletePropertyOrThrow(O, to);
      }
      for (var j = 0; j < argCount; j++) {
        O[j] = arguments[j];
      }
    }
    return setArrayLength(O, len + argCount);
  }
});

// node_modules/handsontable/plugins/contextMenu/commandExecutor.mjs
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var CommandExecutor = class {
  constructor(hotInstance) {
    _defineProperty2(this, "hot", void 0);
    _defineProperty2(this, "commands", {});
    _defineProperty2(this, "commonCallback", null);
    this.hot = hotInstance;
  }
  /**
   * Register command.
   *
   * @param {string} name Command name.
   * @param {object} commandDescriptor Command descriptor object with properties like `key` (command id),
   *                                   `callback` (task to execute), `name` (command name), `disabled` (command availability).
   */
  registerCommand(name, commandDescriptor) {
    this.commands[name] = commandDescriptor;
  }
  /**
   * Set common callback which will be trigger on every executed command.
   *
   * @param {Function} callback Function which will be fired on every command execute.
   */
  setCommonCallback(callback) {
    this.commonCallback = callback;
  }
  /**
   * Execute command by its name.
   *
   * @param {string} commandName Command id.
   * @param {*} params Arguments passed to command task.
   */
  execute(commandName) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    const commandSplit = commandName.split(":");
    const commandNamePrimary = commandSplit[0];
    const subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;
    let command = this.commands[commandNamePrimary];
    if (!command) {
      throw new Error(`Menu command '${commandNamePrimary}' not exists.`);
    }
    if (subCommandName && command.submenu) {
      command = findSubCommand(subCommandName, command.submenu.items);
    }
    if (command.disabled === true) {
      return;
    }
    if (typeof command.disabled === "function" && command.disabled.call(this.hot) === true) {
      return;
    }
    if (hasOwnProperty(command, "submenu")) {
      return;
    }
    const callbacks = [];
    if (typeof command.callback === "function") {
      callbacks.push(command.callback);
    }
    if (typeof this.commonCallback === "function") {
      callbacks.push(this.commonCallback);
    }
    params.unshift(commandSplit.join(":"));
    arrayEach(callbacks, (callback) => callback.apply(this.hot, params));
  }
};
function findSubCommand(subCommandName, subCommands) {
  let command;
  arrayEach(subCommands, (cmd) => {
    const cmds = cmd.key ? cmd.key.split(":") : null;
    if (Array.isArray(cmds) && cmds[1] === subCommandName) {
      command = cmd;
      return false;
    }
  });
  return command;
}

// node_modules/handsontable/plugins/contextMenu/utils.mjs
function prepareVerticalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  const replacedClassName = className.replace("htTop", "").replace("htMiddle", "").replace("htBottom", "").replace("  ", "");
  return `${replacedClassName} ${alignment}`;
}
function prepareHorizontalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  const replacedClassName = className.replace("htLeft", "").replace("htCenter", "").replace("htRight", "").replace("htJustify", "").replace("  ", "");
  return `${replacedClassName} ${alignment}`;
}
function getAlignmentClasses(ranges, callback) {
  const classes = {};
  arrayEach(ranges, (range) => {
    range.forAll((row, col) => {
      if (row >= 0 && col >= 0) {
        if (!classes[row]) {
          classes[row] = [];
        }
        classes[row][col] = callback(row, col);
      }
    });
  });
  return classes;
}
function align(ranges, type, alignment, cellDescriptor, propertySetter) {
  arrayEach(ranges, (range) => {
    range.forAll((row, col) => {
      if (row >= 0 && col >= 0) {
        applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter);
      }
    });
  });
}
function applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter) {
  const cellMeta = cellDescriptor(row, col);
  let className = alignment;
  if (cellMeta.className) {
    if (type === "vertical") {
      className = prepareVerticalAlignClass(cellMeta.className, alignment);
    } else {
      className = prepareHorizontalAlignClass(cellMeta.className, alignment);
    }
  }
  propertySetter(row, col, "className", className);
}
function markLabelAsSelected(label) {
  return `<span class="selected">${String.fromCharCode(10003)}</span>${label}`;
}
function checkSelectionConsistency(ranges, comparator) {
  let result = false;
  if (Array.isArray(ranges)) {
    arrayEach(ranges, (range) => {
      range.forAll((row, col) => {
        if (row >= 0 && col >= 0 && comparator(row, col)) {
          result = true;
          return false;
        }
      });
      return result;
    });
  }
  return result;
}
function getDocumentOffsetByElement(elementToCheck, baseDocument) {
  const offset = {
    top: 0,
    left: 0
  };
  if (baseDocument !== elementToCheck.ownerDocument) {
    const {
      frameElement
    } = baseDocument.defaultView;
    const {
      top,
      left
    } = frameElement.getBoundingClientRect();
    offset.top = top;
    offset.left = left;
  }
  return offset;
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/separator.mjs
var KEY = "---------";
function separatorItem() {
  return {
    name: KEY
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/alignment.mjs
var KEY2 = "alignment";
function alignmentItem() {
  return {
    key: KEY2,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT);
    },
    disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());
    },
    submenu: {
      items: [{
        key: `${KEY2}:left`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htLeft") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htLeft";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:center`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htCenter") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htCenter";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:right`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htRight") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htRight";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:justify`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htJustify") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htJustify";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        name: KEY
      }, {
        key: `${KEY2}:top`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_TOP);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htTop") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htTop";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:middle`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htMiddle") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htMiddle";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:bottom`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htBottom") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htBottom";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }]
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/clearColumn.mjs
var KEY3 = "clear_column";
function clearColumnItem() {
  return {
    key: KEY3,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CLEAR_COLUMN);
    },
    callback(key, selection) {
      const startColumn = selection[0].start.col;
      const endColumn = selection[0].end.col;
      if (this.countRows()) {
        this.populateFromArray(0, startColumn, [[null]], Math.max(selection[0].start.row, selection[0].end.row), endColumn, "ContextMenu.clearColumn");
      }
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.col < 0) {
        return true;
      }
      return !this.selection.isSelectedByColumnHeader();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/columnLeft.mjs
var KEY4 = "col_left";
function columnLeftItem() {
  return {
    key: KEY4,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_LEFT);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopLeftCorner();
      const alterAction = this.isRtl() ? "insert_col_end" : "insert_col_start";
      this.alter(alterAction, latestSelection.col, 1, "ContextMenu.columnLeft");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.col < 0) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        const totalColumns = this.countCols();
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/columnRight.mjs
var KEY5 = "col_right";
function columnRightItem() {
  return {
    key: KEY5,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_RIGHT);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopRightCorner();
      const alterAction = this.isRtl() ? "insert_col_start" : "insert_col_end";
      this.alter(alterAction, latestSelection.col, 1, "ContextMenu.columnRight");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.col < 0) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/readOnly.mjs
var KEY6 = "make_read_only";
function readOnlyItem() {
  return {
    key: KEY6,
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY);
      const atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), (row, col) => this.getCellMeta(row, col).readOnly);
      if (atLeastOneReadOnly) {
        label = markLabelAsSelected(label);
      }
      return label;
    },
    callback() {
      const ranges = this.getSelectedRange();
      const atLeastOneReadOnly = checkSelectionConsistency(ranges, (row, col) => this.getCellMeta(row, col).readOnly);
      arrayEach(ranges, (range) => {
        range.forAll((row, col) => {
          if (row >= 0 && col >= 0) {
            this.setCellMeta(row, col, "readOnly", !atLeastOneReadOnly);
          }
        });
      });
      this.render();
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return true;
      }
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      if (!this.getSelectedRange() || this.getSelectedRange().length === 0) {
        return true;
      }
      return false;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/redo.mjs
var KEY7 = "redo";
function redoItem() {
  return {
    key: KEY7,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REDO);
    },
    callback() {
      this.redo();
    },
    hidden() {
      const undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled() {
      return !this.getPlugin("undoRedo").isRedoAvailable();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/removeColumn.mjs
var KEY8 = "remove_col";
function removeColumnItem() {
  return {
    key: KEY8,
    name() {
      const selection = this.getSelected();
      let pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          const [, fromColumn, , toColumn] = selection[0];
          if (fromColumn - toColumn !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COLUMN, pluralForm);
    },
    callback() {
      this.alter("remove_col", transformSelectionToColumnDistance(this), null, "ContextMenu.removeColumn");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.col < 0) {
        return true;
      }
      const totalColumns = this.countCols();
      if (this.selection.isSelectedByCorner()) {
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || totalColumns === 0;
    },
    hidden() {
      return !this.getSettings().allowRemoveColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/removeRow.mjs
var KEY9 = "remove_row";
function removeRowItem() {
  return {
    key: KEY9,
    name() {
      const selection = this.getSelected();
      let pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          const [fromRow, , toRow] = selection[0];
          if (fromRow - toRow !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_ROW, pluralForm);
    },
    callback() {
      this.alter("remove_row", transformSelectionToRowDistance(this), 1, "ContextMenu.removeRow");
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.row < 0) {
        return true;
      }
      const totalRows = this.countRows();
      if (this.selection.isSelectedByCorner()) {
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || totalRows === 0;
    },
    hidden() {
      return !this.getSettings().allowRemoveRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/rowAbove.mjs
var KEY10 = "row_above";
function rowAboveItem() {
  return {
    key: KEY10,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_ABOVE);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopLeftCorner();
      this.alter("insert_row_above", latestSelection.row, 1, "ContextMenu.rowAbove");
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.row < 0) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        const totalRows = this.countRows();
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/rowBelow.mjs
var KEY11 = "row_below";
function rowBelowItem() {
  return {
    key: KEY11,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_BELOW);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getBottomRightCorner();
      this.alter("insert_row_below", latestSelection.row, 1, "ContextMenu.rowBelow");
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.row < 0) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/noItems.mjs
var KEY12 = "no_items";
function noItemsItem() {
  return {
    key: KEY12,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NO_ITEMS);
    },
    disabled: true,
    isCommand: false
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/undo.mjs
var KEY13 = "undo";
function undoItem() {
  return {
    key: KEY13,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNDO);
    },
    callback() {
      this.undo();
    },
    hidden() {
      const undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled() {
      return !this.getPlugin("undoRedo").isUndoAvailable();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/index.mjs
var ITEMS = [KEY10, KEY11, KEY4, KEY5, KEY3, KEY9, KEY8, KEY13, KEY7, KEY6, KEY2, KEY, KEY12];
var _predefinedItems = {
  [KEY]: separatorItem,
  [KEY12]: noItemsItem,
  [KEY10]: rowAboveItem,
  [KEY11]: rowBelowItem,
  [KEY4]: columnLeftItem,
  [KEY5]: columnRightItem,
  [KEY3]: clearColumnItem,
  [KEY9]: removeRowItem,
  [KEY8]: removeColumnItem,
  [KEY13]: undoItem,
  [KEY7]: redoItem,
  [KEY6]: readOnlyItem,
  [KEY2]: alignmentItem
};
function predefinedItems() {
  const items = {};
  objectEach(_predefinedItems, (itemFactory, key) => {
    items[key] = itemFactory();
  });
  return items;
}

// node_modules/handsontable/plugins/contextMenu/itemsFactory.mjs
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive3(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var ItemsFactory = class {
  constructor(hotInstance) {
    let orderPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    _defineProperty3(this, "hot", void 0);
    _defineProperty3(this, "predefinedItems", predefinedItems());
    _defineProperty3(this, "defaultOrderPattern", void 0);
    this.hot = hotInstance;
    this.defaultOrderPattern = orderPattern;
  }
  /**
   * Set predefined items.
   *
   * @param {Array} predefinedItemsCollection Array of predefined items.
   */
  setPredefinedItems(predefinedItemsCollection) {
    const items = {};
    this.defaultOrderPattern.length = 0;
    objectEach(predefinedItemsCollection, (value, key) => {
      let menuItemKey = "";
      if (value.name === KEY) {
        items[KEY] = value;
        menuItemKey = KEY;
      } else if (isNaN(parseInt(key, 10))) {
        value.key = value.key === void 0 ? key : value.key;
        items[key] = value;
        menuItemKey = value.key;
      } else {
        items[value.key] = value;
        menuItemKey = value.key;
      }
      this.defaultOrderPattern.push(menuItemKey);
    });
    this.predefinedItems = items;
  }
  /**
   * Get all menu items based on pattern.
   *
   * @param {Array|object|boolean} pattern Pattern which you can define by displaying menu items order. If `true` default
   *                                       pattern will be used.
   * @returns {Array}
   */
  getItems() {
    let pattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return getItems(pattern, this.defaultOrderPattern, this.predefinedItems);
  }
};
function getItems() {
  let itemsPattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
  let defaultPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let items = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const result = [];
  let pattern = itemsPattern;
  if (pattern && pattern.items) {
    pattern = pattern.items;
  } else if (!Array.isArray(pattern)) {
    pattern = defaultPattern;
  }
  if (isObject(pattern)) {
    objectEach(pattern, (value, key) => {
      let item = items[typeof value === "string" ? value : key];
      if (!item) {
        item = value;
      }
      if (isObject(value)) {
        extend(item, value);
      } else if (typeof item === "string") {
        item = {
          name: item
        };
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  } else {
    arrayEach(pattern, (name, key) => {
      let item = items[name];
      if (!item && ITEMS.indexOf(name) >= 0) {
        return;
      }
      if (!item) {
        item = {
          name,
          key: `${key}`
        };
      }
      if (isObject(name)) {
        extend(item, name);
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  }
  return result;
}

// node_modules/handsontable/plugins/contextMenu/menu/cursor.mjs
function _defineProperty4(obj, key, value) {
  key = _toPropertyKey4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey4(arg) {
  var key = _toPrimitive4(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive4(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Cursor = class {
  constructor(object, rootWindow) {
    _defineProperty4(this, "top", void 0);
    _defineProperty4(this, "topRelative", void 0);
    _defineProperty4(this, "left", void 0);
    _defineProperty4(this, "leftRelative", void 0);
    _defineProperty4(this, "scrollTop", void 0);
    _defineProperty4(this, "scrollLeft", void 0);
    _defineProperty4(this, "cellHeight", void 0);
    _defineProperty4(this, "cellWidth", void 0);
    const windowScrollTop = rootWindow.scrollY;
    const windowScrollLeft = rootWindow.scrollX;
    let top;
    let topRelative;
    let left;
    let leftRelative;
    let cellHeight;
    let cellWidth;
    this.rootWindow = rootWindow;
    this.type = this.getSourceType(object);
    if (this.type === "literal") {
      top = parseInt(object.top, 10);
      left = parseInt(object.left, 10);
      cellHeight = object.height || 0;
      cellWidth = object.width || 0;
      topRelative = top;
      leftRelative = left;
      top += windowScrollTop;
      left += windowScrollLeft;
    } else if (this.type === "event") {
      top = parseInt(object.pageY, 10);
      left = parseInt(object.pageX, 10);
      cellHeight = object.target.clientHeight;
      cellWidth = object.target.clientWidth;
      topRelative = top - windowScrollTop;
      leftRelative = left - windowScrollLeft;
    }
    this.top = top;
    this.topRelative = topRelative;
    this.left = left;
    this.leftRelative = leftRelative;
    this.scrollTop = windowScrollTop;
    this.scrollLeft = windowScrollLeft;
    this.cellHeight = cellHeight;
    this.cellWidth = cellWidth;
  }
  /**
   * Get source type name.
   *
   * @param {*} object Event or Object with coordinates.
   * @returns {string} Returns one of this values: `'literal'`, `'event'`.
   */
  getSourceType(object) {
    let type = "literal";
    if (object instanceof Event) {
      type = "event";
    }
    return type;
  }
  /**
   * Checks if element can be placed above the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit above the cursor.
   * @returns {boolean}
   */
  fitsAbove(element) {
    return this.topRelative >= element.offsetHeight;
  }
  /**
   * Checks if element can be placed below the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit below the cursor.
   * @param {number} [viewportHeight] The viewport height.
   * @returns {boolean}
   */
  fitsBelow(element) {
    let viewportHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerHeight;
    return this.topRelative + element.offsetHeight <= viewportHeight;
  }
  /**
   * Checks if element can be placed on the right of the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit on the right of the cursor.
   * @param {number} [viewportWidth] The viewport width.
   * @returns {boolean}
   */
  fitsOnRight(element) {
    let viewportWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerWidth;
    return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;
  }
  /**
   * Checks if element can be placed on the left on the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit on the left of the cursor.
   * @returns {boolean}
   */
  fitsOnLeft(element) {
    return this.leftRelative >= element.offsetWidth;
  }
};

// node_modules/handsontable/plugins/contextMenu/menu/positioner.mjs
function _classPrivateFieldInitSpec2(obj, privateMap, value) {
  _checkPrivateRedeclaration2(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration2(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet2(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
  return _classApplyDescriptorGet2(receiver, descriptor);
}
function _classApplyDescriptorGet2(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor2(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _container = /* @__PURE__ */ new WeakMap();
var _parentContainer = /* @__PURE__ */ new WeakMap();
var _cursor = /* @__PURE__ */ new WeakMap();
var _keepInViewport = /* @__PURE__ */ new WeakMap();
var _offset = /* @__PURE__ */ new WeakMap();
var Positioner = class {
  constructor(keepInViewport) {
    _classPrivateFieldInitSpec2(this, _container, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec2(this, _parentContainer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec2(this, _cursor, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec2(this, _keepInViewport, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec2(this, _offset, {
      writable: true,
      value: {
        above: 0,
        below: 0,
        left: 0,
        right: 0
      }
    });
    _classPrivateFieldSet(this, _keepInViewport, keepInViewport);
  }
  /**
   * Sets offset position for specified directions (`above`, `below`, `left` or `right`).
   *
   * @param {'above' | 'below' | 'left' | 'right'} direction A direction name.
   * @param {number} [offset=0] Offset value.
   * @returns {Positioner}
   */
  setOffset(direction) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    _classPrivateFieldGet2(this, _offset)[direction] = offset;
    return this;
  }
  /**
   * Sets the menu element to work with. The element can be owned by the main menu or the submenu.
   *
   * @param {HTMLElement} container The menu container element.
   * @returns {Positioner}
   */
  setElement(container) {
    _classPrivateFieldSet(this, _container, container);
    return this;
  }
  /**
   * Sets the parent menu element to work with.
   *
   * @param {HTMLElement} container The parent menu container element.
   * @returns {Positioner}
   */
  setParentElement(container) {
    _classPrivateFieldSet(this, _parentContainer, container);
    return this;
  }
  /**
   * Updates the menu position.
   *
   * @param {object|MouseEvent} coords The literal object with `top`, `left`, `width` and `height` props or a
   * mouse event object.
   */
  updatePosition(coords) {
    _classPrivateFieldSet(this, _cursor, new Cursor(coords, _classPrivateFieldGet2(this, _container).ownerDocument.defaultView));
    if (_classPrivateFieldGet2(this, _keepInViewport)) {
      if (_classPrivateFieldGet2(this, _cursor).fitsBelow(_classPrivateFieldGet2(this, _container))) {
        this.setPositionBelowCursor();
      } else if (_classPrivateFieldGet2(this, _cursor).fitsAbove(_classPrivateFieldGet2(this, _container))) {
        this.setPositionAboveCursor();
      } else {
        this.setPositionBelowCursor();
      }
      this.updateHorizontalPosition();
    } else {
      this.setPositionBelowCursor();
      this.setPositionOnRightOfCursor();
    }
  }
  /**
   * Updates the menu horizontal position.
   */
  updateHorizontalPosition() {
    if (_classPrivateFieldGet2(this, _container).dir === "rtl") {
      if (_classPrivateFieldGet2(this, _cursor).fitsOnLeft(_classPrivateFieldGet2(this, _container))) {
        this.setPositionOnLeftOfCursor();
      } else {
        this.setPositionOnRightOfCursor();
      }
    } else if (_classPrivateFieldGet2(this, _cursor).fitsOnRight(_classPrivateFieldGet2(this, _container))) {
      this.setPositionOnRightOfCursor();
    } else {
      this.setPositionOnLeftOfCursor();
    }
  }
  /**
   * Sets the menu position above the cursor object.
   */
  setPositionAboveCursor() {
    let top = _classPrivateFieldGet2(this, _offset).above + _classPrivateFieldGet2(this, _cursor).top - _classPrivateFieldGet2(this, _container).offsetHeight;
    if (_classPrivateFieldGet2(this, _parentContainer)) {
      top = _classPrivateFieldGet2(this, _cursor).top + _classPrivateFieldGet2(this, _cursor).cellHeight - _classPrivateFieldGet2(this, _container).offsetHeight + 3;
    }
    _classPrivateFieldGet2(this, _container).style.top = `${top}px`;
  }
  /**
   * Sets the menu position below the cursor object.
   */
  setPositionBelowCursor() {
    let top = _classPrivateFieldGet2(this, _offset).below + _classPrivateFieldGet2(this, _cursor).top + 1;
    if (_classPrivateFieldGet2(this, _parentContainer)) {
      top = _classPrivateFieldGet2(this, _cursor).top - 1;
    }
    _classPrivateFieldGet2(this, _container).style.top = `${top}px`;
  }
  /**
   * Sets the menu position on the right of the cursor object.
   */
  setPositionOnRightOfCursor() {
    let left = _classPrivateFieldGet2(this, _cursor).left;
    if (_classPrivateFieldGet2(this, _parentContainer)) {
      const {
        right: parentMenuRight
      } = _classPrivateFieldGet2(this, _parentContainer).getBoundingClientRect();
      left += _classPrivateFieldGet2(this, _cursor).cellWidth + parentMenuRight - (_classPrivateFieldGet2(this, _cursor).left + _classPrivateFieldGet2(this, _cursor).cellWidth);
    } else {
      left += _classPrivateFieldGet2(this, _offset).right;
    }
    _classPrivateFieldGet2(this, _container).style.left = `${left}px`;
  }
  /**
   * Sets the menu position on the left of the cursor object.
   */
  setPositionOnLeftOfCursor() {
    let left = _classPrivateFieldGet2(this, _offset).left + _classPrivateFieldGet2(this, _cursor).left - _classPrivateFieldGet2(this, _container).offsetWidth;
    if (_classPrivateFieldGet2(this, _parentContainer)) {
      const {
        left: parentMenuLeft
      } = _classPrivateFieldGet2(this, _parentContainer).getBoundingClientRect();
      left -= _classPrivateFieldGet2(this, _cursor).left - parentMenuLeft;
    }
    _classPrivateFieldGet2(this, _container).style.left = `${left}px`;
  }
};

// node_modules/handsontable/utils/paginator.mjs
function createPaginator(_ref) {
  let {
    initialPage = -1,
    size = () => 0,
    onItemSelect = () => {
    },
    onClear = () => {
    }
  } = _ref;
  const visitedPages = /* @__PURE__ */ new Set();
  let currentIndex = clamp(initialPage, -1, getSize() - 1);
  function _updateState(newIndex, direction) {
    const lastIndex = getSize() - 1;
    if (newIndex < 0) {
      newIndex = lastIndex;
    }
    if (newIndex > lastIndex) {
      newIndex = 0;
    }
    if (visitedPages.has(newIndex)) {
      return -1;
    }
    visitedPages.add(newIndex);
    const changeProceed = onItemSelect(newIndex, false);
    if (changeProceed === false) {
      newIndex = _updateState(
        direction === 1 ? ++newIndex : --newIndex,
        // eslint-disable-line no-plusplus
        direction
      );
    }
    return newIndex;
  }
  function setCurrentPage(index) {
    if (index > -1 && index < getSize() && onItemSelect(index, true) !== false) {
      currentIndex = index;
    }
  }
  function getCurrentPage() {
    return currentIndex;
  }
  function toFirstItem() {
    if (getSize() > 0) {
      visitedPages.clear();
      currentIndex = _updateState(0, 1);
    }
  }
  function toLastItem() {
    if (getSize() > 0) {
      visitedPages.clear();
      currentIndex = _updateState(getSize() - 1, -1);
    }
  }
  function toNextItem() {
    if (getSize() > 0) {
      visitedPages.clear();
      currentIndex = _updateState(++currentIndex, 1);
    }
  }
  function toPreviousItem() {
    if (getSize() > 0) {
      visitedPages.clear();
      currentIndex = _updateState(--currentIndex, -1);
    }
  }
  function getSize() {
    return Math.max(size(), 0);
  }
  function clear() {
    visitedPages.clear();
    currentIndex = initialPage;
    onClear();
  }
  return {
    setCurrentPage,
    getCurrentPage,
    toFirstItem,
    toLastItem,
    toNextItem,
    toPreviousItem,
    getSize,
    clear
  };
}

// node_modules/handsontable/plugins/contextMenu/menu/utils.mjs
function normalizeSelection(selRanges) {
  return arrayMap(selRanges, (range) => ({
    start: range.getTopStartCorner(),
    end: range.getBottomEndCorner()
  }));
}
function isItemSubMenu(itemToTest) {
  return hasOwnProperty(itemToTest, "submenu");
}
function isItemSeparator(itemToTest) {
  return new RegExp(KEY, "i").test(itemToTest.name);
}
function isItemDisabled(itemToTest, hot) {
  return itemToTest.disabled === true || typeof itemToTest.disabled === "function" && itemToTest.disabled.call(hot) === true;
}
function isItemSelectionDisabled(itemToTest) {
  return hasOwnProperty(itemToTest, "disableSelection");
}
function isSeparator(cell) {
  return hasClass(cell, "htSeparator");
}
function hasSubMenu(cell) {
  return hasClass(cell, "htSubmenu");
}
function isDisabled(cell) {
  return hasClass(cell, "htDisabled");
}
function isSelectionDisabled(cell) {
  return hasClass(cell, "htSelectionDisabled");
}
function isItemHidden(item, instance) {
  return !item.hidden || !(typeof item.hidden === "function" && item.hidden.call(instance));
}
function shiftSeparators(items, separator) {
  const result = items.slice(0);
  for (let i = 0; i < result.length; ) {
    if (result[i].name === separator) {
      result.shift();
    } else {
      break;
    }
  }
  return result;
}
function popSeparators(items, separator) {
  let result = items.slice(0);
  result.reverse();
  result = shiftSeparators(result, separator);
  result.reverse();
  return result;
}
function removeDuplicatedSeparators(items) {
  const result = [];
  arrayEach(items, (value, index) => {
    if (index > 0) {
      if (result[result.length - 1].name !== value.name) {
        result.push(value);
      }
    } else {
      result.push(value);
    }
  });
  return result;
}
function filterSeparators(items) {
  let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : KEY;
  let result = items.slice(0);
  result = shiftSeparators(result, separator);
  result = popSeparators(result, separator);
  result = removeDuplicatedSeparators(result);
  return result;
}

// node_modules/handsontable/plugins/contextMenu/menu/navigator.mjs
function createMenuNavigator(hotMenu) {
  return createPaginator({
    size: () => hotMenu.countRows(),
    onItemSelect(currentItem, directItemChange) {
      const cell = hotMenu.getCell(currentItem, 0);
      if (!cell || isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        return false;
      }
      hotMenu.selectCell(currentItem, 0, ...directItemChange ? [currentItem, 0, false, false] : []);
    },
    onClear() {
      hotMenu.deselectCell();
    }
  });
}

// node_modules/handsontable/plugins/contextMenu/menu/defaultShortcutsList.mjs
function createDefaultShortcutsList(menu) {
  return [{
    keys: [["Tab"], ["Shift", "Tab"], ["Control/Meta", "A"]],
    forwardToContext: menu.hot.getShortcutManager().getContext("grid"),
    callback: () => menu.close(true)
  }, {
    keys: [["Escape"]],
    callback: () => menu.close()
  }, {
    keys: [["ArrowDown"]],
    callback: () => menu.getNavigator().toNextItem()
  }, {
    keys: [["ArrowUp"]],
    callback: () => menu.getNavigator().toPreviousItem()
  }, {
    keys: [["ArrowRight"]],
    callback: () => {
      const selection = menu.hotMenu.getSelectedLast();
      if (selection) {
        const subMenu = menu.openSubMenu(selection[0]);
        if (subMenu) {
          subMenu.getNavigator().toFirstItem();
        }
      }
    }
  }, {
    keys: [["ArrowLeft"]],
    callback: () => {
      const selection = menu.hotMenu.getSelectedLast();
      if (selection && menu.isSubMenu()) {
        menu.close();
        if (menu.isSubMenu()) {
          menu.parentMenu.hotMenu.listen();
        }
      }
    }
  }, {
    keys: [["Control/Meta", "ArrowUp"], ["Home"]],
    callback: () => menu.getNavigator().toFirstItem()
  }, {
    keys: [["Control/Meta", "ArrowDown"], ["End"]],
    callback: () => menu.getNavigator().toLastItem()
  }, {
    keys: [["Enter"], ["Space"]],
    callback: (event) => {
      const selection = menu.hotMenu.getSelectedLast();
      if (!selection) {
        return;
      }
      if (menu.hotMenu.getSourceDataAtRow(selection[0]).submenu) {
        menu.openSubMenu(selection[0]).getNavigator().toFirstItem();
      } else {
        menu.executeCommand(event);
        menu.close(true);
      }
    }
  }, {
    keys: [["PageUp"]],
    callback: () => {
      const selection = menu.hotMenu.getSelectedLast();
      if (selection) {
        menu.hotMenu.selection.transformStart(-menu.hotMenu.countVisibleRows(), 0);
      } else {
        menu.getNavigator().toFirstItem();
      }
    }
  }, {
    keys: [["PageDown"]],
    callback: () => {
      const selection = menu.hotMenu.getSelectedLast();
      if (selection) {
        menu.hotMenu.selection.transformStart(menu.hotMenu.countVisibleRows(), 0);
      } else {
        menu.getNavigator().toLastItem();
      }
    }
  }];
}

// node_modules/handsontable/plugins/contextMenu/menu/shortcuts.mjs
var SHORTCUTS_CONTEXT = "menu";
var SHORTCUTS_GROUP = SHORTCUTS_CONTEXT;
function createKeyboardShortcutsCtrl(menu) {
  let customKeyboardShortcuts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const customShortcuts = [];
  _addShortcuts(createDefaultShortcutsList(menu));
  customKeyboardShortcuts.forEach((_ref) => {
    let {
      shortcuts,
      contextName
    } = _ref;
    addCustomShortcuts(shortcuts, contextName);
  });
  function _addShortcuts(shortcuts, contextName) {
    getContext(contextName).addShortcuts(shortcuts, {
      group: SHORTCUTS_CONTEXT
    });
  }
  function addCustomShortcuts(shortcuts, contextName) {
    const context = getContext(contextName);
    shortcuts.forEach((_ref2) => {
      let {
        keys
      } = _ref2;
      keys.forEach((k) => context.removeShortcutsByKeys(k));
    });
    customShortcuts.push({
      shortcuts,
      contextName
    });
    _addShortcuts(shortcuts, contextName);
  }
  function getCustomShortcuts() {
    return [...customShortcuts];
  }
  function _getContextName(contextName) {
    return contextName ? `${SHORTCUTS_GROUP}:${contextName}` : SHORTCUTS_GROUP;
  }
  function getContext(contextName) {
    var _manager$getContext;
    const manager = menu.hotMenu.getShortcutManager();
    const name = _getContextName(contextName);
    return (_manager$getContext = manager.getContext(name)) !== null && _manager$getContext !== void 0 ? _manager$getContext : manager.addContext(name);
  }
  function listen(contextName) {
    menu.hotMenu.getShortcutManager().setActiveContextName(_getContextName(contextName));
  }
  return {
    addCustomShortcuts,
    getCustomShortcuts,
    getContext,
    listen
  };
}

// node_modules/handsontable/plugins/contextMenu/menu/menuItemRenderer.mjs
function createMenuItemRenderer(mainTableHot) {
  return (menuHot, TD, row, col, prop, value) => {
    if (TD.hasAttribute("ghost-table")) {
      return;
    }
    const item = menuHot.getSourceDataAtRow(row);
    const wrapper = mainTableHot.rootDocument.createElement("div");
    const itemValue = typeof value === "function" ? value.call(mainTableHot) : value;
    empty(TD);
    addClass(wrapper, "htItemWrapper");
    if (mainTableHot.getSettings().ariaTags) {
      const isFocusable = !isItemDisabled(item, mainTableHot) && !isItemSelectionDisabled(item) && !isItemSeparator(item);
      setAttribute(TD, [A11Y_MENU_ITEM(), A11Y_LABEL(itemValue), ...isFocusable ? [A11Y_TABINDEX(-1)] : [], ...isItemDisabled(item, mainTableHot) ? [A11Y_DISABLED()] : [], ...isItemSubMenu(item) ? [A11Y_EXPANDED(false)] : []]);
    }
    TD.className = "";
    TD.appendChild(wrapper);
    if (isItemSeparator(item)) {
      addClass(TD, "htSeparator");
    } else if (typeof item.renderer === "function") {
      addClass(TD, "htCustomMenuRenderer");
      TD.appendChild(item.renderer(menuHot, wrapper, row, col, prop, itemValue));
    } else {
      fastInnerHTML(wrapper, itemValue);
    }
    if (isItemDisabled(item, mainTableHot)) {
      addClass(TD, "htDisabled");
    } else if (isItemSelectionDisabled(item)) {
      addClass(TD, "htSelectionDisabled");
    } else if (isItemSubMenu(item)) {
      addClass(TD, "htSubmenu");
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/menu/menu.mjs
function _classPrivateFieldInitSpec3(obj, privateMap, value) {
  _checkPrivateRedeclaration3(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration3(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty5(obj, key, value) {
  key = _toPropertyKey5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey5(arg) {
  var key = _toPrimitive5(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive5(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldSet2(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "set");
  _classApplyDescriptorSet2(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet2(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet3(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "get");
  return _classApplyDescriptorGet3(receiver, descriptor);
}
function _classExtractFieldDescriptor3(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet3(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var MIN_WIDTH = 215;
var _navigator = /* @__PURE__ */ new WeakMap();
var _shortcutsCtrl = /* @__PURE__ */ new WeakMap();
var Menu = class _Menu {
  /**
   * @param {Core} hotInstance Handsontable instance.
   * @param {MenuOptions} [options] Menu options.
   */
  constructor(hotInstance, options) {
    var _this = this;
    _defineProperty5(this, "hot", void 0);
    _defineProperty5(this, "options", void 0);
    _defineProperty5(this, "eventManager", new eventManager_default(this));
    _defineProperty5(this, "container", void 0);
    _defineProperty5(this, "positioner", void 0);
    _defineProperty5(this, "hotMenu", null);
    _defineProperty5(this, "hotSubMenus", {});
    _defineProperty5(this, "parentMenu", void 0);
    _defineProperty5(this, "menuItems", null);
    _defineProperty5(this, "origOutsideClickDeselects", null);
    _classPrivateFieldInitSpec3(this, _navigator, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec3(this, _shortcutsCtrl, {
      writable: true,
      value: void 0
    });
    this.hot = hotInstance;
    this.options = options || {
      parent: null,
      name: null,
      className: "",
      keepInViewport: true,
      standalone: false,
      minWidth: MIN_WIDTH,
      container: this.hot.rootDocument.documentElement
    };
    this.container = this.createContainer(this.options.name);
    this.positioner = new Positioner(this.options.keepInViewport);
    this.parentMenu = this.options.parent || null;
    this.registerEvents();
    if (this.isSubMenu()) {
      this.addLocalHook("afterSelectionChange", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _this.parentMenu.runLocalHooks("afterSelectionChange", ...args);
      });
    }
  }
  /**
   * Register event listeners.
   *
   * @private
   */
  registerEvents() {
    let frame = this.hot.rootWindow;
    while (frame) {
      this.eventManager.addEventListener(frame.document, "mousedown", (event) => this.onDocumentMouseDown(event));
      this.eventManager.addEventListener(frame.document, "contextmenu", (event) => this.onDocumentContextMenu(event));
      frame = getParentWindow(frame);
    }
  }
  /**
   * Set array of objects which defines menu items.
   *
   * @param {Array} menuItems Menu items to display.
   */
  setMenuItems(menuItems) {
    this.menuItems = menuItems;
  }
  /**
   * Gets the controller object that allows modifying the the menu item selection.
   *
   * @returns {Paginator | undefined}
   */
  getNavigator() {
    return _classPrivateFieldGet3(this, _navigator);
  }
  /**
   * Gets the controller object that allows extending the keyboard shortcuts of the menu.
   *
   * @returns {KeyboardShortcutsMenuController | undefined}
   */
  getKeyboardShortcutsCtrl() {
    return _classPrivateFieldGet3(this, _shortcutsCtrl);
  }
  /**
   * Returns currently selected menu item. Returns `null` if no item was selected.
   *
   * @returns {object|null}
   */
  getSelectedItem() {
    return this.hasSelectedItem() ? this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelectedLast()[0]) : null;
  }
  /**
   * Checks if the menu has selected (highlighted) any item from the menu list.
   *
   * @returns {boolean}
   */
  hasSelectedItem() {
    return Array.isArray(this.hotMenu.getSelectedLast());
  }
  /**
   * Check if menu is using as sub-menu.
   *
   * @returns {boolean}
   */
  isSubMenu() {
    return this.parentMenu !== null;
  }
  /**
   * Open menu.
   *
   * @fires Hooks#beforeContextMenuShow
   * @fires Hooks#afterContextMenuShow
   */
  open() {
    this.runLocalHooks("beforeOpen");
    this.container.removeAttribute("style");
    this.container.style.display = "block";
    const delayedOpenSubMenu = debounce((row) => this.openSubMenu(row), 300);
    const minWidthOfMenu = this.options.minWidth || MIN_WIDTH;
    let noItemsDefined = false;
    let filteredItems = arrayFilter(this.menuItems, (item) => {
      if (item.key === KEY12) {
        noItemsDefined = true;
      }
      return isItemHidden(item, this.hot);
    });
    if (filteredItems.length < 1 && !noItemsDefined) {
      filteredItems.push(predefinedItems()[KEY12]);
    } else if (filteredItems.length === 0) {
      return;
    }
    filteredItems = filterSeparators(filteredItems, KEY);
    let shouldAutoCloseMenu = false;
    const settings = {
      data: filteredItems,
      colHeaders: false,
      autoColumnSize: true,
      autoWrapRow: false,
      modifyColWidth(width) {
        if (isDefined(width) && width < minWidthOfMenu) {
          return minWidthOfMenu;
        }
        return width;
      },
      autoRowSize: false,
      readOnly: true,
      editor: false,
      copyPaste: false,
      hiddenRows: true,
      maxCols: 1,
      columns: [{
        data: "name",
        renderer: createMenuItemRenderer(this.hot)
      }],
      renderAllRows: true,
      fragmentSelection: false,
      outsideClickDeselects: false,
      disableVisualSelection: "area",
      layoutDirection: this.hot.isRtl() ? "rtl" : "ltr",
      ariaTags: false,
      beforeOnCellMouseOver: (event, coords) => {
        _classPrivateFieldGet3(this, _navigator).setCurrentPage(coords.row);
      },
      afterOnCellMouseOver: (event, coords) => {
        if (this.isAllSubMenusClosed()) {
          delayedOpenSubMenu(coords.row);
        } else {
          this.openSubMenu(coords.row);
        }
      },
      rowHeights: (row) => filteredItems[row].name === KEY ? 1 : 23,
      afterOnCellContextMenu: (event) => {
        event.preventDefault();
        if (isWindowsOS() && shouldAutoCloseMenu && this.hasSelectedItem()) {
          this.close(true);
        }
      },
      afterSelection: (row, column, row2, column2, preventScrolling) => {
        if (this.hotMenu.view.isMouseDown()) {
          preventScrolling.value = true;
        }
        this.runLocalHooks("afterSelectionChange", this.getSelectedItem());
      },
      beforeOnCellMouseUp: (event) => {
        if (this.hasSelectedItem()) {
          shouldAutoCloseMenu = !this.isCommandPassive(this.getSelectedItem());
          this.executeCommand(event);
        }
      },
      afterOnCellMouseUp: (event) => {
        if ((!isWindowsOS() || !isRightClick(event)) && shouldAutoCloseMenu && this.hasSelectedItem()) {
          if (isMobileBrowser() || isIpadOS()) {
            this.hot._registerTimeout(() => this.close(true), 325);
          } else {
            this.close(true);
          }
        }
      },
      afterUnlisten: () => {
        if (!this.hasSelectedItem() && this.isOpened()) {
          this.hotMenu.listen();
        }
      }
    };
    this.origOutsideClickDeselects = this.hot.getSettings().outsideClickDeselects;
    this.hot.getSettings().outsideClickDeselects = false;
    this.hotMenu = new this.hot.constructor(this.container, settings);
    this.hotMenu.addHook("afterInit", () => this.onAfterInit());
    this.hotMenu.init();
    _classPrivateFieldSet2(this, _navigator, createMenuNavigator(this.hotMenu));
    _classPrivateFieldSet2(this, _shortcutsCtrl, createKeyboardShortcutsCtrl(this));
    _classPrivateFieldGet3(this, _shortcutsCtrl).listen();
    this.focus();
    if (this.isSubMenu()) {
      this.addLocalHook("afterOpen", () => this.parentMenu.runLocalHooks("afterSubmenuOpen", this));
    }
    this.runLocalHooks("afterOpen", this);
  }
  /**
   * Close menu.
   *
   * @param {boolean} [closeParent=false] If `true` try to close parent menu if exists.
   */
  close() {
    let closeParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!this.isOpened()) {
      return;
    }
    if (closeParent && this.isSubMenu()) {
      this.parentMenu.close();
    } else {
      _classPrivateFieldGet3(this, _navigator).clear();
      this.closeAllSubMenus();
      this.container.style.display = "none";
      this.hotMenu.destroy();
      this.hotMenu = null;
      this.hot.getSettings().outsideClickDeselects = this.origOutsideClickDeselects;
      this.runLocalHooks("afterClose");
      if (this.isSubMenu()) {
        if (this.hot.getSettings().ariaTags) {
          const selection = this.parentMenu.hotMenu.getSelectedLast();
          if (selection) {
            const cell = this.parentMenu.hotMenu.getCell(selection[0], 0);
            setAttribute(cell, [A11Y_EXPANDED(false)]);
          }
        }
        this.parentMenu.hotMenu.listen();
      }
    }
  }
  /**
   * Open sub menu at the provided row index.
   *
   * @param {number} row Row index.
   * @returns {Menu|boolean} Returns created menu or `false` if no one menu was created.
   */
  openSubMenu(row) {
    if (!this.hotMenu) {
      return false;
    }
    const cell = this.hotMenu.getCell(row, 0);
    this.closeAllSubMenus();
    if (!cell || !hasSubMenu(cell)) {
      return false;
    }
    const dataItem = this.hotMenu.getSourceDataAtRow(row);
    const subMenu = new _Menu(this.hot, {
      parent: this,
      name: dataItem.name,
      className: this.options.className,
      keepInViewport: true,
      container: this.options.container
    });
    subMenu.setMenuItems(dataItem.submenu.items);
    subMenu.open();
    subMenu.setPosition(cell.getBoundingClientRect());
    this.hotSubMenus[dataItem.key] = subMenu;
    if (this.hot.getSettings().ariaTags) {
      setAttribute(cell, [A11Y_EXPANDED(true)]);
    }
    return subMenu;
  }
  /**
   * Close sub menu at row index.
   *
   * @param {number} row Row index.
   */
  closeSubMenu(row) {
    const dataItem = this.hotMenu.getSourceDataAtRow(row);
    const menus = this.hotSubMenus[dataItem.key];
    if (menus) {
      menus.destroy();
      delete this.hotSubMenus[dataItem.key];
      const cell = this.hotMenu.getCell(row, 0);
      if (this.hot.getSettings().ariaTags) {
        setAttribute(cell, [A11Y_EXPANDED(false)]);
      }
    }
  }
  /**
   * Close all opened sub menus.
   */
  closeAllSubMenus() {
    arrayEach(this.hotMenu.getData(), (value, row) => this.closeSubMenu(row));
  }
  /**
   * Checks if all created and opened sub menus are closed.
   *
   * @returns {boolean}
   */
  isAllSubMenusClosed() {
    return Object.keys(this.hotSubMenus).length === 0;
  }
  /**
   * Focus the menu so all keyboard shortcuts become active.
   */
  focus() {
    if (this.isOpened()) {
      this.hotMenu.rootElement.focus({
        preventScroll: true
      });
      this.getKeyboardShortcutsCtrl().listen();
      this.hotMenu.listen();
    }
  }
  /**
   * Destroy instance.
   */
  destroy() {
    const menuContainerParentElement = this.container.parentNode;
    this.clearLocalHooks();
    this.close();
    this.parentMenu = null;
    this.eventManager.destroy();
    if (menuContainerParentElement) {
      menuContainerParentElement.removeChild(this.container);
    }
  }
  /**
   * Checks if menu was opened.
   *
   * @returns {boolean} Returns `true` if menu was opened.
   */
  isOpened() {
    return this.hotMenu !== null;
  }
  /**
   * Execute menu command.
   *
   * The `executeCommand()` method works only for selected cells.
   *
   * When no cells are selected, `executeCommand()` doesn't do anything.
   *
   * @param {Event} [event] The mouse event object.
   */
  executeCommand(event) {
    if (!this.isOpened() || !this.hasSelectedItem()) {
      return;
    }
    const selectedItem = this.getSelectedItem();
    this.runLocalHooks("select", selectedItem, event);
    if (this.isCommandPassive(selectedItem)) {
      return;
    }
    const selRanges = this.hot.getSelectedRange();
    const normalizedSelection = selRanges ? normalizeSelection(selRanges) : [];
    this.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event);
    if (this.isSubMenu()) {
      this.parentMenu.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event);
    }
  }
  /**
   * Checks if the passed command is passive or not. The command is passive when it's marked as
   * disabled, the descriptor object contains `isCommand` property set to `false`, command
   * is a separator, or the item is recognized as submenu. For passive items the menu is not
   * closed automatically after the user trigger the command through the UI.
   *
   * @param {object} commandDescriptor Selected menu item from the menu data source.
   * @returns {boolean}
   */
  isCommandPassive(commandDescriptor) {
    return commandDescriptor.isCommand === false || isItemSeparator(commandDescriptor) || isItemDisabled(commandDescriptor, this.hot) || isItemSubMenu(commandDescriptor);
  }
  /**
   * Set offset menu position for specified area (`above`, `below`, `left` or `right`).
   *
   * @param {string} area Specified area name (`above`, `below`, `left` or `right`).
   * @param {number} offset Offset value.
   */
  setOffset(area) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.positioner.setOffset(area, offset);
  }
  /**
   * Set menu position based on dom event or based on literal object.
   *
   * @param {Event|object} coords Event or literal Object with coordinates.
   */
  setPosition(coords) {
    if (this.isSubMenu()) {
      this.positioner.setParentElement(this.parentMenu.container);
    }
    this.positioner.setElement(this.container).updatePosition(coords);
  }
  /**
   * Create container/wrapper for handsontable.
   *
   * @private
   * @param {string} [name] Class name.
   * @returns {HTMLElement}
   */
  createContainer() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const doc = this.options.container.ownerDocument;
    let className = name;
    let container;
    if (className) {
      if (isFunction(className)) {
        className = className.call(this.hot);
        if (className === null || isUndefined(className)) {
          className = "";
        } else {
          className = className.toString();
        }
      }
      className = className.replace(/[^A-z0-9]/g, "_");
      className = `${this.options.className}Sub_${className}`;
      container = doc.querySelector(`.${this.options.className}.${className}`);
    }
    if (!container) {
      container = doc.createElement("div");
      addClass(container, `htMenu ${this.options.className}`);
      if (className) {
        addClass(container, className);
      }
      this.options.container.appendChild(container);
    }
    return container;
  }
  /**
   * On after init listener.
   *
   * @private
   */
  onAfterInit() {
    const {
      wtTable
    } = this.hotMenu.view._wt;
    const data = this.hotMenu.getSettings().data;
    const hiderStyle = wtTable.hider.style;
    const holderStyle = wtTable.holder.style;
    const currentHiderWidth = parseInt(hiderStyle.width, 10);
    const realHeight = arrayReduce(data, (accumulator, value) => accumulator + (value.name === KEY ? 1 : 26), 0);
    holderStyle.width = `${currentHiderWidth + 3}px`;
    holderStyle.height = `${realHeight + 3}px`;
    hiderStyle.height = holderStyle.height;
    if (this.hot.getSettings().ariaTags) {
      setAttribute(this.hotMenu.rootElement, [A11Y_MENU(), A11Y_TABINDEX(-1)]);
    }
  }
  /**
   * Document mouse down listener.
   *
   * @private
   * @param {Event} event The mouse event object.
   */
  onDocumentMouseDown(event) {
    if (!this.isOpened()) {
      return;
    }
    if (this.options.standalone && this.hotMenu && !isChildOf(event.target, this.hotMenu.rootElement)) {
      this.close(true);
    } else if ((this.isAllSubMenusClosed() || this.isSubMenu()) && !isChildOf(event.target, ".htMenu")) {
      this.close(true);
    }
  }
  /**
   * Document's contextmenu listener.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onDocumentContextMenu(event) {
    if (!this.isOpened()) {
      return;
    }
    if (hasClass(event.target, "htCore") && isChildOf(event.target, this.hotMenu.rootElement)) {
      event.preventDefault();
    }
  }
};
mixin(Menu, localHooks_default);

// node_modules/handsontable/plugins/contextMenu/contextMenu.mjs
function _classPrivateMethodInitSpec2(obj, privateSet) {
  _checkPrivateRedeclaration4(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration4(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty6(obj, key, value) {
  key = _toPropertyKey6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey6(arg) {
  var key = _toPrimitive6(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive6(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet2(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY2 = "contextMenu";
var PLUGIN_PRIORITY = 70;
var SHORTCUTS_GROUP2 = PLUGIN_KEY2;
pluginHooks_default.getSingleton().register("afterContextMenuDefaultOptions");
pluginHooks_default.getSingleton().register("beforeContextMenuShow");
pluginHooks_default.getSingleton().register("afterContextMenuShow");
pluginHooks_default.getSingleton().register("afterContextMenuHide");
pluginHooks_default.getSingleton().register("afterContextMenuExecute");
var _onAfterOnCellContextMenu = /* @__PURE__ */ new WeakSet();
var _onMenuBeforeOpen = /* @__PURE__ */ new WeakSet();
var _onMenuAfterOpen = /* @__PURE__ */ new WeakSet();
var _onMenuAfterClose = /* @__PURE__ */ new WeakSet();
var ContextMenu = class _ContextMenu extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec2(this, _onMenuAfterClose);
    _classPrivateMethodInitSpec2(this, _onMenuAfterOpen);
    _classPrivateMethodInitSpec2(this, _onMenuBeforeOpen);
    _classPrivateMethodInitSpec2(this, _onAfterOnCellContextMenu);
    _defineProperty6(this, "commandExecutor", new CommandExecutor(this.hot));
    _defineProperty6(this, "itemsFactory", null);
    _defineProperty6(this, "menu", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY2;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:AutoColumnSize"];
  }
  /**
   * Context menu default items order when `contextMenu` options is set as `true`.
   *
   * @returns {string[]}
   */
  static get DEFAULT_ITEMS() {
    return [KEY10, KEY11, KEY, KEY4, KEY5, KEY, KEY9, KEY8, KEY, KEY13, KEY7, KEY, KEY6, KEY, KEY2];
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ContextMenu#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY2];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const settings = this.hot.getSettings()[PLUGIN_KEY2];
    if (typeof settings.callback === "function") {
      this.commandExecutor.setCommonCallback(settings.callback);
    }
    this.menu = new Menu(this.hot, {
      className: "htContextMenu",
      keepInViewport: true,
      container: settings.uiContainer || this.hot.rootDocument.body
    });
    this.menu.addLocalHook("beforeOpen", () => _classPrivateMethodGet2(this, _onMenuBeforeOpen, _onMenuBeforeOpen2).call(this));
    this.menu.addLocalHook("afterOpen", () => _classPrivateMethodGet2(this, _onMenuAfterOpen, _onMenuAfterOpen2).call(this));
    this.menu.addLocalHook("afterClose", () => _classPrivateMethodGet2(this, _onMenuAfterClose, _onMenuAfterClose2).call(this));
    this.menu.addLocalHook("executeCommand", function() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      return _this.executeCommand.call(_this, ...params);
    });
    this.addHook("afterOnCellContextMenu", (event) => _classPrivateMethodGet2(this, _onAfterOnCellContextMenu, _onAfterOnCellContextMenu2).call(this, event));
    this.registerShortcuts();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`contextMenu`](@/api/options.md#contextmenu)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
      this.menu = null;
    }
    this.unregisterShortcuts();
    super.disablePlugin();
  }
  /**
   * Register shortcuts responsible for toggling context menu.
   *
   * @private
   */
  registerShortcuts() {
    this.hot.getShortcutManager().getContext("grid").addShortcut({
      keys: [["Control/Meta", "Shift", "Backslash"], ["Shift", "F10"]],
      callback: () => {
        const {
          highlight
        } = this.hot.getSelectedRangeLast();
        this.hot.scrollToFocusedCell();
        const rect = this.hot.getCell(highlight.row, highlight.col, true).getBoundingClientRect();
        const offset = getDocumentOffsetByElement(this.menu.container, this.hot.rootDocument);
        this.open({
          left: rect.left + offset.left,
          top: rect.top + offset.top - 1 + rect.height
        }, {
          left: rect.width,
          above: -rect.height
        });
        this.menu.getNavigator().toFirstItem();
      },
      runOnlyIf: () => {
        var _this$hot$getSelected;
        const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
        return highlight && this.hot.selection.isCellVisible(highlight) && !this.menu.isOpened();
      },
      group: SHORTCUTS_GROUP2
    });
  }
  /**
   * Unregister shortcuts responsible for toggling context menu.
   *
   * @private
   */
  unregisterShortcuts() {
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP2);
  }
  /**
   * Opens menu and re-position it based on the passed coordinates.
   *
   * @param {{ top: number, left: number }|Event} position An object with `top` and `left` properties
   * which contains coordinates relative to the browsers viewport (without included scroll offsets).
   * Or if the native event is passed the menu will be positioned based on the `pageX` and `pageY`
   * coordinates.
   * @param {{ above: number, below: number, left: number, right: number }} offset An object allows applying
   * the offset to the menu position.
   * @fires Hooks#beforeContextMenuShow
   * @fires Hooks#afterContextMenuShow
   */
  open(position) {
    var _this$menu;
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      above: 0,
      below: 0,
      left: 0,
      right: 0
    };
    if ((_this$menu = this.menu) !== null && _this$menu !== void 0 && _this$menu.isOpened()) {
      return;
    }
    this.prepareMenuItems();
    this.menu.open();
    objectEach(offset, (value, key) => {
      this.menu.setOffset(key, value);
    });
    this.menu.setPosition(position);
  }
  /**
   * Closes the menu.
   */
  close() {
    var _this$menu2;
    (_this$menu2 = this.menu) === null || _this$menu2 === void 0 || _this$menu2.close();
    this.itemsFactory = null;
  }
  /**
   * Execute context menu command.
   *
   * The `executeCommand()` method works only for selected cells.
   *
   * When no cells are selected, `executeCommand()` doesn't do anything.
   *
   * You can execute all predefined commands:
   *  * `'row_above'` - Insert row above
   *  * `'row_below'` - Insert row below
   *  * `'col_left'` - Insert column left
   *  * `'col_right'` - Insert column right
   *  * `'clear_column'` - Clear selected column
   *  * `'remove_row'` - Remove row
   *  * `'remove_col'` - Remove column
   *  * `'undo'` - Undo last action
   *  * `'redo'` - Redo last action
   *  * `'make_read_only'` - Make cell read only
   *  * `'alignment:left'` - Alignment to the left
   *  * `'alignment:top'` - Alignment to the top
   *  * `'alignment:right'` - Alignment to the right
   *  * `'alignment:bottom'` - Alignment to the bottom
   *  * `'alignment:middle'` - Alignment to the middle
   *  * `'alignment:center'` - Alignment to the center (justify).
   *
   * Or you can execute command registered in settings where `key` is your command name.
   *
   * @param {string} commandName The command name to be executed.
   * @param {*} params Additional parameters passed to command executor module.
   */
  executeCommand(commandName) {
    if (this.itemsFactory === null) {
      this.prepareMenuItems();
    }
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    this.commandExecutor.execute(commandName, ...params);
  }
  /**
   * Prepares available contextMenu's items list and registers them in commandExecutor.
   *
   * @private
   * @fires Hooks#afterContextMenuDefaultOptions
   * @fires Hooks#beforeContextMenuSetItems
   */
  prepareMenuItems() {
    this.itemsFactory = new ItemsFactory(this.hot, _ContextMenu.DEFAULT_ITEMS);
    const settings = this.hot.getSettings()[PLUGIN_KEY2];
    const predefinedItems2 = {
      items: this.itemsFactory.getItems(settings)
    };
    this.hot.runHooks("afterContextMenuDefaultOptions", predefinedItems2);
    this.itemsFactory.setPredefinedItems(predefinedItems2.items);
    const menuItems = this.itemsFactory.getItems(settings);
    this.hot.runHooks("beforeContextMenuSetItems", menuItems);
    this.menu.setMenuItems(menuItems);
    arrayEach(menuItems, (command) => this.commandExecutor.registerCommand(command.key, command));
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
    }
    super.destroy();
  }
};
function _onAfterOnCellContextMenu2(event) {
  const settings = this.hot.getSettings();
  const showRowHeaders = settings.rowHeaders;
  const showColHeaders = settings.colHeaders;
  function isValidElement(element2) {
    return element2.nodeName === "TD" || element2.parentNode.nodeName === "TD";
  }
  const element = event.target;
  this.close();
  if (hasClass(element, "handsontableInput")) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  if (!(showRowHeaders || showColHeaders)) {
    if (!isValidElement(element) && !(hasClass(element, "current") && hasClass(element, "wtBorder"))) {
      return;
    }
  }
  const offset = getDocumentOffsetByElement(this.menu.container, this.hot.rootDocument);
  this.open({
    top: event.clientY + offset.top,
    left: event.clientX + offset.left
  });
}
function _onMenuBeforeOpen2() {
  this.hot.runHooks("beforeContextMenuShow", this);
}
function _onMenuAfterOpen2() {
  this.hot.runHooks("afterContextMenuShow", this);
}
function _onMenuAfterClose2() {
  this.hot.listen();
  this.hot.runHooks("afterContextMenuHide", this);
}
ContextMenu.SEPARATOR = {
  name: KEY
};

export {
  BasePlugin,
  CommandExecutor,
  align,
  markLabelAsSelected,
  checkSelectionConsistency,
  getDocumentOffsetByElement,
  KEY,
  KEY2,
  KEY3,
  KEY4,
  KEY5,
  KEY6,
  KEY8 as KEY7,
  ItemsFactory,
  createPaginator,
  Menu,
  PLUGIN_KEY2 as PLUGIN_KEY,
  PLUGIN_PRIORITY,
  ContextMenu
};
//# sourceMappingURL=chunk-AWTF6NMB.js.map
