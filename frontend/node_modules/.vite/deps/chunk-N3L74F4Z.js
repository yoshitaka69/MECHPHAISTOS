import {
  _getEditorInstance,
  isCtrlMetaKey,
  isEdge,
  isFunctionKey,
  isIOS
} from "./chunk-PJRC6Q4Z.js";
import {
  A11Y_HIDDEN,
  A11Y_TABINDEX,
  addClass,
  eventManager_default,
  getCaretPosition,
  getComputedStyle,
  getScrollbarWidth,
  hasClass,
  hasHorizontalScrollbar,
  hasVerticalScrollbar,
  isImmediatePropagationStopped,
  isThisHotChild,
  offset,
  outerHeight,
  outerWidth,
  rangeEach,
  removeClass,
  setAttribute,
  setCaretPosition
} from "./chunk-IWTULMLB.js";
import {
  arrayEach,
  defineGetter,
  isDefined,
  mixin,
  objectEach,
  stringify
} from "./chunk-DSUKSR6K.js";

// node_modules/handsontable/editorManager.mjs
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var SHORTCUTS_GROUP_NAVIGATION = "editorManager.navigation";
var _onAfterDocumentKeyDown = /* @__PURE__ */ new WeakSet();
var _onCellDblClick = /* @__PURE__ */ new WeakSet();
var EditorManager = class {
  /**
   * @param {Core} hotInstance The Handsontable instance.
   * @param {TableMeta} tableMeta The table meta instance.
   * @param {Selection} selection The selection instance.
   */
  constructor(hotInstance, tableMeta, _selection) {
    _classPrivateMethodInitSpec(this, _onCellDblClick);
    _classPrivateMethodInitSpec(this, _onAfterDocumentKeyDown);
    _defineProperty(this, "hot", void 0);
    _defineProperty(this, "tableMeta", void 0);
    _defineProperty(this, "selection", void 0);
    _defineProperty(this, "eventManager", void 0);
    _defineProperty(this, "destroyed", false);
    _defineProperty(this, "lock", false);
    _defineProperty(this, "activeEditor", void 0);
    _defineProperty(this, "cellProperties", void 0);
    this.hot = hotInstance;
    this.tableMeta = tableMeta;
    this.selection = _selection;
    this.eventManager = new eventManager_default(hotInstance);
    this.hot.addHook("afterDocumentKeyDown", (event2) => _classPrivateMethodGet(this, _onAfterDocumentKeyDown, _onAfterDocumentKeyDown2).call(this, event2));
    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, "compositionstart", (event2) => {
      if (!this.destroyed && this.hot.isListening()) {
        this.openEditor("", event2);
      }
    });
    this.hot.view._wt.update("onCellDblClick", (event2, coords, elem) => _classPrivateMethodGet(this, _onCellDblClick, _onCellDblClick2).call(this, event2, coords, elem));
  }
  /**
   * Lock the editor from being prepared and closed. Locking the editor prevents its closing and
   * reinitialized after selecting the new cell. This feature is necessary for a mobile editor.
   */
  lockEditor() {
    this.lock = true;
  }
  /**
   * Unlock the editor from being prepared and closed. This method restores the original behavior of
   * the editors where for every new selection its instances are closed.
   */
  unlockEditor() {
    this.lock = false;
  }
  /**
   * Destroy current editor, if exists.
   *
   * @param {boolean} revertOriginal If `false` and the cell using allowInvalid option,
   *                                 then an editor won't be closed until validation is passed.
   */
  destroyEditor(revertOriginal) {
    if (!this.lock) {
      this.closeEditor(revertOriginal);
    }
  }
  /**
   * Get active editor.
   *
   * @returns {BaseEditor}
   */
  getActiveEditor() {
    return this.activeEditor;
  }
  /**
   * Prepare text input to be displayed at given grid cell.
   */
  prepareEditor() {
    if (this.lock) {
      return;
    }
    if (this.activeEditor && this.activeEditor.isWaiting()) {
      this.closeEditor(false, false, (dataSaved) => {
        if (dataSaved) {
          this.prepareEditor();
        }
      });
      return;
    }
    const {
      highlight
    } = this.hot.getSelectedRangeLast();
    if (highlight.isHeader()) {
      return;
    }
    const {
      row,
      col
    } = highlight;
    const modifiedCellCoords = this.hot.runHooks("modifyGetCellCoords", row, col);
    let visualRowToCheck = row;
    let visualColumnToCheck = col;
    if (Array.isArray(modifiedCellCoords)) {
      [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;
    }
    this.cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);
    if (!this.isCellEditable()) {
      this.clearActiveEditor();
      return;
    }
    const td = this.hot.getCell(row, col, true);
    if (td) {
      const editorClass = this.hot.getCellEditor(this.cellProperties);
      const prop = this.hot.colToProp(visualColumnToCheck);
      const originalValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(visualRowToCheck), visualColumnToCheck);
      this.activeEditor = _getEditorInstance(editorClass, this.hot);
      this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);
    }
  }
  /**
   * Check is editor is opened/showed.
   *
   * @returns {boolean}
   */
  isEditorOpened() {
    return this.activeEditor && this.activeEditor.isOpened();
  }
  /**
   * Open editor with initial value.
   *
   * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.
   * @param {Event} event The event object.
   * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor
   *                                             when arrow keys are pressed.
   */
  openEditor(newInitialValue, event2) {
    let enableFullEditMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!this.isCellEditable()) {
      this.clearActiveEditor();
      return;
    }
    if (!this.activeEditor) {
      this.hot.scrollToFocusedCell();
      this.prepareEditor();
    }
    if (this.activeEditor) {
      if (enableFullEditMode) {
        this.activeEditor.enableFullEditMode();
      }
      this.activeEditor.beginEditing(newInitialValue, event2);
    }
  }
  /**
   * Close editor, finish editing cell.
   *
   * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.
   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.
   * @param {Function} callback The callback function, fired after editor closing.
   */
  closeEditor(restoreOriginalValue, isCtrlPressed, callback) {
    if (this.activeEditor) {
      this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);
    } else if (callback) {
      callback(false);
    }
  }
  /**
   * Close editor and save changes.
   *
   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.
   */
  closeEditorAndSaveChanges(isCtrlPressed) {
    this.closeEditor(false, isCtrlPressed);
  }
  /**
   * Close editor and restore original value.
   *
   * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.
   */
  closeEditorAndRestoreOriginalValue(isCtrlPressed) {
    this.closeEditor(true, isCtrlPressed);
  }
  /**
   * Clears reference to an instance of the active editor.
   *
   * @private
   */
  clearActiveEditor() {
    this.activeEditor = void 0;
  }
  /**
   * Checks if the currently selected cell (pointed by selection highlight coords) is editable.
   * Editable cell is when:
   *   - the cell has defined an editor type;
   *   - the cell is not marked as read-only;
   *   - the cell is not hidden.
   *
   * @private
   * @returns {boolean}
   */
  isCellEditable() {
    const selection = this.hot.getSelectedRangeLast();
    if (!selection) {
      return false;
    }
    const editorClass = this.hot.getCellEditor(this.cellProperties);
    const {
      row,
      col
    } = selection.highlight;
    const {
      rowIndexMapper,
      columnIndexMapper
    } = this.hot;
    const isCellHidden = rowIndexMapper.isHidden(this.hot.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.hot.toPhysicalColumn(col));
    if (this.cellProperties.readOnly || !editorClass || isCellHidden) {
      return false;
    }
    return true;
  }
  /**
   * Controls selection's behaviour after clicking `Enter`.
   *
   * @private
   * @param {boolean} isShiftPressed If `true`, then the selection will move up after hit enter.
   */
  moveSelectionAfterEnter(isShiftPressed) {
    const enterMoves = typeof this.tableMeta.enterMoves === "function" ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves;
    if (isShiftPressed) {
      this.selection.transformStart(-enterMoves.row, -enterMoves.col);
    } else {
      this.selection.transformStart(enterMoves.row, enterMoves.col, true);
    }
  }
  /**
   * Destroy the instance.
   */
  destroy() {
    this.destroyed = true;
    this.eventManager.destroy();
  }
};
function _onAfterDocumentKeyDown2(event2) {
  const selection = this.hot.getSelectedRangeLast();
  if (!this.hot.isListening() || !selection || selection.highlight.isHeader() || isImmediatePropagationStopped(event2)) {
    return;
  }
  const {
    keyCode
  } = event2;
  const isCtrlPressed = (event2.ctrlKey || event2.metaKey) && !event2.altKey;
  if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {
    if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {
      const shortcutManager = this.hot.getShortcutManager();
      const editorContext = shortcutManager.getContext("editor");
      const runOnlySelectedConfig = {
        runOnlyIf: () => isDefined(this.hot.getSelected()),
        group: SHORTCUTS_GROUP_NAVIGATION
      };
      editorContext.addShortcuts([{
        keys: [["ArrowUp"]],
        callback: () => {
          this.hot.selection.transformStart(-1, 0);
        }
      }, {
        keys: [["ArrowDown"]],
        callback: () => {
          this.hot.selection.transformStart(1, 0);
        }
      }, {
        keys: [["ArrowLeft"]],
        callback: () => {
          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());
        }
      }, {
        keys: [["ArrowRight"]],
        callback: () => {
          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());
        }
      }], runOnlySelectedConfig);
      this.openEditor("", event2);
    }
  }
}
function _onCellDblClick2(event2, coords, elem) {
  if (elem.nodeName === "TD") {
    this.openEditor(null, event2, true);
  }
}
var instances = /* @__PURE__ */ new WeakMap();
EditorManager.getInstance = function(hotInstance, tableMeta, selection) {
  let editorManager = instances.get(hotInstance);
  if (!editorManager) {
    editorManager = new EditorManager(hotInstance, tableMeta, selection);
    instances.set(hotInstance, editorManager);
  }
  return editorManager;
};
var editorManager_default = EditorManager;

// node_modules/handsontable/mixins/hooksRefRegisterer.mjs
var MIXIN_NAME = "hooksRefRegisterer";
var hooksRefRegisterer = {
  /**
   * Internal hooks storage.
   */
  _hooksStorage: /* @__PURE__ */ Object.create(null),
  /**
   * Add hook to the collection.
   *
   * @param {string} key The hook name.
   * @param {Function} callback The hook callback.
   * @returns {object}
   */
  addHook(key, callback) {
    if (!this._hooksStorage[key]) {
      this._hooksStorage[key] = [];
    }
    this.hot.addHook(key, callback);
    this._hooksStorage[key].push(callback);
    return this;
  },
  /**
   * Remove all hooks listeners by hook name.
   *
   * @param {string} key The hook name.
   */
  removeHooksByKey(key) {
    arrayEach(this._hooksStorage[key] || [], (callback) => {
      this.hot.removeHook(key, callback);
    });
  },
  /**
   * Clear all added hooks.
   */
  clearHooks() {
    objectEach(this._hooksStorage, (callbacks, name) => this.removeHooksByKey(name));
    this._hooksStorage = {};
  }
};
defineGetter(hooksRefRegisterer, "MIXIN_NAME", MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var hooksRefRegisterer_default = hooksRefRegisterer;

// node_modules/handsontable/editors/baseEditor/baseEditor.mjs
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var EDITOR_TYPE = "base";
var EDITOR_STATE = Object.freeze({
  VIRGIN: "STATE_VIRGIN",
  // before editing
  EDITING: "STATE_EDITING",
  WAITING: "STATE_WAITING",
  // waiting for async validation
  FINISHED: "STATE_FINISHED"
});
var SHORTCUTS_GROUP_EDITOR = "baseEditor";
var BaseEditor = class {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE;
  }
  /**
   * A reference to the source instance of the Handsontable.
   *
   * @type {Handsontable}
   */
  /**
   * @param {Handsontable} hotInstance A reference to the source instance of the Handsontable.
   */
  constructor(hotInstance) {
    _defineProperty2(this, "hot", void 0);
    _defineProperty2(this, "state", EDITOR_STATE.VIRGIN);
    _defineProperty2(this, "_opened", false);
    _defineProperty2(this, "_fullEditMode", false);
    _defineProperty2(this, "_closeCallback", null);
    _defineProperty2(this, "TD", null);
    _defineProperty2(this, "row", null);
    _defineProperty2(this, "col", null);
    _defineProperty2(this, "prop", null);
    _defineProperty2(this, "originalValue", null);
    _defineProperty2(this, "cellProperties", null);
    this.hot = hotInstance;
    this.init();
  }
  /**
   * Fires callback after closing editor.
   *
   * @private
   * @param {boolean} result The editor value.
   */
  _fireCallbacks(result) {
    if (this._closeCallback) {
      this._closeCallback(result);
      this._closeCallback = null;
    }
  }
  /**
   * Initializes an editor's intance.
   */
  init() {
  }
  /**
   * Required method to get current value from editable element.
   */
  getValue() {
    throw Error("Editor getValue() method unimplemented");
  }
  /**
   * Required method to set new value into editable element.
   */
  setValue() {
    throw Error("Editor setValue() method unimplemented");
  }
  /**
   * Required method to open editor.
   */
  open() {
    throw Error("Editor open() method unimplemented");
  }
  /**
   * Required method to close editor.
   */
  close() {
    throw Error("Editor close() method unimplemented");
  }
  /**
   * Prepares editor's meta data.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    this.TD = td;
    this.row = row;
    this.col = col;
    this.prop = prop;
    this.originalValue = value;
    this.cellProperties = cellProperties;
    this.state = EDITOR_STATE.VIRGIN;
  }
  /**
   * Fallback method to provide extendable editors in ES5.
   *
   * @returns {Function}
   */
  extend() {
    return class Editor extends this.constructor {
    };
  }
  /**
   * Saves value from editor into data storage.
   *
   * @param {*} value The editor value.
   * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.
   */
  saveValue(value, ctrlDown) {
    let visualRowFrom;
    let visualColumnFrom;
    let visualRowTo;
    let visualColumnTo;
    if (ctrlDown) {
      const selectedLast = this.hot.getSelectedLast();
      visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0);
      visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0);
      visualRowTo = Math.max(selectedLast[0], selectedLast[2]);
      visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);
    } else {
      [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = [this.row, this.col, null, null];
    }
    const modifiedCellCoords = this.hot.runHooks("modifyGetCellCoords", visualRowFrom, visualColumnFrom);
    if (Array.isArray(modifiedCellCoords)) {
      [visualRowFrom, visualColumnFrom] = modifiedCellCoords;
    }
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    const contextConfig = {
      runOnlyIf: () => isDefined(this.hot.getSelected()),
      group: SHORTCUTS_GROUP_EDITOR
    };
    if (this.isInFullEditMode()) {
      editorContext.addShortcuts([{
        keys: [["ArrowUp"]],
        callback: () => {
          this.hot.selection.transformStart(-1, 0);
        }
      }, {
        keys: [["ArrowDown"]],
        callback: () => {
          this.hot.selection.transformStart(1, 0);
        }
      }, {
        keys: [["ArrowLeft"]],
        callback: () => {
          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());
        }
      }, {
        keys: [["ArrowRight"]],
        callback: () => {
          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());
        }
      }], contextConfig);
    }
    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, "edit");
  }
  /**
   * Begins editing on a highlighted cell and hides fillHandle corner if was present.
   *
   * @param {*} newInitialValue The initial editor value.
   * @param {Event} event The keyboard event object.
   */
  beginEditing(newInitialValue, event2) {
    if (this.state !== EDITOR_STATE.VIRGIN) {
      return;
    }
    const hotInstance = this.hot;
    const renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);
    const renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);
    hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));
    this.state = EDITOR_STATE.EDITING;
    if (this.isInFullEditMode()) {
      const stringifiedInitialValue = typeof newInitialValue === "string" ? newInitialValue : stringify(this.originalValue);
      this.setValue(stringifiedInitialValue);
    }
    this.open(event2);
    this._opened = true;
    this.focus();
    hotInstance.view.render();
    hotInstance.runHooks("afterBeginEditing", this.row, this.col);
  }
  /**
   * Finishes editing and start saving or restoring process for editing cell or last selected range.
   *
   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
   * @param {Function} callback The callback function, fired after editor closing.
   */
  finishEditing(restoreOriginalValue, ctrlDown, callback) {
    let val;
    if (callback) {
      const previousCloseCallback = this._closeCallback;
      this._closeCallback = (result) => {
        if (previousCloseCallback) {
          previousCloseCallback(result);
        }
        callback(result);
        this.hot.view.render();
      };
    }
    if (this.isWaiting()) {
      return;
    }
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);
    if (this.state === EDITOR_STATE.VIRGIN) {
      this.hot._registerTimeout(() => {
        this._fireCallbacks(true);
      });
      return;
    }
    if (this.state === EDITOR_STATE.EDITING) {
      if (restoreOriginalValue) {
        this.cancelChanges();
        this.hot.view.render();
        return;
      }
      const value = this.getValue();
      if (this.cellProperties.trimWhitespace) {
        val = [[typeof value === "string" ? String.prototype.trim.call(value || "") : value]];
      } else {
        val = [[value]];
      }
      this.state = EDITOR_STATE.WAITING;
      this.saveValue(val, ctrlDown);
      if (this.hot.getCellValidator(this.cellProperties)) {
        this.hot.addHookOnce("postAfterValidate", (result) => {
          this.state = EDITOR_STATE.FINISHED;
          this.discardEditor(result);
        });
      } else {
        this.state = EDITOR_STATE.FINISHED;
        this.discardEditor(true);
      }
    }
  }
  /**
   * Finishes editing without singout saving value.
   */
  cancelChanges() {
    this.state = EDITOR_STATE.FINISHED;
    this.discardEditor();
  }
  /**
   * Verifies result of validation or closes editor if user's cancelled changes.
   *
   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,
   *                                   then an editor won't be closed until validation is passed.
   */
  discardEditor(result) {
    if (this.state !== EDITOR_STATE.FINISHED) {
      return;
    }
    if (result === false && this.cellProperties.allowInvalid !== true) {
      this.hot.selectCell(this.row, this.col);
      this.focus();
      this.state = EDITOR_STATE.EDITING;
      this._fireCallbacks(false);
    } else {
      this.close();
      this._opened = false;
      this._fullEditMode = false;
      this.state = EDITOR_STATE.VIRGIN;
      this._fireCallbacks(true);
      const shortcutManager = this.hot.getShortcutManager();
      shortcutManager.setActiveContextName("grid");
    }
  }
  /**
   * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated
   * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.
   */
  enableFullEditMode() {
    this._fullEditMode = true;
  }
  /**
   * Checks if editor is in full edit mode.
   *
   * @returns {boolean}
   */
  isInFullEditMode() {
    return this._fullEditMode;
  }
  /**
   * Returns information whether the editor is open.
   *
   * @returns {boolean}
   */
  isOpened() {
    return this._opened;
  }
  /**
   * Returns information whether the editor is waiting, eg.: for async validation.
   *
   * @returns {boolean}
   */
  isWaiting() {
    return this.state === EDITOR_STATE.WAITING;
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Gets the object that provides information about the edited cell size and its position
   * relative to the table viewport.
   *
   * The rectangle has six integer properties:
   *  - `top` The top position relative to the table viewport
   *  - `start` The left (or right in RTL) position relative to the table viewport
   *  - `width` The cell's current width;
   *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport
   *  - `height` The cell's current height;
   *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport
   *
   * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}
   */
  getEditedCellRect() {
    var _wtOverlays$getParent;
    const TD = this.getEditedCell();
    if (!TD) {
      return;
    }
    const {
      wtOverlays,
      wtViewport
    } = this.hot.view._wt;
    const rootWindow = this.hot.rootWindow;
    const currentOffset = offset(TD);
    const cellWidth = outerWidth(TD);
    const containerOffset = offset(this.hot.rootElement);
    const containerWidth = outerWidth(this.hot.rootElement);
    const scrollableContainerTop = wtOverlays.topOverlay.holder;
    const scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;
    const containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;
    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;
    const gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;
    const {
      wtTable: overlayTable
    } = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt;
    const overlayName = overlayTable.name;
    const scrollTop = ["master", "inline_start"].includes(overlayName) ? containerScrollTop : 0;
    const scrollLeft = ["master", "top", "bottom"].includes(overlayName) ? containerScrollLeft : 0;
    const editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;
    let topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;
    let inlineStartPos = 0;
    if (this.hot.isRtl()) {
      inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;
    } else {
      inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;
    }
    if (["top", "top_inline_start_corner"].includes(overlayName)) {
      topPos += wtOverlays.topOverlay.getOverlayOffset();
    }
    if (["inline_start", "top_inline_start_corner"].includes(overlayName)) {
      inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());
    }
    const hasColumnHeaders = this.hot.hasColHeaders();
    const renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);
    const renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);
    const nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();
    const firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting("fixedRowsBottom");
    if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {
      topPos += 1;
    }
    if (renderableColumn <= 0) {
      inlineStartPos += 1;
    }
    const firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;
    const firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;
    const horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());
    const verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();
    const scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);
    let cellTopOffset = TD.offsetTop;
    if (["inline_start", "master"].includes(overlayName)) {
      cellTopOffset += firstRowOffset - verticalScrollPosition;
    }
    if (["bottom", "bottom_inline_start_corner"].includes(overlayName)) {
      const {
        wtViewport: bottomWtViewport,
        wtTable: bottomWtTable
      } = wtOverlays.bottomOverlay.clone;
      cellTopOffset += bottomWtViewport.getWorkspaceHeight() - bottomWtTable.getHeight() - scrollbarWidth;
    }
    let cellStartOffset = TD.offsetLeft;
    if (this.hot.isRtl()) {
      if (cellStartOffset >= 0) {
        cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;
      } else {
        cellStartOffset = Math.abs(cellStartOffset);
      }
      cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;
    } else if (["top", "master", "bottom"].includes(overlayName)) {
      cellStartOffset += firstColumnOffset - horizontalScrollPosition;
    }
    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);
    const borderPhysicalWidthProp = this.hot.isRtl() ? "borderRightWidth" : "borderLeftWidth";
    const inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;
    const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;
    const width = outerWidth(TD) + inlineStartBorderCompensation;
    const height = outerHeight(TD) + topBorderCompensation;
    const actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;
    const actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;
    const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;
    const maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, 23);
    return {
      top: topPos,
      start: inlineStartPos,
      height,
      maxHeight,
      width,
      maxWidth
    };
  }
  /* eslint-enable jsdoc/require-description-complete-sentence */
  /**
   * Gets className of the edited cell if exist.
   *
   * @returns {string}
   */
  getEditedCellsLayerClass() {
    const editorSection = this.checkEditorSection();
    switch (editorSection) {
      case "inline-start":
        return "ht_clone_left ht_clone_inline_start";
      case "bottom":
        return "ht_clone_bottom";
      case "bottom-inline-start-corner":
        return "ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner";
      case "top":
        return "ht_clone_top";
      case "top-inline-start-corner":
        return "ht_clone_top_left_corner ht_clone_top_inline_start_corner";
      default:
        return "ht_clone_master";
    }
  }
  /**
   * Gets HTMLTableCellElement of the edited cell if exist.
   *
   * @returns {HTMLTableCellElement|null}
   */
  getEditedCell() {
    return this.hot.getCell(this.row, this.col, true);
  }
  /**
   * Returns name of the overlay, where editor is placed.
   *
   * @private
   * @returns {string}
   */
  checkEditorSection() {
    const totalRows = this.hot.countRows();
    let section = "";
    if (this.row < this.hot.getSettings().fixedRowsTop) {
      if (this.col < this.hot.getSettings().fixedColumnsStart) {
        section = "top-inline-start-corner";
      } else {
        section = "top";
      }
    } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {
      if (this.col < this.hot.getSettings().fixedColumnsStart) {
        section = "bottom-inline-start-corner";
      } else {
        section = "bottom";
      }
    } else if (this.col < this.hot.getSettings().fixedColumnsStart) {
      section = "inline-start";
    }
    return section;
  }
};
mixin(BaseEditor, hooksRefRegisterer_default);

// node_modules/handsontable/utils/autoResize.mjs
function observe(element, eventName, handler) {
  element.addEventListener(eventName, handler, false);
}
function unObserve(element, eventName, handler) {
  element.removeEventListener(eventName, handler, false);
}
function getComputedStyle2(element) {
  return element.ownerDocument.defaultView.getComputedStyle(element);
}
function createInputElementResizer(ownerDocument) {
  const defaults = {
    minHeight: 200,
    maxHeight: 300,
    minWidth: 100,
    maxWidth: 300
  };
  const body = ownerDocument.body;
  const textHolder = ownerDocument.createTextNode("");
  const textContainer = ownerDocument.createElement("span");
  let observedElement;
  function resize() {
    textHolder.textContent = observedElement.value;
    textContainer.style.position = "absolute";
    textContainer.style.fontSize = getComputedStyle2(observedElement).fontSize;
    textContainer.style.fontFamily = getComputedStyle2(observedElement).fontFamily;
    textContainer.style.whiteSpace = "pre";
    body.appendChild(textContainer);
    const width = textContainer.clientWidth + 2;
    body.removeChild(textContainer);
    const elementStyle = observedElement.style;
    elementStyle.height = `${defaults.minHeight}px`;
    if (defaults.minWidth > width) {
      elementStyle.width = `${defaults.minWidth}px`;
    } else if (width > defaults.maxWidth) {
      elementStyle.width = `${defaults.maxWidth}px`;
    } else {
      elementStyle.width = `${width}px`;
    }
    const scrollHeight = observedElement.scrollHeight ? observedElement.scrollHeight - 1 : 0;
    if (defaults.minHeight > scrollHeight) {
      elementStyle.height = `${defaults.minHeight}px`;
    } else if (defaults.maxHeight < scrollHeight) {
      elementStyle.height = `${defaults.maxHeight}px`;
      elementStyle.overflowY = "visible";
    } else {
      elementStyle.height = `${scrollHeight}px`;
    }
  }
  function delayedResize() {
    ownerDocument.defaultView.setTimeout(resize, 0);
  }
  function extendDefaults(config) {
    if (config && config.minHeight) {
      if (config.minHeight === "inherit") {
        defaults.minHeight = observedElement.clientHeight;
      } else {
        const minHeight = parseInt(config.minHeight, 10);
        if (!isNaN(minHeight)) {
          defaults.minHeight = minHeight;
        }
      }
    }
    if (config && config.maxHeight) {
      if (config.maxHeight === "inherit") {
        defaults.maxHeight = observedElement.clientHeight;
      } else {
        const maxHeight = parseInt(config.maxHeight, 10);
        if (!isNaN(maxHeight)) {
          defaults.maxHeight = maxHeight;
        }
      }
    }
    if (config && config.minWidth) {
      if (config.minWidth === "inherit") {
        defaults.minWidth = observedElement.clientWidth;
      } else {
        const minWidth = parseInt(config.minWidth, 10);
        if (!isNaN(minWidth)) {
          defaults.minWidth = minWidth;
        }
      }
    }
    if (config && config.maxWidth) {
      if (config.maxWidth === "inherit") {
        defaults.maxWidth = observedElement.clientWidth;
      } else {
        const maxWidth = parseInt(config.maxWidth, 10);
        if (!isNaN(maxWidth)) {
          defaults.maxWidth = maxWidth;
        }
      }
    }
    if (!textContainer.firstChild) {
      textContainer.className = "autoResize";
      textContainer.style.display = "inline-block";
      textContainer.appendChild(textHolder);
    }
  }
  function init(elementToObserve, config) {
    let doObserve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    observedElement = elementToObserve;
    extendDefaults(config);
    if (observedElement.nodeName === "TEXTAREA") {
      observedElement.style.resize = "none";
      observedElement.style.overflowY = "";
      observedElement.style.height = `${defaults.minHeight}px`;
      observedElement.style.minWidth = `${defaults.minWidth}px`;
      observedElement.style.maxWidth = `${defaults.maxWidth}px`;
      observedElement.style.overflowY = "hidden";
    }
    if (doObserve) {
      observe(observedElement, "input", resize);
      observe(observedElement, "keydown", delayedResize);
    }
    resize();
  }
  return {
    init,
    resize,
    unObserve() {
      unObserve(observedElement, "input", resize);
      unObserve(observedElement, "keydown", delayedResize);
    }
  };
}

// node_modules/handsontable/editors/textEditor/caretPositioner.mjs
function updateCaretPosition(actionName, textareaElement) {
  const caretPosition = getCaretPosition(textareaElement);
  const textLines = textareaElement.value.split("\n");
  let newCaretPosition = caretPosition;
  let lineStartIndex = 0;
  for (let i = 0; i < textLines.length; i++) {
    const textLine = textLines[i];
    if (i !== 0) {
      lineStartIndex += textLines[i - 1].length + 1;
    }
    const lineEndIndex = lineStartIndex + textLine.length;
    if (actionName === "home") {
      newCaretPosition = lineStartIndex;
    } else if (actionName === "end") {
      newCaretPosition = lineEndIndex;
    }
    if (caretPosition <= lineEndIndex) {
      break;
    }
  }
  setCaretPosition(textareaElement, newCaretPosition);
}

// node_modules/handsontable/editors/textEditor/textEditor.mjs
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive3(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var EDITOR_VISIBLE_CLASS_NAME = "ht_editor_visible";
var EDITOR_HIDDEN_CLASS_NAME = "ht_editor_hidden";
var SHORTCUTS_GROUP = "textEditor";
var EDITOR_TYPE2 = "text";
var TextEditor = class extends BaseEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE2;
  }
  /**
   * Instance of {@link EventManager}.
   *
   * @private
   * @type {EventManager}
   */
  /**
   * @param {Core} hotInstance The Handsontable instance.
   */
  constructor(hotInstance) {
    super(hotInstance);
    _defineProperty3(this, "eventManager", new eventManager_default(this));
    _defineProperty3(this, "autoResize", createInputElementResizer(this.hot.rootDocument));
    _defineProperty3(this, "TEXTAREA", void 0);
    _defineProperty3(this, "textareaStyle", void 0);
    _defineProperty3(this, "TEXTAREA_PARENT", void 0);
    _defineProperty3(this, "textareaParentStyle", void 0);
    _defineProperty3(this, "layerClass", void 0);
    this.eventManager = new eventManager_default(this);
    this.createElements();
    this.bindEvents();
    this.hot.addHookOnce("afterDestroy", () => this.destroy());
  }
  /**
   * Gets current value from editable element.
   *
   * @returns {number}
   */
  getValue() {
    return this.TEXTAREA.value;
  }
  /**
   * Sets new value into editable element.
   *
   * @param {*} newValue The editor value.
   */
  setValue(newValue) {
    this.TEXTAREA.value = newValue;
  }
  /**
   * Opens the editor and adjust its size.
   */
  open() {
    this.refreshDimensions();
    this.showEditableElement();
    this.hot.getShortcutManager().setActiveContextName("editor");
    this.registerShortcuts();
  }
  /**
   * Closes the editor.
   */
  close() {
    this.autoResize.unObserve();
    if (isThisHotChild(this.hot.rootDocument.activeElement, this.hot.rootElement)) {
      this.hot.listen();
    }
    this.hideEditableElement();
    this.unregisterShortcuts();
  }
  /**
   * Prepares editor's meta data.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    const previousState = this.state;
    super.prepare(row, col, prop, td, value, cellProperties);
    if (!cellProperties.readOnly) {
      this.refreshDimensions(true);
      const {
        allowInvalid
      } = cellProperties;
      if (allowInvalid) {
        this.TEXTAREA.value = "";
      }
      if (previousState !== EDITOR_STATE.FINISHED) {
        this.hideEditableElement();
      }
    }
  }
  /**
   * Begins editing on a highlighted cell and hides fillHandle corner if was present.
   *
   * @param {*} newInitialValue The editor initial value.
   * @param {Event} event The keyboard event object.
   */
  beginEditing(newInitialValue, event2) {
    if (this.state !== EDITOR_STATE.VIRGIN) {
      return;
    }
    this.TEXTAREA.value = "";
    super.beginEditing(newInitialValue, event2);
  }
  /**
   * Sets focus state on the select element.
   */
  focus() {
    this.TEXTAREA.select();
    setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
  }
  /**
   * Creates an editor's elements and adds necessary CSS classnames.
   */
  createElements() {
    const {
      rootDocument
    } = this.hot;
    this.TEXTAREA = rootDocument.createElement("TEXTAREA");
    setAttribute(this.TEXTAREA, [["data-hot-input", ""], A11Y_TABINDEX(-1)]);
    if (this.hot.getSettings().ariaTags) {
      setAttribute(this.TEXTAREA, [A11Y_HIDDEN()]);
    }
    addClass(this.TEXTAREA, "handsontableInput");
    this.textareaStyle = this.TEXTAREA.style;
    this.textareaStyle.width = 0;
    this.textareaStyle.height = 0;
    this.textareaStyle.overflowY = "visible";
    this.TEXTAREA_PARENT = rootDocument.createElement("DIV");
    addClass(this.TEXTAREA_PARENT, "handsontableInputHolder");
    if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {
      removeClass(this.TEXTAREA_PARENT, this.layerClass);
    }
    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
    this.textareaParentStyle = this.TEXTAREA_PARENT.style;
    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
    this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);
  }
  /**
   * Moves an editable element out of the viewport, but element must be able to hold focus for IME support.
   *
   * @private
   */
  hideEditableElement() {
    if (isEdge()) {
      this.textareaStyle.textIndent = "-99999px";
    }
    this.textareaStyle.overflowY = "visible";
    this.textareaParentStyle.opacity = "0";
    this.textareaParentStyle.height = "1px";
    removeClass(this.TEXTAREA_PARENT, this.layerClass);
    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
  }
  /**
   * Resets an editable element position.
   *
   * @private
   */
  showEditableElement() {
    this.textareaParentStyle.height = "";
    this.textareaParentStyle.overflow = "";
    this.textareaParentStyle.position = "";
    this.textareaParentStyle[this.hot.isRtl() ? "left" : "right"] = "auto";
    this.textareaParentStyle.opacity = "1";
    this.textareaStyle.textIndent = "";
    this.textareaStyle.overflowY = "hidden";
    const childNodes = this.TEXTAREA_PARENT.childNodes;
    let hasClassHandsontableEditor = false;
    rangeEach(childNodes.length - 1, (index) => {
      const childNode = childNodes[index];
      if (hasClass(childNode, "handsontableEditor")) {
        hasClassHandsontableEditor = true;
        return false;
      }
    });
    if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {
      removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);
    }
    if (hasClassHandsontableEditor) {
      this.layerClass = EDITOR_VISIBLE_CLASS_NAME;
      addClass(this.TEXTAREA_PARENT, this.layerClass);
    } else {
      this.layerClass = this.getEditedCellsLayerClass();
      addClass(this.TEXTAREA_PARENT, this.layerClass);
    }
  }
  /**
   * Refreshes editor's value using source data.
   *
   * @private
   */
  refreshValue() {
    const physicalRow = this.hot.toPhysicalRow(this.row);
    const sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);
    this.originalValue = sourceData;
    this.setValue(sourceData);
    this.refreshDimensions();
  }
  /**
   * Refreshes editor's size and position.
   *
   * @private
   * @param {boolean} force Indicates if the refreshing editor dimensions should be triggered.
   */
  refreshDimensions() {
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (this.state !== EDITOR_STATE.EDITING && !force) {
      return;
    }
    this.TD = this.getEditedCell();
    if (!this.TD) {
      if (!force) {
        this.close();
      }
      return;
    }
    const {
      top,
      start,
      width,
      maxWidth,
      height,
      maxHeight
    } = this.getEditedCellRect();
    this.textareaParentStyle.top = `${top}px`;
    this.textareaParentStyle[this.hot.isRtl() ? "right" : "left"] = `${start}px`;
    this.showEditableElement();
    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);
    this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;
    this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;
    this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;
    const textareaComputedStyle = getComputedStyle(this.TEXTAREA);
    const horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + parseInt(textareaComputedStyle.paddingRight, 10);
    const verticalPadding = parseInt(textareaComputedStyle.paddingTop, 10) + parseInt(textareaComputedStyle.paddingBottom, 10);
    const finalWidth = width - horizontalPadding;
    const finalHeight = height - verticalPadding;
    const finalMaxWidth = maxWidth - horizontalPadding;
    const finalMaxHeight = maxHeight - verticalPadding;
    this.autoResize.init(this.TEXTAREA, {
      minWidth: Math.min(finalWidth, finalMaxWidth),
      minHeight: Math.min(finalHeight, finalMaxHeight),
      // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
      maxWidth: finalMaxWidth,
      maxHeight: finalMaxHeight
    }, true);
  }
  /**
   * Binds events and hooks.
   *
   * @private
   */
  bindEvents() {
    if (isIOS()) {
      this.eventManager.addEventListener(this.TEXTAREA, "focusout", () => this.finishEditing(false));
    }
    this.addHook("afterScrollHorizontally", () => this.refreshDimensions());
    this.addHook("afterScrollVertically", () => this.refreshDimensions());
    this.addHook("afterColumnResize", () => {
      this.refreshDimensions();
      if (this.state === EDITOR_STATE.EDITING) {
        this.focus();
      }
    });
    this.addHook("afterRowResize", () => {
      this.refreshDimensions();
      if (this.state === EDITOR_STATE.EDITING) {
        this.focus();
      }
    });
  }
  /**
   * Ugly hack for autocompleteEditor.
   *
   * @private
   */
  allowKeyEventPropagation() {
  }
  /**
   * Destroys the internal event manager and clears attached hooks.
   *
   * @private
   */
  destroy() {
    this.eventManager.destroy();
    this.clearHooks();
  }
  /**
   * Register shortcuts responsible for handling editor.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    const gridContext = shortcutManager.getContext("grid");
    const contextConfig = {
      runOnlyIf: () => isDefined(this.hot.getSelected()),
      group: SHORTCUTS_GROUP
    };
    const insertNewLine = () => {
      this.hot.rootDocument.execCommand("insertText", false, "\n");
    };
    editorContext.addShortcuts([{
      keys: [["Tab"], ["Shift", "Tab"], ["PageUp"], ["PageDown"]],
      forwardToContext: gridContext,
      callback: () => {
      }
    }, {
      keys: [["Control", "Enter"]],
      callback: () => {
        insertNewLine();
        return false;
      },
      runOnlyIf: (event2) => !this.hot.selection.isMultiple() && // We trigger a data population for multiple selection.
      // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
      !event2.altKey
    }, {
      keys: [["Meta", "Enter"]],
      callback: () => {
        insertNewLine();
        return false;
      },
      runOnlyIf: () => !this.hot.selection.isMultiple()
      // We trigger a data population for multiple selection.
    }, {
      keys: [["Alt", "Enter"]],
      callback: () => {
        insertNewLine();
        return false;
      }
    }, {
      keys: [["Home"]],
      callback: (event2, _ref) => {
        let [keyName] = _ref;
        updateCaretPosition(keyName, this.TEXTAREA);
      }
    }, {
      keys: [["End"]],
      callback: (event2, _ref2) => {
        let [keyName] = _ref2;
        updateCaretPosition(keyName, this.TEXTAREA);
      }
    }], contextConfig);
  }
  /**
   * Unregister shortcuts responsible for handling editor.
   *
   * @private
   */
  unregisterShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const editorContext = shortcutManager.getContext("editor");
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);
    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);
  }
};

export {
  SHORTCUTS_GROUP_NAVIGATION,
  editorManager_default,
  EDITOR_TYPE,
  EDITOR_STATE,
  BaseEditor,
  EDITOR_TYPE2,
  TextEditor
};
//# sourceMappingURL=chunk-N3L74F4Z.js.map
