import {
  ACTIVE_HEADER_TYPE,
  HEADER_TYPE,
  HidingMap,
  IndexMap,
  IndexesSequence,
  LinkedPhysicalIndexToValueMap,
  PhysicalIndexToValueMap,
  TrimmingMap,
  _dataToHTML,
  alterUtilsFactory,
  cancelAnimationFrame,
  dataRowToChangesArray,
  detectSelectionType,
  getComparisonFunction,
  getDecreasedIndexes,
  getIncreasedIndexes,
  getPluginsNames,
  hasPlugin,
  htmlToGridSettings,
  isArrayOfArrays,
  isArrayOfObjects,
  isTouchSupported,
  localHooks_default,
  normalizeSelectionFactory,
  parse,
  registerPlugin,
  requestAnimationFrame,
  stringify as stringify2,
  transformSelectionToColumnDistance,
  transformSelectionToRowDistance,
  viewportColumns_default,
  viewportRows_default
} from "./chunk-JED7MOYF.js";
import {
  hasItem as hasItem4
} from "./chunk-3RNNLNAE.js";
import {
  CONTEXTMENU_ITEMS_ADD_COMMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT,
  CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM,
  CONTEXTMENU_ITEMS_ALIGNMENT_CENTER,
  CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY,
  CONTEXTMENU_ITEMS_ALIGNMENT_LEFT,
  CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE,
  CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT,
  CONTEXTMENU_ITEMS_ALIGNMENT_TOP,
  CONTEXTMENU_ITEMS_BORDERS,
  CONTEXTMENU_ITEMS_BORDERS_BOTTOM,
  CONTEXTMENU_ITEMS_BORDERS_LEFT,
  CONTEXTMENU_ITEMS_BORDERS_RIGHT,
  CONTEXTMENU_ITEMS_BORDERS_TOP,
  CONTEXTMENU_ITEMS_CLEAR_COLUMN,
  CONTEXTMENU_ITEMS_COPY,
  CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY,
  CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS,
  CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS,
  CONTEXTMENU_ITEMS_CUT,
  CONTEXTMENU_ITEMS_EDIT_COMMENT,
  CONTEXTMENU_ITEMS_FREEZE_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_COLUMN,
  CONTEXTMENU_ITEMS_HIDE_ROW,
  CONTEXTMENU_ITEMS_INSERT_LEFT,
  CONTEXTMENU_ITEMS_INSERT_RIGHT,
  CONTEXTMENU_ITEMS_MERGE_CELLS,
  CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD,
  CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD,
  CONTEXTMENU_ITEMS_NO_ITEMS,
  CONTEXTMENU_ITEMS_READ_ONLY,
  CONTEXTMENU_ITEMS_READ_ONLY_COMMENT,
  CONTEXTMENU_ITEMS_REDO,
  CONTEXTMENU_ITEMS_REMOVE_BORDERS,
  CONTEXTMENU_ITEMS_REMOVE_COLUMN,
  CONTEXTMENU_ITEMS_REMOVE_COMMENT,
  CONTEXTMENU_ITEMS_REMOVE_ROW,
  CONTEXTMENU_ITEMS_ROW_ABOVE,
  CONTEXTMENU_ITEMS_ROW_BELOW,
  CONTEXTMENU_ITEMS_SHOW_COLUMN,
  CONTEXTMENU_ITEMS_SHOW_ROW,
  CONTEXTMENU_ITEMS_UNDO,
  CONTEXTMENU_ITEMS_UNFREEZE_COLUMN,
  CONTEXTMENU_ITEMS_UNMERGE_CELLS,
  FILTERS_BUTTONS_CANCEL,
  FILTERS_BUTTONS_CLEAR,
  FILTERS_BUTTONS_OK,
  FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
  FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE,
  FILTERS_BUTTONS_PLACEHOLDER_VALUE,
  FILTERS_BUTTONS_SELECT_ALL,
  FILTERS_CONDITIONS_AFTER,
  FILTERS_CONDITIONS_BEFORE,
  FILTERS_CONDITIONS_BEGINS_WITH,
  FILTERS_CONDITIONS_BETWEEN,
  FILTERS_CONDITIONS_CONTAINS,
  FILTERS_CONDITIONS_EMPTY,
  FILTERS_CONDITIONS_ENDS_WITH,
  FILTERS_CONDITIONS_EQUAL,
  FILTERS_CONDITIONS_GREATER_THAN,
  FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_LESS_THAN,
  FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  FILTERS_CONDITIONS_NAMESPACE,
  FILTERS_CONDITIONS_NONE,
  FILTERS_CONDITIONS_NOT_BETWEEN,
  FILTERS_CONDITIONS_NOT_CONTAIN,
  FILTERS_CONDITIONS_NOT_EMPTY,
  FILTERS_CONDITIONS_NOT_EQUAL,
  FILTERS_CONDITIONS_TODAY,
  FILTERS_CONDITIONS_TOMORROW,
  FILTERS_CONDITIONS_YESTERDAY,
  FILTERS_DIVS_FILTER_BY_CONDITION,
  FILTERS_DIVS_FILTER_BY_VALUE,
  FILTERS_LABELS_CONJUNCTION,
  FILTERS_LABELS_DISJUNCTION,
  FILTERS_NAMESPACE,
  FILTERS_VALUES_BLANK_CELLS,
  hasItem as hasItem2
} from "./chunk-YR3BPVTS.js";
import {
  hasItem as hasItem3
} from "./chunk-JCAYH75Q.js";
import {
  hasItem,
  isChrome,
  isIpadOS,
  isKey,
  isMobileBrowser,
  isSafari,
  isWindowsOS
} from "./chunk-QS5TVTBW.js";
import {
  A11Y_DISABLED,
  A11Y_EXPANDED,
  A11Y_HASPOPUP,
  A11Y_HIDDEN,
  A11Y_LABEL,
  A11Y_LISTBOX,
  A11Y_MENU,
  A11Y_MENU_ITEM,
  A11Y_SORT,
  A11Y_TABINDEX,
  addClass,
  arrayEach,
  arrayFilter,
  arrayMap,
  arrayReduce,
  arrayUnique,
  clamp,
  clone,
  closest,
  curry,
  debounce,
  deepClone,
  deepExtend,
  defineGetter,
  empty,
  error,
  eventManager_default,
  extend,
  fastInnerHTML,
  fastInnerText,
  getParentWindow,
  getScrollbarWidth,
  getStyle,
  getTrimmingContainer,
  hasClass,
  hasOwnProperty,
  inherit,
  init_moment,
  isChildOf,
  isDefined,
  isDetached,
  isEmpty,
  isFunction,
  isLeftClick,
  isNumeric,
  isObject,
  isObjectEqual,
  isPercentValue,
  isRightClick,
  isUndefined,
  isVisible,
  makeElementContentEditableAndSelectItsContent,
  mixin,
  moment_default,
  objectEach,
  offset,
  offsetRelativeTo,
  outerHeight,
  outerWidth,
  partial,
  pluginHooks_default,
  rangeEach,
  rangeEachReverse,
  removeAttribute,
  removeClass,
  removeContentEditableFromElementAndDeselect,
  require_array_set_length,
  require_does_not_exceed_safe_integer,
  require_export,
  require_length_of_array_like,
  require_to_object,
  require_try_to_string,
  runWithSelectedContendEditableElement,
  sanitize,
  setAttribute,
  staticRegister,
  stopImmediatePropagation,
  stringify,
  substitute,
  toSingleLine,
  toUpperCaseFirst,
  valueAccordingPercent,
  warn
} from "./chunk-ST45JAFY.js";
import {
  __commonJS
} from "./chunk-AUZ3RYOM.js";

// node_modules/core-js/internals/delete-property-or-throw.js
var require_delete_property_or_throw = __commonJS({
  "node_modules/core-js/internals/delete-property-or-throw.js"(exports, module) {
    "use strict";
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(O, P) {
      if (!delete O[P])
        throw new $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
    };
  }
});

// node_modules/handsontable/plugins/base/base.mjs
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var DEPS_TYPE_CHECKERS = /* @__PURE__ */ new Map([["plugin", hasPlugin], ["cell-type", hasItem4], ["editor", hasItem], ["renderer", hasItem2], ["validator", hasItem3]]);
var PLUGIN_KEY = "base";
var missingDepsMsgs = [];
var initializedPlugins = null;
var _hooks = /* @__PURE__ */ new WeakMap();
var _isRelevantToSettings = /* @__PURE__ */ new WeakSet();
var BasePlugin = class {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY;
  }
  /**
   * The `SETTING_KEYS` getter defines the keys that, when present in the config object, trigger the plugin update
   * after the `updateSettings` calls.
   * - When it returns `true`, the plugin updates after all `updateSettings` calls, regardless of the contents of the
   * config object.
   * - When it returns `false`, the plugin never updates on `updateSettings` calls.
   *
   * @returns {string[] | boolean}
   */
  static get SETTING_KEYS() {
    return [this.PLUGIN_KEY];
  }
  /**
   * The instance of the {@link EventManager} class.
   *
   * @type {EventManager}
   */
  /**
   * @param {object} hotInstance Handsontable instance.
   */
  constructor(hotInstance) {
    _classPrivateMethodInitSpec(this, _isRelevantToSettings);
    _defineProperty(this, "eventManager", new eventManager_default(this));
    _defineProperty(this, "pluginName", null);
    _defineProperty(this, "pluginsInitializedCallbacks", []);
    _defineProperty(this, "isPluginsReady", false);
    _defineProperty(this, "enabled", false);
    _defineProperty(this, "initialized", false);
    _classPrivateFieldInitSpec(this, _hooks, {
      writable: true,
      value: {}
    });
    defineGetter(this, "hot", hotInstance, {
      writable: false
    });
    initializedPlugins = null;
    this.hot.addHook("afterPluginsInitialized", () => this.onAfterPluginsInitialized());
    this.hot.addHook("afterUpdateSettings", (newSettings) => this.onUpdateSettings(newSettings));
    this.hot.addHook("beforeInit", () => this.init());
  }
  init() {
    this.pluginName = this.hot.getPluginName(this);
    const pluginDeps = this.constructor.PLUGIN_DEPS;
    const deps = Array.isArray(pluginDeps) ? pluginDeps : [];
    if (deps.length > 0) {
      const missingDependencies = [];
      deps.forEach((dependency) => {
        const [type, moduleName] = dependency.split(":");
        if (!DEPS_TYPE_CHECKERS.has(type)) {
          throw new Error(`Unknown plugin dependency type "${type}" was found.`);
        }
        if (!DEPS_TYPE_CHECKERS.get(type)(moduleName)) {
          missingDependencies.push(` - ${moduleName} (${type})`);
        }
      });
      if (missingDependencies.length > 0) {
        const errorMsg = [`The ${this.pluginName} plugin requires the following modules:
`, `${missingDependencies.join("\n")}
`].join("");
        missingDepsMsgs.push(errorMsg);
      }
    }
    if (!initializedPlugins) {
      initializedPlugins = getPluginsNames();
    }
    if (initializedPlugins.indexOf("UndoRedo") >= 0) {
      initializedPlugins.splice(initializedPlugins.indexOf("UndoRedo"), 1);
    }
    if (initializedPlugins.indexOf(this.pluginName) >= 0) {
      initializedPlugins.splice(initializedPlugins.indexOf(this.pluginName), 1);
    }
    this.hot.addHookOnce("afterPluginsInitialized", () => {
      if (this.isEnabled && this.isEnabled()) {
        this.enablePlugin();
      }
    });
    const isAllPluginsAreInitialized = initializedPlugins.length === 0;
    if (isAllPluginsAreInitialized) {
      if (missingDepsMsgs.length > 0) {
        const errorMsg = [`${missingDepsMsgs.join("\n")}
`, "You have to import and register them manually."].join("");
        throw new Error(errorMsg);
      }
      this.hot.runHooks("afterPluginsInitialized");
    }
    this.initialized = true;
  }
  /**
   * Enable plugin for this Handsontable instance.
   */
  enablePlugin() {
    this.enabled = true;
  }
  /**
   * Disable plugin for this Handsontable instance.
   */
  disablePlugin() {
    var _this$eventManager;
    (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 || _this$eventManager.clear();
    this.clearHooks();
    this.enabled = false;
  }
  /**
   * Add listener to plugin hooks system.
   *
   * @param {string} name The hook name.
   * @param {Function} callback The listener function to add.
   */
  addHook(name, callback) {
    _classPrivateFieldGet(this, _hooks)[name] = _classPrivateFieldGet(this, _hooks)[name] || [];
    const hooks = _classPrivateFieldGet(this, _hooks)[name];
    this.hot.addHook(name, callback);
    hooks.push(callback);
    _classPrivateFieldGet(this, _hooks)[name] = hooks;
  }
  /**
   * Remove all hooks listeners by hook name.
   *
   * @param {string} name The hook name.
   */
  removeHooks(name) {
    arrayEach(_classPrivateFieldGet(this, _hooks)[name] || [], (callback) => {
      this.hot.removeHook(name, callback);
    });
  }
  /**
   * Clear all hooks.
   */
  clearHooks() {
    const hooks = _classPrivateFieldGet(this, _hooks);
    objectEach(hooks, (callbacks, name) => this.removeHooks(name));
    hooks.length = 0;
  }
  /**
   * Register function which will be immediately called after all plugins initialized.
   *
   * @param {Function} callback The listener function to call.
   */
  callOnPluginsReady(callback) {
    if (this.isPluginsReady) {
      callback();
    } else {
      this.pluginsInitializedCallbacks.push(callback);
    }
  }
  /**
   * On after plugins initialized listener.
   *
   * @private
   */
  onAfterPluginsInitialized() {
    arrayEach(this.pluginsInitializedCallbacks, (callback) => callback());
    this.pluginsInitializedCallbacks.length = 0;
    this.isPluginsReady = true;
  }
  /**
   * On update settings listener.
   *
   * @private
   * @param {object} newSettings New set of settings passed to the `updateSettings` method.
   */
  onUpdateSettings(newSettings) {
    const relevantToSettings = _classPrivateMethodGet(this, _isRelevantToSettings, _isRelevantToSettings2).call(this, newSettings);
    if (this.isEnabled) {
      if (this.enabled && !this.isEnabled()) {
        this.disablePlugin();
      }
      if (!this.enabled && this.isEnabled()) {
        this.enablePlugin();
      }
      if (this.enabled && this.isEnabled() && relevantToSettings) {
        this.updatePlugin(newSettings);
      }
    }
  }
  /**
   * Updates the plugin to use the latest options you have specified.
   *
   * @private
   */
  updatePlugin() {
  }
  /**
   * Destroy plugin.
   */
  destroy() {
    var _this$eventManager2;
    (_this$eventManager2 = this.eventManager) === null || _this$eventManager2 === void 0 || _this$eventManager2.destroy();
    this.clearHooks();
    objectEach(this, (value, property) => {
      if (property !== "hot") {
        this[property] = null;
      }
    });
    delete this.t;
    delete this.hot;
  }
};
function _isRelevantToSettings2(settings) {
  if (!settings) {
    return false;
  }
  const settingKeys = this.constructor.SETTING_KEYS;
  if (typeof settingKeys === "boolean") {
    return settingKeys;
  }
  for (let i = 0; i < settingKeys.length; i++) {
    if (settings[settingKeys[i]] !== void 0) {
      return true;
    }
  }
  return false;
}

// node_modules/handsontable/utils/ghostTable.mjs
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var GhostTable = class {
  constructor(hotInstance) {
    _defineProperty2(this, "hot", null);
    _defineProperty2(this, "container", null);
    _defineProperty2(this, "injected", false);
    _defineProperty2(this, "rows", []);
    _defineProperty2(this, "columns", []);
    _defineProperty2(this, "samples", null);
    _defineProperty2(this, "settings", {
      useHeaders: true
    });
    this.hot = hotInstance;
  }
  /**
   * Add row.
   *
   * @param {number} row Row index.
   * @param {Map} samples Samples Map object.
   */
  addRow(row, samples) {
    if (this.columns.length) {
      throw new Error("Doesn't support multi-dimensional table");
    }
    if (!this.rows.length) {
      this.container = this.createContainer(this.hot.rootElement.className);
    }
    const rowObject = {
      row
    };
    this.rows.push(rowObject);
    this.samples = samples;
    this.table = this.createTable(this.hot.table.className);
    this.table.colGroup.appendChild(this.createColGroupsCol(row));
    this.table.tr.appendChild(this.createRow(row));
    this.container.container.appendChild(this.table.fragment);
    rowObject.table = this.table.table;
  }
  /**
   * Add a row consisting of the column headers.
   *
   * @param {Map} samples A map with sampled table values.
   */
  addColumnHeadersRow(samples) {
    const colHeader = this.hot.getColHeader(0);
    if (colHeader !== null && colHeader !== void 0) {
      const rowObject = {
        row: -1
      };
      this.rows.push(rowObject);
      this.container = this.createContainer(this.hot.rootElement.className);
      this.samples = samples;
      this.table = this.createTable(this.hot.table.className);
      this.table.colGroup.appendChild(this.createColGroupsCol());
      this.appendColumnHeadersRow();
      this.container.container.appendChild(this.table.fragment);
      rowObject.table = this.table.table;
    }
  }
  /**
   * Add column.
   *
   * @param {number} column Column index.
   * @param {Map} samples A map with sampled table values.
   */
  addColumn(column, samples) {
    if (this.rows.length) {
      throw new Error("Doesn't support multi-dimensional table");
    }
    if (!this.columns.length) {
      this.container = this.createContainer(this.hot.rootElement.className);
    }
    const columnObject = {
      col: column
    };
    this.columns.push(columnObject);
    this.samples = samples;
    this.table = this.createTable(this.hot.table.className);
    if (this.getSetting("useHeaders") && this.hot.getColHeader(column) !== null) {
      this.hot.view.appendColHeader(column, this.table.th);
    }
    this.table.tBody.appendChild(this.createCol(column));
    this.container.container.appendChild(this.table.fragment);
    columnObject.table = this.table.table;
  }
  /**
   * Get calculated heights.
   *
   * @param {Function} callback Callback which will be fired for each calculated row.
   */
  getHeights(callback) {
    if (!this.injected) {
      this.injectTable();
    }
    arrayEach(this.rows, (row) => {
      callback(row.row, outerHeight(row.table) - 1);
    });
  }
  /**
   * Get calculated widths.
   *
   * @param {Function} callback Callback which will be fired for each calculated column.
   */
  getWidths(callback) {
    if (!this.injected) {
      this.injectTable();
    }
    arrayEach(this.columns, (column) => {
      const {
        width
      } = column.table.getBoundingClientRect();
      callback(column.col, Math.ceil(width));
    });
  }
  /**
   * Set the Ghost Table settings to the provided object.
   *
   * @param {object} settings New Ghost Table Settings.
   */
  setSettings(settings) {
    this.settings = settings;
  }
  /**
   * Set a single setting of the Ghost Table.
   *
   * @param {string} name Setting name.
   * @param {*} value Setting value.
   */
  setSetting(name, value) {
    if (!this.settings) {
      this.settings = {};
    }
    this.settings[name] = value;
  }
  /**
   * Get the Ghost Table settings.
   *
   * @returns {object|null}
   */
  getSettings() {
    return this.settings;
  }
  /**
   * Get a single Ghost Table setting.
   *
   * @param {string} name The setting name to get.
   * @returns {boolean|null}
   */
  getSetting(name) {
    if (this.settings) {
      return this.settings[name];
    }
    return null;
  }
  /**
   * Create colgroup col elements.
   *
   * @param {number} row Visual row index.
   * @returns {DocumentFragment}
   */
  createColGroupsCol(row) {
    const fragment = this.hot.rootDocument.createDocumentFragment();
    if (this.hot.hasRowHeaders()) {
      fragment.appendChild(this.createColElement(-1, -1));
    }
    this.samples.forEach((sample) => {
      arrayEach(sample.strings, (string) => {
        fragment.appendChild(this.createColElement(string.col, row));
      });
    });
    return fragment;
  }
  /**
   * Create table row element.
   *
   * @param {number} row Row index.
   * @returns {DocumentFragment} Returns created table row elements.
   */
  createRow(row) {
    const {
      rootDocument
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    const th = rootDocument.createElement("th");
    if (this.hot.hasRowHeaders()) {
      this.hot.view.appendRowHeader(row, th);
      fragment.appendChild(th);
    }
    this.samples.forEach((sample) => {
      arrayEach(sample.strings, (string) => {
        const column = string.col;
        const cellProperties = this.hot.getCellMeta(row, column);
        cellProperties.col = column;
        cellProperties.row = row;
        const renderer = this.hot.getCellRenderer(cellProperties);
        const td = rootDocument.createElement("td");
        td.setAttribute("ghost-table", 1);
        renderer(this.hot, td, row, column, this.hot.colToProp(column), string.value, cellProperties);
        fragment.appendChild(td);
      });
    });
    return fragment;
  }
  /**
   * Creates DOM elements for headers and appends them to the THEAD element of the table.
   */
  appendColumnHeadersRow() {
    const {
      rootDocument
    } = this.hot;
    const domFragment = rootDocument.createDocumentFragment();
    const columnHeaders = [];
    if (this.hot.hasRowHeaders()) {
      const th = rootDocument.createElement("th");
      columnHeaders.push([-1, th]);
      domFragment.appendChild(th);
    }
    this.samples.forEach((sample) => {
      arrayEach(sample.strings, (string) => {
        const column = string.col;
        const th = rootDocument.createElement("th");
        columnHeaders.push([column, th]);
        domFragment.appendChild(th);
      });
    });
    this.table.tHead.appendChild(domFragment);
    arrayEach(columnHeaders, (columnHeader) => {
      const [column, th] = columnHeader;
      this.hot.view.appendColHeader(column, th);
    });
  }
  /**
   * Create table column elements.
   *
   * @param {number} column Column index.
   * @returns {DocumentFragment} Returns created column table column elements.
   */
  createCol(column) {
    const {
      rootDocument
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    this.samples.forEach((sample) => {
      arrayEach(sample.strings, (string) => {
        const row = string.row;
        const cellProperties = this.hot.getCellMeta(row, column);
        cellProperties.col = column;
        cellProperties.row = row;
        const renderer = this.hot.getCellRenderer(cellProperties);
        const td = rootDocument.createElement("td");
        const tr = rootDocument.createElement("tr");
        td.setAttribute("ghost-table", 1);
        renderer(this.hot, td, row, column, this.hot.colToProp(column), string.value, cellProperties);
        tr.appendChild(td);
        fragment.appendChild(tr);
      });
    });
    return fragment;
  }
  /**
   * Remove table from document and reset internal state.
   */
  clean() {
    this.rows.length = 0;
    this.rows[-1] = void 0;
    this.columns.length = 0;
    if (this.samples) {
      this.samples.clear();
    }
    this.samples = null;
    this.removeTable();
  }
  /**
   * Inject generated table into document.
   *
   * @param {HTMLElement} [parent=null] The element to which the ghost table is injected.
   */
  injectTable() {
    let parent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (!this.injected) {
      (parent || this.hot.rootElement).appendChild(this.container.fragment);
      this.injected = true;
    }
  }
  /**
   * Remove table from document.
   */
  removeTable() {
    if (this.injected && this.container.container.parentNode) {
      this.container.container.parentNode.removeChild(this.container.container);
      this.container = null;
      this.injected = false;
    }
  }
  /**
   * Create col element.
   *
   * @param {number} column Visual column index.
   * @param {number} row Visual row index.
   * @returns {HTMLElement}
   */
  createColElement(column, row) {
    const col = this.hot.rootDocument.createElement("col");
    let colspan = 0;
    if (row >= 0 && column >= 0) {
      colspan = this.hot.getCellMeta(row, column).colspan;
    }
    let width = this.hot.view._wt.wtTable.getStretchedColumnWidth(column);
    if (colspan > 1) {
      for (let nextColumn = column + 1; nextColumn < column + colspan; nextColumn++) {
        width += this.hot.view._wt.wtTable.getStretchedColumnWidth(nextColumn);
      }
    }
    col.style.width = `${width}px`;
    return col;
  }
  /**
   * Create table element.
   *
   * @param {string} className The CSS classes to add.
   * @returns {object}
   */
  createTable() {
    let className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const {
      rootDocument
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    const table = rootDocument.createElement("table");
    const tHead = rootDocument.createElement("thead");
    const tBody = rootDocument.createElement("tbody");
    const colGroup = rootDocument.createElement("colgroup");
    const tr = rootDocument.createElement("tr");
    const th = rootDocument.createElement("th");
    if (this.isVertical()) {
      table.appendChild(colGroup);
    }
    if (this.isHorizontal()) {
      tr.appendChild(th);
      tHead.appendChild(tr);
      table.style.tableLayout = "auto";
      table.style.width = "auto";
    }
    table.appendChild(tHead);
    if (this.isVertical()) {
      tBody.appendChild(tr);
    }
    table.appendChild(tBody);
    addClass(table, className);
    fragment.appendChild(table);
    return {
      fragment,
      table,
      tHead,
      tBody,
      colGroup,
      tr,
      th
    };
  }
  /**
   * Create container for tables.
   *
   * @param {string} className The CSS classes to add.
   * @returns {object}
   */
  createContainer() {
    let className = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const {
      rootDocument
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    const container = rootDocument.createElement("div");
    const containerClassName = `htGhostTable htAutoSize ${className.trim()}`;
    addClass(container, containerClassName);
    fragment.appendChild(container);
    return {
      fragment,
      container
    };
  }
  /**
   * Checks if table is raised vertically (checking rows).
   *
   * @returns {boolean}
   */
  isVertical() {
    return !!(this.rows.length && !this.columns.length);
  }
  /**
   * Checks if table is raised horizontally (checking columns).
   *
   * @returns {boolean}
   */
  isHorizontal() {
    return !!(this.columns.length && !this.rows.length);
  }
};
var ghostTable_default = GhostTable;

// node_modules/handsontable/utils/samplesGenerator.mjs
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive3(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var SamplesGenerator = class _SamplesGenerator {
  /**
   * Number of samples to take of each value length.
   *
   * @type {number}
   */
  static get SAMPLE_COUNT() {
    return 3;
  }
  /**
   * Samples prepared for calculations.
   *
   * @type {Map}
   * @default {null}
   */
  constructor(dataFactory) {
    _defineProperty3(this, "samples", null);
    _defineProperty3(this, "dataFactory", null);
    _defineProperty3(this, "customSampleCount", null);
    _defineProperty3(this, "allowDuplicates", false);
    this.dataFactory = dataFactory;
  }
  /**
   * Get the sample count for this instance.
   *
   * @returns {number}
   */
  getSampleCount() {
    if (this.customSampleCount) {
      return this.customSampleCount;
    }
    return _SamplesGenerator.SAMPLE_COUNT;
  }
  /**
   * Set the sample count.
   *
   * @param {number} sampleCount Number of samples to be collected.
   */
  setSampleCount(sampleCount) {
    this.customSampleCount = sampleCount;
  }
  /**
   * Set if the generator should accept duplicate values.
   *
   * @param {boolean} allowDuplicates `true` to allow duplicate values.
   */
  setAllowDuplicates(allowDuplicates) {
    this.allowDuplicates = allowDuplicates;
  }
  /**
   * Generate samples for row. You can control which area should be sampled by passing `rowRange` object and `colRange` object.
   *
   * @param {object|number} rowRange The rows range to generate the samples.
   * @param {object} colRange The column range to generate the samples.
   * @returns {object}
   */
  generateRowSamples(rowRange, colRange) {
    return this.generateSamples("row", colRange, rowRange);
  }
  /**
   * Generate samples for column. You can control which area should be sampled by passing `colRange` object and `rowRange` object.
   *
   * @param {object} colRange Column index.
   * @param {object} rowRange Column index.
   * @returns {object}
   */
  generateColumnSamples(colRange, rowRange) {
    return this.generateSamples("col", rowRange, colRange);
  }
  /**
   * Generate collection of samples.
   *
   * @param {string} type Type to generate. Can be `col` or `row`.
   * @param {object} range The range to generate the samples.
   * @param {object|number} specifierRange The range to generate the samples.
   * @returns {Map}
   */
  generateSamples(type, range, specifierRange) {
    const samples = /* @__PURE__ */ new Map();
    const {
      from,
      to
    } = typeof specifierRange === "number" ? {
      from: specifierRange,
      to: specifierRange
    } : specifierRange;
    rangeEach(from, to, (index) => {
      const sample = this.generateSample(type, range, index);
      samples.set(index, sample);
    });
    return samples;
  }
  /**
   * Generate sample for specified type (`row` or `col`).
   *
   * @param {string} type Samples type `row` or `col`.
   * @param {object} range The range to generate the samples.
   * @param {number} specifierValue The range to generate the samples.
   * @returns {Map}
   */
  generateSample(type, range, specifierValue) {
    if (type !== "row" && type !== "col") {
      throw new Error("Unsupported sample type");
    }
    const samples = /* @__PURE__ */ new Map();
    const computedKey = type === "row" ? "col" : "row";
    const sampledValues = [];
    rangeEach(range.from, range.to, (index) => {
      const data = type === "row" ? this.dataFactory(specifierValue, index) : this.dataFactory(index, specifierValue);
      if (data === false) {
        return;
      }
      const {
        value,
        bundleSeed
      } = data;
      const hasCustomBundleSeed = typeof bundleSeed === "string" && bundleSeed.length > 0;
      let seed;
      if (hasCustomBundleSeed) {
        seed = bundleSeed;
      } else if (isObject(value)) {
        seed = `${Object.keys(value).length}`;
      } else if (Array.isArray(value)) {
        seed = `${value.length}`;
      } else {
        seed = `${stringify(value).length}`;
      }
      if (!samples.has(seed)) {
        samples.set(seed, {
          needed: this.getSampleCount(),
          strings: []
        });
      }
      const sample = samples.get(seed);
      if (sample.needed) {
        const duplicate = sampledValues.indexOf(value) > -1;
        if (!duplicate || this.allowDuplicates || hasCustomBundleSeed) {
          sample.strings.push({
            value,
            [computedKey]: index
          });
          sampledValues.push(value);
          sample.needed -= 1;
        }
      }
    });
    return samples;
  }
};
var samplesGenerator_default = SamplesGenerator;

// node_modules/handsontable/plugins/autoColumnSize/autoColumnSize.mjs
function _classPrivateMethodInitSpec2(obj, privateSet) {
  _checkPrivateRedeclaration2(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec2(obj, privateMap, value) {
  _checkPrivateRedeclaration2(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration2(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty4(obj, key, value) {
  key = _toPropertyKey4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey4(arg) {
  var key = _toPrimitive4(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive4(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet2(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor2(receiver, privateMap, "get");
  return _classApplyDescriptorGet2(receiver, descriptor);
}
function _classExtractFieldDescriptor2(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet2(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet2(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
pluginHooks_default.getSingleton().register("modifyAutoColumnSizeSeed");
var PLUGIN_KEY2 = "autoColumnSize";
var PLUGIN_PRIORITY = 10;
var COLUMN_SIZE_MAP_NAME = "autoColumnSize";
var _cachedColumnHeaders = /* @__PURE__ */ new WeakMap();
var _onBeforeViewRender = /* @__PURE__ */ new WeakSet();
var _onAfterLoadData = /* @__PURE__ */ new WeakSet();
var _onBeforeChange = /* @__PURE__ */ new WeakSet();
var _onBeforeColumnResize = /* @__PURE__ */ new WeakSet();
var _onAfterInit = /* @__PURE__ */ new WeakSet();
var _onAfterFormulasValuesUpdate = /* @__PURE__ */ new WeakSet();
var AutoColumnSize = class _AutoColumnSize extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY2;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY;
  }
  static get SETTING_KEYS() {
    return true;
  }
  static get CALCULATION_STEP() {
    return 50;
  }
  static get SYNC_CALCULATION_LIMIT() {
    return 50;
  }
  /**
   * Instance of {@link GhostTable} for rows and columns size calculations.
   *
   * @private
   * @type {GhostTable}
   */
  constructor(hotInstance) {
    super(hotInstance);
    _classPrivateMethodInitSpec2(this, _onAfterFormulasValuesUpdate);
    _classPrivateMethodInitSpec2(this, _onAfterInit);
    _classPrivateMethodInitSpec2(this, _onBeforeColumnResize);
    _classPrivateMethodInitSpec2(this, _onBeforeChange);
    _classPrivateMethodInitSpec2(this, _onAfterLoadData);
    _classPrivateMethodInitSpec2(this, _onBeforeViewRender);
    _defineProperty4(this, "ghostTable", new ghostTable_default(this.hot));
    _defineProperty4(this, "samplesGenerator", new samplesGenerator_default((row, column) => {
      const cellMeta = this.hot.getCellMeta(row, column);
      let cellValue = "";
      if (!cellMeta.spanned) {
        cellValue = this.hot.getDataAtCell(row, column);
      }
      let bundleSeed = "";
      if (this.hot.hasHook("modifyAutoColumnSizeSeed")) {
        bundleSeed = this.hot.runHooks("modifyAutoColumnSizeSeed", bundleSeed, cellMeta, cellValue);
      }
      return {
        value: cellValue,
        bundleSeed
      };
    }));
    _defineProperty4(this, "firstCalculation", true);
    _defineProperty4(this, "inProgress", false);
    _defineProperty4(this, "measuredColumns", 0);
    _defineProperty4(this, "columnWidthsMap", new PhysicalIndexToValueMap());
    _classPrivateFieldInitSpec2(this, _cachedColumnHeaders, {
      writable: true,
      value: []
    });
    this.hot.columnIndexMapper.registerMap(COLUMN_SIZE_MAP_NAME, this.columnWidthsMap);
    this.addHook("beforeColumnResize", (size, column, isDblClick) => _classPrivateMethodGet2(this, _onBeforeColumnResize, _onBeforeColumnResize2).call(this, size, column, isDblClick));
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link #enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY2] !== false && !this.hot.getSettings().colWidths;
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const setting = this.hot.getSettings()[PLUGIN_KEY2];
    if (setting && setting.useHeaders !== null && setting.useHeaders !== void 0) {
      this.ghostTable.setSetting("useHeaders", setting.useHeaders);
    }
    this.setSamplingOptions();
    this.addHook("afterLoadData", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet2(_this, _onAfterLoadData, _onAfterLoadData2).call(_this, ...args);
    });
    this.addHook("beforeChangeRender", (changes) => _classPrivateMethodGet2(this, _onBeforeChange, _onBeforeChange2).call(this, changes));
    this.addHook("afterFormulasValuesUpdate", (changes) => _classPrivateMethodGet2(this, _onAfterFormulasValuesUpdate, _onAfterFormulasValuesUpdate2).call(this, changes));
    this.addHook("beforeViewRender", (force) => _classPrivateMethodGet2(this, _onBeforeViewRender, _onBeforeViewRender2).call(this, force));
    this.addHook("modifyColWidth", (width, col) => this.getColumnWidth(col, width));
    this.addHook("afterInit", () => _classPrivateMethodGet2(this, _onAfterInit, _onAfterInit2).call(this));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state. This method is executed when {@link Core#updateSettings} is invoked.
   */
  updatePlugin() {
    const changedColumns = this.findColumnsWhereHeaderWasChanged();
    if (changedColumns.length) {
      this.clearCache(changedColumns);
      this.calculateVisibleColumnsWidth();
    }
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
    this.addHook("beforeColumnResize", (size, column, isDblClick) => _classPrivateMethodGet2(this, _onBeforeColumnResize, _onBeforeColumnResize2).call(this, size, column, isDblClick));
  }
  /**
   * Calculates visible columns width.
   */
  calculateVisibleColumnsWidth() {
    const rowsCount = this.hot.countRows();
    if (!rowsCount) {
      return;
    }
    const force = this.hot.renderCall;
    const firstVisibleColumn = this.getFirstVisibleColumn();
    const lastVisibleColumn = this.getLastVisibleColumn();
    if (firstVisibleColumn === -1 || lastVisibleColumn === -1) {
      return;
    }
    this.calculateColumnsWidth({
      from: firstVisibleColumn,
      to: lastVisibleColumn
    }, void 0, force);
  }
  /**
   * Calculates a columns width.
   *
   * @param {number|object} colRange Visual column index or an object with `from` and `to` visual indexes as a range.
   * @param {number|object} rowRange Visual row index or an object with `from` and `to` visual indexes as a range.
   * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.
   */
  calculateColumnsWidth() {
    let colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      from: 0,
      to: this.hot.countCols() - 1
    };
    let rowRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      from: 0,
      to: this.hot.countRows() - 1
    };
    let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const columnsRange = typeof colRange === "number" ? {
      from: colRange,
      to: colRange
    } : colRange;
    const rowsRange = typeof rowRange === "number" ? {
      from: rowRange,
      to: rowRange
    } : rowRange;
    rangeEach(columnsRange.from, columnsRange.to, (visualColumn) => {
      let physicalColumn = this.hot.toPhysicalColumn(visualColumn);
      if (physicalColumn === null) {
        physicalColumn = visualColumn;
      }
      if (force || this.columnWidthsMap.getValueAtIndex(physicalColumn) === null && !this.hot._getColWidthFromSettings(physicalColumn)) {
        const samples = this.samplesGenerator.generateColumnSamples(visualColumn, rowsRange);
        arrayEach(samples, (_ref) => {
          let [column, sample] = _ref;
          return this.ghostTable.addColumn(column, sample);
        });
      }
    });
    if (this.ghostTable.columns.length) {
      this.hot.batchExecution(() => {
        this.ghostTable.getWidths((visualColumn, width) => {
          const physicalColumn = this.hot.toPhysicalColumn(visualColumn);
          this.columnWidthsMap.setValueAtIndex(physicalColumn, width);
        });
      }, true);
      this.measuredColumns = columnsRange.to + 1;
      this.ghostTable.clean();
    }
  }
  /**
   * Calculates all columns width. The calculated column will be cached in the {@link AutoColumnSize#widths} property.
   * To retrieve width for specified column use {@link AutoColumnSize##getColumnWidth} method.
   *
   * @param {object|number} rowRange Row index or an object with `from` and `to` properties which define row range.
   */
  calculateAllColumnsWidth() {
    let rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      from: 0,
      to: this.hot.countRows() - 1
    };
    let current = 0;
    const length = this.hot.countCols() - 1;
    let timer = null;
    this.inProgress = true;
    const loop = () => {
      if (!this.hot) {
        cancelAnimationFrame(timer);
        this.inProgress = false;
        return;
      }
      this.calculateColumnsWidth({
        from: current,
        to: Math.min(current + _AutoColumnSize.CALCULATION_STEP, length)
      }, rowRange);
      current = current + _AutoColumnSize.CALCULATION_STEP + 1;
      if (current < length) {
        timer = requestAnimationFrame(loop);
      } else {
        cancelAnimationFrame(timer);
        this.inProgress = false;
        this.hot.view.adjustElementsSize();
      }
    };
    const syncLimit = this.getSyncCalculationLimit();
    if (this.firstCalculation && syncLimit >= 0) {
      this.calculateColumnsWidth({
        from: 0,
        to: syncLimit
      }, rowRange);
      this.firstCalculation = false;
      current = syncLimit + 1;
    }
    if (current < length) {
      loop();
    } else {
      this.inProgress = false;
    }
  }
  /**
   * Sets the sampling options.
   *
   * @private
   */
  setSamplingOptions() {
    const setting = this.hot.getSettings()[PLUGIN_KEY2];
    const samplingRatio = setting && hasOwnProperty(setting, "samplingRatio") ? setting.samplingRatio : void 0;
    const allowSampleDuplicates = setting && hasOwnProperty(setting, "allowSampleDuplicates") ? setting.allowSampleDuplicates : void 0;
    if (samplingRatio && !isNaN(samplingRatio)) {
      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
    }
    if (allowSampleDuplicates) {
      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
    }
  }
  /**
   * Recalculates all columns width (overwrite cache values).
   */
  recalculateAllColumnsWidth() {
    if (this.hot.view && this.hot.view._wt.wtTable.isVisible()) {
      this.clearCache();
      this.calculateAllColumnsWidth();
    }
  }
  /**
   * Gets value which tells how many columns should be calculated synchronously (rest of the columns will be calculated
   * asynchronously). The limit is calculated based on `syncLimit` set to `autoColumnSize` option (see {@link Options#autoColumnSize}).
   *
   * @returns {number}
   */
  getSyncCalculationLimit() {
    const settings = this.hot.getSettings()[PLUGIN_KEY2];
    let limit = _AutoColumnSize.SYNC_CALCULATION_LIMIT;
    const colsLimit = this.hot.countCols() - 1;
    if (isObject(settings)) {
      limit = settings.syncLimit;
      if (isPercentValue(limit)) {
        limit = valueAccordingPercent(colsLimit, limit);
      } else {
        limit >>= 0;
      }
    }
    return Math.min(limit, colsLimit);
  }
  /**
   * Gets the calculated column width.
   *
   * @param {number} column Visual column index.
   * @param {number} [defaultWidth] Default column width. It will be picked up if no calculated width found.
   * @param {boolean} [keepMinimum=true] If `true` then returned value won't be smaller then 50 (default column width).
   * @returns {number}
   */
  getColumnWidth(column) {
    let defaultWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    let keepMinimum = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let width = defaultWidth;
    if (width === void 0) {
      width = this.columnWidthsMap.getValueAtIndex(this.hot.toPhysicalColumn(column));
      if (keepMinimum && typeof width === "number") {
        width = Math.max(width, viewportColumns_default.DEFAULT_WIDTH);
      }
    }
    return width;
  }
  /**
   * Gets the first visible column.
   *
   * @returns {number} Returns visual column index, -1 if table is not rendered or if there are no columns to base the the calculations on.
   */
  getFirstVisibleColumn() {
    const wot = this.hot.view._wt;
    if (wot.wtViewport.columnsVisibleCalculator) {
      const firstFullyVisibleColumn = wot.wtTable.getFirstVisibleColumn();
      if (firstFullyVisibleColumn !== -1) {
        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstFullyVisibleColumn);
      }
    }
    if (wot.wtViewport.columnsRenderCalculator) {
      const firstRenderedColumn = wot.wtTable.getFirstRenderedColumn();
      if (firstRenderedColumn !== -1) {
        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(firstRenderedColumn);
      }
    }
    return -1;
  }
  /**
   * Gets the last visible column.
   *
   * @returns {number} Returns visual column index or -1 if table is not rendered.
   */
  getLastVisibleColumn() {
    const wot = this.hot.view._wt;
    if (wot.wtViewport.columnsVisibleCalculator) {
      const lastFullyVisibleColumn = wot.wtTable.getLastVisibleColumn();
      if (lastFullyVisibleColumn !== -1) {
        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastFullyVisibleColumn);
      }
    }
    if (wot.wtViewport.columnsRenderCalculator) {
      const lastRenderedColumn = wot.wtTable.getLastRenderedColumn();
      if (lastRenderedColumn !== -1) {
        return this.hot.columnIndexMapper.getVisualFromRenderableIndex(lastRenderedColumn);
      }
    }
    return -1;
  }
  /**
   * Collects all columns which titles has been changed in comparison to the previous state.
   *
   * @private
   * @returns {Array} It returns an array of physical column indexes.
   */
  findColumnsWhereHeaderWasChanged() {
    const columnHeaders = this.hot.getColHeader();
    const changedColumns = arrayReduce(columnHeaders, (acc, columnTitle, physicalColumn) => {
      const cachedColumnsLength = _classPrivateFieldGet2(this, _cachedColumnHeaders).length;
      if (cachedColumnsLength - 1 < physicalColumn || _classPrivateFieldGet2(this, _cachedColumnHeaders)[physicalColumn] !== columnTitle) {
        acc.push(physicalColumn);
      }
      if (cachedColumnsLength - 1 < physicalColumn) {
        _classPrivateFieldGet2(this, _cachedColumnHeaders).push(columnTitle);
      } else {
        _classPrivateFieldGet2(this, _cachedColumnHeaders)[physicalColumn] = columnTitle;
      }
      return acc;
    }, []);
    return changedColumns;
  }
  /**
   * Clears cache of calculated column widths. If you want to clear only selected columns pass an array with their indexes.
   * Otherwise whole cache will be cleared.
   *
   * @param {number[]} [columns] List of physical column indexes to clear.
   */
  clearCache() {
    let columns = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (columns.length) {
      this.hot.batchExecution(() => {
        arrayEach(columns, (physicalIndex) => {
          this.columnWidthsMap.setValueAtIndex(physicalIndex, null);
        });
      }, true);
    } else {
      this.columnWidthsMap.clear();
    }
  }
  /**
   * Checks if all widths were calculated. If not then return `true` (need recalculate).
   *
   * @returns {boolean}
   */
  isNeedRecalculate() {
    return !!arrayFilter(this.columnWidthsMap.getValues().slice(0, this.measuredColumns), (item) => item === null).length;
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.ghostTable.clean();
    super.destroy();
  }
};
function _onBeforeViewRender2() {
  this.calculateVisibleColumnsWidth();
  if (this.isNeedRecalculate() && !this.inProgress) {
    this.calculateAllColumnsWidth();
  }
}
function _onAfterLoadData2() {
  if (this.hot.view) {
    this.recalculateAllColumnsWidth();
  } else {
    setTimeout(() => {
      if (this.hot) {
        this.recalculateAllColumnsWidth();
      }
    }, 0);
  }
}
function _onBeforeChange2(changes) {
  const changedColumns = arrayMap(changes, (_ref2) => {
    let [, columnProperty] = _ref2;
    return this.hot.toPhysicalColumn(this.hot.propToCol(columnProperty));
  });
  this.clearCache(Array.from(new Set(changedColumns)));
}
function _onBeforeColumnResize2(size, column, isDblClick) {
  let newSize = size;
  if (isDblClick) {
    this.calculateColumnsWidth(column, void 0, true);
    newSize = this.getColumnWidth(column, void 0, false);
  }
  return newSize;
}
function _onAfterInit2() {
  _classPrivateFieldSet(this, _cachedColumnHeaders, this.hot.getColHeader());
}
function _onAfterFormulasValuesUpdate2(changes) {
  const filteredChanges = arrayFilter(changes, (change) => {
    var _change$address;
    return isDefined((_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.col);
  });
  const changedColumns = arrayMap(filteredChanges, (change) => change.address.col);
  this.clearCache(Array.from(new Set(changedColumns)));
}

// node_modules/handsontable/plugins/autofill/utils.mjs
var DIRECTIONS = {
  horizontal: "horizontal",
  vertical: "vertical"
};
function getDragDirectionAndRange(startSelection, endSelection, cellCoordsFactory) {
  let startOfDragCoords;
  let endOfDragCoords;
  let directionOfDrag;
  if (endSelection[0] === startSelection[0] && endSelection[1] < startSelection[1]) {
    directionOfDrag = "left";
    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);
    endOfDragCoords = cellCoordsFactory(endSelection[2], startSelection[1] - 1);
  } else if (endSelection[2] === startSelection[2] && endSelection[0] === startSelection[0] && endSelection[3] > startSelection[3]) {
    directionOfDrag = "right";
    startOfDragCoords = cellCoordsFactory(endSelection[0], startSelection[3] + 1);
    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);
  } else if (endSelection[0] < startSelection[0] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "up";
    startOfDragCoords = cellCoordsFactory(endSelection[0], endSelection[1]);
    endOfDragCoords = cellCoordsFactory(startSelection[0] - 1, endSelection[3]);
  } else if (endSelection[2] > startSelection[2] && endSelection[1] === startSelection[1]) {
    directionOfDrag = "down";
    startOfDragCoords = cellCoordsFactory(startSelection[2] + 1, endSelection[1]);
    endOfDragCoords = cellCoordsFactory(endSelection[2], endSelection[3]);
  }
  if (startOfDragCoords) {
    startOfDragCoords.normalize();
  }
  if (endOfDragCoords) {
    endOfDragCoords.normalize();
  }
  return {
    directionOfDrag,
    startOfDragCoords,
    endOfDragCoords
  };
}
function getMappedFillHandleSetting(fillHandle) {
  const mappedSettings = {};
  if (fillHandle === true) {
    mappedSettings.directions = Object.keys(DIRECTIONS);
    mappedSettings.autoInsertRow = true;
  } else if (isObject(fillHandle)) {
    if (isDefined(fillHandle.autoInsertRow)) {
      if (fillHandle.direction === DIRECTIONS.horizontal) {
        mappedSettings.autoInsertRow = false;
      } else {
        mappedSettings.autoInsertRow = fillHandle.autoInsertRow;
      }
    } else {
      mappedSettings.autoInsertRow = false;
    }
    if (isDefined(fillHandle.direction)) {
      mappedSettings.directions = [fillHandle.direction];
    } else {
      mappedSettings.directions = Object.keys(DIRECTIONS);
    }
  } else if (typeof fillHandle === "string") {
    mappedSettings.directions = [fillHandle];
    mappedSettings.autoInsertRow = true;
  } else {
    mappedSettings.directions = [];
    mappedSettings.autoInsertRow = false;
  }
  return mappedSettings;
}

// node_modules/handsontable/plugins/autofill/autofill.mjs
function _classPrivateMethodInitSpec3(obj, privateSet) {
  _checkPrivateRedeclaration3(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration3(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty5(obj, key, value) {
  key = _toPropertyKey5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey5(arg) {
  var key = _toPrimitive5(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive5(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet3(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
pluginHooks_default.getSingleton().register("modifyAutofillRange");
pluginHooks_default.getSingleton().register("beforeAutofill");
pluginHooks_default.getSingleton().register("afterAutofill");
var PLUGIN_KEY3 = "autofill";
var PLUGIN_PRIORITY2 = 20;
var SETTING_KEYS = ["fillHandle"];
var INSERT_ROW_ALTER_ACTION_NAME = "insert_row_below";
var INTERVAL_FOR_ADDING_ROW = 200;
var _onCellCornerDblClick = /* @__PURE__ */ new WeakSet();
var _onAfterCellCornerMouseDown = /* @__PURE__ */ new WeakSet();
var _onBeforeCellMouseOver = /* @__PURE__ */ new WeakSet();
var _onMouseUp = /* @__PURE__ */ new WeakSet();
var _onMouseMove = /* @__PURE__ */ new WeakSet();
var Autofill = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec3(this, _onMouseMove);
    _classPrivateMethodInitSpec3(this, _onMouseUp);
    _classPrivateMethodInitSpec3(this, _onBeforeCellMouseOver);
    _classPrivateMethodInitSpec3(this, _onAfterCellCornerMouseDown);
    _classPrivateMethodInitSpec3(this, _onCellCornerDblClick);
    _defineProperty5(this, "addingStarted", false);
    _defineProperty5(this, "mouseDownOnCellCorner", false);
    _defineProperty5(this, "mouseDragOutside", false);
    _defineProperty5(this, "handleDraggedCells", 0);
    _defineProperty5(this, "directions", []);
    _defineProperty5(this, "autoInsertRow", false);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY3;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY2;
  }
  static get SETTING_KEYS() {
    return [PLUGIN_KEY3, ...SETTING_KEYS];
  }
  /**
   * Checks if the plugin is enabled in the Handsontable settings.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings().fillHandle;
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.mapSettings();
    this.registerEvents();
    this.addHook("afterOnCellCornerMouseDown", (event) => _classPrivateMethodGet3(this, _onAfterCellCornerMouseDown, _onAfterCellCornerMouseDown2).call(this, event));
    this.addHook("afterOnCellCornerDblClick", (event) => _classPrivateMethodGet3(this, _onCellCornerDblClick, _onCellCornerDblClick2).call(this, event));
    this.addHook("beforeOnCellMouseOver", (_, coords) => _classPrivateMethodGet3(this, _onBeforeCellMouseOver, _onBeforeCellMouseOver2).call(this, coords));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - `autofill`
   *  - [`fillHandle`](@/api/options.md#fillhandle)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.clearMappedSettings();
    super.disablePlugin();
  }
  /**
   * Gets selection data.
   *
   * @private
   * @returns {object[]} Ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.
   */
  getSelectionData() {
    const selection = this.hot.getSelectedRangeLast();
    const {
      row: startRow,
      col: startCol
    } = selection.getTopStartCorner();
    const {
      row: endRow,
      col: endCol
    } = selection.getBottomEndCorner();
    const copyableRanges = this.hot.runHooks("modifyCopyableRange", [{
      startRow,
      startCol,
      endRow,
      endCol
    }]);
    const copyableRows = [];
    const copyableColumns = [];
    const data = [];
    arrayEach(copyableRanges, (range) => {
      for (let visualRow = range.startRow; visualRow <= range.endRow; visualRow += 1) {
        if (copyableRows.indexOf(visualRow) === -1) {
          copyableRows.push(visualRow);
        }
      }
      for (let visualColumn = range.startCol; visualColumn <= range.endCol; visualColumn += 1) {
        if (copyableColumns.indexOf(visualColumn) === -1) {
          copyableColumns.push(visualColumn);
        }
      }
    });
    arrayEach(copyableRows, (row) => {
      const rowSet = [];
      arrayEach(copyableColumns, (column) => {
        rowSet.push(this.hot.getCopyableData(row, column));
      });
      data.push(rowSet);
    });
    return data;
  }
  /**
   * Try to apply fill values to the area in fill border, omitting the selection border.
   *
   * @private
   * @returns {boolean} Reports if fill was applied.
   *
   * @fires Hooks#modifyAutofillRange
   * @fires Hooks#beforeAutofill
   * @fires Hooks#afterAutofill
   */
  fillIn() {
    if (this.hot.selection.highlight.getFill().isEmpty()) {
      return false;
    }
    const [fillStartRow, fillStartColumn, fillEndRow, fillEndColumn] = this.hot.selection.highlight.getFill().getVisualCorners();
    const selectionRangeLast = this.hot.getSelectedRangeLast();
    const topStartCorner = selectionRangeLast.getTopStartCorner();
    const bottomEndCorner = selectionRangeLast.getBottomEndCorner();
    this.resetSelectionOfDraggedArea();
    const cornersOfSelectedCells = [topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col];
    const cornersOfSelectionAndDragAreas = this.hot.runHooks("modifyAutofillRange", [Math.min(topStartCorner.row, fillStartRow), Math.min(topStartCorner.col, fillStartColumn), Math.max(bottomEndCorner.row, fillEndRow), Math.max(bottomEndCorner.col, fillEndColumn)], cornersOfSelectedCells);
    const {
      directionOfDrag,
      startOfDragCoords,
      endOfDragCoords
    } = getDragDirectionAndRange(cornersOfSelectedCells, cornersOfSelectionAndDragAreas, (row, column) => this.hot._createCellCoords(row, column));
    if (startOfDragCoords && startOfDragCoords.row > -1 && startOfDragCoords.col > -1) {
      const selectionData = this.getSelectionData();
      const sourceRange = selectionRangeLast.clone();
      const targetRange = this.hot._createCellRange(startOfDragCoords, startOfDragCoords, endOfDragCoords);
      const beforeAutofillHookResult = this.hot.runHooks("beforeAutofill", selectionData, sourceRange, targetRange, directionOfDrag);
      if (beforeAutofillHookResult === false) {
        this.hot.selection.highlight.getFill().clear();
        this.hot.render();
        return false;
      }
      let fillData = beforeAutofillHookResult;
      const res = beforeAutofillHookResult;
      if (["up", "left"].indexOf(directionOfDrag) > -1 && !(res.length === 1 && res[0].length === 0)) {
        fillData = [];
        if (directionOfDrag === "up") {
          const dragLength = endOfDragCoords.row - startOfDragCoords.row + 1;
          const fillOffset = dragLength % res.length;
          for (let i = 0; i < dragLength; i++) {
            fillData.push(res[(i + (res.length - fillOffset)) % res.length]);
          }
        } else {
          const dragLength = endOfDragCoords.col - startOfDragCoords.col + 1;
          const fillOffset = dragLength % res[0].length;
          for (let i = 0; i < res.length; i++) {
            fillData.push([]);
            for (let j = 0; j < dragLength; j++) {
              fillData[i].push(res[i][(j + (res[i].length - fillOffset)) % res[i].length]);
            }
          }
        }
      }
      this.hot.populateFromArray(startOfDragCoords.row, startOfDragCoords.col, fillData, endOfDragCoords.row, endOfDragCoords.col, `${this.pluginName}.fill`, null);
      this.setSelection(cornersOfSelectionAndDragAreas);
      this.hot.runHooks("afterAutofill", fillData, sourceRange, targetRange, directionOfDrag);
      this.hot.render();
    } else {
      this.hot._refreshBorders();
    }
    return true;
  }
  /**
   * Reduces the selection area if the handle was dragged outside of the table or on headers.
   *
   * @private
   * @param {CellCoords} coords Indexes of selection corners.
   * @returns {CellCoords}
   */
  reduceSelectionAreaIfNeeded(coords) {
    if (coords.row < 0) {
      coords.row = 0;
    }
    if (coords.col < 0) {
      coords.col = 0;
    }
    return coords;
  }
  /**
   * Gets the coordinates of the drag & drop borders.
   *
   * @private
   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.
   * @returns {CellCoords}
   */
  getCoordsOfDragAndDropBorders(coordsOfSelection) {
    const currentSelection = this.hot.getSelectedRangeLast();
    const bottomRightCorner = currentSelection.getBottomEndCorner();
    let coords = coordsOfSelection;
    if (this.directions.includes(DIRECTIONS.vertical) && this.directions.includes(DIRECTIONS.horizontal)) {
      const topStartCorner = currentSelection.getTopStartCorner();
      if (bottomRightCorner.col <= coordsOfSelection.col || topStartCorner.col >= coordsOfSelection.col) {
        coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);
      }
      if (bottomRightCorner.row < coordsOfSelection.row || topStartCorner.row > coordsOfSelection.row) {
        coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);
      }
    } else if (this.directions.includes(DIRECTIONS.vertical)) {
      coords = this.hot._createCellCoords(coordsOfSelection.row, bottomRightCorner.col);
    } else if (this.directions.includes(DIRECTIONS.horizontal)) {
      coords = this.hot._createCellCoords(bottomRightCorner.row, coordsOfSelection.col);
    } else {
      return;
    }
    return this.reduceSelectionAreaIfNeeded(coords);
  }
  /**
   * Show the fill border.
   *
   * @private
   * @param {CellCoords} coordsOfSelection `CellCoords` coord object.
   */
  showBorder(coordsOfSelection) {
    const coordsOfDragAndDropBorders = this.getCoordsOfDragAndDropBorders(coordsOfSelection);
    if (coordsOfDragAndDropBorders) {
      this.redrawBorders(coordsOfDragAndDropBorders);
    }
  }
  /**
   * Add new row.
   *
   * @private
   */
  addRow() {
    this.hot._registerTimeout(() => {
      this.hot.alter(INSERT_ROW_ALTER_ACTION_NAME, void 0, 1, `${this.pluginName}.fill`);
      this.addingStarted = false;
    }, INTERVAL_FOR_ADDING_ROW);
  }
  /**
   * Add new rows if they are needed to continue auto-filling values.
   *
   * @private
   */
  addNewRowIfNeeded() {
    if (!this.hot.selection.highlight.getFill().isEmpty() && this.addingStarted === false && this.autoInsertRow) {
      const cornersOfSelectedCells = this.hot.getSelectedLast();
      const cornersOfSelectedDragArea = this.hot.selection.highlight.getFill().getVisualCorners();
      const nrOfTableRows = this.hot.countRows();
      if (cornersOfSelectedCells[2] < nrOfTableRows - 1 && cornersOfSelectedDragArea[2] === nrOfTableRows - 1) {
        this.addingStarted = true;
        this.addRow();
      }
    }
  }
  /**
   * Get index of last adjacent filled in row.
   *
   * @private
   * @param {Array} cornersOfSelectedCells Indexes of selection corners.
   * @returns {number} Gives number greater than or equal to zero when selection adjacent can be applied.
   *                   Or -1 when selection adjacent can't be applied.
   */
  getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells) {
    const data = this.hot.getData();
    const nrOfTableRows = this.hot.countRows();
    let lastFilledInRowIndex;
    for (let rowIndex = cornersOfSelectedCells[2] + 1; rowIndex < nrOfTableRows; rowIndex++) {
      for (let columnIndex = cornersOfSelectedCells[1]; columnIndex <= cornersOfSelectedCells[3]; columnIndex++) {
        const dataInCell = data[rowIndex][columnIndex];
        if (dataInCell) {
          return -1;
        }
      }
      const dataInNextLeftCell = data[rowIndex][cornersOfSelectedCells[1] - 1];
      const dataInNextRightCell = data[rowIndex][cornersOfSelectedCells[3] + 1];
      if (!!dataInNextLeftCell || !!dataInNextRightCell) {
        lastFilledInRowIndex = rowIndex;
      }
    }
    return lastFilledInRowIndex;
  }
  /**
   * Adds a selection from the start area to the specific row index.
   *
   * @private
   * @param {Array} selectStartArea Selection area from which we start to create more comprehensive selection.
   * @param {number} rowIndex The row index into the selection will be added.
   */
  addSelectionFromStartAreaToSpecificRowIndex(selectStartArea, rowIndex) {
    this.hot.selection.highlight.getFill().clear().add(this.hot._createCellCoords(selectStartArea[0], selectStartArea[1])).add(this.hot._createCellCoords(rowIndex, selectStartArea[3])).commit();
  }
  /**
   * Sets selection based on passed corners.
   *
   * @private
   * @param {Array} cornersOfArea An array witch defines selection.
   */
  setSelection(cornersOfArea) {
    this.hot.selectCell(...arrayMap(cornersOfArea, (index) => Math.max(index, 0)), false, false);
  }
  /**
   * Try to select cells down to the last row in the left column and then returns if selection was applied.
   *
   * @private
   * @returns {boolean}
   */
  selectAdjacent() {
    const cornersOfSelectedCells = this.hot.getSelectedLast();
    const lastFilledInRowIndex = this.getIndexOfLastAdjacentFilledInRow(cornersOfSelectedCells);
    if (lastFilledInRowIndex === -1 || lastFilledInRowIndex === void 0) {
      return false;
    }
    this.addSelectionFromStartAreaToSpecificRowIndex(cornersOfSelectedCells, lastFilledInRowIndex);
    return true;
  }
  /**
   * Resets selection of dragged area.
   *
   * @private
   */
  resetSelectionOfDraggedArea() {
    this.handleDraggedCells = 0;
    this.hot.selection.highlight.getFill().clear();
  }
  /**
   * Redraws borders.
   *
   * @private
   * @param {CellCoords} coords `CellCoords` coord object.
   */
  redrawBorders(coords) {
    this.hot.selection.highlight.getFill().clear().add(this.hot.getSelectedRangeLast().from).add(this.hot.getSelectedRangeLast().to).add(coords).commit();
    this.hot.view.render();
  }
  /**
   * Get if mouse was dragged outside.
   *
   * @private
   * @param {MouseEvent} event `mousemove` event properties.
   * @returns {boolean}
   */
  getIfMouseWasDraggedOutside(event) {
    const {
      documentElement
    } = this.hot.rootDocument;
    const tableBottom = offset(this.hot.table).top - (this.hot.rootWindow.pageYOffset || documentElement.scrollTop) + outerHeight(this.hot.table);
    const tableRight = offset(this.hot.table).left - (this.hot.rootWindow.pageXOffset || documentElement.scrollLeft) + outerWidth(this.hot.table);
    return event.clientY > tableBottom && event.clientX <= tableRight;
  }
  /**
   * Bind the events used by the plugin.
   *
   * @private
   */
  registerEvents() {
    const {
      documentElement
    } = this.hot.rootDocument;
    this.eventManager.addEventListener(documentElement, "mouseup", () => _classPrivateMethodGet3(this, _onMouseUp, _onMouseUp2).call(this));
    this.eventManager.addEventListener(documentElement, "mousemove", (event) => _classPrivateMethodGet3(this, _onMouseMove, _onMouseMove2).call(this, event));
  }
  /**
   * Clears mapped settings.
   *
   * @private
   */
  clearMappedSettings() {
    this.directions.length = 0;
    this.autoInsertRow = false;
  }
  /**
   * Map settings.
   *
   * @private
   */
  mapSettings() {
    const mappedSettings = getMappedFillHandleSetting(this.hot.getSettings().fillHandle);
    this.directions = mappedSettings.directions;
    this.autoInsertRow = mappedSettings.autoInsertRow;
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _onCellCornerDblClick2() {
  const selectionApplied = this.selectAdjacent();
  if (selectionApplied) {
    this.fillIn();
  }
}
function _onAfterCellCornerMouseDown2() {
  this.handleDraggedCells = 1;
  this.mouseDownOnCellCorner = true;
}
function _onBeforeCellMouseOver2(coords) {
  if (this.mouseDownOnCellCorner && !this.hot.view.isMouseDown() && this.handleDraggedCells) {
    this.handleDraggedCells += 1;
    this.showBorder(coords);
    this.addNewRowIfNeeded();
  }
}
function _onMouseUp2() {
  if (this.handleDraggedCells) {
    if (this.handleDraggedCells > 1) {
      this.fillIn();
    }
    this.handleDraggedCells = 0;
    this.mouseDownOnCellCorner = false;
  }
}
function _onMouseMove2(event) {
  const mouseWasDraggedOutside = this.getIfMouseWasDraggedOutside(event);
  if (this.addingStarted === false && this.handleDraggedCells > 0 && mouseWasDraggedOutside) {
    this.mouseDragOutside = true;
    this.addingStarted = true;
  } else {
    this.mouseDragOutside = false;
  }
  if (this.mouseDragOutside && this.autoInsertRow) {
    this.addRow();
  }
}

// node_modules/handsontable/plugins/autoRowSize/autoRowSize.mjs
function _classPrivateMethodInitSpec4(obj, privateSet) {
  _checkPrivateRedeclaration4(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration4(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty6(obj, key, value) {
  key = _toPropertyKey6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey6(arg) {
  var key = _toPrimitive6(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive6(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet4(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY4 = "autoRowSize";
var PLUGIN_PRIORITY3 = 40;
var ROW_WIDTHS_MAP_NAME = "autoRowSize";
var _onBeforeViewRender3 = /* @__PURE__ */ new WeakSet();
var _onBeforeRowResize = /* @__PURE__ */ new WeakSet();
var _onAfterLoadData3 = /* @__PURE__ */ new WeakSet();
var _onBeforeChange3 = /* @__PURE__ */ new WeakSet();
var AutoRowSize = class _AutoRowSize extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY4;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY3;
  }
  static get SETTING_KEYS() {
    return true;
  }
  static get CALCULATION_STEP() {
    return 50;
  }
  static get SYNC_CALCULATION_LIMIT() {
    return 500;
  }
  /**
   * Columns header's height cache.
   *
   * @private
   * @type {number}
   */
  constructor(hotInstance) {
    super(hotInstance);
    _classPrivateMethodInitSpec4(this, _onBeforeChange3);
    _classPrivateMethodInitSpec4(this, _onAfterLoadData3);
    _classPrivateMethodInitSpec4(this, _onBeforeRowResize);
    _classPrivateMethodInitSpec4(this, _onBeforeViewRender3);
    _defineProperty6(this, "headerHeight", null);
    _defineProperty6(this, "ghostTable", new ghostTable_default(this.hot));
    _defineProperty6(this, "samplesGenerator", new samplesGenerator_default((row, column) => {
      if (row >= 0 && column >= 0) {
        const cellMeta = this.hot.getCellMeta(row, column);
        if (cellMeta.hidden) {
          return false;
        }
      }
      let cellValue;
      if (row >= 0) {
        cellValue = this.hot.getDataAtCell(row, column);
      } else if (row === -1) {
        cellValue = this.hot.getColHeader(column);
      }
      return {
        value: cellValue
      };
    }));
    _defineProperty6(this, "firstCalculation", true);
    _defineProperty6(this, "inProgress", false);
    _defineProperty6(this, "measuredRows", 0);
    _defineProperty6(this, "rowHeightsMap", new PhysicalIndexToValueMap());
    this.hot.rowIndexMapper.registerMap(ROW_WIDTHS_MAP_NAME, this.rowHeightsMap);
    this.addHook("beforeRowResize", (size, row, isDblClick) => _classPrivateMethodGet4(this, _onBeforeRowResize, _onBeforeRowResize2).call(this, size, row, isDblClick));
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    const settings = this.hot.getSettings()[PLUGIN_KEY4];
    return settings === true || isObject(settings);
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.setSamplingOptions();
    this.addHook("afterLoadData", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet4(_this, _onAfterLoadData3, _onAfterLoadData22).call(_this, ...args);
    });
    this.addHook("beforeChangeRender", (changes) => _classPrivateMethodGet4(this, _onBeforeChange3, _onBeforeChange22).call(this, changes));
    this.addHook("beforeColumnResize", () => this.recalculateAllRowsHeight());
    this.addHook("beforeViewRender", (force) => _classPrivateMethodGet4(this, _onBeforeViewRender3, _onBeforeViewRender22).call(this, force));
    this.addHook("modifyRowHeight", (height, row) => this.getRowHeight(row, height));
    this.addHook("modifyColumnHeaderHeight", () => this.getColumnHeaderHeight());
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.headerHeight = null;
    super.disablePlugin();
    this.addHook("beforeRowResize", (size, row, isDblClick) => _classPrivateMethodGet4(this, _onBeforeRowResize, _onBeforeRowResize2).call(this, size, row, isDblClick));
  }
  /**
   * Calculate a given rows height.
   *
   * @param {number|object} rowRange Row index or an object with `from` and `to` indexes as a range.
   * @param {number|object} colRange Column index or an object with `from` and `to` indexes as a range.
   * @param {boolean} [force=false] If `true` the calculation will be processed regardless of whether the width exists in the cache.
   */
  calculateRowsHeight() {
    let rowRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      from: 0,
      to: this.hot.countRows() - 1
    };
    let colRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      from: 0,
      to: this.hot.countCols() - 1
    };
    let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const rowsRange = typeof rowRange === "number" ? {
      from: rowRange,
      to: rowRange
    } : rowRange;
    const columnsRange = typeof colRange === "number" ? {
      from: colRange,
      to: colRange
    } : colRange;
    if (this.hot.getColHeader(0) !== null) {
      const samples = this.samplesGenerator.generateRowSamples(-1, columnsRange);
      this.ghostTable.addColumnHeadersRow(samples.get(-1));
    }
    rangeEach(rowsRange.from, rowsRange.to, (row) => {
      if (force || this.rowHeightsMap.getValueAtIndex(row) === null) {
        const samples = this.samplesGenerator.generateRowSamples(row, columnsRange);
        arrayEach(samples, (_ref) => {
          let [rowIndex, sample] = _ref;
          return this.ghostTable.addRow(rowIndex, sample);
        });
      }
    });
    if (this.ghostTable.rows.length) {
      this.hot.batchExecution(() => {
        this.ghostTable.getHeights((row, height) => {
          if (row < 0) {
            this.headerHeight = height;
          } else {
            this.rowHeightsMap.setValueAtIndex(this.hot.toPhysicalRow(row), height);
          }
        });
      }, true);
      this.measuredRows = rowsRange.to + 1;
      this.ghostTable.clean();
    }
  }
  /**
   * Calculate all rows heights. The calculated row will be cached in the {@link AutoRowSize#heights} property.
   * To retrieve height for specified row use {@link AutoRowSize#getRowHeight} method.
   *
   * @param {object|number} colRange Row index or an object with `from` and `to` properties which define row range.
   */
  calculateAllRowsHeight() {
    let colRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      from: 0,
      to: this.hot.countCols() - 1
    };
    let current = 0;
    const length = this.hot.countRows() - 1;
    let timer = null;
    this.inProgress = true;
    const loop = () => {
      if (!this.hot) {
        cancelAnimationFrame(timer);
        this.inProgress = false;
        return;
      }
      this.calculateRowsHeight({
        from: current,
        to: Math.min(current + _AutoRowSize.CALCULATION_STEP, length)
      }, colRange);
      current = current + _AutoRowSize.CALCULATION_STEP + 1;
      if (current < length) {
        timer = requestAnimationFrame(loop);
      } else {
        cancelAnimationFrame(timer);
        this.inProgress = false;
        this.hot.view.adjustElementsSize(true);
        if (this.hot.view._wt.wtOverlays.inlineStartOverlay.needFullRender) {
          this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.draw();
        }
      }
    };
    const syncLimit = this.getSyncCalculationLimit();
    if (this.firstCalculation && syncLimit >= 0) {
      this.calculateRowsHeight({
        from: 0,
        to: syncLimit
      }, colRange);
      this.firstCalculation = false;
      current = syncLimit + 1;
    }
    if (current < length) {
      loop();
    } else {
      this.inProgress = false;
      this.hot.view.adjustElementsSize(false);
    }
  }
  /**
   * Sets the sampling options.
   *
   * @private
   */
  setSamplingOptions() {
    const setting = this.hot.getSettings()[PLUGIN_KEY4];
    const samplingRatio = setting && hasOwnProperty(setting, "samplingRatio") ? setting.samplingRatio : void 0;
    const allowSampleDuplicates = setting && hasOwnProperty(setting, "allowSampleDuplicates") ? setting.allowSampleDuplicates : void 0;
    if (samplingRatio && !isNaN(samplingRatio)) {
      this.samplesGenerator.setSampleCount(parseInt(samplingRatio, 10));
    }
    if (allowSampleDuplicates) {
      this.samplesGenerator.setAllowDuplicates(allowSampleDuplicates);
    }
  }
  /**
   * Recalculates all rows height (overwrite cache values).
   */
  recalculateAllRowsHeight() {
    if (isVisible(this.hot.view._wt.wtTable.TABLE)) {
      this.clearCache();
      this.calculateAllRowsHeight();
    }
  }
  /**
   * Gets value which tells how many rows should be calculated synchronously (rest of the rows will be calculated
   * asynchronously). The limit is calculated based on `syncLimit` set to autoRowSize option (see {@link Options#autoRowSize}).
   *
   * @returns {number}
   */
  getSyncCalculationLimit() {
    const settings = this.hot.getSettings()[PLUGIN_KEY4];
    let limit = _AutoRowSize.SYNC_CALCULATION_LIMIT;
    const rowsLimit = this.hot.countRows() - 1;
    if (isObject(settings)) {
      limit = settings.syncLimit;
      if (isPercentValue(limit)) {
        limit = valueAccordingPercent(rowsLimit, limit);
      } else {
        limit >>= 0;
      }
    }
    return Math.min(limit, rowsLimit);
  }
  /**
   * Get a row's height, as measured in the DOM.
   *
   * The height returned includes 1 px of the row's bottom border.
   *
   * Mind that this method is different from the
   * [`getRowHeight()`](@/api/core.md#getrowheight) method
   * of Handsontable's [Core](@/api/core.md).
   *
   * @param {number} row A visual row index.
   * @param {number} [defaultHeight] If no height is found, `defaultHeight` is returned instead.
   * @returns {number} The height of the specified row, in pixels.
   */
  getRowHeight(row) {
    let defaultHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    const cachedHeight = row < 0 ? this.headerHeight : this.rowHeightsMap.getValueAtIndex(this.hot.toPhysicalRow(row));
    let height = defaultHeight;
    if (cachedHeight !== null && cachedHeight > (defaultHeight || 0)) {
      height = cachedHeight;
    }
    return height;
  }
  /**
   * Get the calculated column header height.
   *
   * @returns {number|undefined}
   */
  getColumnHeaderHeight() {
    return this.headerHeight;
  }
  /**
   * Get the first visible row.
   *
   * @returns {number} Returns row index, -1 if table is not rendered or if there are no rows to base the the calculations on.
   */
  getFirstVisibleRow() {
    const wot = this.hot.view._wt;
    if (wot.wtViewport.rowsVisibleCalculator) {
      return wot.wtTable.getFirstVisibleRow();
    }
    if (wot.wtViewport.rowsRenderCalculator) {
      return wot.wtTable.getFirstRenderedRow();
    }
    return -1;
  }
  /**
   * Gets the last visible row.
   *
   * @returns {number} Returns row index or -1 if table is not rendered.
   */
  getLastVisibleRow() {
    const wot = this.hot.view._wt;
    if (wot.wtViewport.rowsVisibleCalculator) {
      return wot.wtTable.getLastVisibleRow();
    }
    if (wot.wtViewport.rowsRenderCalculator) {
      return wot.wtTable.getLastRenderedRow();
    }
    return -1;
  }
  /**
   * Clears cached heights.
   */
  clearCache() {
    this.headerHeight = null;
    this.rowHeightsMap.init();
  }
  /**
   * Clears cache by range.
   *
   * @param {object|number} range Row index or an object with `from` and `to` properties which define row range.
   */
  clearCacheByRange(range) {
    const {
      from,
      to
    } = typeof range === "number" ? {
      from: range,
      to: range
    } : range;
    this.hot.batchExecution(() => {
      rangeEach(Math.min(from, to), Math.max(from, to), (row) => {
        this.rowHeightsMap.setValueAtIndex(row, null);
      });
    }, true);
  }
  /**
   * Checks if all heights were calculated. If not then return `true` (need recalculate).
   *
   * @returns {boolean}
   */
  isNeedRecalculate() {
    return !!arrayFilter(this.rowHeightsMap.getValues().slice(0, this.measuredRows), (item) => item === null).length;
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.ghostTable.clean();
    super.destroy();
  }
};
function _onBeforeViewRender22() {
  const force = this.hot.renderCall;
  const fixedRowsBottom = this.hot.getSettings().fixedRowsBottom;
  const firstVisibleRow = this.getFirstVisibleRow();
  const lastVisibleRow = this.getLastVisibleRow();
  if (firstVisibleRow === -1 || lastVisibleRow === -1) {
    return;
  }
  this.calculateRowsHeight({
    from: firstVisibleRow,
    to: lastVisibleRow
  }, void 0, force);
  if (fixedRowsBottom) {
    const totalRows = this.hot.countRows() - 1;
    this.calculateRowsHeight({
      from: totalRows - fixedRowsBottom,
      to: totalRows
    });
  }
  if (this.isNeedRecalculate() && !this.inProgress) {
    this.calculateAllRowsHeight();
  }
}
function _onBeforeRowResize2(size, row, isDblClick) {
  let newSize = size;
  if (isDblClick) {
    this.calculateRowsHeight(row, void 0, true);
    newSize = this.getRowHeight(row);
  }
  return newSize;
}
function _onAfterLoadData22() {
  if (this.hot.view) {
    this.recalculateAllRowsHeight();
  } else {
    this.hot._registerTimeout(() => {
      if (this.hot) {
        this.recalculateAllRowsHeight();
      }
    });
  }
}
function _onBeforeChange22(changes) {
  let range = null;
  if (changes.length === 1) {
    range = changes[0][0];
  } else if (changes.length > 1) {
    range = {
      from: changes[0][0],
      to: changes[changes.length - 1][0]
    };
  }
  if (range !== null) {
    this.clearCacheByRange(range);
  }
}

// node_modules/handsontable/plugins/bindRowsWithHeaders/maps/looseBindsMap.mjs
var {
  getListWithInsertedItems,
  getListWithRemovedItems
} = alterUtilsFactory("physicallyIndexed");
var LooseBindsMap = class extends IndexMap {
  constructor() {
    super((index) => index);
  }
  /**
   * Add values to list and reorganize.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    const listAfterUpdate = getIncreasedIndexes(this.indexedValues, insertedIndexes);
    this.indexedValues = getListWithInsertedItems(listAfterUpdate, insertionIndex, insertedIndexes, this.initValueOrFn);
    super.insert(insertionIndex, insertedIndexes);
  }
  /**
   * Remove values from the list and reorganize.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    const listAfterUpdate = getListWithRemovedItems(this.indexedValues, removedIndexes);
    this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);
    super.remove(removedIndexes);
  }
};
var looseBindsMap_default = LooseBindsMap;

// node_modules/handsontable/plugins/bindRowsWithHeaders/maps/strictBindsMap.mjs
var {
  getListWithInsertedItems: getListWithInsertedItems2,
  getListWithRemovedItems: getListWithRemovedItems2
} = alterUtilsFactory("physicallyIndexed");
var StrictBindsMap = class extends IndexMap {
  constructor() {
    super((index) => index);
  }
  /**
   * Add values to list and reorganize.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    this.indexedValues = getListWithInsertedItems2(this.indexedValues, insertionIndex, insertedIndexes, (_, ordinalNumber) => this.getNextValue(ordinalNumber));
    super.insert(insertionIndex, insertedIndexes);
  }
  /**
   * Remove values from the list and reorganize.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    this.indexedValues = getListWithRemovedItems2(this.indexedValues, removedIndexes);
    super.remove(removedIndexes);
  }
  /**
   * Get next values, which should be greater than actual maximum value in the list.
   *
   * @param {number} ordinalNumber Position in the list.
   * @returns {number}
   */
  getNextValue(ordinalNumber) {
    return Math.max(...this.getValues()) + 1 + ordinalNumber;
  }
};
var strictBindsMap_default = StrictBindsMap;

// node_modules/handsontable/plugins/bindRowsWithHeaders/bindRowsWithHeaders.mjs
function _classPrivateMethodInitSpec5(obj, privateSet) {
  _checkPrivateRedeclaration5(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration5(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty7(obj, key, value) {
  key = _toPropertyKey7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey7(arg) {
  var key = _toPrimitive7(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive7(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet5(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY5 = "bindRowsWithHeaders";
var PLUGIN_PRIORITY4 = 210;
var DEFAULT_BIND = "loose";
var bindTypeToMapStrategy = /* @__PURE__ */ new Map([["loose", looseBindsMap_default], ["strict", strictBindsMap_default]]);
var _onModifyRowHeader = /* @__PURE__ */ new WeakSet();
var BindRowsWithHeaders = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec5(this, _onModifyRowHeader);
    _defineProperty7(this, "headerIndexes", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY5;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY4;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link BindRowsWithHeaders#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY5];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    let bindType = this.hot.getSettings()[PLUGIN_KEY5];
    if (typeof bindType !== "string") {
      bindType = DEFAULT_BIND;
    }
    const MapStrategy = bindTypeToMapStrategy.get(bindType);
    this.headerIndexes = this.hot.rowIndexMapper.registerMap("bindRowsWithHeaders", new MapStrategy());
    this.addHook("modifyRowHeader", (row) => _classPrivateMethodGet5(this, _onModifyRowHeader, _onModifyRowHeader2).call(this, row));
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.rowIndexMapper.unregisterMap("bindRowsWithHeaders");
    super.disablePlugin();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _onModifyRowHeader2(row) {
  return this.headerIndexes.getValueAtIndex(this.hot.toPhysicalRow(row));
}

// node_modules/handsontable/plugins/collapsibleColumns/collapsibleColumns.mjs
function _classPrivateMethodInitSpec6(obj, privateSet) {
  _checkPrivateRedeclaration6(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec3(obj, privateMap, value) {
  _checkPrivateRedeclaration6(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration6(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty8(obj, key, value) {
  key = _toPropertyKey8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey8(arg) {
  var key = _toPrimitive8(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive8(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet3(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "get");
  return _classApplyDescriptorGet3(receiver, descriptor);
}
function _classApplyDescriptorGet3(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet6(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldSet2(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor3(receiver, privateMap, "set");
  _classApplyDescriptorSet2(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor3(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet2(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var PLUGIN_KEY6 = "collapsibleColumns";
var PLUGIN_PRIORITY5 = 290;
var SETTING_KEYS2 = ["nestedHeaders"];
var COLLAPSIBLE_ELEMENT_CLASS = "collapsibleIndicator";
var SHORTCUTS_GROUP = PLUGIN_KEY6;
var actionDictionary = /* @__PURE__ */ new Map([["collapse", {
  hideColumn: true,
  beforeHook: "beforeColumnCollapse",
  afterHook: "afterColumnCollapse"
}], ["expand", {
  hideColumn: false,
  beforeHook: "beforeColumnExpand",
  afterHook: "afterColumnExpand"
}]]);
var _collapsedColumnsMap = /* @__PURE__ */ new WeakMap();
var _onAfterGetColHeader = /* @__PURE__ */ new WeakSet();
var _onBeforeOnCellMouseDown = /* @__PURE__ */ new WeakSet();
var _onInit = /* @__PURE__ */ new WeakSet();
var _onAfterLoadData4 = /* @__PURE__ */ new WeakSet();
var CollapsibleColumns = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec6(this, _onAfterLoadData4);
    _classPrivateMethodInitSpec6(this, _onInit);
    _classPrivateMethodInitSpec6(this, _onBeforeOnCellMouseDown);
    _classPrivateMethodInitSpec6(this, _onAfterGetColHeader);
    _defineProperty8(this, "nestedHeadersPlugin", null);
    _defineProperty8(this, "headerStateManager", null);
    _classPrivateFieldInitSpec3(this, _collapsedColumnsMap, {
      writable: true,
      value: null
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY6;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY5;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:NestedHeaders"];
  }
  static get SETTING_KEYS() {
    return [PLUGIN_KEY6, ...SETTING_KEYS2];
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link CollapsibleColumns#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY6];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const {
      nestedHeaders
    } = this.hot.getSettings();
    if (!nestedHeaders) {
      warn("You need to configure the Nested Headers plugin in order to use collapsible headers.");
    }
    _classPrivateFieldSet2(this, _collapsedColumnsMap, this.hot.columnIndexMapper.createAndRegisterIndexMap(this.pluginName, "hiding"));
    this.nestedHeadersPlugin = this.hot.getPlugin("nestedHeaders");
    this.headerStateManager = this.nestedHeadersPlugin.getStateManager();
    this.addHook("init", () => _classPrivateMethodGet6(this, _onInit, _onInit2).call(this));
    this.addHook("afterLoadData", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet6(_this, _onAfterLoadData4, _onAfterLoadData23).call(_this, ...args);
    });
    this.addHook("afterGetColHeader", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet6(_this, _onAfterGetColHeader, _onAfterGetColHeader2).call(_this, ...args);
    });
    this.addHook("beforeOnCellMouseDown", (event, coords, TD) => _classPrivateMethodGet6(this, _onBeforeOnCellMouseDown, _onBeforeOnCellMouseDown2).call(this, event, coords, TD));
    this.registerShortcuts();
    super.enablePlugin();
    this.updatePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *   - [`collapsibleColumns`](@/api/options.md#collapsiblecolumns)
   *   - [`nestedHeaders`](@/api/options.md#nestedheaders)
   */
  updatePlugin() {
    if (!this.hot.view) {
      return;
    }
    if (!this.nestedHeadersPlugin.detectedOverlappedHeaders) {
      const {
        collapsibleColumns
      } = this.hot.getSettings();
      if (typeof collapsibleColumns === "boolean") {
        this.headerStateManager.mapState((headerSettings) => {
          return {
            collapsible: headerSettings.origColspan > 1
          };
        });
      } else if (Array.isArray(collapsibleColumns)) {
        this.headerStateManager.mapState(() => {
          return {
            collapsible: false
          };
        });
        this.headerStateManager.mergeStateWith(collapsibleColumns);
      }
    }
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.columnIndexMapper.unregisterMap(this.pluginName);
    _classPrivateFieldSet2(this, _collapsedColumnsMap, null);
    this.nestedHeadersPlugin = null;
    this.unregisterShortcuts();
    this.clearButtons();
    super.disablePlugin();
  }
  /**
   * Register shortcuts responsible for toggling collapsible columns.
   *
   * @private
   */
  registerShortcuts() {
    this.hot.getShortcutManager().getContext("grid").addShortcut({
      keys: [["Enter"]],
      callback: () => {
        var _this$headerStateMana;
        const {
          row,
          col
        } = this.hot.getSelectedRangeLast().highlight;
        const {
          collapsible,
          isCollapsed,
          columnIndex
        } = (_this$headerStateMana = this.headerStateManager.getHeaderTreeNodeData(row, col)) !== null && _this$headerStateMana !== void 0 ? _this$headerStateMana : {};
        if (!collapsible) {
          return;
        }
        if (isCollapsed) {
          this.expandSection({
            row,
            col: columnIndex
          });
        } else {
          this.collapseSection({
            row,
            col: columnIndex
          });
        }
      },
      runOnlyIf: () => {
        var _this$hot$getSelected;
        return (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight.isHeader();
      },
      group: SHORTCUTS_GROUP
    });
  }
  /**
   * Unregister shortcuts responsible for toggling collapsible columns.
   *
   * @private
   */
  unregisterShortcuts() {
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP);
  }
  /**
   * Clears the expand/collapse buttons.
   *
   * @private
   */
  clearButtons() {
    if (!this.hot.view) {
      return;
    }
    const headerLevels = this.hot.view._wt.getSetting("columnHeaders").length;
    const mainHeaders = this.hot.view._wt.wtTable.THEAD;
    const topHeaders = this.hot.view._wt.wtOverlays.topOverlay.clone.wtTable.THEAD;
    const topLeftCornerHeaders = this.hot.view._wt.wtOverlays.topInlineStartCornerOverlay ? this.hot.view._wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;
    const removeButton = function(button) {
      if (button) {
        button.parentNode.removeChild(button);
      }
    };
    rangeEach(0, headerLevels - 1, (i) => {
      const masterLevel = mainHeaders.childNodes[i];
      const topLevel = topHeaders.childNodes[i];
      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;
      rangeEach(0, masterLevel.childNodes.length - 1, (j) => {
        let button = masterLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);
        removeButton(button);
        if (topLevel && topLevel.childNodes[j]) {
          button = topLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);
          removeButton(button);
        }
        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {
          button = topLeftCornerLevel.childNodes[j].querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);
          removeButton(button);
        }
      });
    }, true);
  }
  /**
   * Expands section at the provided coords.
   *
   * @param {object} coords Contains coordinates information. (`coords.row`, `coords.col`).
   */
  expandSection(coords) {
    this.toggleCollapsibleSection([coords], "expand");
  }
  /**
   * Collapses section at the provided coords.
   *
   * @param {object} coords Contains coordinates information. (`coords.row`, `coords.col`).
   */
  collapseSection(coords) {
    this.toggleCollapsibleSection([coords], "collapse");
  }
  /**
   * Collapses or expand all collapsible sections, depending on the action parameter.
   *
   * @param {string} action 'collapse' or 'expand'.
   */
  toggleAllCollapsibleSections(action) {
    const coords = this.headerStateManager.mapNodes((headerSettings) => {
      const {
        collapsible,
        origColspan,
        headerLevel,
        columnIndex,
        isCollapsed
      } = headerSettings;
      if (collapsible === true && origColspan > 1 && (isCollapsed && action === "expand" || !isCollapsed && action === "collapse")) {
        return {
          row: this.headerStateManager.levelToRowCoords(headerLevel),
          col: columnIndex
        };
      }
    });
    this.toggleCollapsibleSection(coords, action);
  }
  /**
   * Collapses all collapsible sections.
   */
  collapseAll() {
    this.toggleAllCollapsibleSections("collapse");
  }
  /**
   * Expands all collapsible sections.
   */
  expandAll() {
    this.toggleAllCollapsibleSections("expand");
  }
  /**
   * Collapses/Expands a section.
   *
   * @param {Array} coords Array of coords - section coordinates.
   * @param {string} [action] Action definition ('collapse' or 'expand').
   * @fires Hooks#beforeColumnCollapse
   * @fires Hooks#beforeColumnExpand
   * @fires Hooks#afterColumnCollapse
   * @fires Hooks#afterColumnExpand
   */
  toggleCollapsibleSection(coords, action) {
    if (!actionDictionary.has(action)) {
      throw new Error(`Unsupported action is passed (${action}).`);
    }
    if (!Array.isArray(coords)) {
      return;
    }
    const filteredCoords = arrayFilter(coords, (_ref) => {
      let {
        row
      } = _ref;
      return row < 0;
    });
    let isActionPossible = filteredCoords.length > 0;
    arrayEach(filteredCoords, (_ref2) => {
      var _this$headerStateMana2;
      let {
        row,
        col: column
      } = _ref2;
      const {
        collapsible,
        isCollapsed
      } = (_this$headerStateMana2 = this.headerStateManager.getHeaderSettings(row, column)) !== null && _this$headerStateMana2 !== void 0 ? _this$headerStateMana2 : {};
      if (!collapsible || isCollapsed && action === "collapse" || !isCollapsed && action === "expand") {
        isActionPossible = false;
        return false;
      }
    });
    const nodeModRollbacks = [];
    const affectedColumnsIndexes = [];
    if (isActionPossible) {
      arrayEach(filteredCoords, (_ref3) => {
        let {
          row,
          col: column
        } = _ref3;
        const {
          colspanCompensation,
          affectedColumns,
          rollbackModification
        } = this.headerStateManager.triggerNodeModification(action, row, column);
        if (colspanCompensation > 0) {
          affectedColumnsIndexes.push(...affectedColumns);
          nodeModRollbacks.push(rollbackModification);
        }
      });
    }
    const currentCollapsedColumns = this.getCollapsedColumns();
    let destinationCollapsedColumns = [];
    if (action === "collapse") {
      destinationCollapsedColumns = arrayUnique([...currentCollapsedColumns, ...affectedColumnsIndexes]);
    } else if (action === "expand") {
      destinationCollapsedColumns = arrayFilter(currentCollapsedColumns, (index) => !affectedColumnsIndexes.includes(index));
    }
    const actionTranslator = actionDictionary.get(action);
    const isActionAllowed = this.hot.runHooks(actionTranslator.beforeHook, currentCollapsedColumns, destinationCollapsedColumns, isActionPossible);
    if (isActionAllowed === false) {
      arrayEach(nodeModRollbacks, (nodeModRollback) => {
        nodeModRollback();
      });
      return;
    }
    this.hot.batchExecution(() => {
      arrayEach(affectedColumnsIndexes, (visualColumn) => {
        _classPrivateFieldGet3(this, _collapsedColumnsMap).setValueAtIndex(this.hot.toPhysicalColumn(visualColumn), actionTranslator.hideColumn);
      });
    }, true);
    const isActionPerformed = this.getCollapsedColumns().length !== currentCollapsedColumns.length;
    this.hot.runHooks(actionTranslator.afterHook, currentCollapsedColumns, destinationCollapsedColumns, isActionPossible, isActionPerformed);
    this.hot.render();
    this.hot.view.adjustElementsSize(true);
  }
  /**
   * Gets an array of physical indexes of collapsed columns.
   *
   * @private
   * @returns {number[]}
   */
  getCollapsedColumns() {
    return _classPrivateFieldGet3(this, _collapsedColumnsMap).getHiddenIndexes();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldSet2(this, _collapsedColumnsMap, null);
    super.destroy();
  }
};
function _onAfterGetColHeader2(column, TH, headerLevel) {
  var _this$headerStateMana3;
  const {
    collapsible,
    origColspan,
    isCollapsed
  } = (_this$headerStateMana3 = this.headerStateManager.getHeaderSettings(headerLevel, column)) !== null && _this$headerStateMana3 !== void 0 ? _this$headerStateMana3 : {};
  const isNodeCollapsible = collapsible && origColspan > 1 && column >= this.hot.getSettings().fixedColumnsStart;
  const isAriaTagsEnabled = this.hot.getSettings().ariaTags;
  let collapsibleElement = TH.querySelector(`.${COLLAPSIBLE_ELEMENT_CLASS}`);
  removeAttribute(TH, [A11Y_EXPANDED("")[0]]);
  if (isNodeCollapsible) {
    if (!collapsibleElement) {
      collapsibleElement = this.hot.rootDocument.createElement("div");
      addClass(collapsibleElement, COLLAPSIBLE_ELEMENT_CLASS);
      TH.querySelector("div:first-child").appendChild(collapsibleElement);
    }
    removeClass(collapsibleElement, ["collapsed", "expanded"]);
    if (isCollapsed) {
      addClass(collapsibleElement, "collapsed");
      fastInnerText(collapsibleElement, "+");
      if (isAriaTagsEnabled) {
        setAttribute(TH, ...A11Y_EXPANDED(false));
      }
    } else {
      addClass(collapsibleElement, "expanded");
      fastInnerText(collapsibleElement, "-");
      if (isAriaTagsEnabled) {
        setAttribute(TH, ...A11Y_EXPANDED(true));
      }
    }
    if (isAriaTagsEnabled) {
      setAttribute(collapsibleElement, ...A11Y_HIDDEN());
    }
  } else {
    var _collapsibleElement;
    (_collapsibleElement = collapsibleElement) === null || _collapsibleElement === void 0 || _collapsibleElement.remove();
  }
}
function _onBeforeOnCellMouseDown2(event, coords) {
  if (hasClass(event.target, COLLAPSIBLE_ELEMENT_CLASS)) {
    if (hasClass(event.target, "expanded")) {
      this.eventManager.fireEvent(event.target, "mouseup");
      this.toggleCollapsibleSection([coords], "collapse");
    } else if (hasClass(event.target, "collapsed")) {
      this.eventManager.fireEvent(event.target, "mouseup");
      this.toggleCollapsibleSection([coords], "expand");
    }
    stopImmediatePropagation(event);
  }
}
function _onInit2() {
  this.updatePlugin();
}
function _onAfterLoadData23(sourceData, initialLoad) {
  if (!initialLoad) {
    this.updatePlugin();
  }
}

// node_modules/handsontable/plugins/columnSorting/columnStatesManager.mjs
function _defineProperty9(obj, key, value) {
  key = _toPropertyKey9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey9(arg) {
  var key = _toPrimitive9(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive9(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var inheritedColumnProperties = ["sortEmptyCells", "indicator", "headerAction", "compareFunctionFactory"];
var SORT_EMPTY_CELLS_DEFAULT = false;
var SHOW_SORT_INDICATOR_DEFAULT = true;
var HEADER_ACTION_DEFAULT = true;
var ColumnStatesManager = class {
  constructor(hot, mapName) {
    _defineProperty9(this, "hot", void 0);
    _defineProperty9(this, "sortingStates", new LinkedPhysicalIndexToValueMap());
    _defineProperty9(this, "sortEmptyCells", SORT_EMPTY_CELLS_DEFAULT);
    _defineProperty9(this, "indicator", SHOW_SORT_INDICATOR_DEFAULT);
    _defineProperty9(this, "headerAction", HEADER_ACTION_DEFAULT);
    _defineProperty9(this, "compareFunctionFactory", void 0);
    _defineProperty9(this, "mapName", void 0);
    this.hot = hot;
    this.mapName = mapName;
    this.hot.columnIndexMapper.registerMap(mapName, this.sortingStates);
  }
  /**
   * Update column properties which affect the sorting result.
   *
   * **Note**: All column properties can be overwritten by {@link Options#columns} option.
   *
   * @param {object} allSortSettings Column sorting plugin's configuration object.
   */
  updateAllColumnsProperties(allSortSettings) {
    if (!isObject(allSortSettings)) {
      return;
    }
    objectEach(allSortSettings, (newValue, propertyName) => {
      if (inheritedColumnProperties.includes(propertyName)) {
        this[propertyName] = newValue;
      }
    });
  }
  /**
   * Get all column properties which affect the sorting result.
   *
   * @returns {object}
   */
  getAllColumnsProperties() {
    const columnProperties = {
      sortEmptyCells: this.sortEmptyCells,
      indicator: this.indicator,
      headerAction: this.headerAction
    };
    if (typeof this.compareFunctionFactory === "function") {
      columnProperties.compareFunctionFactory = this.compareFunctionFactory;
    }
    return columnProperties;
  }
  /**
   * Get sort order of column.
   *
   * @param {number} searchedColumn Visual column index.
   * @returns {string|undefined} Sort order (`asc` for ascending, `desc` for descending and undefined for not sorted).
   */
  getSortOrderOfColumn(searchedColumn) {
    var _this$sortingStates$g;
    return (_this$sortingStates$g = this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(searchedColumn))) === null || _this$sortingStates$g === void 0 ? void 0 : _this$sortingStates$g.sortOrder;
  }
  /**
   * Get order of particular column in the states queue.
   *
   * @param {number} column Visual column index.
   * @returns {number}
   */
  getIndexOfColumnInSortQueue(column) {
    column = this.hot.toPhysicalColumn(column);
    return this.sortingStates.getEntries().findIndex((_ref) => {
      let [physicalColumn] = _ref;
      return physicalColumn === column;
    });
  }
  /**
   * Get number of sorted columns.
   *
   * @returns {number}
   */
  getNumberOfSortedColumns() {
    return this.sortingStates.getLength();
  }
  /**
   * Get if list of sorted columns is empty.
   *
   * @returns {boolean}
   */
  isListOfSortedColumnsEmpty() {
    return this.getNumberOfSortedColumns() === 0;
  }
  /**
   * Get if particular column is sorted.
   *
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  isColumnSorted(column) {
    return isObject(this.sortingStates.getValueAtIndex(this.hot.toPhysicalColumn(column)));
  }
  /**
   * Queue of sort states containing sorted columns and their orders (Array of objects containing `column` and `sortOrder` properties).
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
   *
   * @returns {Array<object>}
   */
  getSortStates() {
    if (this.sortingStates === null) {
      return [];
    }
    const sortingStatesQueue = this.sortingStates.getEntries();
    return sortingStatesQueue.map((_ref2) => {
      let [physicalColumn, value] = _ref2;
      return {
        column: this.hot.toVisualColumn(physicalColumn),
        ...value
      };
    });
  }
  /**
   * Get sort state for particular column. Object contains `column` and `sortOrder` properties.
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
   *
   * @param {number} column Visual column index.
   * @returns {object|undefined}
   */
  getColumnSortState(column) {
    const sortOrder = this.getSortOrderOfColumn(column);
    if (isDefined(sortOrder)) {
      return {
        column,
        sortOrder
      };
    }
  }
  /**
   * Set all column states.
   *
   * @param {Array} sortStates Sort states.
   */
  setSortStates(sortStates) {
    this.sortingStates.clear();
    for (let i = 0; i < sortStates.length; i += 1) {
      this.sortingStates.setValueAtIndex(this.hot.toPhysicalColumn(sortStates[i].column), {
        sortOrder: sortStates[i].sortOrder
      });
    }
  }
  /**
   * Destroy the state manager.
   */
  destroy() {
    this.hot.columnIndexMapper.unregisterMap(this.mapName);
    this.sortingStates = null;
  }
};

// node_modules/handsontable/plugins/columnSorting/utils.mjs
var ASC_SORT_STATE = "asc";
var DESC_SORT_STATE = "desc";
var HEADER_SPAN_CLASS = "colHeader";
function isValidColumnState(columnState) {
  if (isObject(columnState) === false) {
    return false;
  }
  const {
    column,
    sortOrder
  } = columnState;
  return Number.isInteger(column) && [ASC_SORT_STATE, DESC_SORT_STATE].includes(sortOrder);
}
function areValidSortStates(sortStates) {
  if (sortStates.some((columnState) => isValidColumnState(columnState) === false)) {
    return false;
  }
  const sortedColumns = sortStates.map((_ref) => {
    let {
      column
    } = _ref;
    return column;
  });
  return new Set(sortedColumns).size === sortedColumns.length;
}
function getNextSortOrder(sortOrder) {
  if (sortOrder === DESC_SORT_STATE) {
    return;
  } else if (sortOrder === ASC_SORT_STATE) {
    return DESC_SORT_STATE;
  }
  return ASC_SORT_STATE;
}
function getHeaderSpanElement(TH) {
  const headerSpanElement = TH.querySelector(`.${HEADER_SPAN_CLASS}`);
  return headerSpanElement;
}
function isFirstLevelColumnHeader(column, TH) {
  if (column < 0 || !TH.parentNode) {
    return false;
  }
  const TRs = TH.parentNode.parentNode.childNodes;
  const headerLevel = Array.from(TRs).indexOf(TH.parentNode) - TRs.length;
  if (headerLevel !== -1) {
    return false;
  }
  return true;
}
function wasHeaderClickedProperly(row, column, clickEvent) {
  return row === -1 && column >= 0 && isRightClick(clickEvent) === false;
}

// node_modules/handsontable/plugins/columnSorting/domHelpers.mjs
var HEADER_CLASS_ASC_SORT = "ascending";
var HEADER_CLASS_DESC_SORT = "descending";
var HEADER_CLASS_INDICATOR_DISABLED = "indicatorDisabled";
var HEADER_SORT_CLASS = "columnSorting";
var HEADER_ACTION_CLASS = "sortAction";
var orderToCssClass = /* @__PURE__ */ new Map([[ASC_SORT_STATE, HEADER_CLASS_ASC_SORT], [DESC_SORT_STATE, HEADER_CLASS_DESC_SORT]]);
function getClassesToAdd(columnStatesManager, column, showSortIndicator, headerAction) {
  const cssClasses = [HEADER_SORT_CLASS];
  if (headerAction) {
    cssClasses.push(HEADER_ACTION_CLASS);
  }
  if (showSortIndicator === false) {
    cssClasses.push(HEADER_CLASS_INDICATOR_DISABLED);
    return cssClasses;
  }
  const columnOrder = columnStatesManager.getSortOrderOfColumn(column);
  if (isDefined(columnOrder)) {
    cssClasses.push(orderToCssClass.get(columnOrder));
  }
  return cssClasses;
}
function getClassesToRemove() {
  return Array.from(orderToCssClass.values()).concat(HEADER_ACTION_CLASS, HEADER_CLASS_INDICATOR_DISABLED, HEADER_SORT_CLASS);
}

// node_modules/handsontable/plugins/columnSorting/sortFunction/default.mjs
function compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings) {
  const locale = columnMeta.locale;
  return function(value, nextValue) {
    const {
      sortEmptyCells
    } = columnPluginSettings;
    if (typeof value === "string") {
      value = value.toLocaleLowerCase(locale);
    }
    if (typeof nextValue === "string") {
      nextValue = nextValue.toLocaleLowerCase(locale);
    }
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    if (isNaN(value) && !isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    } else if (!isNaN(value) && isNaN(nextValue)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (!(isNaN(value) || isNaN(nextValue))) {
      value = parseFloat(value);
      nextValue = parseFloat(nextValue);
    }
    if (value < nextValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (value > nextValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE = "default";

// node_modules/handsontable/plugins/columnSorting/sortFunction/numeric.mjs
function compareFunctionFactory2(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    const parsedFirstValue = parseFloat(value);
    const parsedSecondValue = parseFloat(nextValue);
    const {
      sortEmptyCells
    } = columnPluginSettings;
    if (parsedFirstValue === parsedSecondValue || isNaN(parsedFirstValue) && isNaN(parsedSecondValue)) {
      return DO_NOT_SWAP;
    }
    if (sortEmptyCells) {
      if (isEmpty(value)) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      if (isEmpty(nextValue)) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
    }
    if (isNaN(parsedFirstValue)) {
      return FIRST_AFTER_SECOND;
    }
    if (isNaN(parsedSecondValue)) {
      return FIRST_BEFORE_SECOND;
    }
    if (parsedFirstValue < parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    } else if (parsedFirstValue > parsedSecondValue) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE2 = "numeric";

// node_modules/handsontable/plugins/columnSorting/sortFunction/checkbox.mjs
function compareFunctionFactory3(sortOrder, columnMeta, columnPluginSettings) {
  const checkedTemplate = columnMeta.checkedTemplate;
  const uncheckedTemplate = columnMeta.uncheckedTemplate;
  const {
    sortEmptyCells
  } = columnPluginSettings;
  return function(value, nextValue) {
    const isEmptyValue = isEmpty(value);
    const isEmptyNextValue = isEmpty(nextValue);
    const unifiedValue = isEmptyValue ? uncheckedTemplate : value;
    const unifiedNextValue = isEmptyNextValue ? uncheckedTemplate : nextValue;
    const isValueFromTemplate = unifiedValue === uncheckedTemplate || unifiedValue === checkedTemplate;
    const isNextValueFromTemplate = unifiedNextValue === uncheckedTemplate || unifiedNextValue === checkedTemplate;
    if (sortEmptyCells === false) {
      if (isEmptyValue && isEmptyNextValue === false) {
        return FIRST_AFTER_SECOND;
      }
      if (isEmptyValue === false && isEmptyNextValue) {
        return FIRST_BEFORE_SECOND;
      }
    }
    if (isValueFromTemplate === false && isNextValueFromTemplate) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (isValueFromTemplate && isNextValueFromTemplate === false) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    if (isValueFromTemplate === false && isNextValueFromTemplate === false) {
      return compareFunctionFactory(sortOrder, columnMeta, columnPluginSettings)(value, nextValue);
    }
    if (unifiedValue === uncheckedTemplate && unifiedNextValue === checkedTemplate) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (unifiedValue === checkedTemplate && unifiedNextValue === uncheckedTemplate) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE3 = "checkbox";

// node_modules/handsontable/plugins/columnSorting/sortFunction/date.mjs
init_moment();
function compareFunctionFactory4(sortOrder, columnMeta, columnPluginSettings) {
  return function(value, nextValue) {
    const {
      sortEmptyCells
    } = columnPluginSettings;
    if (value === nextValue) {
      return DO_NOT_SWAP;
    }
    if (isEmpty(value)) {
      if (isEmpty(nextValue)) {
        return DO_NOT_SWAP;
      }
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
      }
      return FIRST_AFTER_SECOND;
    }
    if (isEmpty(nextValue)) {
      if (sortEmptyCells) {
        return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
      }
      return FIRST_BEFORE_SECOND;
    }
    const dateFormat = columnMeta.dateFormat;
    const firstDate = moment_default(value, dateFormat);
    const nextDate = moment_default(nextValue, dateFormat);
    if (!firstDate.isValid()) {
      return FIRST_AFTER_SECOND;
    }
    if (!nextDate.isValid()) {
      return FIRST_BEFORE_SECOND;
    }
    if (nextDate.isAfter(firstDate)) {
      return sortOrder === "asc" ? FIRST_BEFORE_SECOND : FIRST_AFTER_SECOND;
    }
    if (nextDate.isBefore(firstDate)) {
      return sortOrder === "asc" ? FIRST_AFTER_SECOND : FIRST_BEFORE_SECOND;
    }
    return DO_NOT_SWAP;
  };
}
var COLUMN_DATA_TYPE4 = "date";

// node_modules/handsontable/plugins/columnSorting/sortService/registry.mjs
var {
  register: registerCompareFunctionFactory,
  getItem: getGloballyCompareFunctionFactory,
  hasItem: hasGloballyCompareFunctionFactory
} = staticRegister("sorting.compareFunctionFactory");
var {
  register: registerRootComparator,
  getItem: getRootComparator
} = staticRegister("sorting.mainSortComparator");
function getCompareFunctionFactory(type) {
  if (hasGloballyCompareFunctionFactory(type)) {
    return getGloballyCompareFunctionFactory(type);
  }
  return getGloballyCompareFunctionFactory(COLUMN_DATA_TYPE);
}
registerCompareFunctionFactory(COLUMN_DATA_TYPE2, compareFunctionFactory2);
registerCompareFunctionFactory(COLUMN_DATA_TYPE3, compareFunctionFactory3);
registerCompareFunctionFactory(COLUMN_DATA_TYPE4, compareFunctionFactory4);
registerCompareFunctionFactory(COLUMN_DATA_TYPE, compareFunctionFactory);

// node_modules/handsontable/plugins/columnSorting/sortService/engine.mjs
var DO_NOT_SWAP = 0;
var FIRST_BEFORE_SECOND = -1;
var FIRST_AFTER_SECOND = 1;
function sort(indexesWithData, rootComparatorId) {
  const rootComparator3 = getRootComparator(rootComparatorId);
  for (var _len = arguments.length, argsForRootComparator = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    argsForRootComparator[_key - 2] = arguments[_key];
  }
  indexesWithData.sort(rootComparator3(...argsForRootComparator));
}

// node_modules/handsontable/plugins/columnSorting/rootComparator.mjs
function rootComparator(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    const [, ...values] = rowIndexWithValues;
    const [, ...nextValues] = nextRowIndexWithValues;
    return function getCompareResult(column) {
      const sortingOrder = sortingOrders[column];
      const columnMeta = columnMetas[column];
      const value = values[column];
      const nextValue = nextValues[column];
      const pluginSettings = columnMeta.columnSorting;
      const compareFunctionFactory5 = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      const compareResult = compareFunctionFactory5(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      return compareResult;
    }(0);
  };
}

// node_modules/handsontable/plugins/columnSorting/columnSorting.mjs
function _classPrivateMethodInitSpec7(obj, privateSet) {
  _checkPrivateRedeclaration7(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration7(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty10(obj, key, value) {
  key = _toPropertyKey10(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey10(arg) {
  var key = _toPrimitive10(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive10(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet7(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY7 = "columnSorting";
var PLUGIN_PRIORITY6 = 50;
var APPEND_COLUMN_CONFIG_STRATEGY = "append";
var REPLACE_COLUMN_CONFIG_STRATEGY = "replace";
var SHORTCUTS_GROUP2 = PLUGIN_KEY7;
registerRootComparator(PLUGIN_KEY7, rootComparator);
pluginHooks_default.getSingleton().register("beforeColumnSort");
pluginHooks_default.getSingleton().register("afterColumnSort");
var _loadOrSortBySettings = /* @__PURE__ */ new WeakSet();
var _onAfterGetColHeader3 = /* @__PURE__ */ new WeakSet();
var _onAfterLoadData5 = /* @__PURE__ */ new WeakSet();
var _onBeforeOnCellMouseDown3 = /* @__PURE__ */ new WeakSet();
var ColumnSorting = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec7(this, _onBeforeOnCellMouseDown3);
    _classPrivateMethodInitSpec7(this, _onAfterLoadData5);
    _classPrivateMethodInitSpec7(this, _onAfterGetColHeader3);
    _classPrivateMethodInitSpec7(this, _loadOrSortBySettings);
    _defineProperty10(this, "columnStatesManager", null);
    _defineProperty10(this, "columnMetaCache", null);
    _defineProperty10(this, "pluginKey", PLUGIN_KEY7);
    _defineProperty10(this, "indexesSequenceCache", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY7;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY6;
  }
  /**
   * Checks if the plugin is enabled in the Handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ColumnSorting#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[this.pluginKey];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.columnStatesManager = new ColumnStatesManager(this.hot, `${this.pluginKey}.sortingStates`);
    this.columnMetaCache = new PhysicalIndexToValueMap((physicalIndex) => {
      let visualIndex = this.hot.toVisualColumn(physicalIndex);
      if (visualIndex === null) {
        visualIndex = physicalIndex;
      }
      return this.getMergedPluginSettings(visualIndex);
    });
    this.hot.columnIndexMapper.registerMap(`${this.pluginKey}.columnMeta`, this.columnMetaCache);
    this.addHook("afterGetColHeader", (column, TH) => _classPrivateMethodGet7(this, _onAfterGetColHeader3, _onAfterGetColHeader22).call(this, column, TH));
    this.addHook("beforeOnCellMouseDown", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet7(_this, _onBeforeOnCellMouseDown3, _onBeforeOnCellMouseDown22).call(_this, ...args);
    });
    this.addHook("afterOnCellMouseDown", (event, target) => this.onAfterOnCellMouseDown(event, target));
    this.addHook("afterInit", () => _classPrivateMethodGet7(this, _loadOrSortBySettings, _loadOrSortBySettings2).call(this));
    this.addHook("afterLoadData", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet7(_this, _onAfterLoadData5, _onAfterLoadData24).call(_this, ...args);
    });
    if (this.hot.view) {
      _classPrivateMethodGet7(this, _loadOrSortBySettings, _loadOrSortBySettings2).call(this);
    }
    this.registerShortcuts();
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    const clearColHeader = (column, TH) => {
      const headerSpanElement = getHeaderSpanElement(TH);
      if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
        return;
      }
      this.updateHeaderClasses(headerSpanElement);
    };
    this.hot.addHook("afterGetColHeader", clearColHeader);
    this.hot.addHookOnce("afterViewRender", () => {
      this.hot.removeHook("afterGetColHeader", clearColHeader);
    });
    this.hot.batchExecution(() => {
      if (this.indexesSequenceCache !== null) {
        this.hot.rowIndexMapper.setIndexesSequence(this.indexesSequenceCache.getValues());
        this.hot.rowIndexMapper.unregisterMap(this.pluginKey);
      }
    }, true);
    this.hot.columnIndexMapper.unregisterMap(`${this.pluginKey}.columnMeta`);
    this.columnStatesManager.destroy();
    this.columnMetaCache = null;
    this.columnStatesManager = null;
    this.unregisterShortcuts();
    super.disablePlugin();
  }
  /**
   * Register shortcuts responsible for toggling column sorting functionality.
   *
   * @private
   */
  registerShortcuts() {
    this.hot.getShortcutManager().getContext("grid").addShortcut({
      keys: [["Enter"]],
      callback: () => {
        const {
          highlight
        } = this.hot.getSelectedRangeLast();
        if (highlight.row === -1 && highlight.col >= 0) {
          this.sort(this.getColumnNextConfig(highlight.col));
        }
      },
      runOnlyIf: () => {
        var _this$hot$getSelected;
        const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
        return highlight && this.hot.selection.isCellVisible(highlight) && highlight.isHeader();
      },
      group: SHORTCUTS_GROUP2
    });
  }
  /**
   * Unregister shortcuts responsible for toggling column sorting functionality.
   *
   * @private
   */
  unregisterShortcuts() {
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP2);
  }
  // DIFF - MultiColumnSorting & ColumnSorting: changed function documentation.
  /**
   * Sorts the table by chosen columns and orders.
   *
   * @param {undefined|object} sortConfig Single column sort configuration. The configuration object contains `column` and `sortOrder` properties.
   * First of them contains visual column index, the second one contains sort order (`asc` for ascending, `desc` for descending).
   *
   * **Note**: Please keep in mind that every call of `sort` function set an entirely new sort order. Previous sort configs aren't preserved.
   *
   * @example
   * ```js
   * // sort ascending first visual column
   * hot.getPlugin('columnSorting').sort({ column: 0, sortOrder: 'asc' });
   * ```
   *
   * @fires Hooks#beforeColumnSort
   * @fires Hooks#afterColumnSort
   */
  sort(sortConfig) {
    const currentSortConfig = this.getSortConfig();
    const destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
    const sortPossible = this.areValidSortConfigs(destinationSortConfigs);
    const allowSort = this.hot.runHooks("beforeColumnSort", currentSortConfig, destinationSortConfigs, sortPossible);
    if (allowSort === false) {
      return;
    }
    if (currentSortConfig.length === 0 && this.indexesSequenceCache === null) {
      this.indexesSequenceCache = this.hot.rowIndexMapper.registerMap(this.pluginKey, new IndexesSequence());
      this.indexesSequenceCache.setValues(this.hot.rowIndexMapper.getIndexesSequence());
    }
    if (sortPossible) {
      this.columnStatesManager.setSortStates(destinationSortConfigs);
      this.sortByPresetSortStates(destinationSortConfigs);
      this.saveAllSortSettings(destinationSortConfigs);
    }
    this.hot.runHooks("afterColumnSort", currentSortConfig, sortPossible ? destinationSortConfigs : currentSortConfig, sortPossible);
    if (sortPossible) {
      this.hot.render();
      this.hot.forceFullRender = false;
      this.hot.view.render();
    }
  }
  /**
   * Clear the sort performed on the table.
   */
  clearSort() {
    this.sort([]);
  }
  /**
   * Checks if the table is sorted (any column have to be sorted).
   *
   * @returns {boolean}
   */
  isSorted() {
    return this.enabled && !this.columnStatesManager.isListOfSortedColumnsEmpty();
  }
  /**
   * Get sort configuration for particular column or for all sorted columns. Objects contain `column` and `sortOrder` properties.
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key. They are handled by the `sort` function.
   *
   * @param {number} [column] Visual column index.
   * @returns {undefined|object|Array}
   */
  getSortConfig(column) {
    if (isDefined(column)) {
      return this.columnStatesManager.getColumnSortState(column);
    }
    return this.columnStatesManager.getSortStates();
  }
  /**
   * @description
   * Warn: Useful mainly for providing server side sort implementation (see in the example below). It doesn't sort the data set. It just sets sort configuration for all sorted columns.
   * Note: Please keep in mind that this method doesn't re-render the table.
   *
   * @example
   * ```js
   * beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {
   *   const columnSortPlugin = this.getPlugin('columnSorting');
   *
   *   columnSortPlugin.setSortConfig(destinationSortConfigs);
   *
   *   // const newData = ... // Calculated data set, ie. from an AJAX call.
   *
   *   this.loadData(newData); // Load new data set and re-render the table.
   *
   *   return false; // The blockade for the default sort action.
   * }
   * ```
   *
   * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   */
  setSortConfig(sortConfig) {
    const destinationSortConfigs = this.getNormalizedSortConfigs(sortConfig);
    if (this.areValidSortConfigs(destinationSortConfigs)) {
      this.columnStatesManager.setSortStates(destinationSortConfigs);
    }
  }
  /**
   * Get normalized sort configs.
   *
   * @private
   * @param {object|Array} [sortConfig=[]] Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   * @returns {Array}
   */
  getNormalizedSortConfigs() {
    let sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (Array.isArray(sortConfig)) {
      return sortConfig.slice(0, 1);
    }
    return [sortConfig];
  }
  /**
   * Get if sort configs are valid.
   *
   * @private
   * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
   * @returns {boolean}
   */
  areValidSortConfigs(sortConfigs) {
    const numberOfColumns = this.hot.countCols();
    return areValidSortStates(sortConfigs) && sortConfigs.every((_ref) => {
      let {
        column
      } = _ref;
      return column <= numberOfColumns && column >= 0;
    });
  }
  /**
   * Saves all sorting settings. Saving works only when {@link Options#persistentState} option is enabled.
   *
   * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
   *
   * @private
   * @fires Hooks#persistentStateSave
   */
  saveAllSortSettings(sortConfigs) {
    const allSortSettings = this.columnStatesManager.getAllColumnsProperties();
    const translateColumnToPhysical = (_ref2) => {
      let {
        column: visualColumn,
        ...restOfProperties
      } = _ref2;
      return {
        column: this.hot.toPhysicalColumn(visualColumn),
        ...restOfProperties
      };
    };
    allSortSettings.initialConfig = arrayMap(sortConfigs, translateColumnToPhysical);
    this.hot.runHooks("persistentStateSave", "columnSorting", allSortSettings);
  }
  /**
   * Get all saved sorting settings. Loading works only when {@link Options#persistentState} option is enabled.
   *
   * @private
   * @returns {object} Previously saved sort settings.
   *
   * @fires Hooks#persistentStateLoad
   */
  getAllSavedSortSettings() {
    const storedAllSortSettings = {};
    this.hot.runHooks("persistentStateLoad", "columnSorting", storedAllSortSettings);
    const allSortSettings = storedAllSortSettings.value;
    const translateColumnToVisual = (_ref3) => {
      let {
        column: physicalColumn,
        ...restOfProperties
      } = _ref3;
      return {
        column: this.hot.toVisualColumn(physicalColumn),
        ...restOfProperties
      };
    };
    if (isDefined(allSortSettings) && Array.isArray(allSortSettings.initialConfig)) {
      allSortSettings.initialConfig = arrayMap(allSortSettings.initialConfig, translateColumnToVisual);
    }
    return allSortSettings;
  }
  /**
   * Get next sort configuration for particular column. Object contain `column` and `sortOrder` properties.
   *
   * **Note**: Please keep in mind that returned object expose **visual** column index under the `column` key.
   *
   * @private
   * @param {number} column Visual column index.
   * @returns {undefined|object}
   */
  getColumnNextConfig(column) {
    const sortOrder = this.columnStatesManager.getSortOrderOfColumn(column);
    if (isDefined(sortOrder)) {
      const nextSortOrder = getNextSortOrder(sortOrder);
      if (isDefined(nextSortOrder)) {
        return {
          column,
          sortOrder: nextSortOrder
        };
      }
      return;
    }
    const nrOfColumns = this.hot.countCols();
    if (Number.isInteger(column) && column >= 0 && column < nrOfColumns) {
      return {
        column,
        sortOrder: getNextSortOrder()
      };
    }
  }
  /**
   * Get sort configuration with "next order" for particular column.
   *
   * @private
   * @param {number} columnToChange Visual column index of column which order will be changed.
   * @param {string} strategyId ID of strategy. Possible values: 'append' and 'replace'. The first one
   * change order of particular column and change it's position in the sort queue to the last one. The second one
   * just change order of particular column.
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key.
   *
   * @returns {Array}
   */
  getNextSortConfig(columnToChange) {
    let strategyId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : APPEND_COLUMN_CONFIG_STRATEGY;
    const indexOfColumnToChange = this.columnStatesManager.getIndexOfColumnInSortQueue(columnToChange);
    const isColumnSorted = indexOfColumnToChange !== -1;
    const currentSortConfig = this.getSortConfig();
    const nextColumnConfig = this.getColumnNextConfig(columnToChange);
    if (isColumnSorted) {
      if (isUndefined(nextColumnConfig)) {
        return [...currentSortConfig.slice(0, indexOfColumnToChange), ...currentSortConfig.slice(indexOfColumnToChange + 1)];
      }
      if (strategyId === APPEND_COLUMN_CONFIG_STRATEGY) {
        return [...currentSortConfig.slice(0, indexOfColumnToChange), ...currentSortConfig.slice(indexOfColumnToChange + 1), nextColumnConfig];
      } else if (strategyId === REPLACE_COLUMN_CONFIG_STRATEGY) {
        return [...currentSortConfig.slice(0, indexOfColumnToChange), nextColumnConfig, ...currentSortConfig.slice(indexOfColumnToChange + 1)];
      }
    }
    if (isDefined(nextColumnConfig)) {
      return currentSortConfig.concat(nextColumnConfig);
    }
    return currentSortConfig;
  }
  /**
   * Get plugin's column config for the specified column index.
   *
   * @private
   * @param {object} columnConfig Configuration inside `columns` property for the specified column index.
   * @returns {object}
   */
  getPluginColumnConfig(columnConfig) {
    if (isObject(columnConfig)) {
      const pluginColumnConfig = columnConfig[this.pluginKey];
      if (isObject(pluginColumnConfig)) {
        return pluginColumnConfig;
      }
    }
    return {};
  }
  /**
   * Get plugin settings related properties, properly merged from cascade settings.
   *
   * @private
   * @param {number} column Visual column index.
   * @returns {object}
   */
  getMergedPluginSettings(column) {
    const pluginMainSettings = this.hot.getSettings()[this.pluginKey];
    const storedColumnProperties = this.columnStatesManager.getAllColumnsProperties();
    const cellMeta = this.hot.getCellMeta(0, column);
    const columnMeta = Object.getPrototypeOf(cellMeta);
    if (Array.isArray(columnMeta.columns)) {
      return Object.assign(storedColumnProperties, pluginMainSettings, this.getPluginColumnConfig(columnMeta.columns[column]));
    } else if (isFunction(columnMeta.columns)) {
      return Object.assign(storedColumnProperties, pluginMainSettings, this.getPluginColumnConfig(columnMeta.columns(column)));
    }
    return Object.assign(storedColumnProperties, pluginMainSettings);
  }
  /**
   * Get copy of settings for first cell in the column.
   *
   * @private
   * @param {number} column Visual column index.
   * @returns {object}
   */
  // TODO: Workaround. Inheriting of non-primitive cell meta values doesn't work. Instead of getting properties from column meta we call this function.
  // TODO: Remove test named: "should not break the dataset when inserted new row" (#5431).
  getFirstCellSettings(column) {
    const cellMeta = this.hot.getCellMeta(0, column);
    const cellMetaCopy = Object.create(cellMeta);
    cellMetaCopy[this.pluginKey] = this.columnMetaCache.getValueAtIndex(this.hot.toPhysicalColumn(column));
    return cellMetaCopy;
  }
  /**
   * Get number of rows which should be sorted.
   *
   * @private
   * @param {number} numberOfRows Total number of displayed rows.
   * @returns {number}
   */
  getNumberOfRowsToSort(numberOfRows) {
    const settings = this.hot.getSettings();
    if (settings.maxRows <= numberOfRows) {
      return settings.maxRows;
    }
    return numberOfRows - settings.minSpareRows;
  }
  /**
   * Performs the sorting using a stable sort function basing on internal state of sorting.
   *
   * @param {Array} sortConfigs Sort configuration for all sorted columns. Objects contain `column` and `sortOrder` properties.
   * @private
   */
  sortByPresetSortStates(sortConfigs) {
    if (sortConfigs.length === 0) {
      this.hot.rowIndexMapper.setIndexesSequence(this.indexesSequenceCache.getValues());
      return;
    }
    const indexesWithData = [];
    const numberOfRows = this.hot.countRows();
    const getDataForSortedColumns = (visualRowIndex) => arrayMap(sortConfigs, (sortConfig) => this.hot.getDataAtCell(visualRowIndex, sortConfig.column));
    for (let visualRowIndex = 0; visualRowIndex < this.getNumberOfRowsToSort(numberOfRows); visualRowIndex += 1) {
      indexesWithData.push([this.hot.toPhysicalRow(visualRowIndex)].concat(getDataForSortedColumns(visualRowIndex)));
    }
    const indexesBefore = arrayMap(indexesWithData, (indexWithData) => indexWithData[0]);
    sort(indexesWithData, this.pluginKey, arrayMap(sortConfigs, (sortConfig) => sortConfig.sortOrder), arrayMap(sortConfigs, (sortConfig) => this.getFirstCellSettings(sortConfig.column)));
    for (let visualRowIndex = indexesWithData.length; visualRowIndex < numberOfRows; visualRowIndex += 1) {
      indexesWithData.push([visualRowIndex].concat(getDataForSortedColumns(visualRowIndex)));
    }
    const indexesAfter = arrayMap(indexesWithData, (indexWithData) => indexWithData[0]);
    const indexMapping = new Map(arrayMap(indexesBefore, (indexBefore, indexInsideArray) => [indexBefore, indexesAfter[indexInsideArray]]));
    const newIndexesSequence = arrayMap(this.hot.rowIndexMapper.getIndexesSequence(), (physicalIndex) => {
      if (indexMapping.has(physicalIndex)) {
        return indexMapping.get(physicalIndex);
      }
      return physicalIndex;
    });
    this.hot.rowIndexMapper.setIndexesSequence(newIndexesSequence);
  }
  /**
   * Sort the table by provided configuration.
   *
   * @private
   * @param {object} allSortSettings All sort config settings. Object may contain `initialConfig`, `indicator`,
   * `sortEmptyCells`, `headerAction` and `compareFunctionFactory` properties.
   */
  sortBySettings(allSortSettings) {
    if (isObject(allSortSettings)) {
      this.columnStatesManager.updateAllColumnsProperties(allSortSettings);
      const initialConfig = allSortSettings.initialConfig;
      if (Array.isArray(initialConfig) || isObject(initialConfig)) {
        this.sort(initialConfig);
      }
    } else {
      this.hot.render();
    }
  }
  /**
   * Update header classes.
   *
   * @private
   * @param {HTMLElement} headerSpanElement Header span element.
   * @param {...*} args Extra arguments for helpers.
   */
  updateHeaderClasses(headerSpanElement) {
    removeClass(headerSpanElement, getClassesToRemove(headerSpanElement));
    if (this.enabled !== false) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      addClass(headerSpanElement, getClassesToAdd(...args));
    }
  }
  /**
   * Overwriting base plugin's `onUpdateSettings` method. Please keep in mind that `onAfterUpdateSettings` isn't called
   * for `updateSettings` in specific situations.
   *
   * @private
   * @param {object} newSettings New settings object.
   */
  onUpdateSettings(newSettings) {
    super.onUpdateSettings();
    if (this.columnMetaCache !== null) {
      this.columnMetaCache.init(this.hot.columnIndexMapper.getNumberOfIndexes());
    }
    if (isDefined(newSettings[this.pluginKey])) {
      this.sortBySettings(newSettings[this.pluginKey]);
    }
  }
  /**
   * Indicates if clickable header was clicked.
   *
   * @private
   * @param {MouseEvent} event The `mousedown` event.
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  wasClickableHeaderClicked(event, column) {
    const pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
    const headerActionEnabled = pluginSettingsForColumn.headerAction;
    return headerActionEnabled && hasClass(event.target, HEADER_SPAN_CLASS);
  }
  /**
   * Callback for the `onAfterOnCellMouseDown` hook.
   *
   * @private
   * @param {Event} event Event which are provided by hook.
   * @param {CellCoords} coords Visual coords of the selected cell.
   */
  onAfterOnCellMouseDown(event, coords) {
    if (wasHeaderClickedProperly(coords.row, coords.col, event) === false) {
      return;
    }
    if (this.wasClickableHeaderClicked(event, coords.col)) {
      if (this.hot.getShortcutManager().isCtrlPressed()) {
        this.hot.deselectCell();
        this.hot.selectColumns(coords.col);
      }
      this.sort(this.getColumnNextConfig(coords.col));
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    var _this$columnStatesMan;
    (_this$columnStatesMan = this.columnStatesManager) === null || _this$columnStatesMan === void 0 || _this$columnStatesMan.destroy();
    super.destroy();
  }
};
function _loadOrSortBySettings2() {
  const storedAllSortSettings = this.getAllSavedSortSettings();
  if (isObject(storedAllSortSettings)) {
    this.sortBySettings(storedAllSortSettings);
  } else {
    const allSortSettings = this.hot.getSettings()[this.pluginKey];
    this.sortBySettings(allSortSettings);
  }
}
function _onAfterGetColHeader22(column, TH) {
  const headerSpanElement = getHeaderSpanElement(TH);
  if (isFirstLevelColumnHeader(column, TH) === false || headerSpanElement === null) {
    return;
  }
  const pluginSettingsForColumn = this.getFirstCellSettings(column)[this.pluginKey];
  const showSortIndicator = pluginSettingsForColumn.indicator;
  const headerActionEnabled = pluginSettingsForColumn.headerAction;
  this.updateHeaderClasses(headerSpanElement, this.columnStatesManager, column, showSortIndicator, headerActionEnabled);
  if (this.hot.getSettings().ariaTags) {
    const currentSortState = this.columnStatesManager.getSortOrderOfColumn(column);
    setAttribute(TH, ...A11Y_SORT(currentSortState ? `${currentSortState}ending` : "none"));
  }
}
function _onAfterLoadData24(initialLoad) {
  if (initialLoad === true) {
    if (this.hot.view) {
      _classPrivateMethodGet7(this, _loadOrSortBySettings, _loadOrSortBySettings2).call(this);
    }
  }
}
function _onBeforeOnCellMouseDown22(event, coords, TD, controller) {
  if (wasHeaderClickedProperly(coords.row, coords.col, event) === false) {
    return;
  }
  if (this.wasClickableHeaderClicked(event, coords.col) && this.hot.getShortcutManager().isCtrlPressed()) {
    controller.column = true;
  }
}

// node_modules/handsontable/plugins/columnSummary/endpoints.mjs
function _defineProperty11(obj, key, value) {
  key = _toPropertyKey11(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey11(arg) {
  var key = _toPrimitive11(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive11(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Endpoints = class {
  constructor(plugin, settings) {
    _defineProperty11(this, "plugin", void 0);
    _defineProperty11(this, "hot", void 0);
    _defineProperty11(this, "endpoints", []);
    _defineProperty11(this, "settings", void 0);
    _defineProperty11(this, "settingsType", "array");
    _defineProperty11(this, "currentEndpoint", null);
    _defineProperty11(this, "cellsToSetCache", []);
    this.plugin = plugin;
    this.hot = this.plugin.hot;
    this.settings = settings;
  }
  /**
   * Get a single endpoint object.
   *
   * @param {number} index Index of the endpoint.
   * @returns {object}
   */
  getEndpoint(index) {
    if (this.settingsType === "function") {
      return this.fillMissingEndpointData(this.settings)[index];
    }
    return this.endpoints[index];
  }
  /**
   * Get an array with all the endpoints.
   *
   * @returns {Array}
   */
  getAllEndpoints() {
    if (this.settingsType === "function") {
      return this.fillMissingEndpointData(this.settings);
    }
    return this.endpoints;
  }
  /**
   * Used to fill the blanks in the endpoint data provided by a settings function.
   *
   * @private
   * @param {Function} func Function provided in the HOT settings.
   * @returns {Array} An array of endpoints.
   */
  fillMissingEndpointData(func) {
    return this.parseSettings(func.call(this));
  }
  /**
   * Parse plugin's settings.
   *
   * @param {Array} settings The settings array.
   * @returns {object[]}
   */
  parseSettings(settings) {
    const endpointsArray = [];
    let settingsArray = settings;
    if (!settingsArray && typeof this.settings === "function") {
      this.settingsType = "function";
      return;
    }
    if (!settingsArray) {
      settingsArray = this.settings;
    }
    arrayEach(settingsArray, (val) => {
      const newEndpoint = {};
      this.assignSetting(val, newEndpoint, "ranges", [[0, this.hot.countRows() - 1]]);
      this.assignSetting(val, newEndpoint, "reversedRowCoords", false);
      this.assignSetting(val, newEndpoint, "destinationRow", new Error(`
        You must provide a destination row for the Column Summary plugin in order to work properly!
      `));
      this.assignSetting(val, newEndpoint, "destinationColumn", new Error(`
        You must provide a destination column for the Column Summary plugin in order to work properly!
      `));
      this.assignSetting(val, newEndpoint, "sourceColumn", val.destinationColumn);
      this.assignSetting(val, newEndpoint, "type", "sum");
      this.assignSetting(val, newEndpoint, "forceNumeric", false);
      this.assignSetting(val, newEndpoint, "suppressDataTypeErrors", true);
      this.assignSetting(val, newEndpoint, "suppressDataTypeErrors", true);
      this.assignSetting(val, newEndpoint, "customFunction", null);
      this.assignSetting(val, newEndpoint, "readOnly", true);
      this.assignSetting(val, newEndpoint, "roundFloat", false);
      endpointsArray.push(newEndpoint);
    });
    return endpointsArray;
  }
  /**
   * Setter for the internal setting objects.
   *
   * @param {object} settings Object with the settings.
   * @param {object} endpoint Contains information about the endpoint for the the calculation.
   * @param {string} name Settings name.
   * @param {object} defaultValue Default value for the settings.
   */
  assignSetting(settings, endpoint, name, defaultValue) {
    if (name === "ranges" && settings[name] === void 0) {
      endpoint[name] = defaultValue;
      return;
    } else if (name === "ranges" && settings[name].length === 0) {
      return;
    }
    if (settings[name] === void 0) {
      if (defaultValue instanceof Error) {
        throw defaultValue;
      }
      endpoint[name] = defaultValue;
    } else {
      if (name === "destinationRow" && endpoint.reversedRowCoords) {
        endpoint[name] = this.hot.countRows() - settings[name] - 1;
      } else {
        endpoint[name] = settings[name];
      }
    }
  }
  /**
   * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.
   *
   * @private
   * @param {string} action Type of the action performed.
   * @param {number} index Row/column index.
   * @param {number} number Number of rows/columns added/removed.
   */
  resetSetupBeforeStructureAlteration(action, index, number) {
    if (this.settingsType !== "function") {
      return;
    }
    const type = action.indexOf("row") > -1 ? "row" : "col";
    const endpoints = this.getAllEndpoints();
    arrayEach(endpoints, (val) => {
      if (type === "row" && val.destinationRow >= index) {
        if (action === "insert_row") {
          val.alterRowOffset = number;
        } else if (action === "remove_row") {
          val.alterRowOffset = -1 * number;
        }
      }
      if (type === "col" && val.destinationColumn >= index) {
        if (action === "insert_col") {
          val.alterColumnOffset = number;
        } else if (action === "remove_col") {
          val.alterColumnOffset = -1 * number;
        }
      }
    });
    this.resetAllEndpoints(endpoints, false);
  }
  /**
   * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality
   * after changing the table structure.
   *
   * @private
   * @param {string} action Type of the action performed.
   * @param {number} index Row/column index.
   * @param {number} number Number of rows/columns added/removed.
   * @param {Array} [logicRows] Array of the logical indexes.
   * @param {string} [source] Source of change.
   * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.
   */
  resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {
    let forceRefresh = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    if (this.settingsType === "function") {
      const beforeViewRenderCallback = () => {
        this.hot.removeHook("beforeViewRender", beforeViewRenderCallback);
        return this.refreshAllEndpoints();
      };
      this.hot.addHookOnce("beforeViewRender", beforeViewRenderCallback);
      return;
    }
    const type = action.indexOf("row") > -1 ? "row" : "col";
    const multiplier = action.indexOf("remove") > -1 ? -1 : 1;
    const endpoints = this.getAllEndpoints();
    const rowMoving = action.indexOf("move_row") === 0;
    const placeOfAlteration = index;
    arrayEach(endpoints, (val) => {
      if (type === "row" && val.destinationRow >= placeOfAlteration) {
        val.alterRowOffset = multiplier * number;
      }
      if (type === "col" && val.destinationColumn >= placeOfAlteration) {
        val.alterColumnOffset = multiplier * number;
      }
    });
    this.resetAllEndpoints(endpoints, !rowMoving);
    if (rowMoving) {
      arrayEach(endpoints, (endpoint) => {
        this.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);
        this.recreatePhysicalRanges(endpoint);
        this.clearOffsetInformation(endpoint);
      });
    } else {
      arrayEach(endpoints, (endpoint) => {
        this.shiftEndpointCoordinates(endpoint, placeOfAlteration);
      });
    }
    if (forceRefresh) {
      this.refreshAllEndpoints();
    }
  }
  /**
   * Clear the offset information from the endpoint object.
   *
   * @private
   * @param {object} endpoint And endpoint object.
   */
  clearOffsetInformation(endpoint) {
    endpoint.alterRowOffset = void 0;
    endpoint.alterColumnOffset = void 0;
  }
  /**
   * Extend the row ranges for the provided endpoint.
   *
   * @private
   * @param {object} endpoint The endpoint object.
   * @param {number} placeOfAlteration Index of the row where the alteration takes place.
   * @param {number} previousPosition Previous endpoint result position.
   * @param {number} offset Offset generated by the alteration.
   */
  extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset2) {
    arrayEach(endpoint.ranges, (range) => {
      if (range[1]) {
        if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {
          if (previousPosition > range[1]) {
            range[1] += offset2;
          } else if (previousPosition < range[0]) {
            range[0] -= offset2;
          }
        } else if (previousPosition >= range[0] && previousPosition <= range[1]) {
          range[1] -= offset2;
          if (placeOfAlteration <= range[0]) {
            range[0] += 1;
            range[1] += 1;
          }
        }
      }
    });
  }
  /**
   * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.
   *
   * @private
   * @param {object} endpoint An endpoint object.
   */
  recreatePhysicalRanges(endpoint) {
    const ranges = endpoint.ranges;
    const newRanges = [];
    const allIndexes = [];
    arrayEach(ranges, (range) => {
      const newRange = [];
      if (range[1]) {
        for (let i = range[0]; i <= range[1]; i++) {
          newRange.push(this.hot.toPhysicalRow(i));
        }
      } else {
        newRange.push(this.hot.toPhysicalRow(range[0]));
      }
      allIndexes.push(newRange);
    });
    arrayEach(allIndexes, (range) => {
      let newRange = [];
      arrayEach(range, (coord, index) => {
        if (index === 0) {
          newRange.push(coord);
        } else if (range[index] !== range[index - 1] + 1) {
          newRange.push(range[index - 1]);
          newRanges.push(newRange);
          newRange = [];
          newRange.push(coord);
        }
        if (index === range.length - 1) {
          newRange.push(coord);
          newRanges.push(newRange);
        }
      });
    });
    endpoint.ranges = newRanges;
  }
  /**
   * Shifts the endpoint coordinates by the defined offset.
   *
   * @private
   * @param {object} endpoint Endpoint object.
   * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.
   */
  shiftEndpointCoordinates(endpoint, offsetStartIndex) {
    if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {
      endpoint.destinationRow += endpoint.alterRowOffset || 0;
      arrayEach(endpoint.ranges, (element) => {
        arrayEach(element, (subElement, j) => {
          if (subElement >= offsetStartIndex) {
            element[j] += endpoint.alterRowOffset || 0;
          }
        });
      });
    } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {
      endpoint.destinationColumn += endpoint.alterColumnOffset || 0;
      endpoint.sourceColumn += endpoint.alterColumnOffset || 0;
    }
  }
  /**
   * Resets (removes) the endpoints from the table.
   *
   * @param {Array} [endpoints] Array containing the endpoints.
   * @param {boolean} [useOffset=true] Use the cell offset value.
   */
  resetAllEndpoints() {
    let endpoints = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getAllEndpoints();
    let useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const anyEndpointOutOfRange = endpoints.some((endpoint) => {
      const alterRowOffset = endpoint.alterRowOffset || 0;
      const alterColOffset = endpoint.alterColumnOffset || 0;
      if (endpoint.destinationRow + alterRowOffset >= this.hot.countRows() || endpoint.destinationColumn + alterColOffset >= this.hot.countCols()) {
        return true;
      }
      return false;
    });
    if (anyEndpointOutOfRange) {
      return;
    }
    this.cellsToSetCache = [];
    arrayEach(endpoints, (endpoint) => {
      this.resetEndpointValue(endpoint, useOffset);
    });
    this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
    this.cellsToSetCache = [];
  }
  /**
   * Calculate and refresh all defined endpoints.
   */
  refreshAllEndpoints() {
    this.cellsToSetCache = [];
    arrayEach(this.getAllEndpoints(), (value) => {
      this.currentEndpoint = value;
      this.plugin.calculate(value);
      this.setEndpointValue(value, "init");
    });
    this.currentEndpoint = null;
    this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
    this.cellsToSetCache = [];
  }
  /**
   * Calculate and refresh endpoints only in the changed columns.
   *
   * @param {Array} changes Array of changes from the `afterChange` hook.
   */
  refreshChangedEndpoints(changes) {
    const needToRefresh = [];
    this.cellsToSetCache = [];
    arrayEach(changes, (value, key, changesObj) => {
      if (`${value[2] || ""}` === `${value[3]}`) {
        return;
      }
      arrayEach(this.getAllEndpoints(), (endpoint, j) => {
        if (this.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {
          needToRefresh.push(j);
        }
      });
    });
    arrayEach(needToRefresh, (value) => {
      this.refreshEndpoint(this.getEndpoint(value));
    });
    this.hot.setDataAtCell(this.cellsToSetCache, "ColumnSummary.reset");
    this.cellsToSetCache = [];
  }
  /**
   * Calculate and refresh a single endpoint.
   *
   * @param {object} endpoint Contains the endpoint information.
   */
  refreshEndpoint(endpoint) {
    this.currentEndpoint = endpoint;
    this.plugin.calculate(endpoint);
    this.setEndpointValue(endpoint);
    this.currentEndpoint = null;
  }
  /**
   * Reset the endpoint value.
   *
   * @param {object} endpoint Contains the endpoint information.
   * @param {boolean} [useOffset=true] Use the cell offset value.
   */
  resetEndpointValue(endpoint) {
    let useOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const alterRowOffset = endpoint.alterRowOffset || 0;
    const alterColOffset = endpoint.alterColumnOffset || 0;
    this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), ""]);
  }
  /**
   * Set the endpoint value.
   *
   * @param {object} endpoint Contains the endpoint information.
   * @param {string} [source] Source of the call information.
   * @param {boolean} [render=false] `true` if it needs to render the table afterwards.
   */
  setEndpointValue(endpoint, source) {
    let render = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);
    if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {
      this.throwOutOfBoundsWarning();
      return;
    }
    const destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow);
    if (destinationVisualRow !== null) {
      const cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn);
      if (source === "init" || cellMeta.readOnly !== endpoint.readOnly) {
        cellMeta.readOnly = endpoint.readOnly;
        cellMeta.className = "columnSummaryResult";
      }
    }
    if (endpoint.roundFloat && !isNaN(endpoint.result)) {
      endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);
    }
    if (render) {
      this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, "ColumnSummary.set");
    } else {
      this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);
    }
    endpoint.alterRowOffset = void 0;
    endpoint.alterColumnOffset = void 0;
  }
  /**
   * Throw an error for the calculation range being out of boundaries.
   *
   * @private
   */
  throwOutOfBoundsWarning() {
    warn("One of the Column Summary plugins' destination points you provided is beyond the table boundaries!");
  }
};
var endpoints_default = Endpoints;

// node_modules/handsontable/plugins/columnSummary/utils.mjs
function isNullishOrNaN(value) {
  return value === null || value === void 0 || isNaN(value);
}

// node_modules/handsontable/plugins/columnSummary/columnSummary.mjs
function _classPrivateMethodInitSpec8(obj, privateSet) {
  _checkPrivateRedeclaration8(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration8(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty12(obj, key, value) {
  key = _toPropertyKey12(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey12(arg) {
  var key = _toPrimitive12(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive12(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet8(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY8 = "columnSummary";
var PLUGIN_PRIORITY7 = 220;
var _onAfterInit3 = /* @__PURE__ */ new WeakSet();
var _onAfterChange = /* @__PURE__ */ new WeakSet();
var _onAfterRowMove = /* @__PURE__ */ new WeakSet();
var ColumnSummary = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec8(this, _onAfterRowMove);
    _classPrivateMethodInitSpec8(this, _onAfterChange);
    _classPrivateMethodInitSpec8(this, _onAfterInit3);
    _defineProperty12(this, "endpoints", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY8;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY7;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ColumnSummary#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY8];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.settings = this.hot.getSettings()[PLUGIN_KEY8];
    this.endpoints = new endpoints_default(this, this.settings);
    this.addHook("afterInit", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet8(_this, _onAfterInit3, _onAfterInit22).call(_this, ...args);
    });
    this.addHook("afterChange", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet8(_this, _onAfterChange, _onAfterChange2).call(_this, ...args);
    });
    this.addHook("beforeCreateRow", (index, amount, source) => this.endpoints.resetSetupBeforeStructureAlteration("insert_row", index, amount, null, source));
    this.addHook("beforeCreateCol", (index, amount, source) => this.endpoints.resetSetupBeforeStructureAlteration("insert_col", index, amount, null, source));
    this.addHook("beforeRemoveRow", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.endpoints.resetSetupBeforeStructureAlteration("remove_row", ...args);
    });
    this.addHook("beforeRemoveCol", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.endpoints.resetSetupBeforeStructureAlteration("remove_col", ...args);
    });
    this.addHook("afterCreateRow", (index, amount, source) => this.endpoints.resetSetupAfterStructureAlteration("insert_row", index, amount, null, source));
    this.addHook("afterCreateCol", (index, amount, source) => this.endpoints.resetSetupAfterStructureAlteration("insert_col", index, amount, null, source));
    this.addHook("afterRemoveRow", function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.endpoints.resetSetupAfterStructureAlteration("remove_row", ...args);
    });
    this.addHook("afterRemoveCol", function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.endpoints.resetSetupAfterStructureAlteration("remove_col", ...args);
    });
    this.addHook("afterRowMove", function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _classPrivateMethodGet8(_this, _onAfterRowMove, _onAfterRowMove2).call(_this, ...args);
    });
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.endpoints = null;
    this.settings = null;
    this.currentEndpoint = null;
  }
  /**
   * Calculates math for a single endpoint.
   *
   * @private
   * @param {object} endpoint Contains information about the endpoint.
   */
  calculate(endpoint) {
    switch (endpoint.type.toLowerCase()) {
      case "sum":
        endpoint.result = this.calculateSum(endpoint);
        break;
      case "min":
        endpoint.result = this.calculateMinMax(endpoint, endpoint.type);
        break;
      case "max":
        endpoint.result = this.calculateMinMax(endpoint, endpoint.type);
        break;
      case "count":
        endpoint.result = this.countEntries(endpoint);
        break;
      case "average":
        endpoint.result = this.calculateAverage(endpoint);
        break;
      case "custom":
        endpoint.result = endpoint.customFunction.call(this, endpoint);
        break;
      default:
        break;
    }
  }
  /**
   * Calculates sum of the values contained in ranges provided in the plugin config.
   *
   * @private
   * @param {object} endpoint Contains the endpoint information.
   * @returns {number} Sum for the selected range.
   */
  calculateSum(endpoint) {
    let sum = 0;
    objectEach(endpoint.ranges, (range) => {
      sum += this.getPartialSum(range, endpoint.sourceColumn);
    });
    return sum;
  }
  /**
   * Returns partial sum of values from a single row range.
   *
   * @private
   * @param {Array} rowRange Range for the sum.
   * @param {number} col Column index.
   * @returns {number} The partial sum.
   */
  getPartialSum(rowRange, col) {
    let sum = 0;
    let i = rowRange[1] || rowRange[0];
    let cellValue = null;
    let biggestDecimalPlacesCount = 0;
    do {
      cellValue = this.getCellValue(i, col);
      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
      if (cellValue !== null) {
        const decimalPlaces = (`${cellValue}`.split(".")[1] || []).length || 1;
        if (decimalPlaces > biggestDecimalPlacesCount) {
          biggestDecimalPlacesCount = decimalPlaces;
        }
      }
      sum += cellValue || 0;
      i -= 1;
    } while (i >= rowRange[0]);
    return Math.round(sum * 10 ** biggestDecimalPlacesCount) / 10 ** biggestDecimalPlacesCount;
  }
  /**
   * Calculates the minimal value for the selected ranges.
   *
   * @private
   * @param {object} endpoint Contains the endpoint information.
   * @param {string} type `'min'` or `'max'`.
   * @returns {number} Min or Max value.
   */
  calculateMinMax(endpoint, type) {
    let result = null;
    objectEach(endpoint.ranges, (range) => {
      const partialResult = this.getPartialMinMax(range, endpoint.sourceColumn, type);
      if (result === null && partialResult !== null) {
        result = partialResult;
      }
      if (partialResult !== null) {
        switch (type) {
          case "min":
            result = Math.min(result, partialResult);
            break;
          case "max":
            result = Math.max(result, partialResult);
            break;
          default:
            break;
        }
      }
    });
    return result === null ? "Not enough data" : result;
  }
  /**
   * Returns a local minimum of the provided sub-range.
   *
   * @private
   * @param {Array} rowRange Range for the calculation.
   * @param {number} col Column index.
   * @param {string} type `'min'` or `'max'`.
   * @returns {number|null} Min or max value.
   */
  getPartialMinMax(rowRange, col, type) {
    let result = null;
    let i = rowRange[1] || rowRange[0];
    let cellValue;
    do {
      cellValue = this.getCellValue(i, col);
      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
      if (result === null) {
        result = cellValue;
      } else if (cellValue !== null) {
        switch (type) {
          case "min":
            result = Math.min(result, cellValue);
            break;
          case "max":
            result = Math.max(result, cellValue);
            break;
          default:
            break;
        }
      }
      i -= 1;
    } while (i >= rowRange[0]);
    return result;
  }
  /**
   * Counts empty cells in the provided row range.
   *
   * @private
   * @param {Array} rowRange Row range for the calculation.
   * @param {number} col Column index.
   * @returns {number} Empty cells count.
   */
  countEmpty(rowRange, col) {
    let cellValue;
    let counter = 0;
    let i = rowRange[1] || rowRange[0];
    do {
      cellValue = this.getCellValue(i, col);
      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;
      if (cellValue === null) {
        counter += 1;
      }
      i -= 1;
    } while (i >= rowRange[0]);
    return counter;
  }
  /**
   * Counts non-empty cells in the provided row range.
   *
   * @private
   * @param {object} endpoint Contains the endpoint information.
   * @returns {number} Entry count.
   */
  countEntries(endpoint) {
    let result = 0;
    const ranges = endpoint.ranges;
    objectEach(ranges, (range) => {
      const partial2 = range[1] === void 0 ? 1 : range[1] - range[0] + 1;
      const emptyCount = this.countEmpty(range, endpoint.sourceColumn);
      result += partial2;
      result -= emptyCount;
    });
    return result;
  }
  /**
   * Calculates the average value from the cells in the range.
   *
   * @private
   * @param {object} endpoint Contains the endpoint information.
   * @returns {number} Avarage value.
   */
  calculateAverage(endpoint) {
    const sum = this.calculateSum(endpoint);
    const entriesCount = this.countEntries(endpoint);
    return sum / entriesCount;
  }
  /**
   * Returns a cell value, taking into consideration a basic validation.
   *
   * @private
   * @param {number} row Row index.
   * @param {number} col Column index.
   * @returns {string} The cell value.
   */
  getCellValue(row, col) {
    const visualRowIndex = this.hot.toVisualRow(row);
    const visualColumnIndex = this.hot.toVisualColumn(col);
    let cellValue = this.hot.getSourceDataAtCell(row, col);
    let cellClassName = "";
    if (visualRowIndex !== null && visualColumnIndex !== null) {
      cellClassName = this.hot.getCellMeta(visualRowIndex, visualColumnIndex).className || "";
    }
    if (cellClassName.indexOf("columnSummaryResult") > -1) {
      return null;
    }
    if (this.endpoints.currentEndpoint.forceNumeric) {
      if (typeof cellValue === "string") {
        cellValue = cellValue.replace(/,/, ".");
      }
      cellValue = parseFloat(cellValue);
    }
    if (isNaN(cellValue)) {
      if (!this.endpoints.currentEndpoint.suppressDataTypeErrors) {
        throw new Error(toSingleLine`ColumnSummary plugin: cell at (${row}, ${col}) is not in a\x20
          numeric format. Cannot do the calculation.`);
      }
    }
    return cellValue;
  }
};
function _onAfterInit22() {
  this.endpoints.endpoints = this.endpoints.parseSettings();
  this.endpoints.refreshAllEndpoints(true);
}
function _onAfterChange2(changes, source) {
  if (changes && source !== "ColumnSummary.reset" && source !== "ColumnSummary.set" && source !== "loadData") {
    this.endpoints.refreshChangedEndpoints(changes);
  }
}
function _onAfterRowMove2(rows, finalIndex) {
  this.endpoints.resetSetupBeforeStructureAlteration("move_row", rows[0], rows.length, rows, this.pluginName);
  this.endpoints.resetSetupAfterStructureAlteration("move_row", finalIndex, rows.length, rows, this.pluginName);
}

// node_modules/handsontable/plugins/comments/commentEditor.mjs
function _defineProperty13(obj, key, value) {
  key = _toPropertyKey13(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey13(arg) {
  var key = _toPrimitive13(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive13(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var CommentEditor = class _CommentEditor {
  static get CLASS_EDITOR_CONTAINER() {
    return "htCommentsContainer";
  }
  static get CLASS_EDITOR() {
    return "htComments";
  }
  static get CLASS_INPUT() {
    return "htCommentTextArea";
  }
  static get CLASS_CELL() {
    return "htCommentCell";
  }
  /**
   * @type {HTMLDocument}
   */
  constructor(rootDocument, isRtl) {
    _defineProperty13(this, "rootDocument", void 0);
    _defineProperty13(this, "isRtl", false);
    _defineProperty13(this, "container", null);
    _defineProperty13(this, "editor", void 0);
    _defineProperty13(this, "editorStyle", void 0);
    _defineProperty13(this, "hidden", true);
    this.rootDocument = rootDocument;
    this.isRtl = isRtl;
    this.editor = this.createEditor();
    this.editorStyle = this.editor.style;
    this.hide();
  }
  /**
   * Set position of the comments editor according to the  provided x and y coordinates.
   *
   * @param {number} x X position (in pixels).
   * @param {number} y Y position (in pixels).
   */
  setPosition(x, y) {
    this.editorStyle.left = `${x}px`;
    this.editorStyle.top = `${y}px`;
  }
  /**
   * Set the editor size according to the provided arguments.
   *
   * @param {number} width Width in pixels.
   * @param {number} height Height in pixels.
   */
  setSize(width, height) {
    if (width && height) {
      const input = this.getInputElement();
      input.style.width = `${width}px`;
      input.style.height = `${height}px`;
    }
  }
  /**
   * Returns the size of the comments editor.
   *
   * @returns {{ width: number, height: number }}
   */
  getSize() {
    return {
      width: outerWidth(this.getInputElement()),
      height: outerHeight(this.getInputElement())
    };
  }
  /**
   * Reset the editor size to its initial state.
   */
  resetSize() {
    const input = this.getInputElement();
    input.style.width = "";
    input.style.height = "";
  }
  /**
   * Set the read-only state for the comments editor.
   *
   * @param {boolean} state The new read only state.
   */
  setReadOnlyState(state) {
    const input = this.getInputElement();
    input.readOnly = state;
  }
  /**
   * Show the comments editor.
   */
  show() {
    this.editorStyle.display = "block";
    this.hidden = false;
  }
  /**
   * Hide the comments editor.
   */
  hide() {
    if (!this.hidden) {
      this.editorStyle.display = "none";
    }
    this.hidden = true;
  }
  /**
   * Checks if the editor is visible.
   *
   * @returns {boolean}
   */
  isVisible() {
    return this.editorStyle.display === "block";
  }
  /**
   * Set the comment value.
   *
   * @param {string} [value] The value to use.
   */
  setValue() {
    let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const comment = value || "";
    this.getInputElement().value = comment;
  }
  /**
   * Get the comment value.
   *
   * @returns {string}
   */
  getValue() {
    return this.getInputElement().value;
  }
  /**
   * Checks if the comment input element is focused.
   *
   * @returns {boolean}
   */
  isFocused() {
    return this.rootDocument.activeElement === this.getInputElement();
  }
  /**
   * Focus the comments input element.
   */
  focus() {
    this.getInputElement().focus();
  }
  /**
   * Create the `textarea` to be used as a comments editor.
   *
   * @returns {HTMLElement}
   */
  createEditor() {
    const editor = this.rootDocument.createElement("div");
    const textArea = this.rootDocument.createElement("textarea");
    editor.style.display = "none";
    this.container = this.rootDocument.createElement("div");
    this.container.setAttribute("dir", this.isRtl ? "rtl" : "ltr");
    addClass(this.container, _CommentEditor.CLASS_EDITOR_CONTAINER);
    this.rootDocument.body.appendChild(this.container);
    addClass(editor, _CommentEditor.CLASS_EDITOR);
    addClass(textArea, _CommentEditor.CLASS_INPUT);
    textArea.setAttribute("data-hot-input", true);
    editor.appendChild(textArea);
    this.container.appendChild(editor);
    return editor;
  }
  /**
   * Get the input element.
   *
   * @returns {HTMLElement}
   */
  getInputElement() {
    return this.editor.querySelector(`.${_CommentEditor.CLASS_INPUT}`);
  }
  /**
   * Destroy the comments editor.
   */
  destroy() {
    const containerParentElement = this.container ? this.container.parentNode : null;
    this.editor.parentNode.removeChild(this.editor);
    this.editor = null;
    this.editorStyle = null;
    if (containerParentElement) {
      containerParentElement.removeChild(this.container);
    }
  }
};
var commentEditor_default = CommentEditor;

// node_modules/handsontable/plugins/comments/displaySwitch.mjs
function _defineProperty14(obj, key, value) {
  key = _toPropertyKey14(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey14(arg) {
  var key = _toPrimitive14(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive14(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var DEFAULT_DISPLAY_DELAY = 250;
var DEFAULT_HIDE_DELAY = 250;
var DisplaySwitch = class {
  constructor(displayDelay) {
    _defineProperty14(this, "wasLastActionShow", true);
    _defineProperty14(this, "showDebounced", null);
    _defineProperty14(this, "hidingTimer", null);
    this.updateDelay(displayDelay);
  }
  /**
   * Responsible for hiding comment after proper delay.
   */
  hide() {
    this.wasLastActionShow = false;
    this.hidingTimer = setTimeout(() => {
      if (this.wasLastActionShow === false) {
        this.runLocalHooks("hide");
      }
    }, DEFAULT_HIDE_DELAY);
  }
  /**
   * Responsible for showing comment after proper delay.
   *
   * @param {object} range Coordinates of selected cell.
   */
  show(range) {
    this.wasLastActionShow = true;
    this.showDebounced(range);
  }
  /**
   * Cancel hiding comment.
   */
  cancelHiding() {
    this.wasLastActionShow = true;
    clearTimeout(this.hidingTimer);
    this.hidingTimer = null;
  }
  /**
   * Update the switch settings.
   *
   * @param {number} displayDelay Delay of showing the comments (in milliseconds).
   */
  updateDelay() {
    let displayDelay = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_DISPLAY_DELAY;
    this.showDebounced = debounce((range) => {
      if (this.wasLastActionShow) {
        this.runLocalHooks("show", range.from.row, range.from.col);
      }
    }, displayDelay);
  }
  /**
   * Destroy the switcher.
   */
  destroy() {
    this.clearLocalHooks();
  }
};
mixin(DisplaySwitch, localHooks_default);
var displaySwitch_default = DisplaySwitch;

// node_modules/handsontable/plugins/contextMenu/utils.mjs
function prepareVerticalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  const replacedClassName = className.replace("htTop", "").replace("htMiddle", "").replace("htBottom", "").replace("  ", "");
  return `${replacedClassName} ${alignment}`;
}
function prepareHorizontalAlignClass(className, alignment) {
  if (className.indexOf(alignment) !== -1) {
    return className;
  }
  const replacedClassName = className.replace("htLeft", "").replace("htCenter", "").replace("htRight", "").replace("htJustify", "").replace("  ", "");
  return `${replacedClassName} ${alignment}`;
}
function getAlignmentClasses(ranges, callback) {
  const classes = {};
  arrayEach(ranges, (range) => {
    range.forAll((row, col) => {
      if (row >= 0 && col >= 0) {
        if (!classes[row]) {
          classes[row] = [];
        }
        classes[row][col] = callback(row, col);
      }
    });
  });
  return classes;
}
function align(ranges, type, alignment, cellDescriptor, propertySetter) {
  arrayEach(ranges, (range) => {
    range.forAll((row, col) => {
      if (row >= 0 && col >= 0) {
        applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter);
      }
    });
  });
}
function applyAlignClassName(row, col, type, alignment, cellDescriptor, propertySetter) {
  const cellMeta = cellDescriptor(row, col);
  let className = alignment;
  if (cellMeta.className) {
    if (type === "vertical") {
      className = prepareVerticalAlignClass(cellMeta.className, alignment);
    } else {
      className = prepareHorizontalAlignClass(cellMeta.className, alignment);
    }
  }
  propertySetter(row, col, "className", className);
}
function markLabelAsSelected(label) {
  return `<span class="selected">${String.fromCharCode(10003)}</span>${label}`;
}
function checkSelectionConsistency(ranges, comparator) {
  let result = false;
  if (Array.isArray(ranges)) {
    arrayEach(ranges, (range) => {
      range.forAll((row, col) => {
        if (row >= 0 && col >= 0 && comparator(row, col)) {
          result = true;
          return false;
        }
      });
      return result;
    });
  }
  return result;
}
function getDocumentOffsetByElement(elementToCheck, baseDocument) {
  const offset2 = {
    top: 0,
    left: 0
  };
  if (baseDocument !== elementToCheck.ownerDocument) {
    const {
      frameElement
    } = baseDocument.defaultView;
    const {
      top: top2,
      left: left2
    } = frameElement.getBoundingClientRect();
    offset2.top = top2;
    offset2.left = left2;
  }
  return offset2;
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/separator.mjs
var KEY = "---------";
function separatorItem() {
  return {
    name: KEY
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/alignment.mjs
var KEY2 = "alignment";
function alignmentItem() {
  return {
    key: KEY2,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT);
    },
    disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      return !(this.getSelectedRange() && !this.selection.isSelectedByCorner());
    },
    submenu: {
      items: [{
        key: `${KEY2}:left`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_LEFT);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htLeft") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htLeft";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:center`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_CENTER);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htCenter") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htCenter";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:right`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htRight") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htRight";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:justify`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htJustify") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "horizontal";
          const alignment = "htJustify";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        name: KEY
      }, {
        key: `${KEY2}:top`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_TOP);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htTop") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htTop";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:middle`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htMiddle") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htMiddle";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }, {
        key: `${KEY2}:bottom`,
        name() {
          let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM);
          const hasClass2 = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
            const className = this.getCellMeta(row, col).className;
            if (className && className.indexOf("htBottom") !== -1) {
              return true;
            }
          });
          if (hasClass2) {
            label = markLabelAsSelected(label);
          }
          return label;
        },
        callback() {
          const selectedRange = this.getSelectedRange();
          const stateBefore = getAlignmentClasses(selectedRange, (row, col) => this.getCellMeta(row, col).className);
          const type = "vertical";
          const alignment = "htBottom";
          this.runHooks("beforeCellAlignment", stateBefore, selectedRange, type, alignment);
          align(selectedRange, type, alignment, (row, col) => this.getCellMeta(row, col), (row, col, key, value) => this.setCellMeta(row, col, key, value));
          this.render();
        },
        disabled: false
      }]
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/clearColumn.mjs
var KEY3 = "clear_column";
function clearColumnItem() {
  return {
    key: KEY3,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CLEAR_COLUMN);
    },
    callback(key, selection) {
      const startColumn = selection[0].start.col;
      const endColumn = selection[0].end.col;
      if (this.countRows()) {
        this.populateFromArray(0, startColumn, [[null]], Math.max(selection[0].start.row, selection[0].end.row), endColumn, "ContextMenu.clearColumn");
      }
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.col < 0) {
        return true;
      }
      return !this.selection.isSelectedByColumnHeader();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/columnLeft.mjs
var KEY4 = "col_left";
function columnLeftItem() {
  return {
    key: KEY4,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_LEFT);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopLeftCorner();
      const alterAction = this.isRtl() ? "insert_col_end" : "insert_col_start";
      this.alter(alterAction, latestSelection.col, 1, "ContextMenu.columnLeft");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.col < 0) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        const totalColumns = this.countCols();
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/columnRight.mjs
var KEY5 = "col_right";
function columnRightItem() {
  return {
    key: KEY5,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_INSERT_RIGHT);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopRightCorner();
      const alterAction = this.isRtl() ? "insert_col_start" : "insert_col_end";
      this.alter(alterAction, latestSelection.col, 1, "ContextMenu.columnRight");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.col < 0) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByRowHeader() || this.countCols() >= this.getSettings().maxCols;
    },
    hidden() {
      return !this.getSettings().allowInsertColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/readOnly.mjs
var KEY6 = "make_read_only";
function readOnlyItem() {
  return {
    key: KEY6,
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY);
      const atLeastOneReadOnly = checkSelectionConsistency(this.getSelectedRange(), (row, col) => this.getCellMeta(row, col).readOnly);
      if (atLeastOneReadOnly) {
        label = markLabelAsSelected(label);
      }
      return label;
    },
    callback() {
      const ranges = this.getSelectedRange();
      const atLeastOneReadOnly = checkSelectionConsistency(ranges, (row, col) => this.getCellMeta(row, col).readOnly);
      arrayEach(ranges, (range) => {
        range.forAll((row, col) => {
          if (row >= 0 && col >= 0) {
            this.setCellMeta(row, col, "readOnly", !atLeastOneReadOnly);
          }
        });
      });
      this.render();
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return true;
      }
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      if (!this.getSelectedRange() || this.getSelectedRange().length === 0) {
        return true;
      }
      return false;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/redo.mjs
var KEY7 = "redo";
function redoItem() {
  return {
    key: KEY7,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REDO);
    },
    callback() {
      this.redo();
    },
    hidden() {
      const undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled() {
      return !this.getPlugin("undoRedo").isRedoAvailable();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/removeColumn.mjs
var KEY8 = "remove_col";
function removeColumnItem() {
  return {
    key: KEY8,
    name() {
      const selection = this.getSelected();
      let pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          const [, fromColumn, , toColumn] = selection[0];
          if (fromColumn - toColumn !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COLUMN, pluralForm);
    },
    callback() {
      this.alter("remove_col", transformSelectionToColumnDistance(this), null, "ContextMenu.removeColumn");
    },
    disabled() {
      if (!this.isColumnModificationAllowed()) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.col < 0) {
        return true;
      }
      const totalColumns = this.countCols();
      if (this.selection.isSelectedByCorner()) {
        return totalColumns === 0;
      }
      return this.selection.isSelectedByRowHeader() || totalColumns === 0;
    },
    hidden() {
      return !this.getSettings().allowRemoveColumn;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/removeRow.mjs
var KEY9 = "remove_row";
function removeRowItem() {
  return {
    key: KEY9,
    name() {
      const selection = this.getSelected();
      let pluralForm = 0;
      if (selection) {
        if (selection.length > 1) {
          pluralForm = 1;
        } else {
          const [fromRow, , toRow] = selection[0];
          if (fromRow - toRow !== 0) {
            pluralForm = 1;
          }
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_ROW, pluralForm);
    },
    callback() {
      this.alter("remove_row", transformSelectionToRowDistance(this), 1, "ContextMenu.removeRow");
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.row < 0) {
        return true;
      }
      const totalRows = this.countRows();
      if (this.selection.isSelectedByCorner()) {
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || totalRows === 0;
    },
    hidden() {
      return !this.getSettings().allowRemoveRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/rowAbove.mjs
var KEY10 = "row_above";
function rowAboveItem() {
  return {
    key: KEY10,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_ABOVE);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getTopLeftCorner();
      this.alter("insert_row_above", latestSelection.row, 1, "ContextMenu.rowAbove");
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.row < 0) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        const totalRows = this.countRows();
        return totalRows === 0;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/rowBelow.mjs
var KEY11 = "row_below";
function rowBelowItem() {
  return {
    key: KEY11,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ROW_BELOW);
    },
    callback() {
      const latestSelection = this.getSelectedRangeLast().getBottomRightCorner();
      this.alter("insert_row_below", latestSelection.row, 1, "ContextMenu.rowBelow");
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader() && range.highlight.row < 0) {
        return true;
      }
      if (this.selection.isSelectedByCorner()) {
        return false;
      }
      return this.selection.isSelectedByColumnHeader() || this.countRows() >= this.getSettings().maxRows;
    },
    hidden() {
      return !this.getSettings().allowInsertRow;
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/noItems.mjs
var KEY12 = "no_items";
function noItemsItem() {
  return {
    key: KEY12,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NO_ITEMS);
    },
    disabled: true,
    isCommand: false
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/undo.mjs
var KEY13 = "undo";
function undoItem() {
  return {
    key: KEY13,
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNDO);
    },
    callback() {
      this.undo();
    },
    hidden() {
      const undoRedo = this.getPlugin("undoRedo");
      return !undoRedo || !undoRedo.isEnabled();
    },
    disabled() {
      return !this.getPlugin("undoRedo").isUndoAvailable();
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/predefinedItems/index.mjs
var ITEMS = [KEY10, KEY11, KEY4, KEY5, KEY3, KEY9, KEY8, KEY13, KEY7, KEY6, KEY2, KEY, KEY12];
var _predefinedItems = {
  [KEY]: separatorItem,
  [KEY12]: noItemsItem,
  [KEY10]: rowAboveItem,
  [KEY11]: rowBelowItem,
  [KEY4]: columnLeftItem,
  [KEY5]: columnRightItem,
  [KEY3]: clearColumnItem,
  [KEY9]: removeRowItem,
  [KEY8]: removeColumnItem,
  [KEY13]: undoItem,
  [KEY7]: redoItem,
  [KEY6]: readOnlyItem,
  [KEY2]: alignmentItem
};
function predefinedItems() {
  const items = {};
  objectEach(_predefinedItems, (itemFactory, key) => {
    items[key] = itemFactory();
  });
  return items;
}

// node_modules/handsontable/plugins/comments/contextMenuItem/addEditComment.mjs
function addEditCommentItem(plugin) {
  return {
    key: "commentsAddEdit",
    name() {
      var _this$getSelectedRang;
      const highlight = (_this$getSelectedRang = this.getSelectedRangeLast()) === null || _this$getSelectedRang === void 0 ? void 0 : _this$getSelectedRang.highlight;
      if (highlight !== null && highlight !== void 0 && highlight.isCell() && plugin.getCommentAtCell(highlight.row, highlight.col)) {
        return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_EDIT_COMMENT);
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_ADD_COMMENT);
    },
    callback() {
      const range = this.getSelectedRangeLast();
      this.deselectCell();
      plugin.setRange(range);
      plugin.show();
      plugin.focusEditor();
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range || range.highlight.isHeader() || this.selection.isEntireRowSelected() && this.selection.isEntireColumnSelected() || this.countRenderedRows() === 0 || this.countRenderedCols() === 0) {
        return true;
      }
      return false;
    }
  };
}

// node_modules/handsontable/plugins/comments/contextMenuItem/removeComment.mjs
function removeCommentItem(plugin) {
  return {
    key: "commentsRemove",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_COMMENT);
    },
    callback() {
      const range = this.getSelectedRangeLast();
      range.forAll((row, column) => {
        if (row >= 0 && column >= 0) {
          plugin.removeCommentAtCell(row, column, false);
        }
      });
      this.render();
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range || range.highlight.isHeader() || this.selection.isEntireRowSelected() && this.selection.isEntireColumnSelected() || this.countRenderedRows() === 0 || this.countRenderedCols() === 0) {
        return true;
      }
      return false;
    }
  };
}

// node_modules/handsontable/plugins/comments/contextMenuItem/readOnlyComment.mjs
function readOnlyCommentItem(plugin) {
  return {
    key: "commentsReadOnly",
    name() {
      const label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_READ_ONLY_COMMENT);
      const areReadOnly = checkSelectionConsistency(this.getSelectedRange(), (row, col) => {
        return plugin.getCommentMeta(row, col, META_READONLY);
      });
      return areReadOnly ? markLabelAsSelected(label) : label;
    },
    callback() {
      const range = this.getSelectedRangeLast();
      range.forAll((row, column) => {
        if (row >= 0 && column >= 0) {
          const currentState = !!plugin.getCommentMeta(row, column, META_READONLY);
          plugin.updateCommentMeta(row, column, {
            [META_READONLY]: !currentState
          });
        }
      });
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range || range.highlight.isHeader() || !plugin.getCommentAtCell(range.highlight.row, range.highlight.col) || this.selection.isEntireRowSelected() && this.selection.isEntireColumnSelected() || this.countRenderedRows() === 0 || this.countRenderedCols() === 0) {
        return true;
      }
      return false;
    }
  };
}

// node_modules/handsontable/plugins/comments/comments.mjs
function _classPrivateMethodInitSpec9(obj, privateSet) {
  _checkPrivateRedeclaration9(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec4(obj, privateMap, value) {
  _checkPrivateRedeclaration9(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration9(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty15(obj, key, value) {
  key = _toPropertyKey15(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey15(arg) {
  var key = _toPrimitive15(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive15(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet9(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldSet3(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor4(receiver, privateMap, "set");
  _classApplyDescriptorSet3(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet3(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet4(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor4(receiver, privateMap, "get");
  return _classApplyDescriptorGet4(receiver, descriptor);
}
function _classExtractFieldDescriptor4(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet4(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY9 = "comments";
var PLUGIN_PRIORITY8 = 60;
var META_COMMENT = "comment";
var META_COMMENT_VALUE = "value";
var META_STYLE = "style";
var META_READONLY = "readOnly";
var SHORTCUTS_GROUP3 = PLUGIN_KEY9;
var SHORTCUTS_CONTEXT_NAME = `plugin:${PLUGIN_KEY9}`;
var _editor = /* @__PURE__ */ new WeakMap();
var _displaySwitch = /* @__PURE__ */ new WeakMap();
var _preventEditorAutoSwitch = /* @__PURE__ */ new WeakMap();
var _preventEditorHiding = /* @__PURE__ */ new WeakMap();
var _tempEditorDimensions = /* @__PURE__ */ new WeakMap();
var _cellBelowCursor = /* @__PURE__ */ new WeakMap();
var _commentValueBeforeSave = /* @__PURE__ */ new WeakMap();
var _onMouseDown = /* @__PURE__ */ new WeakSet();
var _onMouseOver = /* @__PURE__ */ new WeakSet();
var _onMouseUp3 = /* @__PURE__ */ new WeakSet();
var _onAfterRenderer = /* @__PURE__ */ new WeakSet();
var _onEditorBlur = /* @__PURE__ */ new WeakSet();
var _onEditorFocus = /* @__PURE__ */ new WeakSet();
var _onEditorMouseDown = /* @__PURE__ */ new WeakSet();
var _onEditorMouseUp = /* @__PURE__ */ new WeakSet();
var _onAfterDocumentKeyDown = /* @__PURE__ */ new WeakSet();
var _onAfterScroll = /* @__PURE__ */ new WeakSet();
var Comments = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec9(this, _onAfterScroll);
    _classPrivateMethodInitSpec9(this, _onAfterDocumentKeyDown);
    _classPrivateMethodInitSpec9(this, _onEditorMouseUp);
    _classPrivateMethodInitSpec9(this, _onEditorMouseDown);
    _classPrivateMethodInitSpec9(this, _onEditorFocus);
    _classPrivateMethodInitSpec9(this, _onEditorBlur);
    _classPrivateMethodInitSpec9(this, _onAfterRenderer);
    _classPrivateMethodInitSpec9(this, _onMouseUp3);
    _classPrivateMethodInitSpec9(this, _onMouseOver);
    _classPrivateMethodInitSpec9(this, _onMouseDown);
    _defineProperty15(this, "range", {});
    _classPrivateFieldInitSpec4(this, _editor, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec4(this, _displaySwitch, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec4(this, _preventEditorAutoSwitch, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec4(this, _preventEditorHiding, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec4(this, _tempEditorDimensions, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec4(this, _cellBelowCursor, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec4(this, _commentValueBeforeSave, {
      writable: true,
      value: ""
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY9;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY8;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link Comments#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY9];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    if (!_classPrivateFieldGet4(this, _editor)) {
      _classPrivateFieldSet3(this, _editor, new commentEditor_default(this.hot.rootDocument, this.hot.isRtl()));
    }
    if (!_classPrivateFieldGet4(this, _displaySwitch)) {
      _classPrivateFieldSet3(this, _displaySwitch, new displaySwitch_default(this.getDisplayDelaySetting()));
    }
    this.addHook("afterContextMenuDefaultOptions", (options) => this.addToContextMenu(options));
    this.addHook("afterRenderer", (TD, row, col, prop, value, cellProperties) => _classPrivateMethodGet9(this, _onAfterRenderer, _onAfterRenderer2).call(this, TD, cellProperties));
    this.addHook("afterScroll", () => _classPrivateMethodGet9(this, _onAfterScroll, _onAfterScroll2).call(this));
    this.addHook("afterBeginEditing", () => this.hide());
    this.addHook("afterDocumentKeyDown", (event) => _classPrivateMethodGet9(this, _onAfterDocumentKeyDown, _onAfterDocumentKeyDown2).call(this, event));
    _classPrivateFieldGet4(this, _displaySwitch).addLocalHook("hide", () => this.hide());
    _classPrivateFieldGet4(this, _displaySwitch).addLocalHook("show", (row, col) => this.showAtCell(row, col));
    this.registerShortcuts();
    this.registerListeners();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *   - [`comments`](@/api/options.md#comments)
   */
  updatePlugin() {
    _classPrivateFieldGet4(this, _displaySwitch).updateDelay(this.getDisplayDelaySetting());
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.unregisterShortcuts();
    super.disablePlugin();
  }
  /**
   * Register shortcuts responsible for toggling context menu.
   *
   * @private
   */
  registerShortcuts() {
    const manager = this.hot.getShortcutManager();
    const gridContext = manager.getContext("grid");
    const pluginContext = manager.addContext(SHORTCUTS_CONTEXT_NAME);
    gridContext.addShortcut({
      keys: [["Control", "Alt", "M"]],
      callback: () => {
        const range = this.hot.getSelectedRangeLast();
        _classPrivateFieldSet3(this, _preventEditorHiding, true);
        this.hot.scrollToFocusedCell(() => {
          this.setRange(range);
          this.show();
          this.focusEditor();
          manager.setActiveContextName(SHORTCUTS_CONTEXT_NAME);
          this.hot._registerTimeout(() => {
            _classPrivateFieldSet3(this, _preventEditorHiding, false);
          });
        });
      },
      stopPropagation: true,
      runOnlyIf: () => {
        var _this$hot$getSelected;
        return ((_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight.isCell()) && !_classPrivateFieldGet4(this, _editor).isVisible();
      },
      group: SHORTCUTS_GROUP3
    });
    pluginContext.addShortcut({
      keys: [["Escape"]],
      callback: () => {
        _classPrivateFieldGet4(this, _editor).setValue(_classPrivateFieldGet4(this, _commentValueBeforeSave));
        this.hide();
        manager.setActiveContextName("grid");
      },
      runOnlyIf: () => {
        var _this$hot$getSelected2;
        return ((_this$hot$getSelected2 = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected2 === void 0 ? void 0 : _this$hot$getSelected2.highlight.isCell()) && _classPrivateFieldGet4(this, _editor).isVisible();
      },
      group: SHORTCUTS_GROUP3
    });
    pluginContext.addShortcut({
      keys: [["Control/Meta", "Enter"]],
      callback: () => {
        this.hide();
        manager.setActiveContextName("grid");
      },
      runOnlyIf: () => {
        var _this$hot$getSelected3;
        return ((_this$hot$getSelected3 = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected3 === void 0 ? void 0 : _this$hot$getSelected3.highlight.isCell()) && _classPrivateFieldGet4(this, _editor).isVisible();
      },
      group: SHORTCUTS_GROUP3
    });
  }
  /**
   * Unregister shortcuts responsible for toggling context menu.
   *
   * @private
   */
  unregisterShortcuts() {
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP3);
  }
  /**
   * Registers all necessary DOM listeners.
   *
   * @private
   */
  registerListeners() {
    const {
      rootDocument
    } = this.hot;
    const editorElement = this.getEditorInputElement();
    this.eventManager.addEventListener(rootDocument, "mouseover", (event) => _classPrivateMethodGet9(this, _onMouseOver, _onMouseOver2).call(this, event));
    this.eventManager.addEventListener(rootDocument, "mousedown", (event) => _classPrivateMethodGet9(this, _onMouseDown, _onMouseDown2).call(this, event));
    this.eventManager.addEventListener(rootDocument, "mouseup", () => _classPrivateMethodGet9(this, _onMouseUp3, _onMouseUp22).call(this));
    this.eventManager.addEventListener(editorElement, "focus", () => _classPrivateMethodGet9(this, _onEditorFocus, _onEditorFocus2).call(this));
    this.eventManager.addEventListener(editorElement, "blur", () => _classPrivateMethodGet9(this, _onEditorBlur, _onEditorBlur2).call(this));
    this.eventManager.addEventListener(editorElement, "mousedown", (event) => _classPrivateMethodGet9(this, _onEditorMouseDown, _onEditorMouseDown2).call(this, event));
    this.eventManager.addEventListener(editorElement, "mouseup", (event) => _classPrivateMethodGet9(this, _onEditorMouseUp, _onEditorMouseUp2).call(this, event));
  }
  /**
   * Sets the current cell range to be able to use general methods like {@link Comments#setComment}, {@link Comments#removeComment}, {@link Comments#show}.
   *
   * @param {object} range Object with `from` property, each with `row` and `col` properties.
   */
  setRange(range) {
    this.range = range;
  }
  /**
   * Clears the currently selected cell.
   */
  clearRange() {
    this.range = {};
  }
  /**
   * Checks if the event target is a cell containing a comment.
   *
   * @private
   * @param {Event} event DOM event.
   * @returns {boolean}
   */
  targetIsCellWithComment(event) {
    const closestCell = closest(event.target, "TD", "TBODY");
    return !!(closestCell && hasClass(closestCell, "htCommentCell") && closest(closestCell, [this.hot.rootElement]));
  }
  /**
   * Checks if the event target is a comment textarea.
   *
   * @private
   * @param {Event} event DOM event.
   * @returns {boolean}
   */
  targetIsCommentTextArea(event) {
    return this.getEditorInputElement() === event.target;
  }
  /**
   * Sets a comment for a cell according to the previously set range (see {@link Comments#setRange}).
   *
   * @param {string} value Comment contents.
   */
  setComment(value) {
    if (!this.range.from) {
      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
    }
    const editorValue = _classPrivateFieldGet4(this, _editor).getValue();
    let comment = "";
    if (value !== null && value !== void 0) {
      comment = value;
    } else if (editorValue !== null && editorValue !== void 0) {
      comment = editorValue;
    }
    const row = this.range.from.row;
    const col = this.range.from.col;
    this.updateCommentMeta(row, col, {
      [META_COMMENT_VALUE]: comment
    });
    this.hot.render();
  }
  /**
   * Sets a comment for a specified cell.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} value Comment contents.
   */
  setCommentAtCell(row, column, value) {
    this.setRange({
      from: this.hot._createCellCoords(row, column)
    });
    this.setComment(value);
  }
  /**
   * Removes a comment from a cell according to previously set range (see {@link Comments#setRange}).
   *
   * @param {boolean} [forceRender=true] If set to `true`, the table will be re-rendered at the end of the operation.
   */
  removeComment() {
    let forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!this.range.from) {
      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
    }
    this.hot.setCellMeta(this.range.from.row, this.range.from.col, META_COMMENT);
    if (forceRender) {
      this.hot.render();
    }
    this.hide();
  }
  /**
   * Removes a comment from a specified cell.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {boolean} [forceRender=true] If `true`, the table will be re-rendered at the end of the operation.
   */
  removeCommentAtCell(row, column) {
    let forceRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    this.setRange({
      from: this.hot._createCellCoords(row, column)
    });
    this.removeComment(forceRender);
  }
  /**
   * Gets comment from a cell according to previously set range (see {@link Comments#setRange}).
   *
   * @returns {string|undefined} Returns a content of the comment.
   */
  getComment() {
    const row = this.range.from.row;
    const column = this.range.from.col;
    return this.getCommentMeta(row, column, META_COMMENT_VALUE);
  }
  /**
   * Gets comment from a cell at the provided coordinates.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {string|undefined} Returns a content of the comment.
   */
  getCommentAtCell(row, column) {
    return this.getCommentMeta(row, column, META_COMMENT_VALUE);
  }
  /**
   * Shows the comment editor accordingly to the previously set range (see {@link Comments#setRange}).
   *
   * @returns {boolean} Returns `true` if comment editor was shown.
   */
  show() {
    var _ref;
    if (!this.range.from) {
      throw new Error('Before using this method, first set cell range (hot.getPlugin("comment").setRange())');
    }
    const {
      from: {
        row,
        col
      }
    } = this.range;
    if (row < 0 || row > this.hot.countSourceRows() - 1 || col < 0 || col > this.hot.countSourceCols() - 1) {
      return false;
    }
    const meta = this.hot.getCellMeta(this.range.from.row, this.range.from.col);
    _classPrivateFieldGet4(this, _displaySwitch).cancelHiding();
    _classPrivateFieldGet4(this, _editor).setValue((_ref = meta[META_COMMENT] ? meta[META_COMMENT][META_COMMENT_VALUE] : null) !== null && _ref !== void 0 ? _ref : "");
    _classPrivateFieldGet4(this, _editor).show();
    this.refreshEditor(true);
    return true;
  }
  /**
   * Shows comment editor according to cell coordinates.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {boolean} Returns `true` if comment editor was shown.
   */
  showAtCell(row, column) {
    this.setRange({
      from: this.hot._createCellCoords(row, column)
    });
    return this.show();
  }
  /**
   * Hides the comment editor.
   */
  hide() {
    _classPrivateFieldGet4(this, _editor).hide();
  }
  /**
   * Refreshes comment editor position and styling.
   *
   * @param {boolean} [force=false] If `true` then recalculation will be forced.
   */
  refreshEditor() {
    var _renderableRow, _renderableColumn;
    let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!force && (!this.range.from || !_classPrivateFieldGet4(this, _editor).isVisible())) {
      return;
    }
    const {
      rowIndexMapper,
      columnIndexMapper
    } = this.hot;
    const {
      row: visualRow,
      col: visualColumn
    } = this.range.from;
    let renderableRow = rowIndexMapper.getRenderableFromVisualIndex(visualRow);
    let renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(visualColumn);
    const targetingPreviousRow = renderableRow === null;
    _classPrivateFieldGet4(this, _editor).setPosition(0, 0);
    if (renderableRow === null) {
      renderableRow = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHiddenIndex(visualRow, -1));
    }
    if (renderableColumn === null) {
      renderableColumn = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(visualColumn, -1));
    }
    const isBeforeRenderedRows = renderableRow === null;
    const isBeforeRenderedColumns = renderableColumn === null;
    renderableRow = (_renderableRow = renderableRow) !== null && _renderableRow !== void 0 ? _renderableRow : 0;
    renderableColumn = (_renderableColumn = renderableColumn) !== null && _renderableColumn !== void 0 ? _renderableColumn : 0;
    const {
      rootWindow,
      view: {
        _wt: wt
      }
    } = this.hot;
    const {
      wtTable
    } = wt;
    const TD = wt.getCell({
      row: renderableRow,
      col: renderableColumn
    }, true);
    const commentStyle = this.getCommentMeta(visualRow, visualColumn, META_STYLE);
    if (commentStyle) {
      _classPrivateFieldGet4(this, _editor).setSize(commentStyle.width, commentStyle.height);
    } else {
      _classPrivateFieldGet4(this, _editor).resetSize();
    }
    const lastColWidth = isBeforeRenderedColumns ? 0 : wtTable.getStretchedColumnWidth(renderableColumn);
    const lastRowHeight = targetingPreviousRow && !isBeforeRenderedRows ? outerHeight(TD) : 0;
    const {
      left: left2,
      top: top2,
      width: cellWidth,
      height: cellHeight
    } = TD.getBoundingClientRect();
    const {
      width: editorWidth,
      height: editorHeight
    } = _classPrivateFieldGet4(this, _editor).getSize();
    const {
      innerWidth,
      innerHeight
    } = this.hot.rootWindow;
    const documentElement = this.hot.rootDocument.documentElement;
    let x = left2 + rootWindow.scrollX + lastColWidth;
    let y = top2 + rootWindow.scrollY + lastRowHeight;
    if (this.hot.isRtl()) {
      x -= editorWidth + lastColWidth;
    }
    if (this.hot.isLtr() && left2 + cellWidth + editorWidth > innerWidth) {
      x = left2 + rootWindow.scrollX - editorWidth - 1;
    } else if (this.hot.isRtl() && x < -(documentElement.scrollWidth - documentElement.clientWidth)) {
      x = left2 + rootWindow.scrollX + lastColWidth + 1;
    }
    if (top2 + editorHeight > innerHeight) {
      y -= editorHeight - cellHeight + 1;
    }
    _classPrivateFieldGet4(this, _editor).setPosition(x, y);
    _classPrivateFieldGet4(this, _editor).setReadOnlyState(this.getCommentMeta(visualRow, visualColumn, META_READONLY));
  }
  /**
   * Focuses the comments editor element.
   */
  focusEditor() {
    _classPrivateFieldGet4(this, _editor).focus();
  }
  /**
   * Sets or update the comment-related cell meta.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} metaObject Object defining all the comment-related meta information.
   */
  updateCommentMeta(row, column, metaObject) {
    const oldComment = this.hot.getCellMeta(row, column)[META_COMMENT];
    let newComment;
    if (oldComment) {
      newComment = deepClone(oldComment);
      deepExtend(newComment, metaObject);
    } else {
      newComment = metaObject;
    }
    this.hot.setCellMeta(row, column, META_COMMENT, newComment);
  }
  /**
   * Gets the comment related meta information.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} property Cell meta property.
   * @returns {Mixed}
   */
  getCommentMeta(row, column, property) {
    const cellMeta = this.hot.getCellMeta(row, column);
    if (!cellMeta[META_COMMENT]) {
      return void 0;
    }
    return cellMeta[META_COMMENT][property];
  }
  /**
   * Add Comments plugin options to the Context Menu.
   *
   * @private
   * @param {object} options The menu options.
   */
  addToContextMenu(options) {
    options.items.push({
      name: KEY
    }, addEditCommentItem(this), removeCommentItem(this), readOnlyCommentItem(this));
  }
  /**
   * Get `displayDelay` setting of comment plugin.
   *
   * @private
   * @returns {number|undefined}
   */
  getDisplayDelaySetting() {
    const commentSetting = this.hot.getSettings()[PLUGIN_KEY9];
    if (isObject(commentSetting)) {
      return commentSetting.displayDelay;
    }
  }
  /**
   * Gets the editors input element.
   *
   * @private
   * @returns {HTMLTextAreaElement}
   */
  getEditorInputElement() {
    return _classPrivateFieldGet4(this, _editor).getInputElement();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    if (_classPrivateFieldGet4(this, _editor)) {
      _classPrivateFieldGet4(this, _editor).destroy();
    }
    if (_classPrivateFieldGet4(this, _displaySwitch)) {
      _classPrivateFieldGet4(this, _displaySwitch).destroy();
    }
    super.destroy();
  }
};
function _onMouseDown2(event) {
  if (!this.hot.view || !this.hot.view._wt) {
    return;
  }
  if (!_classPrivateFieldGet4(this, _preventEditorAutoSwitch) && !this.targetIsCommentTextArea(event)) {
    const eventCell = closest(event.target, "TD", "TBODY");
    let coordinates = null;
    if (eventCell) {
      coordinates = this.hot.getCoords(eventCell);
    }
    if (!eventCell || this.range.from && coordinates && (this.range.from.row !== coordinates.row || this.range.from.col !== coordinates.col)) {
      this.hide();
    }
  }
}
function _onMouseOver2(event) {
  const {
    rootDocument
  } = this.hot;
  if (_classPrivateFieldGet4(this, _preventEditorAutoSwitch) || _classPrivateFieldGet4(this, _editor).isFocused() || hasClass(event.target, "wtBorder") || _classPrivateFieldGet4(this, _cellBelowCursor) === event.target || !_classPrivateFieldGet4(this, _editor)) {
    return;
  }
  _classPrivateFieldSet3(this, _cellBelowCursor, rootDocument.elementFromPoint(event.clientX, event.clientY));
  if (this.targetIsCellWithComment(event)) {
    const range = this.hot._createCellRange(this.hot.getCoords(event.target));
    _classPrivateFieldGet4(this, _displaySwitch).show(range);
  } else if (isChildOf(event.target, rootDocument) && !this.targetIsCommentTextArea(event)) {
    _classPrivateFieldGet4(this, _displaySwitch).hide();
  }
}
function _onMouseUp22() {
  _classPrivateFieldSet3(this, _preventEditorAutoSwitch, false);
}
function _onAfterRenderer2(TD, cellProperties) {
  if (cellProperties[META_COMMENT] && cellProperties[META_COMMENT][META_COMMENT_VALUE]) {
    addClass(TD, cellProperties.commentedCellClassName);
  }
}
function _onEditorBlur2() {
  _classPrivateFieldSet3(this, _commentValueBeforeSave, "");
  this.hot.getShortcutManager().setActiveContextName("grid");
  this.setComment();
}
function _onEditorFocus2() {
  _classPrivateFieldSet3(this, _commentValueBeforeSave, this.getComment());
  this.hot.listen();
  this.hot.getShortcutManager().setActiveContextName(SHORTCUTS_CONTEXT_NAME);
}
function _onEditorMouseDown2(event) {
  _classPrivateFieldSet3(this, _tempEditorDimensions, {
    width: outerWidth(event.target),
    height: outerHeight(event.target)
  });
}
function _onEditorMouseUp2(event) {
  const currentWidth = outerWidth(event.target);
  const currentHeight = outerHeight(event.target);
  if (currentWidth !== _classPrivateFieldGet4(this, _tempEditorDimensions).width + 1 || currentHeight !== _classPrivateFieldGet4(this, _tempEditorDimensions).height + 2) {
    this.updateCommentMeta(this.range.from.row, this.range.from.col, {
      [META_STYLE]: {
        width: currentWidth,
        height: currentHeight
      }
    });
  }
}
function _onAfterDocumentKeyDown2(event) {
  if (_classPrivateFieldGet4(this, _editor).isVisible()) {
    stopImmediatePropagation(event);
  }
}
function _onAfterScroll2() {
  if (!_classPrivateFieldGet4(this, _preventEditorHiding)) {
    this.hide();
  }
}

// node_modules/core-js/modules/es.array.unshift.js
var $ = require_export();
var toObject = require_to_object();
var lengthOfArrayLike = require_length_of_array_like();
var setArrayLength = require_array_set_length();
var deletePropertyOrThrow = require_delete_property_or_throw();
var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
var INCORRECT_RESULT = [].unshift(0) !== 1;
var properErrorOnNonWritableLength = function() {
  try {
    Object.defineProperty([], "length", { writable: false }).unshift();
  } catch (error2) {
    return error2 instanceof TypeError;
  }
};
var FORCED = INCORRECT_RESULT || !properErrorOnNonWritableLength();
$({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  unshift: function unshift(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    if (argCount) {
      doesNotExceedSafeInteger(len + argCount);
      var k = len;
      while (k--) {
        var to = k + argCount;
        if (k in O)
          O[to] = O[k];
        else
          deletePropertyOrThrow(O, to);
      }
      for (var j = 0; j < argCount; j++) {
        O[j] = arguments[j];
      }
    }
    return setArrayLength(O, len + argCount);
  }
});

// node_modules/handsontable/plugins/contextMenu/commandExecutor.mjs
function _defineProperty16(obj, key, value) {
  key = _toPropertyKey16(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey16(arg) {
  var key = _toPrimitive16(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive16(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var CommandExecutor = class {
  constructor(hotInstance) {
    _defineProperty16(this, "hot", void 0);
    _defineProperty16(this, "commands", {});
    _defineProperty16(this, "commonCallback", null);
    this.hot = hotInstance;
  }
  /**
   * Register command.
   *
   * @param {string} name Command name.
   * @param {object} commandDescriptor Command descriptor object with properties like `key` (command id),
   *                                   `callback` (task to execute), `name` (command name), `disabled` (command availability).
   */
  registerCommand(name, commandDescriptor) {
    this.commands[name] = commandDescriptor;
  }
  /**
   * Set common callback which will be trigger on every executed command.
   *
   * @param {Function} callback Function which will be fired on every command execute.
   */
  setCommonCallback(callback) {
    this.commonCallback = callback;
  }
  /**
   * Execute command by its name.
   *
   * @param {string} commandName Command id.
   * @param {*} params Arguments passed to command task.
   */
  execute(commandName) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    const commandSplit = commandName.split(":");
    const commandNamePrimary = commandSplit[0];
    const subCommandName = commandSplit.length === 2 ? commandSplit[1] : null;
    let command = this.commands[commandNamePrimary];
    if (!command) {
      throw new Error(`Menu command '${commandNamePrimary}' not exists.`);
    }
    if (subCommandName && command.submenu) {
      command = findSubCommand(subCommandName, command.submenu.items);
    }
    if (command.disabled === true) {
      return;
    }
    if (typeof command.disabled === "function" && command.disabled.call(this.hot) === true) {
      return;
    }
    if (hasOwnProperty(command, "submenu")) {
      return;
    }
    const callbacks = [];
    if (typeof command.callback === "function") {
      callbacks.push(command.callback);
    }
    if (typeof this.commonCallback === "function") {
      callbacks.push(this.commonCallback);
    }
    params.unshift(commandSplit.join(":"));
    arrayEach(callbacks, (callback) => callback.apply(this.hot, params));
  }
};
function findSubCommand(subCommandName, subCommands) {
  let command;
  arrayEach(subCommands, (cmd) => {
    const cmds = cmd.key ? cmd.key.split(":") : null;
    if (Array.isArray(cmds) && cmds[1] === subCommandName) {
      command = cmd;
      return false;
    }
  });
  return command;
}

// node_modules/handsontable/plugins/contextMenu/itemsFactory.mjs
function _defineProperty17(obj, key, value) {
  key = _toPropertyKey17(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey17(arg) {
  var key = _toPrimitive17(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive17(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var ItemsFactory = class {
  constructor(hotInstance) {
    let orderPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    _defineProperty17(this, "hot", void 0);
    _defineProperty17(this, "predefinedItems", predefinedItems());
    _defineProperty17(this, "defaultOrderPattern", void 0);
    this.hot = hotInstance;
    this.defaultOrderPattern = orderPattern;
  }
  /**
   * Set predefined items.
   *
   * @param {Array} predefinedItemsCollection Array of predefined items.
   */
  setPredefinedItems(predefinedItemsCollection) {
    const items = {};
    this.defaultOrderPattern.length = 0;
    objectEach(predefinedItemsCollection, (value, key) => {
      let menuItemKey = "";
      if (value.name === KEY) {
        items[KEY] = value;
        menuItemKey = KEY;
      } else if (isNaN(parseInt(key, 10))) {
        value.key = value.key === void 0 ? key : value.key;
        items[key] = value;
        menuItemKey = value.key;
      } else {
        items[value.key] = value;
        menuItemKey = value.key;
      }
      this.defaultOrderPattern.push(menuItemKey);
    });
    this.predefinedItems = items;
  }
  /**
   * Get all menu items based on pattern.
   *
   * @param {Array|object|boolean} pattern Pattern which you can define by displaying menu items order. If `true` default
   *                                       pattern will be used.
   * @returns {Array}
   */
  getItems() {
    let pattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return getItems(pattern, this.defaultOrderPattern, this.predefinedItems);
  }
};
function getItems() {
  let itemsPattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
  let defaultPattern = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let items = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const result = [];
  let pattern = itemsPattern;
  if (pattern && pattern.items) {
    pattern = pattern.items;
  } else if (!Array.isArray(pattern)) {
    pattern = defaultPattern;
  }
  if (isObject(pattern)) {
    objectEach(pattern, (value, key) => {
      let item = items[typeof value === "string" ? value : key];
      if (!item) {
        item = value;
      }
      if (isObject(value)) {
        extend(item, value);
      } else if (typeof item === "string") {
        item = {
          name: item
        };
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  } else {
    arrayEach(pattern, (name, key) => {
      let item = items[name];
      if (!item && ITEMS.indexOf(name) >= 0) {
        return;
      }
      if (!item) {
        item = {
          name,
          key: `${key}`
        };
      }
      if (isObject(name)) {
        extend(item, name);
      }
      if (item.key === void 0) {
        item.key = key;
      }
      result.push(item);
    });
  }
  return result;
}

// node_modules/handsontable/plugins/contextMenu/menu/cursor.mjs
function _defineProperty18(obj, key, value) {
  key = _toPropertyKey18(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey18(arg) {
  var key = _toPrimitive18(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive18(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Cursor = class {
  constructor(object, rootWindow) {
    _defineProperty18(this, "top", void 0);
    _defineProperty18(this, "topRelative", void 0);
    _defineProperty18(this, "left", void 0);
    _defineProperty18(this, "leftRelative", void 0);
    _defineProperty18(this, "scrollTop", void 0);
    _defineProperty18(this, "scrollLeft", void 0);
    _defineProperty18(this, "cellHeight", void 0);
    _defineProperty18(this, "cellWidth", void 0);
    const windowScrollTop = rootWindow.scrollY;
    const windowScrollLeft = rootWindow.scrollX;
    let top2;
    let topRelative;
    let left2;
    let leftRelative;
    let cellHeight;
    let cellWidth;
    this.rootWindow = rootWindow;
    this.type = this.getSourceType(object);
    if (this.type === "literal") {
      top2 = parseInt(object.top, 10);
      left2 = parseInt(object.left, 10);
      cellHeight = object.height || 0;
      cellWidth = object.width || 0;
      topRelative = top2;
      leftRelative = left2;
      top2 += windowScrollTop;
      left2 += windowScrollLeft;
    } else if (this.type === "event") {
      top2 = parseInt(object.pageY, 10);
      left2 = parseInt(object.pageX, 10);
      cellHeight = object.target.clientHeight;
      cellWidth = object.target.clientWidth;
      topRelative = top2 - windowScrollTop;
      leftRelative = left2 - windowScrollLeft;
    }
    this.top = top2;
    this.topRelative = topRelative;
    this.left = left2;
    this.leftRelative = leftRelative;
    this.scrollTop = windowScrollTop;
    this.scrollLeft = windowScrollLeft;
    this.cellHeight = cellHeight;
    this.cellWidth = cellWidth;
  }
  /**
   * Get source type name.
   *
   * @param {*} object Event or Object with coordinates.
   * @returns {string} Returns one of this values: `'literal'`, `'event'`.
   */
  getSourceType(object) {
    let type = "literal";
    if (object instanceof Event) {
      type = "event";
    }
    return type;
  }
  /**
   * Checks if element can be placed above the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit above the cursor.
   * @returns {boolean}
   */
  fitsAbove(element) {
    return this.topRelative >= element.offsetHeight;
  }
  /**
   * Checks if element can be placed below the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit below the cursor.
   * @param {number} [viewportHeight] The viewport height.
   * @returns {boolean}
   */
  fitsBelow(element) {
    let viewportHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerHeight;
    return this.topRelative + element.offsetHeight <= viewportHeight;
  }
  /**
   * Checks if element can be placed on the right of the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit on the right of the cursor.
   * @param {number} [viewportWidth] The viewport width.
   * @returns {boolean}
   */
  fitsOnRight(element) {
    let viewportWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.rootWindow.innerWidth;
    return this.leftRelative + this.cellWidth + element.offsetWidth <= viewportWidth;
  }
  /**
   * Checks if element can be placed on the left on the cursor.
   *
   * @param {HTMLElement} element Element to check if it's size will fit on the left of the cursor.
   * @returns {boolean}
   */
  fitsOnLeft(element) {
    return this.leftRelative >= element.offsetWidth;
  }
};

// node_modules/handsontable/plugins/contextMenu/menu/positioner.mjs
function _classPrivateFieldInitSpec5(obj, privateMap, value) {
  _checkPrivateRedeclaration10(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration10(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet5(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor5(receiver, privateMap, "get");
  return _classApplyDescriptorGet5(receiver, descriptor);
}
function _classApplyDescriptorGet5(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet4(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor5(receiver, privateMap, "set");
  _classApplyDescriptorSet4(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor5(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet4(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _container = /* @__PURE__ */ new WeakMap();
var _parentContainer = /* @__PURE__ */ new WeakMap();
var _cursor = /* @__PURE__ */ new WeakMap();
var _keepInViewport = /* @__PURE__ */ new WeakMap();
var _offset = /* @__PURE__ */ new WeakMap();
var Positioner = class {
  constructor(keepInViewport) {
    _classPrivateFieldInitSpec5(this, _container, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec5(this, _parentContainer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec5(this, _cursor, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec5(this, _keepInViewport, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec5(this, _offset, {
      writable: true,
      value: {
        above: 0,
        below: 0,
        left: 0,
        right: 0
      }
    });
    _classPrivateFieldSet4(this, _keepInViewport, keepInViewport);
  }
  /**
   * Sets offset position for specified directions (`above`, `below`, `left` or `right`).
   *
   * @param {'above' | 'below' | 'left' | 'right'} direction A direction name.
   * @param {number} [offset=0] Offset value.
   * @returns {Positioner}
   */
  setOffset(direction) {
    let offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    _classPrivateFieldGet5(this, _offset)[direction] = offset2;
    return this;
  }
  /**
   * Sets the menu element to work with. The element can be owned by the main menu or the submenu.
   *
   * @param {HTMLElement} container The menu container element.
   * @returns {Positioner}
   */
  setElement(container) {
    _classPrivateFieldSet4(this, _container, container);
    return this;
  }
  /**
   * Sets the parent menu element to work with.
   *
   * @param {HTMLElement} container The parent menu container element.
   * @returns {Positioner}
   */
  setParentElement(container) {
    _classPrivateFieldSet4(this, _parentContainer, container);
    return this;
  }
  /**
   * Updates the menu position.
   *
   * @param {object|MouseEvent} coords The literal object with `top`, `left`, `width` and `height` props or a
   * mouse event object.
   */
  updatePosition(coords) {
    _classPrivateFieldSet4(this, _cursor, new Cursor(coords, _classPrivateFieldGet5(this, _container).ownerDocument.defaultView));
    if (_classPrivateFieldGet5(this, _keepInViewport)) {
      if (_classPrivateFieldGet5(this, _cursor).fitsBelow(_classPrivateFieldGet5(this, _container))) {
        this.setPositionBelowCursor();
      } else if (_classPrivateFieldGet5(this, _cursor).fitsAbove(_classPrivateFieldGet5(this, _container))) {
        this.setPositionAboveCursor();
      } else {
        this.setPositionBelowCursor();
      }
      this.updateHorizontalPosition();
    } else {
      this.setPositionBelowCursor();
      this.setPositionOnRightOfCursor();
    }
  }
  /**
   * Updates the menu horizontal position.
   */
  updateHorizontalPosition() {
    if (_classPrivateFieldGet5(this, _container).dir === "rtl") {
      if (_classPrivateFieldGet5(this, _cursor).fitsOnLeft(_classPrivateFieldGet5(this, _container))) {
        this.setPositionOnLeftOfCursor();
      } else {
        this.setPositionOnRightOfCursor();
      }
    } else if (_classPrivateFieldGet5(this, _cursor).fitsOnRight(_classPrivateFieldGet5(this, _container))) {
      this.setPositionOnRightOfCursor();
    } else {
      this.setPositionOnLeftOfCursor();
    }
  }
  /**
   * Sets the menu position above the cursor object.
   */
  setPositionAboveCursor() {
    let top2 = _classPrivateFieldGet5(this, _offset).above + _classPrivateFieldGet5(this, _cursor).top - _classPrivateFieldGet5(this, _container).offsetHeight;
    if (_classPrivateFieldGet5(this, _parentContainer)) {
      top2 = _classPrivateFieldGet5(this, _cursor).top + _classPrivateFieldGet5(this, _cursor).cellHeight - _classPrivateFieldGet5(this, _container).offsetHeight + 3;
    }
    _classPrivateFieldGet5(this, _container).style.top = `${top2}px`;
  }
  /**
   * Sets the menu position below the cursor object.
   */
  setPositionBelowCursor() {
    let top2 = _classPrivateFieldGet5(this, _offset).below + _classPrivateFieldGet5(this, _cursor).top + 1;
    if (_classPrivateFieldGet5(this, _parentContainer)) {
      top2 = _classPrivateFieldGet5(this, _cursor).top - 1;
    }
    _classPrivateFieldGet5(this, _container).style.top = `${top2}px`;
  }
  /**
   * Sets the menu position on the right of the cursor object.
   */
  setPositionOnRightOfCursor() {
    let left2 = _classPrivateFieldGet5(this, _cursor).left;
    if (_classPrivateFieldGet5(this, _parentContainer)) {
      const {
        right: parentMenuRight
      } = _classPrivateFieldGet5(this, _parentContainer).getBoundingClientRect();
      left2 += _classPrivateFieldGet5(this, _cursor).cellWidth + parentMenuRight - (_classPrivateFieldGet5(this, _cursor).left + _classPrivateFieldGet5(this, _cursor).cellWidth);
    } else {
      left2 += _classPrivateFieldGet5(this, _offset).right;
    }
    _classPrivateFieldGet5(this, _container).style.left = `${left2}px`;
  }
  /**
   * Sets the menu position on the left of the cursor object.
   */
  setPositionOnLeftOfCursor() {
    let left2 = _classPrivateFieldGet5(this, _offset).left + _classPrivateFieldGet5(this, _cursor).left - _classPrivateFieldGet5(this, _container).offsetWidth;
    if (_classPrivateFieldGet5(this, _parentContainer)) {
      const {
        left: parentMenuLeft
      } = _classPrivateFieldGet5(this, _parentContainer).getBoundingClientRect();
      left2 -= _classPrivateFieldGet5(this, _cursor).left - parentMenuLeft;
    }
    _classPrivateFieldGet5(this, _container).style.left = `${left2}px`;
  }
};

// node_modules/handsontable/utils/paginator.mjs
function createPaginator(_ref) {
  let {
    initialPage = -1,
    size = () => 0,
    onItemSelect = () => {
    },
    onClear = () => {
    }
  } = _ref;
  const visitedPages = /* @__PURE__ */ new Set();
  let currentIndex = clamp(initialPage, -1, getSize() - 1);
  function _updateState(newIndex, direction) {
    const lastIndex = getSize() - 1;
    if (newIndex < 0) {
      newIndex = lastIndex;
    }
    if (newIndex > lastIndex) {
      newIndex = 0;
    }
    if (visitedPages.has(newIndex)) {
      return -1;
    }
    visitedPages.add(newIndex);
    const changeProceed = onItemSelect(newIndex, false);
    if (changeProceed === false) {
      newIndex = _updateState(
        direction === 1 ? ++newIndex : --newIndex,
        // eslint-disable-line no-plusplus
        direction
      );
    }
    return newIndex;
  }
  function setCurrentPage(index) {
    if (index > -1 && index < getSize() && onItemSelect(index, true) !== false) {
      currentIndex = index;
    }
  }
  function getCurrentPage() {
    return currentIndex;
  }
  function toFirstItem() {
    if (getSize() > 0) {
      visitedPages.clear();
      currentIndex = _updateState(0, 1);
    }
  }
  function toLastItem() {
    if (getSize() > 0) {
      visitedPages.clear();
      currentIndex = _updateState(getSize() - 1, -1);
    }
  }
  function toNextItem() {
    if (getSize() > 0) {
      visitedPages.clear();
      currentIndex = _updateState(++currentIndex, 1);
    }
  }
  function toPreviousItem() {
    if (getSize() > 0) {
      visitedPages.clear();
      currentIndex = _updateState(--currentIndex, -1);
    }
  }
  function getSize() {
    return Math.max(size(), 0);
  }
  function clear() {
    visitedPages.clear();
    currentIndex = initialPage;
    onClear();
  }
  return {
    setCurrentPage,
    getCurrentPage,
    toFirstItem,
    toLastItem,
    toNextItem,
    toPreviousItem,
    getSize,
    clear
  };
}

// node_modules/handsontable/plugins/contextMenu/menu/utils.mjs
function normalizeSelection(selRanges) {
  return arrayMap(selRanges, (range) => ({
    start: range.getTopStartCorner(),
    end: range.getBottomEndCorner()
  }));
}
function isItemSubMenu(itemToTest) {
  return hasOwnProperty(itemToTest, "submenu");
}
function isItemSeparator(itemToTest) {
  return new RegExp(KEY, "i").test(itemToTest.name);
}
function isItemDisabled(itemToTest, hot) {
  return itemToTest.disabled === true || typeof itemToTest.disabled === "function" && itemToTest.disabled.call(hot) === true;
}
function isItemSelectionDisabled(itemToTest) {
  return hasOwnProperty(itemToTest, "disableSelection");
}
function isSeparator(cell) {
  return hasClass(cell, "htSeparator");
}
function hasSubMenu(cell) {
  return hasClass(cell, "htSubmenu");
}
function isDisabled(cell) {
  return hasClass(cell, "htDisabled");
}
function isSelectionDisabled(cell) {
  return hasClass(cell, "htSelectionDisabled");
}
function isItemHidden(item, instance) {
  return !item.hidden || !(typeof item.hidden === "function" && item.hidden.call(instance));
}
function shiftSeparators(items, separator) {
  const result = items.slice(0);
  for (let i = 0; i < result.length; ) {
    if (result[i].name === separator) {
      result.shift();
    } else {
      break;
    }
  }
  return result;
}
function popSeparators(items, separator) {
  let result = items.slice(0);
  result.reverse();
  result = shiftSeparators(result, separator);
  result.reverse();
  return result;
}
function removeDuplicatedSeparators(items) {
  const result = [];
  arrayEach(items, (value, index) => {
    if (index > 0) {
      if (result[result.length - 1].name !== value.name) {
        result.push(value);
      }
    } else {
      result.push(value);
    }
  });
  return result;
}
function filterSeparators(items) {
  let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : KEY;
  let result = items.slice(0);
  result = shiftSeparators(result, separator);
  result = popSeparators(result, separator);
  result = removeDuplicatedSeparators(result);
  return result;
}

// node_modules/handsontable/plugins/contextMenu/menu/navigator.mjs
function createMenuNavigator(hotMenu) {
  return createPaginator({
    size: () => hotMenu.countRows(),
    onItemSelect(currentItem, directItemChange) {
      const cell = hotMenu.getCell(currentItem, 0);
      if (!cell || isSeparator(cell) || isDisabled(cell) || isSelectionDisabled(cell)) {
        return false;
      }
      hotMenu.selectCell(currentItem, 0, ...directItemChange ? [currentItem, 0, false, false] : []);
    },
    onClear() {
      hotMenu.deselectCell();
    }
  });
}

// node_modules/handsontable/plugins/contextMenu/menu/defaultShortcutsList.mjs
function createDefaultShortcutsList(menu) {
  return [{
    keys: [["Tab"], ["Shift", "Tab"], ["Control/Meta", "A"]],
    forwardToContext: menu.hot.getShortcutManager().getContext("grid"),
    callback: () => menu.close(true)
  }, {
    keys: [["Escape"]],
    callback: () => menu.close()
  }, {
    keys: [["ArrowDown"]],
    callback: () => menu.getNavigator().toNextItem()
  }, {
    keys: [["ArrowUp"]],
    callback: () => menu.getNavigator().toPreviousItem()
  }, {
    keys: [["ArrowRight"]],
    callback: () => {
      const selection = menu.hotMenu.getSelectedLast();
      if (selection) {
        const subMenu = menu.openSubMenu(selection[0]);
        if (subMenu) {
          subMenu.getNavigator().toFirstItem();
        }
      }
    }
  }, {
    keys: [["ArrowLeft"]],
    callback: () => {
      const selection = menu.hotMenu.getSelectedLast();
      if (selection && menu.isSubMenu()) {
        menu.close();
        if (menu.isSubMenu()) {
          menu.parentMenu.hotMenu.listen();
        }
      }
    }
  }, {
    keys: [["Control/Meta", "ArrowUp"], ["Home"]],
    callback: () => menu.getNavigator().toFirstItem()
  }, {
    keys: [["Control/Meta", "ArrowDown"], ["End"]],
    callback: () => menu.getNavigator().toLastItem()
  }, {
    keys: [["Enter"], ["Space"]],
    callback: (event) => {
      const selection = menu.hotMenu.getSelectedLast();
      if (!selection) {
        return;
      }
      if (menu.hotMenu.getSourceDataAtRow(selection[0]).submenu) {
        menu.openSubMenu(selection[0]).getNavigator().toFirstItem();
      } else {
        menu.executeCommand(event);
        menu.close(true);
      }
    }
  }, {
    keys: [["PageUp"]],
    callback: () => {
      const selection = menu.hotMenu.getSelectedLast();
      if (selection) {
        menu.hotMenu.selection.transformStart(-menu.hotMenu.countVisibleRows(), 0);
      } else {
        menu.getNavigator().toFirstItem();
      }
    }
  }, {
    keys: [["PageDown"]],
    callback: () => {
      const selection = menu.hotMenu.getSelectedLast();
      if (selection) {
        menu.hotMenu.selection.transformStart(menu.hotMenu.countVisibleRows(), 0);
      } else {
        menu.getNavigator().toLastItem();
      }
    }
  }];
}

// node_modules/handsontable/plugins/contextMenu/menu/shortcuts.mjs
var SHORTCUTS_CONTEXT = "menu";
var SHORTCUTS_GROUP4 = SHORTCUTS_CONTEXT;
function createKeyboardShortcutsCtrl(menu) {
  let customKeyboardShortcuts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const customShortcuts = [];
  _addShortcuts(createDefaultShortcutsList(menu));
  customKeyboardShortcuts.forEach((_ref) => {
    let {
      shortcuts,
      contextName
    } = _ref;
    addCustomShortcuts(shortcuts, contextName);
  });
  function _addShortcuts(shortcuts, contextName) {
    getContext(contextName).addShortcuts(shortcuts, {
      group: SHORTCUTS_CONTEXT
    });
  }
  function addCustomShortcuts(shortcuts, contextName) {
    const context = getContext(contextName);
    shortcuts.forEach((_ref2) => {
      let {
        keys
      } = _ref2;
      keys.forEach((k) => context.removeShortcutsByKeys(k));
    });
    customShortcuts.push({
      shortcuts,
      contextName
    });
    _addShortcuts(shortcuts, contextName);
  }
  function getCustomShortcuts() {
    return [...customShortcuts];
  }
  function _getContextName(contextName) {
    return contextName ? `${SHORTCUTS_GROUP4}:${contextName}` : SHORTCUTS_GROUP4;
  }
  function getContext(contextName) {
    var _manager$getContext;
    const manager = menu.hotMenu.getShortcutManager();
    const name = _getContextName(contextName);
    return (_manager$getContext = manager.getContext(name)) !== null && _manager$getContext !== void 0 ? _manager$getContext : manager.addContext(name);
  }
  function listen(contextName) {
    menu.hotMenu.getShortcutManager().setActiveContextName(_getContextName(contextName));
  }
  return {
    addCustomShortcuts,
    getCustomShortcuts,
    getContext,
    listen
  };
}

// node_modules/handsontable/plugins/contextMenu/menu/menuItemRenderer.mjs
function createMenuItemRenderer(mainTableHot) {
  return (menuHot, TD, row, col, prop, value) => {
    if (TD.hasAttribute("ghost-table")) {
      return;
    }
    const item = menuHot.getSourceDataAtRow(row);
    const wrapper = mainTableHot.rootDocument.createElement("div");
    const itemValue = typeof value === "function" ? value.call(mainTableHot) : value;
    empty(TD);
    addClass(wrapper, "htItemWrapper");
    if (mainTableHot.getSettings().ariaTags) {
      const isFocusable = !isItemDisabled(item, mainTableHot) && !isItemSelectionDisabled(item) && !isItemSeparator(item);
      setAttribute(TD, [A11Y_MENU_ITEM(), A11Y_LABEL(itemValue), ...isFocusable ? [A11Y_TABINDEX(-1)] : [], ...isItemDisabled(item, mainTableHot) ? [A11Y_DISABLED()] : [], ...isItemSubMenu(item) ? [A11Y_EXPANDED(false)] : []]);
    }
    TD.className = "";
    TD.appendChild(wrapper);
    if (isItemSeparator(item)) {
      addClass(TD, "htSeparator");
    } else if (typeof item.renderer === "function") {
      addClass(TD, "htCustomMenuRenderer");
      TD.appendChild(item.renderer(menuHot, wrapper, row, col, prop, itemValue));
    } else {
      fastInnerHTML(wrapper, itemValue);
    }
    if (isItemDisabled(item, mainTableHot)) {
      addClass(TD, "htDisabled");
    } else if (isItemSelectionDisabled(item)) {
      addClass(TD, "htSelectionDisabled");
    } else if (isItemSubMenu(item)) {
      addClass(TD, "htSubmenu");
    }
  };
}

// node_modules/handsontable/plugins/contextMenu/menu/menu.mjs
function _classPrivateFieldInitSpec6(obj, privateMap, value) {
  _checkPrivateRedeclaration11(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration11(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty19(obj, key, value) {
  key = _toPropertyKey19(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey19(arg) {
  var key = _toPrimitive19(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive19(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldSet5(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor6(receiver, privateMap, "set");
  _classApplyDescriptorSet5(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet5(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet6(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor6(receiver, privateMap, "get");
  return _classApplyDescriptorGet6(receiver, descriptor);
}
function _classExtractFieldDescriptor6(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet6(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var MIN_WIDTH = 215;
var _navigator = /* @__PURE__ */ new WeakMap();
var _shortcutsCtrl = /* @__PURE__ */ new WeakMap();
var Menu = class _Menu {
  /**
   * @param {Core} hotInstance Handsontable instance.
   * @param {MenuOptions} [options] Menu options.
   */
  constructor(hotInstance, options) {
    var _this = this;
    _defineProperty19(this, "hot", void 0);
    _defineProperty19(this, "options", void 0);
    _defineProperty19(this, "eventManager", new eventManager_default(this));
    _defineProperty19(this, "container", void 0);
    _defineProperty19(this, "positioner", void 0);
    _defineProperty19(this, "hotMenu", null);
    _defineProperty19(this, "hotSubMenus", {});
    _defineProperty19(this, "parentMenu", void 0);
    _defineProperty19(this, "menuItems", null);
    _defineProperty19(this, "origOutsideClickDeselects", null);
    _classPrivateFieldInitSpec6(this, _navigator, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec6(this, _shortcutsCtrl, {
      writable: true,
      value: void 0
    });
    this.hot = hotInstance;
    this.options = options || {
      parent: null,
      name: null,
      className: "",
      keepInViewport: true,
      standalone: false,
      minWidth: MIN_WIDTH,
      container: this.hot.rootDocument.documentElement
    };
    this.container = this.createContainer(this.options.name);
    this.positioner = new Positioner(this.options.keepInViewport);
    this.parentMenu = this.options.parent || null;
    this.registerEvents();
    if (this.isSubMenu()) {
      this.addLocalHook("afterSelectionChange", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _this.parentMenu.runLocalHooks("afterSelectionChange", ...args);
      });
    }
  }
  /**
   * Register event listeners.
   *
   * @private
   */
  registerEvents() {
    let frame = this.hot.rootWindow;
    while (frame) {
      this.eventManager.addEventListener(frame.document, "mousedown", (event) => this.onDocumentMouseDown(event));
      this.eventManager.addEventListener(frame.document, "contextmenu", (event) => this.onDocumentContextMenu(event));
      frame = getParentWindow(frame);
    }
  }
  /**
   * Set array of objects which defines menu items.
   *
   * @param {Array} menuItems Menu items to display.
   */
  setMenuItems(menuItems) {
    this.menuItems = menuItems;
  }
  /**
   * Gets the controller object that allows modifying the the menu item selection.
   *
   * @returns {Paginator | undefined}
   */
  getNavigator() {
    return _classPrivateFieldGet6(this, _navigator);
  }
  /**
   * Gets the controller object that allows extending the keyboard shortcuts of the menu.
   *
   * @returns {KeyboardShortcutsMenuController | undefined}
   */
  getKeyboardShortcutsCtrl() {
    return _classPrivateFieldGet6(this, _shortcutsCtrl);
  }
  /**
   * Returns currently selected menu item. Returns `null` if no item was selected.
   *
   * @returns {object|null}
   */
  getSelectedItem() {
    return this.hasSelectedItem() ? this.hotMenu.getSourceDataAtRow(this.hotMenu.getSelectedLast()[0]) : null;
  }
  /**
   * Checks if the menu has selected (highlighted) any item from the menu list.
   *
   * @returns {boolean}
   */
  hasSelectedItem() {
    return Array.isArray(this.hotMenu.getSelectedLast());
  }
  /**
   * Check if menu is using as sub-menu.
   *
   * @returns {boolean}
   */
  isSubMenu() {
    return this.parentMenu !== null;
  }
  /**
   * Open menu.
   *
   * @fires Hooks#beforeContextMenuShow
   * @fires Hooks#afterContextMenuShow
   */
  open() {
    this.runLocalHooks("beforeOpen");
    this.container.removeAttribute("style");
    this.container.style.display = "block";
    const delayedOpenSubMenu = debounce((row) => this.openSubMenu(row), 300);
    const minWidthOfMenu = this.options.minWidth || MIN_WIDTH;
    let noItemsDefined = false;
    let filteredItems = arrayFilter(this.menuItems, (item) => {
      if (item.key === KEY12) {
        noItemsDefined = true;
      }
      return isItemHidden(item, this.hot);
    });
    if (filteredItems.length < 1 && !noItemsDefined) {
      filteredItems.push(predefinedItems()[KEY12]);
    } else if (filteredItems.length === 0) {
      return;
    }
    filteredItems = filterSeparators(filteredItems, KEY);
    let shouldAutoCloseMenu = false;
    const settings = {
      data: filteredItems,
      colHeaders: false,
      autoColumnSize: true,
      autoWrapRow: false,
      modifyColWidth(width) {
        if (isDefined(width) && width < minWidthOfMenu) {
          return minWidthOfMenu;
        }
        return width;
      },
      autoRowSize: false,
      readOnly: true,
      editor: false,
      copyPaste: false,
      hiddenRows: true,
      maxCols: 1,
      columns: [{
        data: "name",
        renderer: createMenuItemRenderer(this.hot)
      }],
      renderAllRows: true,
      fragmentSelection: false,
      outsideClickDeselects: false,
      disableVisualSelection: "area",
      layoutDirection: this.hot.isRtl() ? "rtl" : "ltr",
      ariaTags: false,
      beforeOnCellMouseOver: (event, coords) => {
        _classPrivateFieldGet6(this, _navigator).setCurrentPage(coords.row);
      },
      afterOnCellMouseOver: (event, coords) => {
        if (this.isAllSubMenusClosed()) {
          delayedOpenSubMenu(coords.row);
        } else {
          this.openSubMenu(coords.row);
        }
      },
      rowHeights: (row) => filteredItems[row].name === KEY ? 1 : 23,
      afterOnCellContextMenu: (event) => {
        event.preventDefault();
        if (isWindowsOS() && shouldAutoCloseMenu && this.hasSelectedItem()) {
          this.close(true);
        }
      },
      afterSelection: (row, column, row2, column2, preventScrolling) => {
        if (this.hotMenu.view.isMouseDown()) {
          preventScrolling.value = true;
        }
        this.runLocalHooks("afterSelectionChange", this.getSelectedItem());
      },
      beforeOnCellMouseUp: (event) => {
        if (this.hasSelectedItem()) {
          shouldAutoCloseMenu = !this.isCommandPassive(this.getSelectedItem());
          this.executeCommand(event);
        }
      },
      afterOnCellMouseUp: (event) => {
        if ((!isWindowsOS() || !isRightClick(event)) && shouldAutoCloseMenu && this.hasSelectedItem()) {
          if (isMobileBrowser() || isIpadOS()) {
            this.hot._registerTimeout(() => this.close(true), 325);
          } else {
            this.close(true);
          }
        }
      },
      afterUnlisten: () => {
        if (!this.hasSelectedItem() && this.isOpened()) {
          this.hotMenu.listen();
        }
      }
    };
    this.origOutsideClickDeselects = this.hot.getSettings().outsideClickDeselects;
    this.hot.getSettings().outsideClickDeselects = false;
    this.hotMenu = new this.hot.constructor(this.container, settings);
    this.hotMenu.addHook("afterInit", () => this.onAfterInit());
    this.hotMenu.init();
    _classPrivateFieldSet5(this, _navigator, createMenuNavigator(this.hotMenu));
    _classPrivateFieldSet5(this, _shortcutsCtrl, createKeyboardShortcutsCtrl(this));
    _classPrivateFieldGet6(this, _shortcutsCtrl).listen();
    this.focus();
    if (this.isSubMenu()) {
      this.addLocalHook("afterOpen", () => this.parentMenu.runLocalHooks("afterSubmenuOpen", this));
    }
    this.runLocalHooks("afterOpen", this);
  }
  /**
   * Close menu.
   *
   * @param {boolean} [closeParent=false] If `true` try to close parent menu if exists.
   */
  close() {
    let closeParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!this.isOpened()) {
      return;
    }
    if (closeParent && this.isSubMenu()) {
      this.parentMenu.close();
    } else {
      _classPrivateFieldGet6(this, _navigator).clear();
      this.closeAllSubMenus();
      this.container.style.display = "none";
      this.hotMenu.destroy();
      this.hotMenu = null;
      this.hot.getSettings().outsideClickDeselects = this.origOutsideClickDeselects;
      this.runLocalHooks("afterClose");
      if (this.isSubMenu()) {
        if (this.hot.getSettings().ariaTags) {
          const selection = this.parentMenu.hotMenu.getSelectedLast();
          if (selection) {
            const cell = this.parentMenu.hotMenu.getCell(selection[0], 0);
            setAttribute(cell, [A11Y_EXPANDED(false)]);
          }
        }
        this.parentMenu.hotMenu.listen();
      }
    }
  }
  /**
   * Open sub menu at the provided row index.
   *
   * @param {number} row Row index.
   * @returns {Menu|boolean} Returns created menu or `false` if no one menu was created.
   */
  openSubMenu(row) {
    if (!this.hotMenu) {
      return false;
    }
    const cell = this.hotMenu.getCell(row, 0);
    this.closeAllSubMenus();
    if (!cell || !hasSubMenu(cell)) {
      return false;
    }
    const dataItem = this.hotMenu.getSourceDataAtRow(row);
    const subMenu = new _Menu(this.hot, {
      parent: this,
      name: dataItem.name,
      className: this.options.className,
      keepInViewport: true,
      container: this.options.container
    });
    subMenu.setMenuItems(dataItem.submenu.items);
    subMenu.open();
    subMenu.setPosition(cell.getBoundingClientRect());
    this.hotSubMenus[dataItem.key] = subMenu;
    if (this.hot.getSettings().ariaTags) {
      setAttribute(cell, [A11Y_EXPANDED(true)]);
    }
    return subMenu;
  }
  /**
   * Close sub menu at row index.
   *
   * @param {number} row Row index.
   */
  closeSubMenu(row) {
    const dataItem = this.hotMenu.getSourceDataAtRow(row);
    const menus = this.hotSubMenus[dataItem.key];
    if (menus) {
      menus.destroy();
      delete this.hotSubMenus[dataItem.key];
      const cell = this.hotMenu.getCell(row, 0);
      if (this.hot.getSettings().ariaTags) {
        setAttribute(cell, [A11Y_EXPANDED(false)]);
      }
    }
  }
  /**
   * Close all opened sub menus.
   */
  closeAllSubMenus() {
    arrayEach(this.hotMenu.getData(), (value, row) => this.closeSubMenu(row));
  }
  /**
   * Checks if all created and opened sub menus are closed.
   *
   * @returns {boolean}
   */
  isAllSubMenusClosed() {
    return Object.keys(this.hotSubMenus).length === 0;
  }
  /**
   * Focus the menu so all keyboard shortcuts become active.
   */
  focus() {
    if (this.isOpened()) {
      this.hotMenu.rootElement.focus({
        preventScroll: true
      });
      this.getKeyboardShortcutsCtrl().listen();
      this.hotMenu.listen();
    }
  }
  /**
   * Destroy instance.
   */
  destroy() {
    const menuContainerParentElement = this.container.parentNode;
    this.clearLocalHooks();
    this.close();
    this.parentMenu = null;
    this.eventManager.destroy();
    if (menuContainerParentElement) {
      menuContainerParentElement.removeChild(this.container);
    }
  }
  /**
   * Checks if menu was opened.
   *
   * @returns {boolean} Returns `true` if menu was opened.
   */
  isOpened() {
    return this.hotMenu !== null;
  }
  /**
   * Execute menu command.
   *
   * The `executeCommand()` method works only for selected cells.
   *
   * When no cells are selected, `executeCommand()` doesn't do anything.
   *
   * @param {Event} [event] The mouse event object.
   */
  executeCommand(event) {
    if (!this.isOpened() || !this.hasSelectedItem()) {
      return;
    }
    const selectedItem = this.getSelectedItem();
    this.runLocalHooks("select", selectedItem, event);
    if (this.isCommandPassive(selectedItem)) {
      return;
    }
    const selRanges = this.hot.getSelectedRange();
    const normalizedSelection = selRanges ? normalizeSelection(selRanges) : [];
    this.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event);
    if (this.isSubMenu()) {
      this.parentMenu.runLocalHooks("executeCommand", selectedItem.key, normalizedSelection, event);
    }
  }
  /**
   * Checks if the passed command is passive or not. The command is passive when it's marked as
   * disabled, the descriptor object contains `isCommand` property set to `false`, command
   * is a separator, or the item is recognized as submenu. For passive items the menu is not
   * closed automatically after the user trigger the command through the UI.
   *
   * @param {object} commandDescriptor Selected menu item from the menu data source.
   * @returns {boolean}
   */
  isCommandPassive(commandDescriptor) {
    return commandDescriptor.isCommand === false || isItemSeparator(commandDescriptor) || isItemDisabled(commandDescriptor, this.hot) || isItemSubMenu(commandDescriptor);
  }
  /**
   * Set offset menu position for specified area (`above`, `below`, `left` or `right`).
   *
   * @param {string} area Specified area name (`above`, `below`, `left` or `right`).
   * @param {number} offset Offset value.
   */
  setOffset(area) {
    let offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.positioner.setOffset(area, offset2);
  }
  /**
   * Set menu position based on dom event or based on literal object.
   *
   * @param {Event|object} coords Event or literal Object with coordinates.
   */
  setPosition(coords) {
    if (this.isSubMenu()) {
      this.positioner.setParentElement(this.parentMenu.container);
    }
    this.positioner.setElement(this.container).updatePosition(coords);
  }
  /**
   * Create container/wrapper for handsontable.
   *
   * @private
   * @param {string} [name] Class name.
   * @returns {HTMLElement}
   */
  createContainer() {
    let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    const doc = this.options.container.ownerDocument;
    let className = name;
    let container;
    if (className) {
      if (isFunction(className)) {
        className = className.call(this.hot);
        if (className === null || isUndefined(className)) {
          className = "";
        } else {
          className = className.toString();
        }
      }
      className = className.replace(/[^A-z0-9]/g, "_");
      className = `${this.options.className}Sub_${className}`;
      container = doc.querySelector(`.${this.options.className}.${className}`);
    }
    if (!container) {
      container = doc.createElement("div");
      addClass(container, `htMenu ${this.options.className}`);
      if (className) {
        addClass(container, className);
      }
      this.options.container.appendChild(container);
    }
    return container;
  }
  /**
   * On after init listener.
   *
   * @private
   */
  onAfterInit() {
    const {
      wtTable
    } = this.hotMenu.view._wt;
    const data = this.hotMenu.getSettings().data;
    const hiderStyle = wtTable.hider.style;
    const holderStyle = wtTable.holder.style;
    const currentHiderWidth = parseInt(hiderStyle.width, 10);
    const realHeight = arrayReduce(data, (accumulator, value) => accumulator + (value.name === KEY ? 1 : 26), 0);
    holderStyle.width = `${currentHiderWidth + 3}px`;
    holderStyle.height = `${realHeight + 3}px`;
    hiderStyle.height = holderStyle.height;
    if (this.hot.getSettings().ariaTags) {
      setAttribute(this.hotMenu.rootElement, [A11Y_MENU(), A11Y_TABINDEX(-1)]);
    }
  }
  /**
   * Document mouse down listener.
   *
   * @private
   * @param {Event} event The mouse event object.
   */
  onDocumentMouseDown(event) {
    if (!this.isOpened()) {
      return;
    }
    if (this.options.standalone && this.hotMenu && !isChildOf(event.target, this.hotMenu.rootElement)) {
      this.close(true);
    } else if ((this.isAllSubMenusClosed() || this.isSubMenu()) && !isChildOf(event.target, ".htMenu")) {
      this.close(true);
    }
  }
  /**
   * Document's contextmenu listener.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onDocumentContextMenu(event) {
    if (!this.isOpened()) {
      return;
    }
    if (hasClass(event.target, "htCore") && isChildOf(event.target, this.hotMenu.rootElement)) {
      event.preventDefault();
    }
  }
};
mixin(Menu, localHooks_default);

// node_modules/handsontable/plugins/contextMenu/contextMenu.mjs
function _classPrivateMethodInitSpec10(obj, privateSet) {
  _checkPrivateRedeclaration12(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration12(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty20(obj, key, value) {
  key = _toPropertyKey20(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey20(arg) {
  var key = _toPrimitive20(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive20(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet10(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY10 = "contextMenu";
var PLUGIN_PRIORITY9 = 70;
var SHORTCUTS_GROUP5 = PLUGIN_KEY10;
pluginHooks_default.getSingleton().register("afterContextMenuDefaultOptions");
pluginHooks_default.getSingleton().register("beforeContextMenuShow");
pluginHooks_default.getSingleton().register("afterContextMenuShow");
pluginHooks_default.getSingleton().register("afterContextMenuHide");
pluginHooks_default.getSingleton().register("afterContextMenuExecute");
var _onAfterOnCellContextMenu = /* @__PURE__ */ new WeakSet();
var _onMenuBeforeOpen = /* @__PURE__ */ new WeakSet();
var _onMenuAfterOpen = /* @__PURE__ */ new WeakSet();
var _onMenuAfterClose = /* @__PURE__ */ new WeakSet();
var ContextMenu = class _ContextMenu extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec10(this, _onMenuAfterClose);
    _classPrivateMethodInitSpec10(this, _onMenuAfterOpen);
    _classPrivateMethodInitSpec10(this, _onMenuBeforeOpen);
    _classPrivateMethodInitSpec10(this, _onAfterOnCellContextMenu);
    _defineProperty20(this, "commandExecutor", new CommandExecutor(this.hot));
    _defineProperty20(this, "itemsFactory", null);
    _defineProperty20(this, "menu", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY10;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY9;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:AutoColumnSize"];
  }
  /**
   * Context menu default items order when `contextMenu` options is set as `true`.
   *
   * @returns {string[]}
   */
  static get DEFAULT_ITEMS() {
    return [KEY10, KEY11, KEY, KEY4, KEY5, KEY, KEY9, KEY8, KEY, KEY13, KEY7, KEY, KEY6, KEY, KEY2];
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ContextMenu#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY10];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const settings = this.hot.getSettings()[PLUGIN_KEY10];
    if (typeof settings.callback === "function") {
      this.commandExecutor.setCommonCallback(settings.callback);
    }
    this.menu = new Menu(this.hot, {
      className: "htContextMenu",
      keepInViewport: true,
      container: settings.uiContainer || this.hot.rootDocument.body
    });
    this.menu.addLocalHook("beforeOpen", () => _classPrivateMethodGet10(this, _onMenuBeforeOpen, _onMenuBeforeOpen2).call(this));
    this.menu.addLocalHook("afterOpen", () => _classPrivateMethodGet10(this, _onMenuAfterOpen, _onMenuAfterOpen2).call(this));
    this.menu.addLocalHook("afterClose", () => _classPrivateMethodGet10(this, _onMenuAfterClose, _onMenuAfterClose2).call(this));
    this.menu.addLocalHook("executeCommand", function() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      return _this.executeCommand.call(_this, ...params);
    });
    this.addHook("afterOnCellContextMenu", (event) => _classPrivateMethodGet10(this, _onAfterOnCellContextMenu, _onAfterOnCellContextMenu2).call(this, event));
    this.registerShortcuts();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`contextMenu`](@/api/options.md#contextmenu)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
      this.menu = null;
    }
    this.unregisterShortcuts();
    super.disablePlugin();
  }
  /**
   * Register shortcuts responsible for toggling context menu.
   *
   * @private
   */
  registerShortcuts() {
    this.hot.getShortcutManager().getContext("grid").addShortcut({
      keys: [["Control/Meta", "Shift", "Backslash"], ["Shift", "F10"]],
      callback: () => {
        const {
          highlight
        } = this.hot.getSelectedRangeLast();
        this.hot.scrollToFocusedCell();
        const rect = this.hot.getCell(highlight.row, highlight.col, true).getBoundingClientRect();
        const offset2 = getDocumentOffsetByElement(this.menu.container, this.hot.rootDocument);
        this.open({
          left: rect.left + offset2.left,
          top: rect.top + offset2.top - 1 + rect.height
        }, {
          left: rect.width,
          above: -rect.height
        });
        this.menu.getNavigator().toFirstItem();
      },
      runOnlyIf: () => {
        var _this$hot$getSelected;
        const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
        return highlight && this.hot.selection.isCellVisible(highlight) && !this.menu.isOpened();
      },
      group: SHORTCUTS_GROUP5
    });
  }
  /**
   * Unregister shortcuts responsible for toggling context menu.
   *
   * @private
   */
  unregisterShortcuts() {
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP5);
  }
  /**
   * Opens menu and re-position it based on the passed coordinates.
   *
   * @param {{ top: number, left: number }|Event} position An object with `top` and `left` properties
   * which contains coordinates relative to the browsers viewport (without included scroll offsets).
   * Or if the native event is passed the menu will be positioned based on the `pageX` and `pageY`
   * coordinates.
   * @param {{ above: number, below: number, left: number, right: number }} offset An object allows applying
   * the offset to the menu position.
   * @fires Hooks#beforeContextMenuShow
   * @fires Hooks#afterContextMenuShow
   */
  open(position) {
    var _this$menu;
    let offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      above: 0,
      below: 0,
      left: 0,
      right: 0
    };
    if ((_this$menu = this.menu) !== null && _this$menu !== void 0 && _this$menu.isOpened()) {
      return;
    }
    this.prepareMenuItems();
    this.menu.open();
    objectEach(offset2, (value, key) => {
      this.menu.setOffset(key, value);
    });
    this.menu.setPosition(position);
  }
  /**
   * Closes the menu.
   */
  close() {
    var _this$menu2;
    (_this$menu2 = this.menu) === null || _this$menu2 === void 0 || _this$menu2.close();
    this.itemsFactory = null;
  }
  /**
   * Execute context menu command.
   *
   * The `executeCommand()` method works only for selected cells.
   *
   * When no cells are selected, `executeCommand()` doesn't do anything.
   *
   * You can execute all predefined commands:
   *  * `'row_above'` - Insert row above
   *  * `'row_below'` - Insert row below
   *  * `'col_left'` - Insert column left
   *  * `'col_right'` - Insert column right
   *  * `'clear_column'` - Clear selected column
   *  * `'remove_row'` - Remove row
   *  * `'remove_col'` - Remove column
   *  * `'undo'` - Undo last action
   *  * `'redo'` - Redo last action
   *  * `'make_read_only'` - Make cell read only
   *  * `'alignment:left'` - Alignment to the left
   *  * `'alignment:top'` - Alignment to the top
   *  * `'alignment:right'` - Alignment to the right
   *  * `'alignment:bottom'` - Alignment to the bottom
   *  * `'alignment:middle'` - Alignment to the middle
   *  * `'alignment:center'` - Alignment to the center (justify).
   *
   * Or you can execute command registered in settings where `key` is your command name.
   *
   * @param {string} commandName The command name to be executed.
   * @param {*} params Additional parameters passed to command executor module.
   */
  executeCommand(commandName) {
    if (this.itemsFactory === null) {
      this.prepareMenuItems();
    }
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    this.commandExecutor.execute(commandName, ...params);
  }
  /**
   * Prepares available contextMenu's items list and registers them in commandExecutor.
   *
   * @private
   * @fires Hooks#afterContextMenuDefaultOptions
   * @fires Hooks#beforeContextMenuSetItems
   */
  prepareMenuItems() {
    this.itemsFactory = new ItemsFactory(this.hot, _ContextMenu.DEFAULT_ITEMS);
    const settings = this.hot.getSettings()[PLUGIN_KEY10];
    const predefinedItems2 = {
      items: this.itemsFactory.getItems(settings)
    };
    this.hot.runHooks("afterContextMenuDefaultOptions", predefinedItems2);
    this.itemsFactory.setPredefinedItems(predefinedItems2.items);
    const menuItems = this.itemsFactory.getItems(settings);
    this.hot.runHooks("beforeContextMenuSetItems", menuItems);
    this.menu.setMenuItems(menuItems);
    arrayEach(menuItems, (command) => this.commandExecutor.registerCommand(command.key, command));
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
    }
    super.destroy();
  }
};
function _onAfterOnCellContextMenu2(event) {
  const settings = this.hot.getSettings();
  const showRowHeaders = settings.rowHeaders;
  const showColHeaders = settings.colHeaders;
  function isValidElement(element2) {
    return element2.nodeName === "TD" || element2.parentNode.nodeName === "TD";
  }
  const element = event.target;
  this.close();
  if (hasClass(element, "handsontableInput")) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  if (!(showRowHeaders || showColHeaders)) {
    if (!isValidElement(element) && !(hasClass(element, "current") && hasClass(element, "wtBorder"))) {
      return;
    }
  }
  const offset2 = getDocumentOffsetByElement(this.menu.container, this.hot.rootDocument);
  this.open({
    top: event.clientY + offset2.top,
    left: event.clientX + offset2.left
  });
}
function _onMenuBeforeOpen2() {
  this.hot.runHooks("beforeContextMenuShow", this);
}
function _onMenuAfterOpen2() {
  this.hot.runHooks("afterContextMenuShow", this);
}
function _onMenuAfterClose2() {
  this.hot.listen();
  this.hot.runHooks("afterContextMenuHide", this);
}
ContextMenu.SEPARATOR = {
  name: KEY
};

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/copy.mjs
function copyItem(copyPastePlugin) {
  return {
    key: "copy",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY);
    },
    callback() {
      copyPastePlugin.copyCellsOnly();
    },
    disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyColumnHeadersOnly.mjs
function copyColumnHeadersOnlyItem(copyPastePlugin) {
  return {
    key: "copy_column_headers_only",
    name() {
      const selectedRange = this.getSelectedRangeLast();
      const nounForm = selectedRange ? clamp(selectedRange.getWidth() - 1, 0, 1) : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY, nounForm);
    },
    callback() {
      copyPastePlugin.copyColumnHeadersOnly();
    },
    disabled() {
      if (!this.hasColHeaders()) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyWithColumnGroupHeaders.mjs
function copyWithColumnGroupHeadersItem(copyPastePlugin) {
  return {
    key: "copy_with_column_group_headers",
    name() {
      const selectedRange = this.getSelectedRangeLast();
      const nounForm = selectedRange ? clamp(selectedRange.getWidth() - 1, 0, 1) : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS, nounForm);
    },
    callback() {
      copyPastePlugin.copyWithAllColumnHeaders();
    },
    disabled() {
      if (!this.hasColHeaders() || !this.getSettings().nestedHeaders) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/copyWithColumnHeaders.mjs
function copyWithColumnHeadersItem(copyPastePlugin) {
  return {
    key: "copy_with_column_headers",
    name() {
      const selectedRange = this.getSelectedRangeLast();
      const nounForm = selectedRange ? clamp(selectedRange.getWidth() - 1, 0, 1) : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS, nounForm);
    },
    callback() {
      copyPastePlugin.copyWithColumnHeaders();
    },
    disabled() {
      if (!this.hasColHeaders()) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/contextMenuItem/cut.mjs
function cutItem(copyPastePlugin) {
  return {
    key: "cut",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_CUT);
    },
    callback() {
      copyPastePlugin.cut();
    },
    disabled() {
      if (this.countRows() === 0 || this.countCols() === 0) {
        return true;
      }
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      const selected = this.getSelected();
      if (!selected || selected.length > 1) {
        return true;
      }
      return false;
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/copyPaste/clipboardData.mjs
var ClipboardData = class {
  constructor() {
    this.data = {};
  }
  setData(type, value) {
    this.data[type] = value;
  }
  getData(type) {
    return this.data[type] || void 0;
  }
};

// node_modules/handsontable/plugins/copyPaste/pasteEvent.mjs
var PasteEvent = class {
  constructor() {
    this.clipboardData = new ClipboardData();
  }
};

// node_modules/handsontable/plugins/copyPaste/copyableRanges.mjs
function _classPrivateMethodInitSpec11(obj, privateSet) {
  _checkPrivateRedeclaration13(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec7(obj, privateMap, value) {
  _checkPrivateRedeclaration13(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration13(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet11(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet7(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor7(receiver, privateMap, "get");
  return _classApplyDescriptorGet7(receiver, descriptor);
}
function _classApplyDescriptorGet7(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet6(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor7(receiver, privateMap, "set");
  _classApplyDescriptorSet6(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor7(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet6(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _selectedRange = /* @__PURE__ */ new WeakMap();
var _countRows = /* @__PURE__ */ new WeakMap();
var _countColumns = /* @__PURE__ */ new WeakMap();
var _rowsLimit = /* @__PURE__ */ new WeakMap();
var _columnsLimit = /* @__PURE__ */ new WeakMap();
var _countColumnHeaders = /* @__PURE__ */ new WeakMap();
var _trimColumnsRange = /* @__PURE__ */ new WeakSet();
var _trimRowsRange = /* @__PURE__ */ new WeakSet();
var CopyableRangesFactory = class {
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @param {{
   *   countRows: function(): number,
   *   countColumns: function(): number,
   *   rowsLimit: function(): number,
   *   columnsLimit: function(): number,
   *   countColumnHeaders: function(): number
   * }} dependencies The utils class dependencies.
   */
  constructor(_ref) {
    let {
      countRows,
      countColumns,
      rowsLimit,
      columnsLimit,
      countColumnHeaders
    } = _ref;
    _classPrivateMethodInitSpec11(this, _trimRowsRange);
    _classPrivateMethodInitSpec11(this, _trimColumnsRange);
    _classPrivateFieldInitSpec7(this, _selectedRange, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _countRows, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _countColumns, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _rowsLimit, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _columnsLimit, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec7(this, _countColumnHeaders, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet6(this, _countRows, countRows);
    _classPrivateFieldSet6(this, _countColumns, countColumns);
    _classPrivateFieldSet6(this, _rowsLimit, rowsLimit);
    _classPrivateFieldSet6(this, _columnsLimit, columnsLimit);
    _classPrivateFieldSet6(this, _countColumnHeaders, countColumnHeaders);
  }
  /* eslint-enable jsdoc/require-description-complete-sentence */
  /**
   * Sets the selection range to be processed.
   *
   * @param {CellRange} selectedRange The selection range represented by the CellRange class.
   */
  setSelectedRange(selectedRange) {
    _classPrivateFieldSet6(this, _selectedRange, selectedRange);
  }
  /**
   * Returns a new coords object within the dataset range (cells) with `startRow`, `startCol`, `endRow`
   * and `endCol` keys.
   *
   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}
   */
  getCellsRange() {
    if (_classPrivateFieldGet7(this, _countRows).call(this) === 0 || _classPrivateFieldGet7(this, _countColumns).call(this) === 0) {
      return null;
    }
    const {
      row: startRow,
      col: startCol
    } = _classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();
    const {
      row: endRow,
      col: endCol
    } = _classPrivateFieldGet7(this, _selectedRange).getBottomEndCorner();
    const finalEndRow = _classPrivateMethodGet11(this, _trimRowsRange, _trimRowsRange2).call(this, startRow, endRow);
    const finalEndCol = _classPrivateMethodGet11(this, _trimColumnsRange, _trimColumnsRange2).call(this, startCol, endCol);
    const isRangeTrimmed = endRow !== finalEndRow || endCol !== finalEndCol;
    return {
      isRangeTrimmed,
      startRow,
      startCol,
      endRow: finalEndRow,
      endCol: finalEndCol
    };
  }
  /**
   * Returns a new coords object within the most-bottom column headers range with `startRow`,
   * `startCol`, `endRow` and `endCol` keys.
   *
   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}
   */
  getMostBottomColumnHeadersRange() {
    if (_classPrivateFieldGet7(this, _countColumns).call(this) === 0 || _classPrivateFieldGet7(this, _countColumnHeaders).call(this) === 0) {
      return null;
    }
    const {
      col: startCol
    } = _classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();
    const {
      col: endCol
    } = _classPrivateFieldGet7(this, _selectedRange).getBottomEndCorner();
    const finalEndCol = _classPrivateMethodGet11(this, _trimColumnsRange, _trimColumnsRange2).call(this, startCol, endCol);
    const isRangeTrimmed = endCol !== finalEndCol;
    return {
      isRangeTrimmed,
      startRow: -1,
      startCol,
      endRow: -1,
      endCol: finalEndCol
    };
  }
  /**
   * Returns a new coords object within all column headers layers (including nested headers) range with
   * `startRow`, `startCol`, `endRow` and `endCol` keys.
   *
   * @returns {{startRow: number, startCol: number, endRow: number, endCol: number} | null}
   */
  getAllColumnHeadersRange() {
    if (_classPrivateFieldGet7(this, _countColumns).call(this) === 0 || _classPrivateFieldGet7(this, _countColumnHeaders).call(this) === 0) {
      return null;
    }
    const {
      col: startCol
    } = _classPrivateFieldGet7(this, _selectedRange).getTopStartCorner();
    const {
      col: endCol
    } = _classPrivateFieldGet7(this, _selectedRange).getBottomEndCorner();
    const finalEndCol = _classPrivateMethodGet11(this, _trimColumnsRange, _trimColumnsRange2).call(this, startCol, endCol);
    const isRangeTrimmed = endCol !== finalEndCol;
    return {
      isRangeTrimmed,
      startRow: -_classPrivateFieldGet7(this, _countColumnHeaders).call(this),
      startCol,
      endRow: -1,
      endCol: finalEndCol
    };
  }
};
function _trimColumnsRange2(startColumn, endColumn) {
  return Math.min(endColumn, Math.max(startColumn + _classPrivateFieldGet7(this, _columnsLimit).call(this) - 1, startColumn));
}
function _trimRowsRange2(startRow, endRow) {
  return Math.min(endRow, Math.max(startRow + _classPrivateFieldGet7(this, _rowsLimit).call(this) - 1, startRow));
}
function normalizeRanges(ranges) {
  const rows = [];
  const columns = [];
  arrayEach(ranges, (range) => {
    const minRow = Math.min(range.startRow, range.endRow);
    const maxRow = Math.max(range.startRow, range.endRow);
    rangeEach(minRow, maxRow, (row) => {
      if (rows.indexOf(row) === -1) {
        rows.push(row);
      }
    });
    const minColumn = Math.min(range.startCol, range.endCol);
    const maxColumn = Math.max(range.startCol, range.endCol);
    rangeEach(minColumn, maxColumn, (column) => {
      if (columns.indexOf(column) === -1) {
        columns.push(column);
      }
    });
  });
  return {
    rows,
    columns
  };
}

// node_modules/handsontable/plugins/copyPaste/copyPaste.mjs
function _classPrivateMethodInitSpec12(obj, privateSet) {
  _checkPrivateRedeclaration14(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec8(obj, privateMap, value) {
  _checkPrivateRedeclaration14(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration14(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty21(obj, key, value) {
  key = _toPropertyKey21(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey21(arg) {
  var key = _toPrimitive21(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive21(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet8(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor8(receiver, privateMap, "get");
  return _classApplyDescriptorGet8(receiver, descriptor);
}
function _classApplyDescriptorGet8(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet12(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldSet7(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor8(receiver, privateMap, "set");
  _classApplyDescriptorSet7(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor8(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet7(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
pluginHooks_default.getSingleton().register("afterCopyLimit");
pluginHooks_default.getSingleton().register("modifyCopyableRange");
pluginHooks_default.getSingleton().register("beforeCut");
pluginHooks_default.getSingleton().register("afterCut");
pluginHooks_default.getSingleton().register("beforePaste");
pluginHooks_default.getSingleton().register("afterPaste");
pluginHooks_default.getSingleton().register("beforeCopy");
pluginHooks_default.getSingleton().register("afterCopy");
var PLUGIN_KEY11 = "copyPaste";
var PLUGIN_PRIORITY10 = 80;
var SETTING_KEYS3 = ["fragmentSelection"];
var META_HEAD = ['<meta name="generator" content="Handsontable"/>', '<style type="text/css">td{white-space:normal}br{mso-data-placement:same-cell}</style>'].join("");
var _enableCopyColumnHeaders = /* @__PURE__ */ new WeakMap();
var _enableCopyColumnGroupHeaders = /* @__PURE__ */ new WeakMap();
var _enableCopyColumnHeadersOnly = /* @__PURE__ */ new WeakMap();
var _copyMode = /* @__PURE__ */ new WeakMap();
var _isTriggeredByCopy = /* @__PURE__ */ new WeakMap();
var _isTriggeredByCut = /* @__PURE__ */ new WeakMap();
var _copyableRangesFactory = /* @__PURE__ */ new WeakMap();
var _ensureClipboardEventsGetTriggered = /* @__PURE__ */ new WeakSet();
var _countCopiedHeaders = /* @__PURE__ */ new WeakSet();
var _addContentEditableToHighlightedCell = /* @__PURE__ */ new WeakSet();
var _removeContentEditableFromHighlightedCell = /* @__PURE__ */ new WeakSet();
var _onAfterContextMenuDefaultOptions = /* @__PURE__ */ new WeakSet();
var _onAfterSelectionEnd = /* @__PURE__ */ new WeakSet();
var _onSafariMouseEnter = /* @__PURE__ */ new WeakSet();
var _onSafariMouseLeave = /* @__PURE__ */ new WeakSet();
var _onSafariAfterSelection = /* @__PURE__ */ new WeakSet();
var CopyPaste = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec12(this, _onSafariAfterSelection);
    _classPrivateMethodInitSpec12(this, _onSafariMouseLeave);
    _classPrivateMethodInitSpec12(this, _onSafariMouseEnter);
    _classPrivateMethodInitSpec12(this, _onAfterSelectionEnd);
    _classPrivateMethodInitSpec12(this, _onAfterContextMenuDefaultOptions);
    _classPrivateMethodInitSpec12(this, _removeContentEditableFromHighlightedCell);
    _classPrivateMethodInitSpec12(this, _addContentEditableToHighlightedCell);
    _classPrivateMethodInitSpec12(this, _countCopiedHeaders);
    _classPrivateMethodInitSpec12(this, _ensureClipboardEventsGetTriggered);
    _defineProperty21(this, "columnsLimit", Infinity);
    _defineProperty21(this, "rowsLimit", Infinity);
    _defineProperty21(this, "pasteMode", "overwrite");
    _defineProperty21(this, "uiContainer", this.hot.rootDocument.body);
    _classPrivateFieldInitSpec8(this, _enableCopyColumnHeaders, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _enableCopyColumnGroupHeaders, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _enableCopyColumnHeadersOnly, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _copyMode, {
      writable: true,
      value: "cells-only"
    });
    _classPrivateFieldInitSpec8(this, _isTriggeredByCopy, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _isTriggeredByCut, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec8(this, _copyableRangesFactory, {
      writable: true,
      value: new CopyableRangesFactory({
        countRows: () => this.hot.countRows(),
        countColumns: () => this.hot.countCols(),
        rowsLimit: () => this.rowsLimit,
        columnsLimit: () => this.columnsLimit,
        countColumnHeaders: () => this.hot.view.getColumnHeadersCount()
      })
    });
    _defineProperty21(this, "copyableRanges", []);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY11;
  }
  static get SETTING_KEYS() {
    return [PLUGIN_KEY11, ...SETTING_KEYS3];
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY10;
  }
  /**
   * Checks if the [`CopyPaste`](#copypaste) plugin is enabled.
   *
   * This method gets called by Handsontable's [`beforeInit`](@/api/hooks.md#beforeinit) hook.
   * If it returns `true`, the [`enablePlugin()`](#enableplugin) method gets called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY11];
  }
  /**
   * Enables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const {
      [PLUGIN_KEY11]: settings
    } = this.hot.getSettings();
    if (typeof settings === "object") {
      var _settings$pasteMode, _settings$uiContainer;
      this.pasteMode = (_settings$pasteMode = settings.pasteMode) !== null && _settings$pasteMode !== void 0 ? _settings$pasteMode : this.pasteMode;
      this.rowsLimit = isNaN(settings.rowsLimit) ? this.rowsLimit : settings.rowsLimit;
      this.columnsLimit = isNaN(settings.columnsLimit) ? this.columnsLimit : settings.columnsLimit;
      _classPrivateFieldSet7(this, _enableCopyColumnHeaders, !!settings.copyColumnHeaders);
      _classPrivateFieldSet7(this, _enableCopyColumnGroupHeaders, !!settings.copyColumnGroupHeaders);
      _classPrivateFieldSet7(this, _enableCopyColumnHeadersOnly, !!settings.copyColumnHeadersOnly);
      this.uiContainer = (_settings$uiContainer = settings.uiContainer) !== null && _settings$uiContainer !== void 0 ? _settings$uiContainer : this.uiContainer;
    }
    this.addHook("afterContextMenuDefaultOptions", (options) => _classPrivateMethodGet12(this, _onAfterContextMenuDefaultOptions, _onAfterContextMenuDefaultOptions2).call(this, options));
    this.addHook("afterSelectionEnd", () => _classPrivateMethodGet12(this, _onAfterSelectionEnd, _onAfterSelectionEnd2).call(this));
    this.eventManager.addEventListener(this.hot.rootDocument, "copy", function() {
      return _this.onCopy(...arguments);
    });
    this.eventManager.addEventListener(this.hot.rootDocument, "cut", function() {
      return _this.onCut(...arguments);
    });
    this.eventManager.addEventListener(this.hot.rootDocument, "paste", function() {
      return _this.onPaste(...arguments);
    });
    if (isSafari()) {
      this.eventManager.addEventListener(this.hot.rootDocument.body, "mouseenter", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _classPrivateMethodGet12(_this, _onSafariMouseEnter, _onSafariMouseEnter2).call(_this, ...args);
      });
      this.eventManager.addEventListener(this.hot.rootDocument.body, "mouseleave", function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return _classPrivateMethodGet12(_this, _onSafariMouseLeave, _onSafariMouseLeave2).call(_this, ...args);
      });
      this.addHook("afterSelection", () => _classPrivateMethodGet12(this, _onSafariAfterSelection, _onSafariAfterSelection2).call(this));
    }
    super.enablePlugin();
  }
  /**
   * Updates the state of the [`CopyPaste`](#copypaste) plugin.
   *
   * Gets called when [`updateSettings()`](@/api/core.md#updatesettings)
   * is invoked with any of the following configuration options:
   *  - [`copyPaste`](@/api/options.md#copypaste)
   *  - [`fragmentSelection`](@/api/options.md#fragmentselection)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the [`CopyPaste`](#copypaste) plugin for your Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
  }
  /**
   * Copies the contents of the selected cells (and/or their related column headers) to the system clipboard.
   *
   * Takes an optional parameter (`copyMode`) that defines the scope of copying:
   *
   * | `copyMode` value              | Description                                                     |
   * | ----------------------------- | --------------------------------------------------------------- |
   * | `'cells-only'` (default)      | Copy the selected cells                                         |
   * | `'with-column-headers'`       | - Copy the selected cells<br>- Copy the nearest column headers  |
   * | `'with-column-group-headers'` | - Copy the selected cells<br>- Copy all related columns headers |
   * | `'column-headers-only'`       | Copy the nearest column headers (without copying cells)         |
   *
   * @param {string} [copyMode='cells-only'] Copy mode.
   */
  copy() {
    let copyMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "cells-only";
    _classPrivateFieldSet7(this, _copyMode, copyMode);
    _classPrivateFieldSet7(this, _isTriggeredByCopy, true);
    _classPrivateMethodGet12(this, _ensureClipboardEventsGetTriggered, _ensureClipboardEventsGetTriggered2).call(this, "copy");
  }
  /**
   * Copies the contents of the selected cells.
   */
  copyCellsOnly() {
    this.copy("cells-only");
  }
  /**
   * Copies the contents of column headers that are nearest to the selected cells.
   */
  copyColumnHeadersOnly() {
    this.copy("column-headers-only");
  }
  /**
   * Copies the contents of the selected cells and all their related column headers.
   */
  copyWithAllColumnHeaders() {
    this.copy("with-column-group-headers");
  }
  /**
   * Copies the contents of the selected cells and their nearest column headers.
   */
  copyWithColumnHeaders() {
    this.copy("with-column-headers");
  }
  /**
   * Cuts the contents of the selected cells to the system clipboard.
   */
  cut() {
    _classPrivateFieldSet7(this, _isTriggeredByCut, true);
    _classPrivateMethodGet12(this, _ensureClipboardEventsGetTriggered, _ensureClipboardEventsGetTriggered2).call(this, "cut");
  }
  /**
   * Converts the contents of multiple ranges (`ranges`) into a single string.
   *
   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `endRow`, `startCol` and `endCol`.
   * @returns {string} A string that will be copied to the clipboard.
   */
  getRangedCopyableData(ranges) {
    return stringify2(this.getRangedData(ranges));
  }
  /**
   * Converts the contents of multiple ranges (`ranges`) into an array of arrays.
   *
   * @param {Array<{startRow: number, startCol: number, endRow: number, endCol: number}>} ranges Array of objects with properties `startRow`, `startCol`, `endRow` and `endCol`.
   * @returns {Array[]} An array of arrays that will be copied to the clipboard.
   */
  getRangedData(ranges) {
    const data = [];
    const {
      rows,
      columns
    } = normalizeRanges(ranges);
    arrayEach(rows, (row) => {
      const rowSet = [];
      arrayEach(columns, (column) => {
        if (row < 0) {
          rowSet.push(this.hot.getColHeader(column, row));
        } else {
          rowSet.push(this.hot.getCopyableData(row, column));
        }
      });
      data.push(rowSet);
    });
    return data;
  }
  /**
   * Simulates the paste action.
   *
   * For security reasons, modern browsers don't allow reading from the system clipboard.
   *
   * @param {string} pastableText The value to paste, as a raw string.
   * @param {string} [pastableHtml=''] The value to paste, as HTML.
   */
  paste() {
    let pastableText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let pastableHtml = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pastableText;
    if (!pastableText && !pastableHtml) {
      return;
    }
    const pasteData = new PasteEvent();
    if (pastableText) {
      pasteData.clipboardData.setData("text/plain", pastableText);
    }
    if (pastableHtml) {
      pasteData.clipboardData.setData("text/html", pastableHtml);
    }
    this.onPaste(pasteData);
  }
  /**
   * Prepares copyable text from the cells selection in the invisible textarea.
   */
  setCopyableText() {
    const selectionRange = this.hot.getSelectedRangeLast();
    if (!selectionRange) {
      return;
    }
    if (selectionRange.isSingleHeader()) {
      this.copyableRanges = [];
      return;
    }
    _classPrivateFieldGet8(this, _copyableRangesFactory).setSelectedRange(selectionRange);
    const groupedRanges = /* @__PURE__ */ new Map([["headers", null], ["cells", null]]);
    if (_classPrivateFieldGet8(this, _copyMode) === "column-headers-only") {
      groupedRanges.set("headers", _classPrivateFieldGet8(this, _copyableRangesFactory).getMostBottomColumnHeadersRange());
    } else {
      if (_classPrivateFieldGet8(this, _copyMode) === "with-column-headers") {
        groupedRanges.set("headers", _classPrivateFieldGet8(this, _copyableRangesFactory).getMostBottomColumnHeadersRange());
      } else if (_classPrivateFieldGet8(this, _copyMode) === "with-column-group-headers") {
        groupedRanges.set("headers", _classPrivateFieldGet8(this, _copyableRangesFactory).getAllColumnHeadersRange());
      }
      groupedRanges.set("cells", _classPrivateFieldGet8(this, _copyableRangesFactory).getCellsRange());
    }
    this.copyableRanges = Array.from(groupedRanges.values()).filter((range) => range !== null).map((_ref) => {
      let {
        startRow,
        startCol,
        endRow,
        endCol
      } = _ref;
      return {
        startRow,
        startCol,
        endRow,
        endCol
      };
    });
    this.copyableRanges = this.hot.runHooks("modifyCopyableRange", this.copyableRanges);
    const cellsRange = groupedRanges.get("cells");
    if (cellsRange !== null && cellsRange.isRangeTrimmed) {
      const {
        startRow,
        startCol,
        endRow,
        endCol
      } = cellsRange;
      this.hot.runHooks("afterCopyLimit", endRow - startRow + 1, endCol - startCol + 1, this.rowsLimit, this.columnsLimit);
    }
  }
  /**
   * Verifies if editor exists and is open.
   *
   * @private
   * @returns {boolean}
   */
  isEditorOpened() {
    var _this$hot$getActiveEd;
    return (_this$hot$getActiveEd = this.hot.getActiveEditor()) === null || _this$hot$getActiveEd === void 0 ? void 0 : _this$hot$getActiveEd.isOpened();
  }
  /**
   * Prepares new values to populate them into datasource.
   *
   * @private
   * @param {Array} inputArray An array of the data to populate.
   * @param {Array} [selection] The selection which indicates from what position the data will be populated.
   * @returns {Array} Range coordinates after populate data.
   */
  populateValues(inputArray) {
    let selection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.hot.getSelectedRangeLast();
    if (!inputArray.length) {
      return;
    }
    const populatedRowsLength = inputArray.length;
    const populatedColumnsLength = inputArray[0].length;
    const newRows = [];
    const {
      row: startRow,
      col: startColumn
    } = selection.getTopStartCorner();
    const {
      row: endRowFromSelection,
      col: endColumnFromSelection
    } = selection.getBottomEndCorner();
    let visualRowForPopulatedData = startRow;
    let visualColumnForPopulatedData = startColumn;
    let lastVisualRow = startRow;
    let lastVisualColumn = startColumn;
    while (newRows.length < populatedRowsLength || visualRowForPopulatedData <= endRowFromSelection) {
      const {
        skipRowOnPaste,
        visualRow
      } = this.hot.getCellMeta(visualRowForPopulatedData, startColumn);
      visualRowForPopulatedData = visualRow + 1;
      if (skipRowOnPaste === true) {
        continue;
      }
      lastVisualRow = visualRow;
      visualColumnForPopulatedData = startColumn;
      const newRow = [];
      const insertedRow = newRows.length % populatedRowsLength;
      while (newRow.length < populatedColumnsLength || visualColumnForPopulatedData <= endColumnFromSelection) {
        const {
          skipColumnOnPaste,
          visualCol
        } = this.hot.getCellMeta(startRow, visualColumnForPopulatedData);
        visualColumnForPopulatedData = visualCol + 1;
        if (skipColumnOnPaste === true) {
          continue;
        }
        lastVisualColumn = visualCol;
        const insertedColumn = newRow.length % populatedColumnsLength;
        newRow.push(inputArray[insertedRow][insertedColumn]);
      }
      newRows.push(newRow);
    }
    this.hot.populateFromArray(startRow, startColumn, newRows, void 0, void 0, "CopyPaste.paste", this.pasteMode);
    return [startRow, startColumn, lastVisualRow, lastVisualColumn];
  }
  /**
   * `copy` event callback on textarea element.
   *
   * @param {Event} event ClipboardEvent.
   * @private
   */
  onCopy(event) {
    if (!this.hot.isListening() && !_classPrivateFieldGet8(this, _isTriggeredByCopy) || this.isEditorOpened()) {
      return;
    }
    this.setCopyableText();
    _classPrivateFieldSet7(this, _isTriggeredByCopy, false);
    const data = this.getRangedData(this.copyableRanges);
    const copiedHeadersCount = _classPrivateMethodGet12(this, _countCopiedHeaders, _countCopiedHeaders2).call(this, this.copyableRanges);
    const allowCopying = !!this.hot.runHooks("beforeCopy", data, this.copyableRanges, copiedHeadersCount);
    if (allowCopying) {
      const textPlain = stringify2(data);
      if (event && event.clipboardData) {
        const textHTML = _dataToHTML(data, this.hot.rootDocument);
        event.clipboardData.setData("text/plain", textPlain);
        event.clipboardData.setData("text/html", [META_HEAD, textHTML].join(""));
      } else if (typeof ClipboardEvent === "undefined") {
        this.hot.rootWindow.clipboardData.setData("Text", textPlain);
      }
      this.hot.runHooks("afterCopy", data, this.copyableRanges, copiedHeadersCount);
    }
    _classPrivateFieldSet7(this, _copyMode, "cells-only");
    event.preventDefault();
  }
  /**
   * `cut` event callback on textarea element.
   *
   * @param {Event} event ClipboardEvent.
   * @private
   */
  onCut(event) {
    if (!this.hot.isListening() && !_classPrivateFieldGet8(this, _isTriggeredByCut) || this.isEditorOpened()) {
      return;
    }
    this.setCopyableText();
    _classPrivateFieldSet7(this, _isTriggeredByCut, false);
    const rangedData = this.getRangedData(this.copyableRanges);
    const allowCuttingOut = !!this.hot.runHooks("beforeCut", rangedData, this.copyableRanges);
    if (allowCuttingOut) {
      const textPlain = stringify2(rangedData);
      if (event && event.clipboardData) {
        const textHTML = _dataToHTML(rangedData, this.hot.rootDocument);
        event.clipboardData.setData("text/plain", textPlain);
        event.clipboardData.setData("text/html", [META_HEAD, textHTML].join(""));
      } else if (typeof ClipboardEvent === "undefined") {
        this.hot.rootWindow.clipboardData.setData("Text", textPlain);
      }
      this.hot.emptySelectedCells("CopyPaste.cut");
      this.hot.runHooks("afterCut", rangedData, this.copyableRanges);
    }
    event.preventDefault();
  }
  /**
   * `paste` event callback on textarea element.
   *
   * @param {Event} event ClipboardEvent or pseudo ClipboardEvent, if paste was called manually.
   * @private
   */
  onPaste(event) {
    if (!this.hot.isListening() || this.isEditorOpened() || !this.hot.getSelected()) {
      return;
    }
    if (event && event.preventDefault) {
      event.preventDefault();
    }
    let pastedData;
    if (event && typeof event.clipboardData !== "undefined") {
      const textHTML = sanitize(event.clipboardData.getData("text/html"), {
        ADD_TAGS: ["meta"],
        ADD_ATTR: ["content"],
        FORCE_BODY: true
      });
      if (textHTML && /(<table)|(<TABLE)/g.test(textHTML)) {
        const parsedConfig = htmlToGridSettings(textHTML, this.hot.rootDocument);
        pastedData = parsedConfig.data;
      } else {
        pastedData = event.clipboardData.getData("text/plain");
      }
    } else if (typeof ClipboardEvent === "undefined" && typeof this.hot.rootWindow.clipboardData !== "undefined") {
      pastedData = this.hot.rootWindow.clipboardData.getData("Text");
    }
    if (typeof pastedData === "string") {
      pastedData = parse(pastedData);
    }
    if (pastedData === void 0 || pastedData && pastedData.length === 0) {
      return;
    }
    if (this.hot.runHooks("beforePaste", pastedData, this.copyableRanges) === false) {
      return;
    }
    const [startRow, startColumn, endRow, endColumn] = this.populateValues(pastedData);
    this.hot.selectCell(startRow, startColumn, Math.min(this.hot.countRows() - 1, endRow), Math.min(this.hot.countCols() - 1, endColumn));
    this.hot.runHooks("afterPaste", pastedData, this.copyableRanges);
  }
  /**
   * Destroys the `CopyPaste` plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _ensureClipboardEventsGetTriggered2(eventName) {
  if (isSafari()) {
    const lastSelectedRange = this.hot.getSelectedRangeLast();
    if (lastSelectedRange) {
      const {
        row: highlightRow,
        col: highlightColumn
      } = lastSelectedRange.highlight;
      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);
      if (currentlySelectedCell) {
        runWithSelectedContendEditableElement(currentlySelectedCell, () => {
          this.hot.rootDocument.execCommand(eventName);
        });
      }
    }
  } else {
    this.hot.rootDocument.execCommand(eventName);
  }
}
function _countCopiedHeaders2(ranges) {
  const {
    rows
  } = normalizeRanges(ranges);
  let columnHeadersCount = 0;
  for (let row = 0; row < rows.length; row++) {
    if (rows[row] >= 0) {
      break;
    }
    columnHeadersCount += 1;
  }
  return {
    columnHeadersCount
  };
}
function _addContentEditableToHighlightedCell2() {
  if (this.hot.isListening()) {
    const lastSelectedRange = this.hot.getSelectedRangeLast();
    if (lastSelectedRange) {
      const {
        row: highlightRow,
        col: highlightColumn
      } = lastSelectedRange.highlight;
      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);
      if (currentlySelectedCell) {
        makeElementContentEditableAndSelectItsContent(currentlySelectedCell);
      }
    }
  }
}
function _removeContentEditableFromHighlightedCell2() {
  if (this.hot.isListening()) {
    const lastSelectedRange = this.hot.getSelectedRangeLast();
    if (lastSelectedRange) {
      const {
        row: highlightRow,
        col: highlightColumn
      } = lastSelectedRange.highlight;
      const currentlySelectedCell = this.hot.getCell(highlightRow, highlightColumn, true);
      if (currentlySelectedCell !== null && currentlySelectedCell !== void 0 && currentlySelectedCell.hasAttribute("contenteditable")) {
        removeContentEditableFromElementAndDeselect(currentlySelectedCell);
      }
    }
  }
}
function _onAfterContextMenuDefaultOptions2(options) {
  options.items.push({
    name: "---------"
  }, copyItem(this));
  if (_classPrivateFieldGet8(this, _enableCopyColumnHeaders)) {
    options.items.push(copyWithColumnHeadersItem(this));
  }
  if (_classPrivateFieldGet8(this, _enableCopyColumnGroupHeaders)) {
    options.items.push(copyWithColumnGroupHeadersItem(this));
  }
  if (_classPrivateFieldGet8(this, _enableCopyColumnHeadersOnly)) {
    options.items.push(copyColumnHeadersOnlyItem(this));
  }
  options.items.push(cutItem(this));
}
function _onAfterSelectionEnd2() {
  if (this.isEditorOpened()) {
    return;
  }
  if (this.hot.getSettings().fragmentSelection) {
    return;
  }
  this.setCopyableText();
}
function _onSafariMouseEnter2() {
  _classPrivateMethodGet12(this, _removeContentEditableFromHighlightedCell, _removeContentEditableFromHighlightedCell2).call(this);
}
function _onSafariMouseLeave2() {
  _classPrivateMethodGet12(this, _addContentEditableToHighlightedCell, _addContentEditableToHighlightedCell2).call(this);
}
function _onSafariAfterSelection2() {
  _classPrivateMethodGet12(this, _removeContentEditableFromHighlightedCell, _removeContentEditableFromHighlightedCell2).call(this);
}

// node_modules/handsontable/plugins/customBorders/utils.mjs
function createId(row, col) {
  return `border_row${row}col${col}`;
}
function createDefaultCustomBorder() {
  return {
    width: 1,
    color: "#000"
  };
}
function createSingleEmptyBorder() {
  return {
    hide: true
  };
}
function createDefaultHtBorder() {
  return {
    width: 1,
    color: "#000",
    cornerVisible: false
  };
}
function normalizeBorder(border) {
  if (isDefined(border.start) || isDefined(border.left)) {
    var _border$start;
    border.start = (_border$start = border.start) !== null && _border$start !== void 0 ? _border$start : border.left;
  }
  if (isDefined(border.end) || isDefined(border.right)) {
    var _border$end;
    border.end = (_border$end = border.end) !== null && _border$end !== void 0 ? _border$end : border.right;
  }
  delete border.left;
  delete border.right;
  return border;
}
function denormalizeBorder(border) {
  if (isDefined(border.start)) {
    border.left = border.start;
  }
  if (isDefined(border.end)) {
    border.right = border.end;
  }
  return border;
}
function createEmptyBorders(row, col) {
  return {
    id: createId(row, col),
    border: createDefaultHtBorder(),
    row,
    col,
    top: createSingleEmptyBorder(),
    bottom: createSingleEmptyBorder(),
    start: createSingleEmptyBorder(),
    end: createSingleEmptyBorder()
  };
}
function extendDefaultBorder(defaultBorder, customBorder) {
  if (hasOwnProperty(customBorder, "border") && customBorder.border) {
    defaultBorder.border = customBorder.border;
  }
  if (hasOwnProperty(customBorder, "top") && isDefined(customBorder.top)) {
    if (customBorder.top) {
      if (!isObject(customBorder.top)) {
        customBorder.top = createDefaultCustomBorder();
      }
      defaultBorder.top = customBorder.top;
    } else {
      customBorder.top = createSingleEmptyBorder();
      defaultBorder.top = customBorder.top;
    }
  }
  if (hasOwnProperty(customBorder, "bottom") && isDefined(customBorder.bottom)) {
    if (customBorder.bottom) {
      if (!isObject(customBorder.bottom)) {
        customBorder.bottom = createDefaultCustomBorder();
      }
      defaultBorder.bottom = customBorder.bottom;
    } else {
      customBorder.bottom = createSingleEmptyBorder();
      defaultBorder.bottom = customBorder.bottom;
    }
  }
  if (hasOwnProperty(customBorder, "start") && isDefined(customBorder.start)) {
    if (customBorder.start) {
      if (!isObject(customBorder.start)) {
        customBorder.start = createDefaultCustomBorder();
      }
      defaultBorder.start = customBorder.start;
    } else {
      customBorder.start = createSingleEmptyBorder();
      defaultBorder.start = customBorder.start;
    }
  }
  if (hasOwnProperty(customBorder, "end") && isDefined(customBorder.end)) {
    if (customBorder.end) {
      if (!isObject(customBorder.end)) {
        customBorder.end = createDefaultCustomBorder();
      }
      defaultBorder.end = customBorder.end;
    } else {
      customBorder.end = createSingleEmptyBorder();
      defaultBorder.end = customBorder.end;
    }
  }
  return defaultBorder;
}
function checkSelectionBorders(hot, direction) {
  let atLeastOneHasBorder = false;
  arrayEach(hot.getSelectedRange(), (range) => {
    range.forAll((r, c) => {
      if (r < 0 || c < 0) {
        return;
      }
      const metaBorders = hot.getCellMeta(r, c).borders;
      if (metaBorders) {
        if (direction) {
          if (!hasOwnProperty(metaBorders[direction], "hide") || metaBorders[direction].hide === false) {
            atLeastOneHasBorder = true;
            return false;
          }
        } else {
          atLeastOneHasBorder = true;
          return false;
        }
      }
    });
  });
  return atLeastOneHasBorder;
}
function markSelected(label) {
  return `<span class="selected">${String.fromCharCode(10003)}</span>${label}`;
}
function hasLeftRightTypeOptions(borders) {
  return borders.some((border) => isDefined(border.left) || isDefined(border.right));
}
function hasStartEndTypeOptions(borders) {
  return borders.some((border) => isDefined(border.start) || isDefined(border.end));
}
var physicalToInlinePropNames = /* @__PURE__ */ new Map([["left", "start"], ["right", "end"]]);
function toInlinePropName(propName) {
  var _physicalToInlineProp;
  return (_physicalToInlineProp = physicalToInlinePropNames.get(propName)) !== null && _physicalToInlineProp !== void 0 ? _physicalToInlineProp : propName;
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/bottom.mjs
function bottom(customBordersPlugin) {
  return {
    key: "borders:bottom",
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_BOTTOM);
      const hasBorder = checkSelectionBorders(this, "bottom");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback(key, selected) {
      const hasBorder = checkSelectionBorders(this, "bottom");
      customBordersPlugin.prepareBorder(selected, "bottom", hasBorder);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/left.mjs
function left(customBordersPlugin) {
  const borderDirection = customBordersPlugin.hot.isRtl() ? "end" : "start";
  return {
    key: "borders:left",
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_LEFT);
      const hasBorder = checkSelectionBorders(this, borderDirection);
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback(key, selected) {
      const hasBorder = checkSelectionBorders(this, borderDirection);
      customBordersPlugin.prepareBorder(selected, borderDirection, hasBorder);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/noBorders.mjs
function noBorders(customBordersPlugin) {
  return {
    key: "borders:no_borders",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_REMOVE_BORDERS);
    },
    callback(key, selected) {
      customBordersPlugin.prepareBorder(selected, "noBorders");
    },
    disabled() {
      return !checkSelectionBorders(this);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/right.mjs
function right(customBordersPlugin) {
  const borderDirection = customBordersPlugin.hot.isRtl() ? "start" : "end";
  return {
    key: "borders:right",
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_RIGHT);
      const hasBorder = checkSelectionBorders(this, borderDirection);
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback(key, selected) {
      const hasBorder = checkSelectionBorders(this, borderDirection);
      customBordersPlugin.prepareBorder(selected, borderDirection, hasBorder);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/contextMenuItem/top.mjs
function top(customBordersPlugin) {
  return {
    key: "borders:top",
    name() {
      let label = this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS_TOP);
      const hasBorder = checkSelectionBorders(this, "top");
      if (hasBorder) {
        label = markSelected(label);
      }
      return label;
    },
    callback(key, selected) {
      const hasBorder = checkSelectionBorders(this, "top");
      customBordersPlugin.prepareBorder(selected, "top", hasBorder);
    }
  };
}

// node_modules/handsontable/plugins/customBorders/customBorders.mjs
function _classPrivateMethodInitSpec13(obj, privateSet) {
  _checkPrivateRedeclaration15(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration15(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty22(obj, key, value) {
  key = _toPropertyKey22(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey22(arg) {
  var key = _toPrimitive22(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive22(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet13(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY12 = "customBorders";
var PLUGIN_PRIORITY11 = 90;
var _onAfterContextMenuDefaultOptions3 = /* @__PURE__ */ new WeakSet();
var _onAfterInit4 = /* @__PURE__ */ new WeakSet();
var CustomBorders = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec13(this, _onAfterInit4);
    _classPrivateMethodInitSpec13(this, _onAfterContextMenuDefaultOptions3);
    _defineProperty22(this, "savedBorders", []);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY12;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY11;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link CustomBorders#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY12];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook("afterContextMenuDefaultOptions", (options) => _classPrivateMethodGet13(this, _onAfterContextMenuDefaultOptions3, _onAfterContextMenuDefaultOptions22).call(this, options));
    this.addHook("init", () => _classPrivateMethodGet13(this, _onAfterInit4, _onAfterInit23).call(this));
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hideBorders();
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`customBorders`](@/api/options.md#customborders)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    this.changeBorderSettings();
    super.updatePlugin();
  }
  /**
   * Set custom borders.
   *
   * @example
   * ```js
   * const customBordersPlugin = hot.getPlugin('customBorders');
   *
   * // Using an array of arrays (produced by `.getSelected()` method).
   * customBordersPlugin.setBorders([[1, 1, 2, 2], [6, 2, 0, 2]], {start: {width: 2, color: 'blue'}});
   *
   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
   * //  Selecting a cell range.
   * hot.selectCell(0, 0, 2, 2);
   * // Returning selected cells' range with the getSelectedRange method.
   * customBordersPlugin.setBorders(hot.getSelectedRange(), {start: {hide: false, width: 2, color: 'blue'}});
   * ```
   *
   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
   * @param {object} borderObject Object with `top`, `right`, `bottom` and `start` properties.
   */
  setBorders(selectionRanges, borderObject) {
    let borderKeys = ["top", "bottom", "start", "end"];
    let normBorder = null;
    if (borderObject) {
      this.checkSettingsCohesion([borderObject]);
      borderKeys = Object.keys(borderObject);
      normBorder = normalizeBorder(borderObject);
    }
    const selectionType = detectSelectionType(selectionRanges);
    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {
      createCellCoords: this.hot._createCellCoords.bind(this.hot),
      createCellRange: this.hot._createCellRange.bind(this.hot)
    });
    arrayEach(selectionRanges, (selection) => {
      selectionSchemaNormalizer(selection).forAll((row, col) => {
        arrayEach(borderKeys, (borderKey) => {
          this.prepareBorderFromCustomAdded(row, col, normBorder, toInlinePropName(borderKey));
        });
      });
    });
    this.hot.view.render();
  }
  /**
   * Get custom borders.
   *
   * @example
   * ```js
   * const customBordersPlugin = hot.getPlugin('customBorders');
   *
   * // Using an array of arrays (produced by `.getSelected()` method).
   * customBordersPlugin.getBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);
   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
   * customBordersPlugin.getBorders(hot.getSelectedRange());
   * // Using without param - return all customBorders.
   * customBordersPlugin.getBorders();
   * ```
   *
   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
   * @returns {object[]} Returns array of border objects.
   */
  getBorders(selectionRanges) {
    if (!Array.isArray(selectionRanges)) {
      return this.savedBorders;
    }
    const selectionType = detectSelectionType(selectionRanges);
    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {
      createCellCoords: this.hot._createCellCoords.bind(this.hot),
      createCellRange: this.hot._createCellRange.bind(this.hot)
    });
    const selectedBorders = [];
    arrayEach(selectionRanges, (selection) => {
      selectionSchemaNormalizer(selection).forAll((row, col) => {
        arrayEach(this.savedBorders, (border) => {
          if (border.row === row && border.col === col) {
            selectedBorders.push(denormalizeBorder(border));
          }
        });
      });
    });
    return selectedBorders;
  }
  /**
   * Clear custom borders.
   *
   * @example
   * ```js
   * const customBordersPlugin = hot.getPlugin('customBorders');
   *
   * // Using an array of arrays (produced by `.getSelected()` method).
   * customBordersPlugin.clearBorders([[1, 1, 2, 2], [6, 2, 0, 2]]);
   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).
   * customBordersPlugin.clearBorders(hot.getSelectedRange());
   * // Using without param - clear all customBorders.
   * customBordersPlugin.clearBorders();
   * ```
   *
   * @param {Array[]|CellRange[]} selectionRanges Array of selection ranges.
   */
  clearBorders(selectionRanges) {
    if (selectionRanges) {
      this.setBorders(selectionRanges);
    } else {
      arrayEach(this.savedBorders, (border) => {
        this.clearBordersFromSelectionSettings(border.id);
        this.clearNullCellRange();
        this.hot.removeCellMeta(border.row, border.col, "borders");
      });
      this.savedBorders.length = 0;
    }
  }
  /**
   * Insert WalkontableSelection instance into Walkontable settings.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
   */
  insertBorderIntoSettings(border, place) {
    const hasSavedBorders = this.checkSavedBorders(border);
    if (!hasSavedBorders) {
      this.savedBorders.push(border);
    }
    const visualCellRange = this.hot._createCellRange(this.hot._createCellCoords(border.row, border.col));
    const hasCustomSelections = this.checkCustomSelections(border, visualCellRange, place);
    if (!hasCustomSelections) {
      this.hot.selection.highlight.addCustomSelection({
        border,
        visualCellRange
      });
    }
  }
  /**
   * Prepare borders from setting (single cell).
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} borderDescriptor Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.
   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
   */
  prepareBorderFromCustomAdded(row, column, borderDescriptor, place) {
    const nrOfRows = this.hot.countRows();
    const nrOfColumns = this.hot.countCols();
    if (row >= nrOfRows || column >= nrOfColumns) {
      return;
    }
    let border = createEmptyBorders(row, column);
    if (borderDescriptor) {
      border = extendDefaultBorder(border, borderDescriptor);
      arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => {
        if (border.id === customSelection.settings.id) {
          Object.assign(customSelection.settings, borderDescriptor);
          border.id = customSelection.settings.id;
          border.top = customSelection.settings.top;
          border.bottom = customSelection.settings.bottom;
          border.start = customSelection.settings.start;
          border.end = customSelection.settings.end;
          return false;
        }
      });
    }
    this.hot.setCellMeta(row, column, "borders", denormalizeBorder(border));
    this.insertBorderIntoSettings(border, place);
  }
  /**
   * Prepare borders from setting (object).
   *
   * @private
   * @param {object} range {CellRange} The CellRange object.
   * @param {object} customBorder Object with `start`, `end`, `top` and `bottom` properties.
   */
  prepareBorderFromCustomAddedRange(range, customBorder) {
    const lastRowIndex = Math.min(range.to.row, this.hot.countRows() - 1);
    const lastColumnIndex = Math.min(range.to.col, this.hot.countCols() - 1);
    rangeEach(range.from.row, lastRowIndex, (rowIndex) => {
      rangeEach(range.from.col, lastColumnIndex, (colIndex) => {
        const border = createEmptyBorders(rowIndex, colIndex);
        let add = 0;
        if (rowIndex === range.from.row) {
          if (hasOwnProperty(customBorder, "top")) {
            add += 1;
            border.top = customBorder.top;
          }
        }
        if (rowIndex === range.to.row) {
          if (hasOwnProperty(customBorder, "bottom")) {
            add += 1;
            border.bottom = customBorder.bottom;
          }
        }
        if (colIndex === range.from.col) {
          if (hasOwnProperty(customBorder, "start")) {
            add += 1;
            border.start = customBorder.start;
          }
        }
        if (colIndex === range.to.col) {
          if (hasOwnProperty(customBorder, "end")) {
            add += 1;
            border.end = customBorder.end;
          }
        }
        if (add > 0) {
          this.hot.setCellMeta(rowIndex, colIndex, "borders", denormalizeBorder(border));
          this.insertBorderIntoSettings(border);
        } else {
        }
      });
    });
  }
  /**
   * Remove border (triggered from context menu).
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   */
  removeAllBorders(row, column) {
    const borderId = createId(row, column);
    this.spliceBorder(borderId);
    this.clearBordersFromSelectionSettings(borderId);
    this.clearNullCellRange();
    this.hot.removeCellMeta(row, column, "borders");
  }
  /**
   * Set borders for each cell re. To border position.
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.
   * @param {boolean} remove True when remove borders, and false when add borders.
   */
  setBorder(row, column, place, remove) {
    let bordersMeta = this.hot.getCellMeta(row, column).borders;
    if (!bordersMeta || bordersMeta.border === void 0) {
      bordersMeta = createEmptyBorders(row, column);
    } else {
      bordersMeta = normalizeBorder(bordersMeta);
    }
    if (remove) {
      bordersMeta[place] = createSingleEmptyBorder();
      const hideCount = this.countHide(bordersMeta);
      if (hideCount === 4) {
        this.removeAllBorders(row, column);
      } else {
        const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
        if (!customSelectionsChecker) {
          this.insertBorderIntoSettings(bordersMeta);
        }
        this.hot.setCellMeta(row, column, "borders", denormalizeBorder(bordersMeta));
      }
    } else {
      bordersMeta[place] = createDefaultCustomBorder();
      const customSelectionsChecker = this.checkCustomSelectionsFromContextMenu(bordersMeta, place, remove);
      if (!customSelectionsChecker) {
        this.insertBorderIntoSettings(bordersMeta);
      }
      this.hot.setCellMeta(row, column, "borders", denormalizeBorder(bordersMeta));
    }
  }
  /**
   * Prepare borders based on cell and border position.
   *
   * @private
   * @param {CellRange[]} selected An array of CellRange objects.
   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `left`, `right` and `noBorders`.
   * @param {boolean} remove True when remove borders, and false when add borders.
   */
  prepareBorder(selected, place, remove) {
    arrayEach(selected, (_ref) => {
      let {
        start,
        end
      } = _ref;
      if (start.row === end.row && start.col === end.col) {
        if (place === "noBorders") {
          this.removeAllBorders(start.row, start.col);
        } else {
          this.setBorder(start.row, start.col, place, remove);
        }
      } else {
        switch (place) {
          case "noBorders":
            rangeEach(start.col, end.col, (colIndex) => {
              rangeEach(start.row, end.row, (rowIndex) => {
                this.removeAllBorders(rowIndex, colIndex);
              });
            });
            break;
          case "top":
            rangeEach(start.col, end.col, (topCol) => {
              this.setBorder(start.row, topCol, place, remove);
            });
            break;
          case "bottom":
            rangeEach(start.col, end.col, (bottomCol) => {
              this.setBorder(end.row, bottomCol, place, remove);
            });
            break;
          case "start":
            rangeEach(start.row, end.row, (rowStart) => {
              this.setBorder(rowStart, start.col, place, remove);
            });
            break;
          case "end":
            rangeEach(start.row, end.row, (rowEnd) => {
              this.setBorder(rowEnd, end.col, place, remove);
            });
            break;
          default:
            break;
        }
      }
    });
  }
  /**
   * Create borders from settings.
   *
   * @private
   * @param {Array} customBorders Object with `row` and `col`, `start`, `end`, `top` and `bottom` properties.
   */
  createCustomBorders(customBorders) {
    arrayEach(customBorders, (customBorder) => {
      const normCustomBorder = normalizeBorder(customBorder);
      if (customBorder.range) {
        this.prepareBorderFromCustomAddedRange(customBorder.range, normCustomBorder);
      } else {
        this.prepareBorderFromCustomAdded(customBorder.row, customBorder.col, normCustomBorder);
      }
    });
  }
  /**
   * Count hide property in border object.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   * @returns {number}
   */
  countHide(border) {
    const {
      top: top2,
      bottom: bottom2,
      start,
      end
    } = border;
    const values = [top2, bottom2, start, end];
    return arrayReduce(values, (accumulator, value) => {
      let result = accumulator;
      if (value && value.hide) {
        result += 1;
      }
      return result;
    }, 0);
  }
  /**
   * Clear borders settings from custom selections.
   *
   * @private
   * @param {string} borderId Border id name as string.
   */
  clearBordersFromSelectionSettings(borderId) {
    const index = arrayMap(this.hot.selection.highlight.customSelections, (customSelection) => customSelection.settings.id).indexOf(borderId);
    if (index > -1) {
      this.hot.selection.highlight.customSelections[index].clear();
    }
  }
  /**
   * Clear cellRange with null value.
   *
   * @private
   */
  clearNullCellRange() {
    arrayEach(this.hot.selection.highlight.customSelections, (customSelection, index) => {
      if (customSelection.cellRange === null) {
        this.hot.selection.highlight.customSelections[index].destroy();
        this.hot.selection.highlight.customSelections.splice(index, 1);
        return false;
      }
    });
  }
  /**
   * Hide custom borders.
   *
   * @private
   */
  hideBorders() {
    arrayEach(this.savedBorders, (border) => {
      this.clearBordersFromSelectionSettings(border.id);
      this.clearNullCellRange();
    });
  }
  /**
   * Splice border from savedBorders.
   *
   * @private
   * @param {string} borderId Border id name as string.
   */
  spliceBorder(borderId) {
    const index = arrayMap(this.savedBorders, (border) => border.id).indexOf(borderId);
    if (index > -1) {
      this.savedBorders.splice(index, 1);
    }
  }
  /**
   * Check if an border already exists in the savedBorders array, and if true update border in savedBorders.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   *
   * @returns {boolean}
   */
  checkSavedBorders(border) {
    let check = false;
    const hideCount = this.countHide(border);
    if (hideCount === 4) {
      this.spliceBorder(border.id);
      check = true;
    } else {
      arrayEach(this.savedBorders, (savedBorder, index) => {
        if (border.id === savedBorder.id) {
          this.savedBorders[index] = border;
          check = true;
          return false;
        }
      });
    }
    return check;
  }
  /**
   * Check if an border already exists in the customSelections, and if true call toggleHiddenClass method.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   * @param {string} place Coordinate where add/remove border - `top`, `bottom`, `start`, `end` and `noBorders`.
   * @param {boolean} remove True when remove borders, and false when add borders.
   *
   * @returns {boolean}
   */
  checkCustomSelectionsFromContextMenu(border, place, remove) {
    let check = false;
    arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => {
      if (border.id === customSelection.settings.id) {
        const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);
        arrayEach(borders, (borderObject) => {
          borderObject.toggleHiddenClass(place, remove);
        });
        check = true;
        return false;
      }
    });
    return check;
  }
  /**
   * Check if an border already exists in the customSelections, and if true reset cellRange.
   *
   * @private
   * @param {object} border Object with `row` and `col`, `start`, `end`, `top` and `bottom`, `id` and
   *                        `border` ({Object} with `color`, `width` and `cornerVisible` property) properties.
   * @param {CellRange} cellRange The selection range to check.
   * @param {string} [place] Coordinate where add/remove border - `top`, `bottom`, `start`, `end`.
   * @returns {boolean}
   */
  checkCustomSelections(border, cellRange, place) {
    const hideCount = this.countHide(border);
    let check = false;
    if (hideCount === 4) {
      this.removeAllBorders(border.row, border.col);
      check = true;
    } else {
      arrayEach(this.hot.selection.highlight.customSelections, (customSelection) => {
        if (border.id === customSelection.settings.id) {
          customSelection.visualCellRange = cellRange;
          customSelection.commit();
          if (place) {
            const borders = this.hot.view._wt.selectionManager.getBorderInstances(customSelection);
            arrayEach(borders, (borderObject) => {
              borderObject.changeBorderStyle(place, border);
            });
          }
          check = true;
          return false;
        }
      });
    }
    return check;
  }
  /**
   * Change borders from settings.
   *
   * @private
   */
  changeBorderSettings() {
    const customBorders = this.hot.getSettings()[PLUGIN_KEY12];
    if (Array.isArray(customBorders)) {
      const bordersClone = deepClone(customBorders);
      this.checkSettingsCohesion(bordersClone);
      if (!bordersClone.length) {
        this.savedBorders = bordersClone;
      }
      this.createCustomBorders(bordersClone);
    } else if (customBorders !== void 0) {
      this.createCustomBorders(this.savedBorders);
    }
  }
  /**
   * Checks the settings cohesion. The properties such like "left"/"right" are supported only
   * in the LTR mode and the "left"/"right" options can not be used together with "start"/"end" properties.
   *
   * @private
   * @param {object[]} customBorders The user defined custom border objects array.
   */
  checkSettingsCohesion(customBorders) {
    const hasLeftOrRight = hasLeftRightTypeOptions(customBorders);
    const hasStartOrEnd = hasStartEndTypeOptions(customBorders);
    if (hasLeftOrRight && hasStartOrEnd) {
      throw new Error('The "left"/"right" and "start"/"end" options should not be used together. Please use only the option "start"/"end".');
    }
    if (this.hot.isRtl() && hasLeftOrRight) {
      throw new Error('The "left"/"right" properties are not supported for RTL. Please use option "start"/"end".');
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _onAfterContextMenuDefaultOptions22(defaultOptions) {
  if (!this.hot.getSettings()[PLUGIN_KEY12]) {
    return;
  }
  defaultOptions.items.push({
    name: "---------"
  }, {
    key: "borders",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_BORDERS);
    },
    disabled() {
      const range = this.getSelectedRangeLast();
      if (!range) {
        return true;
      }
      if (range.isSingleHeader()) {
        return true;
      }
      return this.selection.isSelectedByCorner();
    },
    submenu: {
      items: [top(this), right(this), bottom(this), left(this), noBorders(this)]
    }
  });
}
function _onAfterInit23() {
  this.changeBorderSettings();
}

// node_modules/handsontable/plugins/dragToScroll/dragToScroll.mjs
function _classPrivateMethodInitSpec14(obj, privateSet) {
  _checkPrivateRedeclaration16(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration16(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty23(obj, key, value) {
  key = _toPropertyKey23(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey23(arg) {
  var key = _toPrimitive23(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive23(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet14(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY13 = "dragToScroll";
var PLUGIN_PRIORITY12 = 100;
var _setupListening = /* @__PURE__ */ new WeakSet();
var DragToScroll = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec14(this, _setupListening);
    _defineProperty23(this, "boundaries", null);
    _defineProperty23(this, "callback", null);
    _defineProperty23(this, "listening", false);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY13;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY12;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link DragToScroll#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY13];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook("afterOnCellMouseDown", (event) => _classPrivateMethodGet14(this, _setupListening, _setupListening2).call(this, event));
    this.addHook("afterOnCellCornerMouseDown", (event) => _classPrivateMethodGet14(this, _setupListening, _setupListening2).call(this, event));
    this.registerEvents();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`dragToScroll`](@/api/options.md#dragtoscroll)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.unregisterEvents();
    super.disablePlugin();
  }
  /**
   * Sets the value of the visible element.
   *
   * @param {DOMRect} boundaries An object with coordinates compatible with DOMRect.
   */
  setBoundaries(boundaries) {
    this.boundaries = boundaries;
  }
  /**
   * Changes callback function.
   *
   * @param {Function} callback The callback function.
   */
  setCallback(callback) {
    this.callback = callback;
  }
  /**
   * Checks if the mouse position (X, Y) is outside of the viewport and fires a callback with calculated X an Y diffs
   * between passed boundaries.
   *
   * @param {number} x Mouse X coordinate to check.
   * @param {number} y Mouse Y coordinate to check.
   */
  check(x, y) {
    let diffX = 0;
    let diffY = 0;
    if (y < this.boundaries.top) {
      diffY = y - this.boundaries.top;
    } else if (y > this.boundaries.bottom) {
      diffY = y - this.boundaries.bottom;
    }
    if (x < this.boundaries.left) {
      diffX = x - this.boundaries.left;
    } else if (x > this.boundaries.right) {
      diffX = x - this.boundaries.right;
    }
    this.callback(diffX, diffY);
  }
  /**
   * Enables listening on `mousemove` event.
   *
   * @private
   */
  listen() {
    this.listening = true;
  }
  /**
   * Disables listening on `mousemove` event.
   *
   * @private
   */
  unlisten() {
    this.listening = false;
  }
  /**
   * Returns current state of listening.
   *
   * @private
   * @returns {boolean}
   */
  isListening() {
    return this.listening;
  }
  /**
   * Registers dom listeners.
   *
   * @private
   */
  registerEvents() {
    const {
      rootWindow
    } = this.hot;
    let frame = rootWindow;
    while (frame) {
      this.eventManager.addEventListener(frame.document, "contextmenu", () => this.unlisten());
      this.eventManager.addEventListener(frame.document, "mouseup", () => this.unlisten());
      this.eventManager.addEventListener(frame.document, "mousemove", (event) => this.onMouseMove(event));
      frame = getParentWindow(frame);
    }
  }
  /**
   * Unbinds the events used by the plugin.
   *
   * @private
   */
  unregisterEvents() {
    this.eventManager.clear();
  }
  /**
   * 'mouseMove' event callback.
   *
   * @private
   * @param {MouseEvent} event `mousemove` event properties.
   */
  onMouseMove(event) {
    if (!this.isListening()) {
      return;
    }
    this.check(event.clientX, event.clientY);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _setupListening2(event) {
  if (isRightClick(event)) {
    return;
  }
  const scrollHandler = this.hot.view._wt.wtTable.holder;
  if (scrollHandler === this.hot.rootWindow) {
    return;
  }
  this.setBoundaries(scrollHandler.getBoundingClientRect());
  this.setCallback((scrollX, scrollY) => {
    if (scrollX < 0) {
      scrollHandler.scrollLeft -= 50;
    } else if (scrollX > 0) {
      scrollHandler.scrollLeft += 50;
    }
    if (scrollY < 0) {
      scrollHandler.scrollTop -= 20;
    } else if (scrollY > 0) {
      scrollHandler.scrollTop += 20;
    }
  });
  this.listen();
}

// node_modules/handsontable/plugins/dropdownMenu/dropdownMenu.mjs
function _classPrivateMethodInitSpec15(obj, privateSet) {
  _checkPrivateRedeclaration17(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration17(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty24(obj, key, value) {
  key = _toPropertyKey24(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey24(arg) {
  var key = _toPrimitive24(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive24(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet15(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
pluginHooks_default.getSingleton().register("afterDropdownMenuDefaultOptions");
pluginHooks_default.getSingleton().register("beforeDropdownMenuShow");
pluginHooks_default.getSingleton().register("afterDropdownMenuShow");
pluginHooks_default.getSingleton().register("afterDropdownMenuHide");
pluginHooks_default.getSingleton().register("afterDropdownMenuExecute");
var PLUGIN_KEY14 = "dropdownMenu";
var PLUGIN_PRIORITY13 = 230;
var BUTTON_CLASS_NAME = "changeType";
var SHORTCUTS_GROUP6 = PLUGIN_KEY14;
var _addCustomShortcuts = /* @__PURE__ */ new WeakSet();
var _onTableClick = /* @__PURE__ */ new WeakSet();
var _onAfterGetColHeader4 = /* @__PURE__ */ new WeakSet();
var _onMenuBeforeOpen3 = /* @__PURE__ */ new WeakSet();
var _onMenuAfterOpen3 = /* @__PURE__ */ new WeakSet();
var _onSubMenuAfterOpen = /* @__PURE__ */ new WeakSet();
var _onMenuAfterClose3 = /* @__PURE__ */ new WeakSet();
var DropdownMenu = class _DropdownMenu extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY14;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY13;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:AutoColumnSize"];
  }
  /**
   * Default menu items order when `dropdownMenu` is enabled by setting the config item to `true`.
   *
   * @returns {Array}
   */
  static get DEFAULT_ITEMS() {
    return [KEY4, KEY5, KEY, KEY8, KEY, KEY3, KEY, KEY6, KEY, KEY2];
  }
  /**
   * Instance of {@link CommandExecutor}.
   *
   * @private
   * @type {CommandExecutor}
   */
  constructor(hotInstance) {
    super(hotInstance);
    _classPrivateMethodInitSpec15(this, _onMenuAfterClose3);
    _classPrivateMethodInitSpec15(this, _onSubMenuAfterOpen);
    _classPrivateMethodInitSpec15(this, _onMenuAfterOpen3);
    _classPrivateMethodInitSpec15(this, _onMenuBeforeOpen3);
    _classPrivateMethodInitSpec15(this, _onAfterGetColHeader4);
    _classPrivateMethodInitSpec15(this, _onTableClick);
    _classPrivateMethodInitSpec15(this, _addCustomShortcuts);
    _defineProperty24(this, "commandExecutor", new CommandExecutor(this.hot));
    _defineProperty24(this, "itemsFactory", null);
    _defineProperty24(this, "menu", null);
    this.hot.addHook("afterGetColHeader", (col, TH) => _classPrivateMethodGet15(this, _onAfterGetColHeader4, _onAfterGetColHeader23).call(this, col, TH));
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link DropdownMenu#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY14];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   *
   * @fires Hooks#afterDropdownMenuDefaultOptions
   * @fires Hooks#beforeDropdownMenuSetItems
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.itemsFactory = new ItemsFactory(this.hot, _DropdownMenu.DEFAULT_ITEMS);
    const settings = this.hot.getSettings()[PLUGIN_KEY14];
    const predefinedItems2 = {
      items: this.itemsFactory.getItems(settings)
    };
    this.registerEvents();
    if (typeof settings.callback === "function") {
      this.commandExecutor.setCommonCallback(settings.callback);
    }
    this.registerShortcuts();
    super.enablePlugin();
    this.callOnPluginsReady(() => {
      this.hot.runHooks("afterDropdownMenuDefaultOptions", predefinedItems2);
      this.itemsFactory.setPredefinedItems(predefinedItems2.items);
      const menuItems = this.itemsFactory.getItems(settings);
      if (this.menu) {
        this.menu.destroy();
      }
      this.menu = new Menu(this.hot, {
        className: "htDropdownMenu",
        keepInViewport: true,
        container: settings.uiContainer || this.hot.rootDocument.body
      });
      this.hot.runHooks("beforeDropdownMenuSetItems", menuItems);
      this.menu.setMenuItems(menuItems);
      this.menu.addLocalHook("beforeOpen", () => _classPrivateMethodGet15(this, _onMenuBeforeOpen3, _onMenuBeforeOpen22).call(this));
      this.menu.addLocalHook("afterOpen", () => _classPrivateMethodGet15(this, _onMenuAfterOpen3, _onMenuAfterOpen22).call(this));
      this.menu.addLocalHook("afterSubmenuOpen", (subMenuInstance) => _classPrivateMethodGet15(this, _onSubMenuAfterOpen, _onSubMenuAfterOpen2).call(this, subMenuInstance));
      this.menu.addLocalHook("afterClose", () => _classPrivateMethodGet15(this, _onMenuAfterClose3, _onMenuAfterClose22).call(this));
      this.menu.addLocalHook("executeCommand", function() {
        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }
        return _this.executeCommand.call(_this, ...params);
      });
      arrayEach(menuItems, (command) => this.commandExecutor.registerCommand(command.key, command));
    });
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`dropdownMenu`](@/api/options.md#dropdownmenu)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
    }
    this.unregisterShortcuts();
    super.disablePlugin();
  }
  /**
   * Register shortcuts responsible for toggling dropdown menu.
   *
   * @private
   */
  registerShortcuts() {
    const gridContext = this.hot.getShortcutManager().getContext("grid");
    const callback = () => {
      const {
        highlight
      } = this.hot.getSelectedRangeLast();
      if ((highlight.isHeader() && highlight.row === -1 || highlight.isCell()) && highlight.col >= 0) {
        this.hot.selectColumns(highlight.col, highlight.col, -1);
        const {
          from
        } = this.hot.getSelectedRangeLast();
        const offset2 = getDocumentOffsetByElement(this.menu.container, this.hot.rootDocument);
        const target = this.hot.getCell(-1, from.col, true);
        const rect = target.getBoundingClientRect();
        this.open({
          left: rect.left + offset2.left,
          top: rect.top + target.offsetHeight + offset2.top
        }, {
          left: rect.width
        });
        this.menu.getNavigator().toFirstItem();
      }
    };
    gridContext.addShortcuts([{
      keys: [["Shift", "Alt", "ArrowDown"], ["Control/Meta", "Enter"]],
      callback,
      runOnlyIf: () => {
        var _this$hot$getSelected;
        const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
        return highlight && this.hot.selection.isCellVisible(highlight) && highlight.isHeader() && !this.menu.isOpened();
      },
      captureCtrl: true,
      group: SHORTCUTS_GROUP6
    }, {
      keys: [["Shift", "Alt", "ArrowDown"]],
      callback,
      runOnlyIf: () => {
        var _this$hot$getSelected2;
        const highlight = (_this$hot$getSelected2 = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected2 === void 0 ? void 0 : _this$hot$getSelected2.highlight;
        return highlight && this.hot.selection.isCellVisible(highlight) && highlight.isCell() && !this.menu.isOpened();
      },
      group: SHORTCUTS_GROUP6
    }]);
  }
  /**
   * Unregister shortcuts responsible for toggling dropdown menu.
   *
   * @private
   */
  unregisterShortcuts() {
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP6);
  }
  /**
   * Registers the DOM listeners.
   *
   * @private
   */
  registerEvents() {
    this.eventManager.addEventListener(this.hot.rootElement, "click", (event) => _classPrivateMethodGet15(this, _onTableClick, _onTableClick2).call(this, event));
  }
  /**
   * Opens menu and re-position it based on the passed coordinates.
   *
   * @param {{ top: number, left: number }|Event} position An object with `top` and `left` properties
   * which contains coordinates relative to the browsers viewport (without included scroll offsets).
   * Or if the native event is passed the menu will be positioned based on the `pageX` and `pageY`
   * coordinates.
   * @param {{ above: number, below: number, left: number, right: number }} offset An object allows applying
   * the offset to the menu position.
   * @fires Hooks#beforeDropdownMenuShow
   * @fires Hooks#afterDropdownMenuShow
   */
  open(position) {
    var _this$menu;
    let offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      above: 0,
      below: 0,
      left: 0,
      right: 0
    };
    if ((_this$menu = this.menu) !== null && _this$menu !== void 0 && _this$menu.isOpened()) {
      return;
    }
    this.menu.open();
    objectEach(offset2, (value, key) => {
      this.menu.setOffset(key, value);
    });
    this.menu.setPosition(position);
  }
  /**
   * Closes dropdown menu.
   */
  close() {
    var _this$menu2;
    (_this$menu2 = this.menu) === null || _this$menu2 === void 0 || _this$menu2.close();
  }
  /**
   * Executes context menu command.
   *
   * The `executeCommand()` method works only for selected cells.
   *
   * When no cells are selected, `executeCommand()` doesn't do anything.
   *
   * You can execute all predefined commands:
   *  * `'row_above'` - Insert row above
   *  * `'row_below'` - Insert row below
   *  * `'col_left'` - Insert column left
   *  * `'col_right'` - Insert column right
   *  * `'clear_column'` - Clear selected column
   *  * `'remove_row'` - Remove row
   *  * `'remove_col'` - Remove column
   *  * `'undo'` - Undo last action
   *  * `'redo'` - Redo last action
   *  * `'make_read_only'` - Make cell read only
   *  * `'alignment:left'` - Alignment to the left
   *  * `'alignment:top'` - Alignment to the top
   *  * `'alignment:right'` - Alignment to the right
   *  * `'alignment:bottom'` - Alignment to the bottom
   *  * `'alignment:middle'` - Alignment to the middle
   *  * `'alignment:center'` - Alignment to the center (justify).
   *
   * Or you can execute command registered in settings where `key` is your command name.
   *
   * @param {string} commandName Command name to execute.
   * @param {*} params Additional parameters passed to the command executor.
   */
  executeCommand(commandName) {
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    this.commandExecutor.execute(commandName, ...params);
  }
  /**
   * Turns on / off listening on dropdown menu.
   *
   * @private
   * @param {boolean} listen Turn on listening when value is set to true, otherwise turn it off.
   */
  setListening() {
    let listen = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (this.menu.isOpened()) {
      if (listen) {
        this.menu.hotMenu.listen();
      } else {
        this.menu.hotMenu.unlisten();
      }
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    this.close();
    if (this.menu) {
      this.menu.destroy();
    }
    super.destroy();
  }
};
function _addCustomShortcuts2(menuInstance) {
  menuInstance.getKeyboardShortcutsCtrl().addCustomShortcuts([{
    keys: [["Control/Meta", "A"]],
    callback: () => false
  }]);
}
function _onTableClick2(event) {
  event.stopPropagation();
  if (hasClass(event.target, BUTTON_CLASS_NAME)) {
    const offset2 = getDocumentOffsetByElement(this.menu.container, this.hot.rootDocument);
    const rect = event.target.getBoundingClientRect();
    this.open({
      left: rect.left + offset2.left,
      top: rect.top + event.target.offsetHeight + 3 + offset2.top
    }, {
      left: rect.width
    });
  }
}
function _onAfterGetColHeader23(col, TH) {
  const headerRow = TH.parentNode;
  if (!headerRow) {
    return;
  }
  const headerRowList = headerRow.parentNode.childNodes;
  const level = Array.prototype.indexOf.call(headerRowList, headerRow);
  if (col < 0 || level !== headerRowList.length - 1) {
    return;
  }
  const existingButton = TH.querySelector(`.${BUTTON_CLASS_NAME}`);
  if (this.enabled && existingButton) {
    return;
  }
  if (!this.enabled) {
    if (existingButton) {
      existingButton.parentNode.removeChild(existingButton);
    }
    return;
  }
  const button = this.hot.rootDocument.createElement("button");
  button.className = BUTTON_CLASS_NAME;
  button.type = "button";
  button.tabIndex = -1;
  if (this.hot.getSettings().ariaTags) {
    setAttribute(button, [A11Y_HIDDEN(), A11Y_LABEL(" ")]);
    setAttribute(TH, [A11Y_HASPOPUP("menu")]);
  }
  button.onclick = function() {
    return false;
  };
  TH.firstChild.insertBefore(button, TH.firstChild.firstChild);
}
function _onMenuBeforeOpen22() {
  this.hot.runHooks("beforeDropdownMenuShow", this);
}
function _onMenuAfterOpen22() {
  this.hot.runHooks("afterDropdownMenuShow", this);
  _classPrivateMethodGet15(this, _addCustomShortcuts, _addCustomShortcuts2).call(this, this.menu);
}
function _onSubMenuAfterOpen2(subMenuInstance) {
  _classPrivateMethodGet15(this, _addCustomShortcuts, _addCustomShortcuts2).call(this, subMenuInstance);
}
function _onMenuAfterClose22() {
  this.hot.listen();
  this.hot.runHooks("afterDropdownMenuHide", this);
}
DropdownMenu.SEPARATOR = {
  name: KEY
};

// node_modules/handsontable/plugins/exportFile/dataProvider.mjs
function _defineProperty25(obj, key, value) {
  key = _toPropertyKey25(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey25(arg) {
  var key = _toPrimitive25(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive25(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var DataProvider = class {
  constructor(hotInstance) {
    _defineProperty25(this, "hot", void 0);
    _defineProperty25(this, "options", {});
    this.hot = hotInstance;
  }
  /**
   * Set options for data provider.
   *
   * @param {object} options Object with specified options.
   */
  setOptions(options) {
    this.options = options;
  }
  /**
   * Get table data based on provided settings to the class constructor.
   *
   * @returns {Array}
   */
  getData() {
    const {
      startRow,
      startCol,
      endRow,
      endCol
    } = this._getDataRange();
    const options = this.options;
    const data = [];
    rangeEach(startRow, endRow, (rowIndex) => {
      const row = [];
      if (!options.exportHiddenRows && this._isHiddenRow(rowIndex)) {
        return;
      }
      rangeEach(startCol, endCol, (colIndex) => {
        if (!options.exportHiddenColumns && this._isHiddenColumn(colIndex)) {
          return;
        }
        row.push(this.hot.getDataAtCell(rowIndex, colIndex));
      });
      data.push(row);
    });
    return data;
  }
  /**
   * Gets list of row headers.
   *
   * @returns {Array}
   */
  getRowHeaders() {
    const headers = [];
    if (this.options.rowHeaders) {
      const {
        startRow,
        endRow
      } = this._getDataRange();
      const rowHeaders = this.hot.getRowHeader();
      rangeEach(startRow, endRow, (row) => {
        if (!this.options.exportHiddenRows && this._isHiddenRow(row)) {
          return;
        }
        headers.push(rowHeaders[row]);
      });
    }
    return headers;
  }
  /**
   * Gets list of columns headers.
   *
   * @returns {Array}
   */
  getColumnHeaders() {
    const headers = [];
    if (this.options.columnHeaders) {
      const {
        startCol,
        endCol
      } = this._getDataRange();
      const colHeaders = this.hot.getColHeader();
      rangeEach(startCol, endCol, (column) => {
        if (!this.options.exportHiddenColumns && this._isHiddenColumn(column)) {
          return;
        }
        headers.push(colHeaders[column]);
      });
    }
    return headers;
  }
  /**
   * Get data range object based on settings provided in the class constructor.
   *
   * @private
   * @returns {object} Returns object with keys `startRow`, `startCol`, `endRow` and `endCol`.
   */
  _getDataRange() {
    const cols = this.hot.countCols() - 1;
    const rows = this.hot.countRows() - 1;
    let [startRow = 0, startCol = 0, endRow = rows, endCol = cols] = this.options.range;
    startRow = Math.max(startRow, 0);
    startCol = Math.max(startCol, 0);
    endRow = Math.min(endRow, rows);
    endCol = Math.min(endCol, cols);
    return {
      startRow,
      startCol,
      endRow,
      endCol
    };
  }
  /**
   * Check if row at specified row index is hidden.
   *
   * @private
   * @param {number} row Row index.
   * @returns {boolean}
   */
  _isHiddenRow(row) {
    return this.hot.rowIndexMapper.isHidden(this.hot.toPhysicalRow(row));
  }
  /**
   * Check if column at specified column index is hidden.
   *
   * @private
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  _isHiddenColumn(column) {
    return this.hot.columnIndexMapper.isHidden(this.hot.toPhysicalColumn(column));
  }
};
var dataProvider_default = DataProvider;

// node_modules/handsontable/plugins/exportFile/types/_base.mjs
function _defineProperty26(obj, key, value) {
  key = _toPropertyKey26(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey26(arg) {
  var key = _toPrimitive26(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive26(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var BaseType = class _BaseType {
  /**
   * Default options.
   *
   * @returns {object}
   */
  static get DEFAULT_OPTIONS() {
    return {
      mimeType: "text/plain",
      fileExtension: "txt",
      filename: "Handsontable [YYYY]-[MM]-[DD]",
      encoding: "utf-8",
      bom: false,
      columnHeaders: false,
      rowHeaders: false,
      exportHiddenColumns: false,
      exportHiddenRows: false,
      range: []
    };
  }
  /**
   * Data provider.
   *
   * @type {DataProvider}
   */
  constructor(dataProvider, options) {
    _defineProperty26(this, "dataProvider", void 0);
    _defineProperty26(this, "options", void 0);
    this.dataProvider = dataProvider;
    this.options = this._mergeOptions(options);
    this.dataProvider.setOptions(this.options);
  }
  /**
   * Merge options provided by users with defaults.
   *
   * @param {object} options An object with options to merge with.
   * @returns {object} Returns new options object.
   */
  _mergeOptions(options) {
    let _options = clone(this.constructor.DEFAULT_OPTIONS);
    const date = /* @__PURE__ */ new Date();
    _options = extend(clone(_BaseType.DEFAULT_OPTIONS), _options);
    _options = extend(_options, options);
    _options.filename = substitute(_options.filename, {
      YYYY: date.getFullYear(),
      MM: `${date.getMonth() + 1}`.padStart(2, "0"),
      DD: `${date.getDate()}`.padStart(2, "0")
    });
    return _options;
  }
};
var base_default = BaseType;

// node_modules/handsontable/plugins/exportFile/types/csv.mjs
var CHAR_CARRIAGE_RETURN = String.fromCharCode(13);
var CHAR_DOUBLE_QUOTES = String.fromCharCode(34);
var CHAR_LINE_FEED = String.fromCharCode(10);
var Csv = class extends base_default {
  /**
   * Default options for exporting CSV format.
   *
   * @returns {object}
   */
  static get DEFAULT_OPTIONS() {
    return {
      mimeType: "text/csv",
      fileExtension: "csv",
      bom: true,
      columnDelimiter: ",",
      rowDelimiter: "\r\n"
    };
  }
  /**
   * Create string body in desired format.
   *
   * @returns {string}
   */
  export() {
    const options = this.options;
    const data = this.dataProvider.getData();
    let columnHeaders = this.dataProvider.getColumnHeaders();
    const hasColumnHeaders = columnHeaders.length > 0;
    const rowHeaders = this.dataProvider.getRowHeaders();
    const hasRowHeaders = rowHeaders.length > 0;
    let result = options.bom ? String.fromCharCode(65279) : "";
    if (hasColumnHeaders) {
      columnHeaders = arrayMap(columnHeaders, (value) => this._escapeCell(value, true));
      if (hasRowHeaders) {
        result += options.columnDelimiter;
      }
      result += columnHeaders.join(options.columnDelimiter);
      result += options.rowDelimiter;
    }
    arrayEach(data, (value, index) => {
      if (index > 0) {
        result += options.rowDelimiter;
      }
      if (hasRowHeaders) {
        result += this._escapeCell(rowHeaders[index]) + options.columnDelimiter;
      }
      result += value.map((cellValue) => this._escapeCell(cellValue)).join(options.columnDelimiter);
    });
    return result;
  }
  /**
   * Escape cell value.
   *
   * @param {*} value Cell value.
   * @param {boolean} [force=false] Indicates if cell value will be escaped forcefully.
   * @returns {string}
   */
  _escapeCell(value) {
    let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let escapedValue = stringify(value);
    if (escapedValue !== "" && (force || escapedValue.indexOf(CHAR_CARRIAGE_RETURN) >= 0 || escapedValue.indexOf(CHAR_DOUBLE_QUOTES) >= 0 || escapedValue.indexOf(CHAR_LINE_FEED) >= 0 || escapedValue.indexOf(this.options.columnDelimiter) >= 0)) {
      escapedValue = escapedValue.replace(new RegExp('"', "g"), '""');
      escapedValue = `"${escapedValue}"`;
    }
    return escapedValue;
  }
};
var csv_default = Csv;

// node_modules/handsontable/plugins/exportFile/typeFactory.mjs
var TYPE_CSV = "csv";
var EXPORT_TYPES = {
  [TYPE_CSV]: csv_default
};
function typeFactory(type, dataProvider, options) {
  if (typeof EXPORT_TYPES[type] === "function") {
    return new EXPORT_TYPES[type](dataProvider, options);
  }
  return null;
}

// node_modules/handsontable/plugins/exportFile/exportFile.mjs
var PLUGIN_KEY15 = "exportFile";
var PLUGIN_PRIORITY14 = 240;
var ExportFile = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY15;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY14;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ExportFile#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return true;
  }
  /**
   * @typedef ExportOptions
   * @memberof ExportFile
   * @type {object}
   * @property {boolean} [exportHiddenRows=false] Include hidden rows in the exported file.
   * @property {boolean} [exportHiddenColumns=false] Include hidden columns in the exported file.
   * @property {boolean} [columnHeaders=false] Include column headers in the exported file.
   * @property {boolean} [rowHeaders=false] Include row headers in the exported file.
   * @property {string} [columnDelimiter=','] Column delimiter.
   * @property {string} [range=[]] Cell range that will be exported to file.
   */
  /**
   * Exports table data as a string.
   *
   * @param {string} format Export format type eq. `'csv'`.
   * @param {ExportOptions} options Export options.
   * @returns {string}
   */
  exportAsString(format) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this._createTypeFormatter(format, options).export();
  }
  /**
   * Exports table data as a blob object.
   *
   * @param {string} format Export format type eq. `'csv'`.
   * @param {ExportOptions} options Export options.
   * @returns {Blob}
   */
  exportAsBlob(format) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this._createBlob(this._createTypeFormatter(format, options));
  }
  /**
   * Exports table data as a downloadable file.
   *
   * @param {string} format Export format type eq. `'csv'`.
   * @param {ExportOptions} options Export options.
   */
  downloadFile(format) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      rootDocument,
      rootWindow
    } = this.hot;
    const formatter = this._createTypeFormatter(format, options);
    const blob = this._createBlob(formatter);
    const URL = rootWindow.URL || rootWindow.webkitURL;
    const a = rootDocument.createElement("a");
    const name = `${formatter.options.filename}.${formatter.options.fileExtension}`;
    if (a.download !== void 0) {
      const url = URL.createObjectURL(blob);
      a.style.display = "none";
      a.setAttribute("href", url);
      a.setAttribute("download", name);
      rootDocument.body.appendChild(a);
      a.dispatchEvent(new MouseEvent("click"));
      rootDocument.body.removeChild(a);
      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 100);
    } else if (navigator.msSaveOrOpenBlob) {
      navigator.msSaveOrOpenBlob(blob, name);
    }
  }
  /**
   * Creates and returns class formatter for specified export type.
   *
   * @private
   * @param {string} format Export format type eq. `'csv'`.
   * @param {ExportOptions} options Export options.
   * @returns {BaseType}
   */
  _createTypeFormatter(format) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!EXPORT_TYPES[format]) {
      throw new Error(`Export format type "${format}" is not supported.`);
    }
    return typeFactory(format, new dataProvider_default(this.hot), options);
  }
  /**
   * Creates blob object based on provided type formatter class.
   *
   * @private
   * @param {BaseType} typeFormatter The instance of the specyfic formatter/exporter.
   * @returns {Blob}
   */
  _createBlob(typeFormatter) {
    let formatter = null;
    if (typeof Blob !== "undefined") {
      formatter = new Blob([typeFormatter.export()], {
        type: `${typeFormatter.options.mimeType};charset=${typeFormatter.options.encoding}`
      });
    }
    return formatter;
  }
};

// node_modules/handsontable/plugins/filters/component/_base.mjs
function _defineProperty27(obj, key, value) {
  key = _toPropertyKey27(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey27(arg) {
  var key = _toPrimitive27(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive27(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var BaseComponent = class {
  constructor(hotInstance, _ref) {
    let {
      id,
      stateless = true
    } = _ref;
    _defineProperty27(this, "hot", void 0);
    _defineProperty27(this, "id", void 0);
    _defineProperty27(this, "elements", []);
    _defineProperty27(this, "hidden", false);
    _defineProperty27(this, "stateId", "");
    _defineProperty27(this, "state", void 0);
    this.hot = hotInstance;
    this.id = id;
    this.stateId = `Filters.component.${this.id}`;
    this.state = stateless ? null : this.hot.columnIndexMapper.registerMap(this.stateId, new LinkedPhysicalIndexToValueMap());
  }
  /**
   * Gets the list of elements from which the component is built.
   *
   * @returns {BaseUI[]}
   */
  getElements() {
    return this.elements;
  }
  /**
   * Reset elements to its initial state.
   */
  reset() {
    arrayEach(this.elements, (ui) => ui.reset());
  }
  /**
   * Hide component.
   */
  hide() {
    this.hidden = true;
  }
  /**
   * Show component.
   */
  show() {
    this.hidden = false;
  }
  /**
   * Check if component is hidden.
   *
   * @returns {boolean}
   */
  isHidden() {
    return this.hot === null || this.hidden;
  }
  /**
   * Restores the component state from the given physical column index. The method
   * internally calls the `setState` method. The state then is individually processed
   * by each component.
   *
   * @param {number} physicalColumn The physical column index.
   */
  restoreState(physicalColumn) {
    if (this.state) {
      this.setState(this.state.getValueAtIndex(physicalColumn));
    }
  }
  /**
   * The custom logic for component state restoring.
   */
  setState() {
    throw new Error("The state setting logic is not implemented");
  }
  /**
   * Saves the component state to the given physical column index. The method
   * internally calls the `getState` method, which returns the current state of
   * the component.
   *
   * @param {number} physicalColumn The physical column index.
   */
  saveState(physicalColumn) {
    if (this.state) {
      this.state.setValueAtIndex(physicalColumn, this.getState());
    }
  }
  /**
   * The custom logic for component state gathering (for stateful components).
   */
  getState() {
    throw new Error("The state gathering logic is not implemented");
  }
  /**
   * Destroy element.
   */
  destroy() {
    this.hot.columnIndexMapper.unregisterMap(this.stateId);
    this.clearLocalHooks();
    arrayEach(this.elements, (ui) => ui.destroy());
    this.state = null;
    this.elements = null;
    this.hot = null;
  }
};
mixin(BaseComponent, localHooks_default);

// node_modules/handsontable/plugins/filters/conditionRegisterer.mjs
var conditions = {};
function getCondition(name, args) {
  if (!conditions[name]) {
    throw Error(`Filter condition "${name}" does not exist.`);
  }
  const {
    condition: condition24,
    descriptor
  } = conditions[name];
  let conditionArguments = args;
  if (descriptor.inputValuesDecorator) {
    conditionArguments = descriptor.inputValuesDecorator(conditionArguments);
  }
  return function(dataRow) {
    return condition24.apply(dataRow.meta.instance, [].concat([dataRow], [conditionArguments]));
  };
}
function getConditionDescriptor(name) {
  if (!conditions[name]) {
    throw Error(`Filter condition "${name}" does not exist.`);
  }
  return conditions[name].descriptor;
}
function registerCondition(name, condition24, descriptor) {
  descriptor.key = name;
  conditions[name] = {
    condition: condition24,
    descriptor
  };
}

// node_modules/handsontable/plugins/filters/condition/none.mjs
var CONDITION_NAME = "none";
function condition() {
  return true;
}
registerCondition(CONDITION_NAME, condition, {
  name: FILTERS_CONDITIONS_NONE,
  inputsCount: 0,
  showOperators: false
});

// node_modules/handsontable/plugins/filters/condition/empty.mjs
var CONDITION_NAME2 = "empty";
function condition2(dataRow) {
  return isEmpty(dataRow.value);
}
registerCondition(CONDITION_NAME2, condition2, {
  name: FILTERS_CONDITIONS_EMPTY,
  inputsCount: 0,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/notEmpty.mjs
var CONDITION_NAME3 = "not_empty";
function condition3(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME2, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME3, condition3, {
  name: FILTERS_CONDITIONS_NOT_EMPTY,
  inputsCount: 0,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/equal.mjs
var CONDITION_NAME4 = "eq";
function condition4(dataRow, _ref) {
  let [value] = _ref;
  return stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale) === stringify(value);
}
registerCondition(CONDITION_NAME4, condition4, {
  name: FILTERS_CONDITIONS_EQUAL,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/notEqual.mjs
var CONDITION_NAME5 = "neq";
function condition5(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME4, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME5, condition5, {
  name: FILTERS_CONDITIONS_NOT_EQUAL,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/greaterThan.mjs
var CONDITION_NAME6 = "gt";
function condition6(dataRow, _ref) {
  let [value] = _ref;
  let conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value > conditionValue;
}
registerCondition(CONDITION_NAME6, condition6, {
  name: FILTERS_CONDITIONS_GREATER_THAN,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/greaterThanOrEqual.mjs
var CONDITION_NAME7 = "gte";
function condition7(dataRow, _ref) {
  let [value] = _ref;
  let conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value >= conditionValue;
}
registerCondition(CONDITION_NAME7, condition7, {
  name: FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/lessThan.mjs
var CONDITION_NAME8 = "lt";
function condition8(dataRow, _ref) {
  let [value] = _ref;
  let conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value < conditionValue;
}
registerCondition(CONDITION_NAME8, condition8, {
  name: FILTERS_CONDITIONS_LESS_THAN,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/lessThanOrEqual.mjs
var CONDITION_NAME9 = "lte";
function condition9(dataRow, _ref) {
  let [value] = _ref;
  let conditionValue = value;
  if (dataRow.meta.type === "numeric") {
    conditionValue = parseFloat(conditionValue, 10);
  }
  return dataRow.value <= conditionValue;
}
registerCondition(CONDITION_NAME9, condition9, {
  name: FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/date/after.mjs
init_moment();
var CONDITION_NAME10 = "date_after";
function condition10(dataRow, _ref) {
  let [value] = _ref;
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  const inputDate = moment_default(value, dataRow.meta.dateFormat);
  if (!date.isValid() || !inputDate.isValid()) {
    return false;
  }
  return date.diff(inputDate) >= 0;
}
registerCondition(CONDITION_NAME10, condition10, {
  name: FILTERS_CONDITIONS_AFTER,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/date/before.mjs
init_moment();
var CONDITION_NAME11 = "date_before";
function condition11(dataRow, _ref) {
  let [value] = _ref;
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  const inputDate = moment_default(value, dataRow.meta.dateFormat);
  if (!date.isValid() || !inputDate.isValid()) {
    return false;
  }
  return date.diff(inputDate) <= 0;
}
registerCondition(CONDITION_NAME11, condition11, {
  name: FILTERS_CONDITIONS_BEFORE,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/between.mjs
var CONDITION_NAME12 = "between";
function condition12(dataRow, _ref) {
  let [from, to] = _ref;
  let fromValue = from;
  let toValue = to;
  if (dataRow.meta.type === "numeric") {
    const _from = parseFloat(fromValue, 10);
    const _to = parseFloat(toValue, 10);
    fromValue = Math.min(_from, _to);
    toValue = Math.max(_from, _to);
  } else if (dataRow.meta.type === "date") {
    const dateBefore = getCondition(CONDITION_NAME11, [toValue]);
    const dateAfter = getCondition(CONDITION_NAME10, [fromValue]);
    return dateBefore(dataRow) && dateAfter(dataRow);
  }
  return dataRow.value >= fromValue && dataRow.value <= toValue;
}
registerCondition(CONDITION_NAME12, condition12, {
  name: FILTERS_CONDITIONS_BETWEEN,
  inputsCount: 2,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/notBetween.mjs
var CONDITION_NAME13 = "not_between";
function condition13(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME12, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME13, condition13, {
  name: FILTERS_CONDITIONS_NOT_BETWEEN,
  inputsCount: 2,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/beginsWith.mjs
var CONDITION_NAME14 = "begins_with";
function condition14(dataRow, _ref) {
  let [value] = _ref;
  return stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).startsWith(stringify(value));
}
registerCondition(CONDITION_NAME14, condition14, {
  name: FILTERS_CONDITIONS_BEGINS_WITH,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/endsWith.mjs
var CONDITION_NAME15 = "ends_with";
function condition15(dataRow, _ref) {
  let [value] = _ref;
  return stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).endsWith(stringify(value));
}
registerCondition(CONDITION_NAME15, condition15, {
  name: FILTERS_CONDITIONS_ENDS_WITH,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/contains.mjs
var CONDITION_NAME16 = "contains";
function condition16(dataRow, _ref) {
  let [value] = _ref;
  return stringify(dataRow.value).toLocaleLowerCase(dataRow.meta.locale).indexOf(stringify(value)) >= 0;
}
registerCondition(CONDITION_NAME16, condition16, {
  name: FILTERS_CONDITIONS_CONTAINS,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/notContains.mjs
var CONDITION_NAME17 = "not_contains";
function condition17(dataRow, inputValues) {
  return !getCondition(CONDITION_NAME16, inputValues)(dataRow);
}
registerCondition(CONDITION_NAME17, condition17, {
  name: FILTERS_CONDITIONS_NOT_CONTAIN,
  inputsCount: 1,
  showOperators: true
});

// node_modules/handsontable/plugins/filters/condition/date/tomorrow.mjs
init_moment();
var CONDITION_NAME18 = "date_tomorrow";
function condition18(dataRow) {
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(moment_default().subtract(-1, "days").startOf("day"), "d");
}
registerCondition(CONDITION_NAME18, condition18, {
  name: FILTERS_CONDITIONS_TOMORROW,
  inputsCount: 0
});

// node_modules/handsontable/plugins/filters/condition/date/today.mjs
init_moment();
var CONDITION_NAME19 = "date_today";
function condition19(dataRow) {
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(moment_default().startOf("day"), "d");
}
registerCondition(CONDITION_NAME19, condition19, {
  name: FILTERS_CONDITIONS_TODAY,
  inputsCount: 0
});

// node_modules/handsontable/plugins/filters/condition/date/yesterday.mjs
init_moment();
var CONDITION_NAME20 = "date_yesterday";
function condition20(dataRow) {
  const date = moment_default(dataRow.value, dataRow.meta.dateFormat);
  if (!date.isValid()) {
    return false;
  }
  return date.isSame(moment_default().subtract(1, "days").startOf("day"), "d");
}
registerCondition(CONDITION_NAME20, condition20, {
  name: FILTERS_CONDITIONS_YESTERDAY,
  inputsCount: 0
});

// node_modules/handsontable/plugins/filters/utils.mjs
var sortCompare = getComparisonFunction();
function toVisualValue(value, defaultEmptyValue) {
  let visualValue = value;
  if (visualValue === "") {
    visualValue = `(${defaultEmptyValue})`;
  }
  return visualValue;
}
var SUPPORT_SET_CONSTRUCTOR = (/* @__PURE__ */ new Set([1])).has(1);
var SUPPORT_FAST_DEDUPE = SUPPORT_SET_CONSTRUCTOR && typeof Array.from === "function";
function createArrayAssertion(initialData) {
  let dataset = initialData;
  if (SUPPORT_SET_CONSTRUCTOR) {
    dataset = new Set(dataset);
  }
  return function(value) {
    let result;
    if (SUPPORT_SET_CONSTRUCTOR) {
      result = dataset.has(value);
    } else {
      result = !!~dataset.indexOf(value);
    }
    return result;
  };
}
function toEmptyString(value) {
  return value === null || value === void 0 ? "" : value;
}
function unifyColumnValues(values) {
  let unifiedValues = values;
  if (SUPPORT_FAST_DEDUPE) {
    unifiedValues = Array.from(new Set(unifiedValues));
  } else {
    unifiedValues = arrayUnique(unifiedValues);
  }
  unifiedValues = unifiedValues.sort((a, b) => {
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    }
    if (a === b) {
      return 0;
    }
    return a > b ? 1 : -1;
  });
  return unifiedValues;
}
function intersectValues(base, selected, defaultEmptyValue, callback) {
  const result = [];
  const same = base === selected;
  let selectedItemsAssertion;
  if (!same) {
    selectedItemsAssertion = createArrayAssertion(selected);
  }
  arrayEach(base, (value) => {
    let checked = false;
    if (same || selectedItemsAssertion(value)) {
      checked = true;
    }
    const item = {
      checked,
      value,
      visualValue: toVisualValue(value, defaultEmptyValue)
    };
    if (callback) {
      callback(item);
    }
    result.push(item);
  });
  return result;
}

// node_modules/handsontable/plugins/filters/condition/byValue.mjs
var CONDITION_NAME21 = "by_value";
function condition21(dataRow, _ref) {
  let [value] = _ref;
  return value(dataRow.value);
}
registerCondition(CONDITION_NAME21, condition21, {
  name: "By value",
  inputsCount: 0,
  inputValuesDecorator(_ref2) {
    let [data] = _ref2;
    return [createArrayAssertion(data)];
  },
  showOperators: false
});

// node_modules/handsontable/plugins/filters/condition/true.mjs
var CONDITION_NAME22 = "true";
function condition22() {
  return true;
}
registerCondition(CONDITION_NAME22, condition22, {
  name: "True"
});

// node_modules/handsontable/plugins/filters/condition/false.mjs
var CONDITION_NAME23 = "false";
function condition23() {
  return false;
}
registerCondition(CONDITION_NAME23, condition23, {
  name: "False"
});

// node_modules/handsontable/plugins/filters/logicalOperationRegisterer.mjs
var operations = {};
function getOperationFunc(id) {
  if (!operations[id]) {
    throw Error(`Operation with id "${id}" does not exist.`);
  }
  const func = operations[id].func;
  return function(conditions2, value) {
    return func(conditions2, value);
  };
}
function getOperationName(id) {
  return operations[id].name;
}
function registerOperation(id, name, func) {
  operations[id] = {
    name,
    func
  };
}

// node_modules/handsontable/plugins/filters/logicalOperations/conjunction.mjs
var OPERATION_ID = "conjunction";
var SHORT_NAME_FOR_COMPONENT = FILTERS_LABELS_CONJUNCTION;
function operationResult(conditions2, value) {
  return conditions2.every((condition24) => condition24.func(value));
}
registerOperation(OPERATION_ID, SHORT_NAME_FOR_COMPONENT, operationResult);

// node_modules/handsontable/plugins/filters/logicalOperations/disjunction.mjs
var OPERATION_ID2 = "disjunction";
var SHORT_NAME_FOR_COMPONENT2 = FILTERS_LABELS_DISJUNCTION;
function operationResult2(conditions2, value) {
  return conditions2.some((condition24) => condition24.func(value));
}
registerOperation(OPERATION_ID2, SHORT_NAME_FOR_COMPONENT2, operationResult2);

// node_modules/handsontable/plugins/filters/logicalOperations/disjunctionWithExtraCondition.mjs
var OPERATION_ID3 = "disjunctionWithExtraCondition";
var SHORT_NAME_FOR_COMPONENT3 = FILTERS_LABELS_DISJUNCTION;
function operationResult3(conditions2, value) {
  if (conditions2.length < 3) {
    throw Error("Operation doesn't work on less then three conditions.");
  }
  return conditions2.slice(0, conditions2.length - 1).some((condition24) => condition24.func(value)) && conditions2[conditions2.length - 1].func(value);
}
registerOperation(OPERATION_ID3, SHORT_NAME_FOR_COMPONENT3, operationResult3);

// node_modules/handsontable/plugins/filters/constants.mjs
var TYPE_NUMERIC = "numeric";
var TYPE_TEXT = "text";
var TYPE_DATE = "date";
var TYPES = {
  [TYPE_NUMERIC]: [CONDITION_NAME, KEY, CONDITION_NAME2, CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, CONDITION_NAME6, CONDITION_NAME7, CONDITION_NAME8, CONDITION_NAME9, CONDITION_NAME12, CONDITION_NAME13],
  [TYPE_TEXT]: [CONDITION_NAME, KEY, CONDITION_NAME2, CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, CONDITION_NAME14, CONDITION_NAME15, KEY, CONDITION_NAME16, CONDITION_NAME17],
  [TYPE_DATE]: [CONDITION_NAME, KEY, CONDITION_NAME2, CONDITION_NAME3, KEY, CONDITION_NAME4, CONDITION_NAME5, KEY, CONDITION_NAME11, CONDITION_NAME10, CONDITION_NAME12, KEY, CONDITION_NAME18, CONDITION_NAME19, CONDITION_NAME20]
};
function getOptionsList(type) {
  const items = [];
  let typeName = type;
  if (!TYPES[typeName]) {
    typeName = TYPE_TEXT;
  }
  arrayEach(TYPES[typeName], (typeValue) => {
    let option;
    if (typeValue === KEY) {
      option = {
        name: KEY
      };
    } else {
      option = clone(getConditionDescriptor(typeValue));
    }
    items.push(option);
  });
  return items;
}

// node_modules/handsontable/plugins/filters/ui/_base.mjs
function _defineProperty28(obj, key, value) {
  key = _toPropertyKey28(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey28(arg) {
  var key = _toPrimitive28(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive28(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var STATE_BUILT = "built";
var STATE_BUILDING = "building";
var EVENTS_TO_REGISTER = ["click", "input", "keydown", "keypress", "keyup", "focus", "blur", "change"];
var BaseUI = class _BaseUI {
  static get DEFAULTS() {
    return clone({
      className: "",
      value: "",
      tagName: "div",
      children: [],
      wrapIt: true
    });
  }
  /**
   * Instance of Handsontable.
   *
   * @type {Core}
   */
  constructor(hotInstance, options) {
    _defineProperty28(this, "hot", void 0);
    _defineProperty28(this, "eventManager", new eventManager_default(this));
    _defineProperty28(this, "options", void 0);
    _defineProperty28(this, "_element", void 0);
    _defineProperty28(this, "buildState", void 0);
    this.hot = hotInstance;
    this.options = extend(_BaseUI.DEFAULTS, options);
    this._element = this.hot.rootDocument.createElement(this.options.wrapIt ? "div" : this.options.tagName);
  }
  /**
   * Set the element value.
   *
   * @param {*} value Set the component value.
   */
  setValue(value) {
    this.options.value = value;
    this.update();
  }
  /**
   * Get the element value.
   *
   * @returns {*}
   */
  getValue() {
    return this.options.value;
  }
  /**
   * Get element as a DOM object.
   *
   * @returns {Element}
   */
  get element() {
    if (this.buildState === STATE_BUILDING) {
      return this._element;
    }
    if (this.buildState === STATE_BUILT) {
      this.update();
      return this._element;
    }
    this.buildState = STATE_BUILDING;
    this.build();
    this.buildState = STATE_BUILT;
    return this._element;
  }
  /**
   * Check if element was built (built whole DOM structure).
   *
   * @returns {boolean}
   */
  isBuilt() {
    return this.buildState === STATE_BUILT;
  }
  /**
   * Translate value if it is possible. It's checked if value belongs to namespace of translated phrases.
   *
   * @param {*} value Value which will may be translated.
   * @returns {*} Translated value if translation was possible, original value otherwise.
   */
  translateIfPossible(value) {
    if (typeof value === "string" && value.startsWith(FILTERS_NAMESPACE)) {
      return this.hot.getTranslatedPhrase(value);
    }
    return value;
  }
  /**
   * Build DOM structure.
   */
  build() {
    const registerEvent = (element, eventName) => {
      this.eventManager.addEventListener(element, eventName, (event) => this.runLocalHooks(eventName, event, this));
    };
    if (!this.buildState) {
      this.buildState = STATE_BUILDING;
    }
    this._element.setAttribute("data-hot-input", true);
    if (this.options.tabIndex !== void 0) {
      this._element.setAttribute("tabindex", this.options.tabIndex);
    }
    if (this.options.role !== void 0) {
      this._element.setAttribute("role", this.options.role);
    }
    if (this.options.className) {
      addClass(this._element, this.options.className);
    }
    if (this.options.children.length) {
      arrayEach(this.options.children, (element) => this._element.appendChild(element.element));
    } else if (this.options.wrapIt) {
      const element = this.hot.rootDocument.createElement(this.options.tagName);
      element.setAttribute("data-hot-input", true);
      objectEach(this.options, (value, key) => {
        if (element[key] !== void 0 && key !== "className" && key !== "tagName" && key !== "children") {
          element[key] = this.translateIfPossible(value);
        }
      });
      this._element.appendChild(element);
      arrayEach(EVENTS_TO_REGISTER, (eventName) => registerEvent(element, eventName));
    } else {
      arrayEach(EVENTS_TO_REGISTER, (eventName) => registerEvent(this._element, eventName));
    }
  }
  /**
   * Update DOM structure.
   */
  update() {
  }
  /**
   * Reset to initial state.
   */
  reset() {
    this.options.value = "";
    this.update();
  }
  /**
   * Show element.
   */
  show() {
    this.element.style.display = "";
  }
  /**
   * Hide element.
   */
  hide() {
    this.element.style.display = "none";
  }
  /**
   * Focus element.
   */
  focus() {
  }
  destroy() {
    this.eventManager.destroy();
    this.eventManager = null;
    this.hot = null;
    if (this._element.parentNode) {
      this._element.parentNode.removeChild(this._element);
    }
    this._element = null;
  }
};
mixin(BaseUI, localHooks_default);

// node_modules/handsontable/plugins/filters/ui/input.mjs
function _classPrivateMethodInitSpec16(obj, privateSet) {
  _checkPrivateRedeclaration18(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec9(obj, privateMap, value) {
  _checkPrivateRedeclaration18(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration18(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet9(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor9(receiver, privateMap, "get");
  return _classApplyDescriptorGet9(receiver, descriptor);
}
function _classApplyDescriptorGet9(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet8(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor9(receiver, privateMap, "set");
  _classApplyDescriptorSet8(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor9(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet8(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateMethodGet16(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var _input = /* @__PURE__ */ new WeakMap();
var _onKeyup = /* @__PURE__ */ new WeakSet();
var InputUI = class _InputUI extends BaseUI {
  static get DEFAULTS() {
    return clone({
      placeholder: "",
      type: "text",
      tagName: "input",
      tabIndex: -1
    });
  }
  /**
   * The reference to the input element.
   *
   * @type {HTMLInputElement}
   */
  constructor(hotInstance, options) {
    super(hotInstance, extend(_InputUI.DEFAULTS, options));
    _classPrivateMethodInitSpec16(this, _onKeyup);
    _classPrivateFieldInitSpec9(this, _input, {
      writable: true,
      value: void 0
    });
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   */
  registerHooks() {
    this.addLocalHook("keyup", (event) => _classPrivateMethodGet16(this, _onKeyup, _onKeyup2).call(this, event));
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    const icon = this.hot.rootDocument.createElement("div");
    _classPrivateFieldSet8(this, _input, this._element.firstChild);
    addClass(this._element, "htUIInput");
    addClass(icon, "htUIInputIcon");
    this._element.appendChild(icon);
    this.update();
  }
  /**
   * Update element.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    _classPrivateFieldGet9(this, _input).type = this.options.type;
    _classPrivateFieldGet9(this, _input).placeholder = this.translateIfPossible(this.options.placeholder);
    _classPrivateFieldGet9(this, _input).value = this.translateIfPossible(this.options.value);
  }
  /**
   * Focus element.
   */
  focus() {
    if (this.isBuilt()) {
      _classPrivateFieldGet9(this, _input).focus();
    }
  }
};
function _onKeyup2(event) {
  this.options.value = event.target.value;
}

// node_modules/handsontable/plugins/filters/ui/select.mjs
function _classPrivateMethodInitSpec17(obj, privateSet) {
  _checkPrivateRedeclaration19(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec10(obj, privateMap, value) {
  _checkPrivateRedeclaration19(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration19(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet9(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor10(receiver, privateMap, "set");
  _classApplyDescriptorSet9(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet9(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateMethodGet17(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet10(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor10(receiver, privateMap, "get");
  return _classApplyDescriptorGet10(receiver, descriptor);
}
function _classExtractFieldDescriptor10(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet10(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _menu = /* @__PURE__ */ new WeakMap();
var _items = /* @__PURE__ */ new WeakMap();
var _caption = /* @__PURE__ */ new WeakMap();
var _captionElement = /* @__PURE__ */ new WeakMap();
var _dropdown = /* @__PURE__ */ new WeakMap();
var _onMenuSelect = /* @__PURE__ */ new WeakSet();
var _onMenuClosed = /* @__PURE__ */ new WeakSet();
var _onClick = /* @__PURE__ */ new WeakSet();
var SelectUI = class _SelectUI extends BaseUI {
  static get DEFAULTS() {
    return clone({
      className: "htUISelect",
      wrapIt: false,
      tabIndex: -1
    });
  }
  /**
   * Instance of {@link Menu}.
   *
   * @type {Menu}
   */
  constructor(hotInstance, options) {
    super(hotInstance, extend(_SelectUI.DEFAULTS, options));
    _classPrivateMethodInitSpec17(this, _onClick);
    _classPrivateMethodInitSpec17(this, _onMenuClosed);
    _classPrivateMethodInitSpec17(this, _onMenuSelect);
    _classPrivateFieldInitSpec10(this, _menu, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec10(this, _items, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec10(this, _caption, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec10(this, _captionElement, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec10(this, _dropdown, {
      writable: true,
      value: void 0
    });
    this.registerHooks();
  }
  /**
   * Gets the instance of the Menu.
   *
   * @returns {Menu}
   */
  getMenu() {
    return _classPrivateFieldGet10(this, _menu);
  }
  /**
   * Register all necessary hooks.
   */
  registerHooks() {
    this.addLocalHook("click", () => _classPrivateMethodGet17(this, _onClick, _onClick2).call(this));
  }
  /**
   * Set options which can be selected in the list.
   *
   * @param {Array} items Array of objects with required keys `key` and `name`.
   */
  setItems(items) {
    _classPrivateFieldSet9(this, _items, this.translateNames(items));
    if (_classPrivateFieldGet10(this, _menu)) {
      _classPrivateFieldGet10(this, _menu).setMenuItems(_classPrivateFieldGet10(this, _items));
    }
  }
  /**
   * Translate names of menu items.
   *
   * @param {Array} items Array of objects with required keys `key` and `name`.
   * @returns {Array} Items with translated `name` keys.
   */
  translateNames(items) {
    arrayEach(items, (item) => {
      item.name = this.translateIfPossible(item.name);
    });
    return items;
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    _classPrivateFieldSet9(this, _menu, new Menu(this.hot, {
      className: "htSelectUI htFiltersConditionsMenu",
      keepInViewport: false,
      standalone: true,
      container: this.options.menuContainer
    }));
    _classPrivateFieldGet10(this, _menu).setMenuItems(_classPrivateFieldGet10(this, _items));
    const caption = new BaseUI(this.hot, {
      className: "htUISelectCaption"
    });
    const dropdown = new BaseUI(this.hot, {
      className: "htUISelectDropdown"
    });
    _classPrivateFieldSet9(this, _caption, caption);
    _classPrivateFieldSet9(this, _captionElement, caption.element);
    _classPrivateFieldSet9(this, _dropdown, dropdown);
    if (this.hot.getSettings().ariaTags) {
      setAttribute(dropdown.element, [A11Y_HIDDEN()]);
      setAttribute(this._element, [A11Y_LISTBOX()]);
    }
    arrayEach([caption, dropdown], (element) => this._element.appendChild(element.element));
    _classPrivateFieldGet10(this, _menu).addLocalHook("select", (command) => _classPrivateMethodGet17(this, _onMenuSelect, _onMenuSelect2).call(this, command));
    _classPrivateFieldGet10(this, _menu).addLocalHook("afterClose", () => _classPrivateMethodGet17(this, _onMenuClosed, _onMenuClosed2).call(this));
    this.update();
  }
  /**
   * Update DOM structure.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    let conditionName;
    if (this.options.value) {
      conditionName = this.options.value.name;
    } else {
      conditionName = _classPrivateFieldGet10(this, _menu).hot.getTranslatedPhrase(FILTERS_CONDITIONS_NONE);
    }
    _classPrivateFieldGet10(this, _captionElement).textContent = conditionName;
    super.update();
  }
  /**
   * Open select dropdown menu with available options.
   */
  openOptions() {
    const rect = this.element.getBoundingClientRect();
    if (_classPrivateFieldGet10(this, _menu)) {
      _classPrivateFieldGet10(this, _menu).open();
      _classPrivateFieldGet10(this, _menu).setPosition({
        left: this.hot.isLtr() ? rect.left - 5 : rect.left - 31,
        top: rect.top - 1,
        width: rect.width,
        height: rect.height
      });
      _classPrivateFieldGet10(this, _menu).getNavigator().toFirstItem();
      _classPrivateFieldGet10(this, _menu).getKeyboardShortcutsCtrl().addCustomShortcuts([{
        keys: [["Tab"], ["Shift", "Tab"]],
        callback: (event) => {
          this.closeOptions();
          this.runLocalHooks("tabKeydown", event);
        }
      }, {
        keys: [["Control/Meta", "A"]],
        callback: () => false
      }]);
    }
  }
  /**
   * Close select dropdown menu.
   */
  closeOptions() {
    if (_classPrivateFieldGet10(this, _menu)) {
      _classPrivateFieldGet10(this, _menu).close();
    }
  }
  /**
   * Focus element.
   */
  focus() {
    if (this.isBuilt()) {
      this.element.focus();
    }
  }
  /**
   * Destroy instance.
   */
  destroy() {
    if (_classPrivateFieldGet10(this, _menu)) {
      _classPrivateFieldGet10(this, _menu).destroy();
      _classPrivateFieldSet9(this, _menu, null);
    }
    if (_classPrivateFieldGet10(this, _caption)) {
      _classPrivateFieldGet10(this, _caption).destroy();
    }
    if (_classPrivateFieldGet10(this, _dropdown)) {
      _classPrivateFieldGet10(this, _dropdown).destroy();
    }
    super.destroy();
  }
};
function _onMenuSelect2(command) {
  if (command.name !== KEY) {
    this.options.value = command;
    this.update();
    this.runLocalHooks("select", this.options.value);
  }
}
function _onMenuClosed2() {
  this.runLocalHooks("afterClose");
}
function _onClick2() {
  this.openOptions();
}

// node_modules/handsontable/plugins/filters/component/condition.mjs
function _classPrivateMethodInitSpec18(obj, privateSet) {
  _checkPrivateRedeclaration20(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration20(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty29(obj, key, value) {
  key = _toPropertyKey29(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey29(arg) {
  var key = _toPrimitive29(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive29(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet18(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var _onConditionSelect = /* @__PURE__ */ new WeakSet();
var _onInputKeyDown = /* @__PURE__ */ new WeakSet();
var ConditionComponent = class extends BaseComponent {
  constructor(hotInstance, options) {
    super(hotInstance, {
      id: options.id,
      stateless: false
    });
    _classPrivateMethodInitSpec18(this, _onInputKeyDown);
    _classPrivateMethodInitSpec18(this, _onConditionSelect);
    _defineProperty29(this, "name", "");
    _defineProperty29(this, "addSeparator", false);
    this.name = options.name;
    this.addSeparator = options.addSeparator;
    this.elements.push(new SelectUI(this.hot, {
      menuContainer: options.menuContainer
    }));
    this.elements.push(new InputUI(this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_VALUE
    }));
    this.elements.push(new InputUI(this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE
    }));
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   *
   * @private
   */
  registerHooks() {
    this.getSelectElement().addLocalHook("select", (command) => _classPrivateMethodGet18(this, _onConditionSelect, _onConditionSelect2).call(this, command)).addLocalHook("afterClose", () => this.runLocalHooks("afterClose")).addLocalHook("tabKeydown", (event) => this.runLocalHooks("selectTabKeydown", event));
    arrayEach(this.getInputElements(), (input) => {
      input.addLocalHook("keydown", (event) => _classPrivateMethodGet18(this, _onInputKeyDown, _onInputKeyDown2).call(this, event));
    });
  }
  /**
   * Set state of the component.
   *
   * @param {object} value State to restore.
   */
  setState(value) {
    this.reset();
    if (!value) {
      return;
    }
    const copyOfCommand = clone(value.command);
    if (copyOfCommand.name.startsWith(FILTERS_CONDITIONS_NAMESPACE)) {
      copyOfCommand.name = this.hot.getTranslatedPhrase(copyOfCommand.name);
    }
    this.getSelectElement().setValue(copyOfCommand);
    arrayEach(value.args, (arg, index) => {
      if (index > copyOfCommand.inputsCount - 1) {
        return false;
      }
      const element = this.getInputElement(index);
      element.setValue(arg);
      element[copyOfCommand.inputsCount > index ? "show" : "hide"]();
      if (!index) {
        this.hot._registerTimeout(() => element.focus(), 10);
      }
    });
  }
  /**
   * Export state of the component (get selected filter and filter arguments).
   *
   * @returns {object} Returns object where `command` key keeps used condition filter and `args` key its arguments.
   */
  getState() {
    const command = this.getSelectElement().getValue() || getConditionDescriptor(CONDITION_NAME);
    const args = [];
    arrayEach(this.getInputElements(), (element, index) => {
      if (command.inputsCount > index) {
        args.push(element.getValue());
      }
    });
    return {
      command,
      args
    };
  }
  /**
   * Update state of component.
   *
   * @param {object} condition The condition object.
   * @param {object} condition.command The command object with condition name as `key` property.
   * @param {Array} condition.args An array of values to compare.
   * @param {number} column Physical column index.
   */
  updateState(condition24, column) {
    const command = condition24 ? getConditionDescriptor(condition24.name) : getConditionDescriptor(CONDITION_NAME);
    this.state.setValueAtIndex(column, {
      command,
      args: condition24 ? condition24.args : []
    });
    if (!condition24) {
      arrayEach(this.getInputElements(), (element) => element.setValue(null));
    }
  }
  /**
   * Get select element.
   *
   * @returns {SelectUI}
   */
  getSelectElement() {
    return this.elements.filter((element) => element instanceof SelectUI)[0];
  }
  /**
   * Get input element.
   *
   * @param {number} index Index an array of elements.
   * @returns {InputUI}
   */
  getInputElement() {
    let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.getInputElements()[index];
  }
  /**
   * Get input elements.
   *
   * @returns {Array}
   */
  getInputElements() {
    return this.elements.filter((element) => element instanceof InputUI);
  }
  /**
   * Get menu object descriptor.
   *
   * @returns {object}
   */
  getMenuItemDescriptor() {
    return {
      key: this.id,
      name: this.name,
      isCommand: false,
      disableSelection: true,
      hidden: () => this.isHidden(),
      renderer: (hot, wrapper, row, col, prop, value) => {
        addClass(wrapper.parentNode, "htFiltersMenuCondition");
        if (this.addSeparator) {
          addClass(wrapper.parentNode, "border");
        }
        const label = this.hot.rootDocument.createElement("div");
        addClass(label, "htFiltersMenuLabel");
        label.textContent = value;
        wrapper.appendChild(label);
        arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));
        return wrapper;
      }
    };
  }
  /**
   * Reset elements to their initial state.
   */
  reset() {
    const selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
    let items = [getConditionDescriptor(CONDITION_NAME)];
    if (selectedColumn !== null) {
      const {
        visualIndex
      } = selectedColumn;
      items = getOptionsList(this.hot.getDataType(0, visualIndex, this.hot.countRows(), visualIndex));
    }
    arrayEach(this.getInputElements(), (element) => element.hide());
    this.getSelectElement().setItems(items);
    super.reset();
    this.getSelectElement().setValue(items[0]);
  }
};
function _onConditionSelect2(command) {
  arrayEach(this.getInputElements(), (element, index) => {
    element[command.inputsCount > index ? "show" : "hide"]();
    if (index === 0) {
      this.hot._registerTimeout(() => element.focus(), 10);
    }
  });
  this.runLocalHooks("change", command);
}
function _onInputKeyDown2(event) {
  if (isKey(event.keyCode, "ESCAPE")) {
    this.runLocalHooks("cancel");
    stopImmediatePropagation(event);
  }
}

// node_modules/handsontable/plugins/filters/ui/radioInput.mjs
function _classPrivateFieldInitSpec11(obj, privateMap, value) {
  _checkPrivateRedeclaration21(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration21(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet11(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor11(receiver, privateMap, "get");
  return _classApplyDescriptorGet11(receiver, descriptor);
}
function _classApplyDescriptorGet11(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet10(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor11(receiver, privateMap, "set");
  _classApplyDescriptorSet10(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor11(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet10(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _input2 = /* @__PURE__ */ new WeakMap();
var _label = /* @__PURE__ */ new WeakMap();
var RadioInputUI = class _RadioInputUI extends BaseUI {
  static get DEFAULTS() {
    return clone({
      type: "radio",
      tagName: "input",
      className: "htUIRadio",
      label: {}
    });
  }
  /**
   * The reference to the input element.
   *
   * @type {HTMLInputElement}
   */
  constructor(hotInstance, options) {
    super(hotInstance, extend(_RadioInputUI.DEFAULTS, options));
    _classPrivateFieldInitSpec11(this, _input2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec11(this, _label, {
      writable: true,
      value: void 0
    });
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    const label = this.hot.rootDocument.createElement("label");
    label.textContent = this.translateIfPossible(this.options.label.textContent);
    label.htmlFor = this.translateIfPossible(this.options.label.htmlFor);
    _classPrivateFieldSet10(this, _label, label);
    _classPrivateFieldSet10(this, _input2, this._element.firstChild);
    _classPrivateFieldGet11(this, _input2).checked = this.options.checked;
    this._element.appendChild(label);
    this.update();
  }
  /**
   * Update element.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    _classPrivateFieldGet11(this, _label).textContent = this.translateIfPossible(this.options.label.textContent);
  }
  /**
   * Check if radio button is checked.
   *
   * @returns {boolean}
   */
  isChecked() {
    return _classPrivateFieldGet11(this, _input2).checked;
  }
  /**
   * Set input checked attribute.
   *
   * @param {boolean} value Set the component state.
   */
  setChecked() {
    let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (this.isBuilt()) {
      _classPrivateFieldGet11(this, _input2).checked = value;
    }
  }
  /**
   * Focus element.
   */
  focus() {
    if (this.isBuilt()) {
      _classPrivateFieldGet11(this, _input2).focus();
    }
  }
};

// node_modules/handsontable/plugins/filters/component/operators.mjs
function _classPrivateMethodInitSpec19(obj, privateSet) {
  _checkPrivateRedeclaration22(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration22(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty30(obj, key, value) {
  key = _toPropertyKey30(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey30(arg) {
  var key = _toPrimitive30(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive30(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet19(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var SELECTED_AT_START_ELEMENT_INDEX = 0;
var _onRadioInputChange = /* @__PURE__ */ new WeakSet();
var OperatorsComponent = class extends BaseComponent {
  constructor(hotInstance, options) {
    super(hotInstance, {
      id: options.id,
      stateless: false
    });
    _classPrivateMethodInitSpec19(this, _onRadioInputChange);
    _defineProperty30(this, "name", "");
    this.name = options.name;
    this.buildOperatorsElement();
  }
  /**
   * Get menu object descriptor.
   *
   * @returns {object}
   */
  getMenuItemDescriptor() {
    return {
      key: this.id,
      name: this.name,
      isCommand: false,
      disableSelection: true,
      hidden: () => this.isHidden(),
      renderer: (hot, wrapper) => {
        addClass(wrapper.parentNode, "htFiltersMenuOperators");
        arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));
        return wrapper;
      }
    };
  }
  /**
   * Add RadioInputUI elements to component.
   *
   * @private
   */
  buildOperatorsElement() {
    const operationKeys = [OPERATION_ID, OPERATION_ID2];
    arrayEach(operationKeys, (operation) => {
      const radioInput = new RadioInputUI(this.hot, {
        name: "operator",
        label: {
          htmlFor: operation,
          textContent: getOperationName(operation)
        },
        value: operation,
        checked: operation === operationKeys[SELECTED_AT_START_ELEMENT_INDEX],
        id: operation
      });
      radioInput.addLocalHook("change", (event) => _classPrivateMethodGet19(this, _onRadioInputChange, _onRadioInputChange2).call(this, event));
      this.elements.push(radioInput);
    });
  }
  /**
   * Set state of operators component to check radio input at specific `index`.
   *
   * @param {number} searchedIndex Index of radio input to check.
   */
  setChecked(searchedIndex) {
    if (this.elements.length < searchedIndex) {
      throw Error(toSingleLine`Radio button with index ${searchedIndex} doesn't exist.`);
    }
    arrayEach(this.elements, (element, index) => {
      element.setChecked(index === searchedIndex);
    });
  }
  /**
   * Get `id` of active operator.
   *
   * @returns {string}
   */
  getActiveOperationId() {
    const operationElement = this.elements.find((element) => element instanceof RadioInputUI && element.isChecked());
    if (operationElement) {
      return operationElement.getValue();
    }
    return OPERATION_ID;
  }
  /**
   * Export state of the component (get selected operator).
   *
   * @returns {string} Returns `id` of selected operator.
   */
  getState() {
    return this.getActiveOperationId();
  }
  /**
   * Set state of the component.
   *
   * @param {object} value State to restore.
   */
  setState(value) {
    this.reset();
    if (value && this.getActiveOperationId() !== value) {
      arrayEach(this.elements, (element) => {
        element.setChecked(element.getValue() === value);
      });
    }
  }
  /**
   * Update state of component.
   *
   * @param {string} [operationId='conjunction'] Id of selected operation.
   * @param {number} column Physical column index.
   */
  updateState() {
    let operationId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OPERATION_ID;
    let column = arguments.length > 1 ? arguments[1] : void 0;
    let selectedOperationId = operationId;
    if (selectedOperationId === OPERATION_ID3) {
      selectedOperationId = OPERATION_ID2;
    }
    this.state.setValueAtIndex(column, selectedOperationId);
  }
  /**
   * Reset elements to their initial state.
   */
  reset() {
    this.setChecked(SELECTED_AT_START_ELEMENT_INDEX);
  }
};
function _onRadioInputChange2(event) {
  this.setState(event.target.value);
}

// node_modules/handsontable/plugins/filters/ui/link.mjs
function _classPrivateFieldInitSpec12(obj, privateMap, value) {
  _checkPrivateRedeclaration23(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration23(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet12(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor12(receiver, privateMap, "get");
  return _classApplyDescriptorGet12(receiver, descriptor);
}
function _classApplyDescriptorGet12(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet11(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor12(receiver, privateMap, "set");
  _classApplyDescriptorSet11(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor12(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet11(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _link = /* @__PURE__ */ new WeakMap();
var LinkUI = class _LinkUI extends BaseUI {
  static get DEFAULTS() {
    return clone({
      href: "#",
      tagName: "a",
      tabIndex: -1,
      role: "button"
    });
  }
  /**
   * The reference to the link element.
   *
   * @type {HTMLLinkElement}
   */
  constructor(hotInstance, options) {
    super(hotInstance, extend(_LinkUI.DEFAULTS, options));
    _classPrivateFieldInitSpec12(this, _link, {
      writable: true,
      value: void 0
    });
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    _classPrivateFieldSet11(this, _link, this._element.firstChild);
  }
  /**
   * Update element.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    _classPrivateFieldGet12(this, _link).textContent = this.translateIfPossible(this.options.textContent);
  }
  /**
   * Focus element.
   */
  focus() {
    if (this.isBuilt()) {
      _classPrivateFieldGet12(this, _link).focus();
    }
  }
  /**
   * Activate the element.
   */
  activate() {
    _classPrivateFieldGet12(this, _link).click();
  }
};

// node_modules/handsontable/plugins/filters/ui/multipleSelect.mjs
function _classPrivateMethodInitSpec20(obj, privateSet) {
  _checkPrivateRedeclaration24(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec13(obj, privateMap, value) {
  _checkPrivateRedeclaration24(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration24(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet20(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet13(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor13(receiver, privateMap, "get");
  return _classApplyDescriptorGet13(receiver, descriptor);
}
function _classApplyDescriptorGet13(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet12(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor13(receiver, privateMap, "set");
  _classApplyDescriptorSet12(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor13(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet12(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var SHORTCUTS_GROUP7 = "multipleSelect.itemBox";
var _items2 = /* @__PURE__ */ new WeakMap();
var _itemsBox = /* @__PURE__ */ new WeakMap();
var _locale = /* @__PURE__ */ new WeakMap();
var _searchInput = /* @__PURE__ */ new WeakMap();
var _selectAllUI = /* @__PURE__ */ new WeakMap();
var _clearAllUI = /* @__PURE__ */ new WeakMap();
var _onInput = /* @__PURE__ */ new WeakSet();
var _onInputKeyDown3 = /* @__PURE__ */ new WeakSet();
var _onSelectAllClick = /* @__PURE__ */ new WeakSet();
var _onClearAllClick = /* @__PURE__ */ new WeakSet();
var MultipleSelectUI = class _MultipleSelectUI extends BaseUI {
  static get DEFAULTS() {
    return clone({
      className: "htUIMultipleSelect",
      value: []
    });
  }
  /**
   * List of available select options.
   *
   * @type {Array}
   */
  constructor(hotInstance, options) {
    super(hotInstance, extend(_MultipleSelectUI.DEFAULTS, options));
    _classPrivateMethodInitSpec20(this, _onClearAllClick);
    _classPrivateMethodInitSpec20(this, _onSelectAllClick);
    _classPrivateMethodInitSpec20(this, _onInputKeyDown3);
    _classPrivateMethodInitSpec20(this, _onInput);
    _classPrivateFieldInitSpec13(this, _items2, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec13(this, _itemsBox, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec13(this, _locale, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec13(this, _searchInput, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec13(this, _selectAllUI, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec13(this, _clearAllUI, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet12(this, _searchInput, new InputUI(this.hot, {
      placeholder: FILTERS_BUTTONS_PLACEHOLDER_SEARCH,
      className: "htUIMultipleSelectSearch"
    }));
    _classPrivateFieldSet12(this, _selectAllUI, new LinkUI(this.hot, {
      textContent: FILTERS_BUTTONS_SELECT_ALL,
      className: "htUISelectAll"
    }));
    _classPrivateFieldSet12(this, _clearAllUI, new LinkUI(this.hot, {
      textContent: FILTERS_BUTTONS_CLEAR,
      className: "htUIClearAll"
    }));
    this.registerHooks();
  }
  /**
   * Gets the instance of the internal Handsontable that acts here as a listbox component.
   *
   * @returns {Handsontable}
   */
  getItemsBox() {
    return _classPrivateFieldGet13(this, _itemsBox);
  }
  /**
   * Register all necessary hooks.
   */
  registerHooks() {
    _classPrivateFieldGet13(this, _searchInput).addLocalHook("keydown", (event) => _classPrivateMethodGet20(this, _onInputKeyDown3, _onInputKeyDown22).call(this, event));
    _classPrivateFieldGet13(this, _searchInput).addLocalHook("input", (event) => _classPrivateMethodGet20(this, _onInput, _onInput2).call(this, event));
    _classPrivateFieldGet13(this, _selectAllUI).addLocalHook("click", (event) => _classPrivateMethodGet20(this, _onSelectAllClick, _onSelectAllClick2).call(this, event));
    _classPrivateFieldGet13(this, _clearAllUI).addLocalHook("click", (event) => _classPrivateMethodGet20(this, _onClearAllClick, _onClearAllClick2).call(this, event));
  }
  /**
   * Set available options.
   *
   * @param {Array} items Array of objects with `checked` and `label` property.
   */
  setItems(items) {
    _classPrivateFieldSet12(this, _items2, items);
    if (_classPrivateFieldGet13(this, _itemsBox)) {
      _classPrivateFieldGet13(this, _itemsBox).loadData(_classPrivateFieldGet13(this, _items2));
    }
  }
  /**
   * Set a locale for the component.
   *
   * @param {string} locale Locale used for filter actions performed on data, ie. `en-US`.
   */
  setLocale(locale) {
    _classPrivateFieldSet12(this, _locale, locale);
  }
  /**
   * Get a locale for the component.
   *
   * @returns {string}
   */
  getLocale() {
    return _classPrivateFieldGet13(this, _locale);
  }
  /**
   * Get all available options.
   *
   * @returns {Array}
   */
  getItems() {
    return [..._classPrivateFieldGet13(this, _items2)];
  }
  /**
   * Get element value.
   *
   * @returns {Array} Array of selected values.
   */
  getValue() {
    return itemsToValue(_classPrivateFieldGet13(this, _items2));
  }
  /**
   * Gets the instance of the search input element.
   *
   * @returns {InputUI}
   */
  getSearchInputElement() {
    return _classPrivateFieldGet13(this, _searchInput);
  }
  /**
   * Gets the instance of the "select all" link element.
   *
   * @returns {LinkUI}
   */
  getSelectAllElement() {
    return _classPrivateFieldGet13(this, _selectAllUI);
  }
  /**
   * Gets the instance of the "clear" link element.
   *
   * @returns {LinkUI}
   */
  getClearAllElement() {
    return _classPrivateFieldGet13(this, _clearAllUI);
  }
  /**
   * Check if all values listed in element are selected.
   *
   * @returns {boolean}
   */
  isSelectedAllValues() {
    return _classPrivateFieldGet13(this, _items2).length === this.getValue().length;
  }
  /**
   * Build DOM structure.
   */
  build() {
    super.build();
    const {
      rootDocument
    } = this.hot;
    const itemsBoxWrapper = rootDocument.createElement("div");
    const selectionControl = new BaseUI(this.hot, {
      className: "htUISelectionControls",
      children: [_classPrivateFieldGet13(this, _selectAllUI), _classPrivateFieldGet13(this, _clearAllUI)]
    });
    this._element.appendChild(_classPrivateFieldGet13(this, _searchInput).element);
    this._element.appendChild(selectionControl.element);
    this._element.appendChild(itemsBoxWrapper);
    const hotInitializer = (wrapper) => {
      if (!this._element) {
        return;
      }
      if (_classPrivateFieldGet13(this, _itemsBox)) {
        _classPrivateFieldGet13(this, _itemsBox).destroy();
      }
      addClass(wrapper, "htUIMultipleSelectHot");
      _classPrivateFieldSet12(this, _itemsBox, new this.hot.constructor(wrapper, {
        data: _classPrivateFieldGet13(this, _items2),
        columns: [{
          data: "checked",
          type: "checkbox",
          label: {
            property: "visualValue",
            position: "after"
          }
        }],
        beforeRenderer: (TD, row, col, prop, value, cellProperties) => {
          TD.title = cellProperties.instance.getDataAtRowProp(row, cellProperties.label.property);
        },
        afterListen: () => {
          this.runLocalHooks("focus", this);
        },
        beforeOnCellMouseUp: () => {
          _classPrivateFieldGet13(this, _itemsBox).listen();
        },
        maxCols: 1,
        autoWrapCol: true,
        height: 110,
        // Workaround for #151.
        colWidths: () => _classPrivateFieldGet13(this, _itemsBox).container.scrollWidth - getScrollbarWidth(rootDocument),
        copyPaste: false,
        disableVisualSelection: "area",
        fillHandle: false,
        fragmentSelection: "cell",
        tabMoves: {
          row: 1,
          col: 0
        },
        layoutDirection: this.hot.isRtl() ? "rtl" : "ltr"
      }));
      _classPrivateFieldGet13(this, _itemsBox).init();
      const shortcutManager = _classPrivateFieldGet13(this, _itemsBox).getShortcutManager();
      const gridContext = shortcutManager.getContext("grid");
      gridContext.removeShortcutsByKeys(["Tab"]);
      gridContext.removeShortcutsByKeys(["Shift", "Tab"]);
      gridContext.addShortcut({
        keys: [["Escape"]],
        callback: (event) => {
          this.runLocalHooks("keydown", event, this);
        },
        group: SHORTCUTS_GROUP7
      });
      gridContext.addShortcut({
        keys: [["Tab"], ["Shift", "Tab"]],
        callback: (event) => {
          _classPrivateFieldGet13(this, _itemsBox).deselectCell();
          this.runLocalHooks("keydown", event, this);
          this.runLocalHooks("listTabKeydown", event, this);
        },
        group: SHORTCUTS_GROUP7
      });
    };
    hotInitializer(itemsBoxWrapper);
    this.hot._registerTimeout(() => hotInitializer(itemsBoxWrapper), 100);
  }
  /**
   * Focus element.
   */
  focus() {
    if (this.isBuilt()) {
      _classPrivateFieldGet13(this, _itemsBox).listen();
    }
  }
  /**
   * Reset DOM structure.
   */
  reset() {
    _classPrivateFieldGet13(this, _searchInput).reset();
    _classPrivateFieldGet13(this, _selectAllUI).reset();
    _classPrivateFieldGet13(this, _clearAllUI).reset();
  }
  /**
   * Update DOM structure.
   */
  update() {
    if (!this.isBuilt()) {
      return;
    }
    _classPrivateFieldGet13(this, _itemsBox).loadData(valueToItems(_classPrivateFieldGet13(this, _items2), this.options.value));
    super.update();
  }
  /**
   * Destroy instance.
   */
  destroy() {
    if (_classPrivateFieldGet13(this, _itemsBox)) {
      _classPrivateFieldGet13(this, _itemsBox).destroy();
    }
    _classPrivateFieldGet13(this, _searchInput).destroy();
    _classPrivateFieldGet13(this, _clearAllUI).destroy();
    _classPrivateFieldGet13(this, _selectAllUI).destroy();
    _classPrivateFieldSet12(this, _searchInput, null);
    _classPrivateFieldSet12(this, _clearAllUI, null);
    _classPrivateFieldSet12(this, _selectAllUI, null);
    _classPrivateFieldSet12(this, _itemsBox, null);
    _classPrivateFieldSet12(this, _items2, null);
    super.destroy();
  }
};
function _onInput2(event) {
  const value = event.target.value.toLocaleLowerCase(this.getLocale());
  let filteredItems;
  if (value === "") {
    filteredItems = [..._classPrivateFieldGet13(this, _items2)];
  } else {
    filteredItems = arrayFilter(_classPrivateFieldGet13(this, _items2), (item) => `${item.value}`.toLocaleLowerCase(this.getLocale()).indexOf(value) >= 0);
  }
  _classPrivateFieldGet13(this, _itemsBox).loadData(filteredItems);
}
function _onInputKeyDown22(event) {
  this.runLocalHooks("keydown", event, this);
  const isKeyCode = partial(isKey, event.keyCode);
  if (isKeyCode("ARROW_DOWN")) {
    event.preventDefault();
    stopImmediatePropagation(event);
    _classPrivateFieldGet13(this, _itemsBox).listen();
    _classPrivateFieldGet13(this, _itemsBox).selectCell(0, 0);
  }
}
function _onSelectAllClick2(event) {
  const changes = [];
  event.preventDefault();
  arrayEach(_classPrivateFieldGet13(this, _itemsBox).getSourceData(), (row, rowIndex) => {
    row.checked = true;
    changes.push(dataRowToChangesArray(row, rowIndex)[0]);
  });
  _classPrivateFieldGet13(this, _itemsBox).setSourceDataAtCell(changes);
}
function _onClearAllClick2(event) {
  const changes = [];
  event.preventDefault();
  arrayEach(_classPrivateFieldGet13(this, _itemsBox).getSourceData(), (row, rowIndex) => {
    row.checked = false;
    changes.push(dataRowToChangesArray(row, rowIndex)[0]);
  });
  _classPrivateFieldGet13(this, _itemsBox).setSourceDataAtCell(changes);
}
function valueToItems(availableItems, selectedValue) {
  const arrayAssertion = createArrayAssertion(selectedValue);
  return arrayMap(availableItems, (item) => {
    item.checked = arrayAssertion(item.value);
    return item;
  });
}
function itemsToValue(availableItems) {
  const items = [];
  arrayEach(availableItems, (item) => {
    if (item.checked) {
      items.push(item.value);
    }
  });
  return items;
}

// node_modules/handsontable/plugins/filters/component/value.mjs
function _classPrivateMethodInitSpec21(obj, privateSet) {
  _checkPrivateRedeclaration25(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration25(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty31(obj, key, value) {
  key = _toPropertyKey31(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey31(arg) {
  var key = _toPrimitive31(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive31(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet21(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var _onInputKeyDown4 = /* @__PURE__ */ new WeakSet();
var ValueComponent = class extends BaseComponent {
  constructor(hotInstance, options) {
    super(hotInstance, {
      id: options.id,
      stateless: false
    });
    _classPrivateMethodInitSpec21(this, _onInputKeyDown4);
    _defineProperty31(this, "name", "");
    this.name = options.name;
    this.elements.push(new MultipleSelectUI(this.hot));
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   *
   * @private
   */
  registerHooks() {
    this.getMultipleSelectElement().addLocalHook("keydown", (event) => _classPrivateMethodGet21(this, _onInputKeyDown4, _onInputKeyDown23).call(this, event)).addLocalHook("listTabKeydown", (event) => this.runLocalHooks("listTabKeydown", event));
  }
  /**
   * Gets the list of elements from which the component is built.
   *
   * @returns {BaseUI[]}
   */
  getElements() {
    const selectElement = this.getMultipleSelectElement();
    return [selectElement.getSearchInputElement(), selectElement.getSelectAllElement(), selectElement.getClearAllElement(), this.getMultipleSelectElement()];
  }
  /**
   * Set state of the component.
   *
   * @param {object} value The component value.
   */
  setState(value) {
    this.reset();
    if (value && value.command.key === CONDITION_NAME21) {
      const select = this.getMultipleSelectElement();
      select.setItems(value.itemsSnapshot);
      select.setValue(value.args[0]);
      select.setLocale(value.locale);
    }
  }
  /**
   * Export state of the component (get selected filter and filter arguments).
   *
   * @returns {object} Returns object where `command` key keeps used condition filter and `args` key its arguments.
   */
  getState() {
    const select = this.getMultipleSelectElement();
    const availableItems = select.getItems();
    return {
      command: {
        key: select.isSelectedAllValues() || !availableItems.length ? CONDITION_NAME : CONDITION_NAME21
      },
      args: [select.getValue()],
      itemsSnapshot: availableItems
    };
  }
  /**
   * Update state of component.
   *
   * @param {object} stateInfo Information about state containing stack of edited column,
   * stack of dependent conditions, data factory and optional condition arguments change. It's described by object containing keys:
   * `editedConditionStack`, `dependentConditionStacks`, `visibleDataFactory` and `conditionArgsChange`.
   */
  updateState(stateInfo) {
    const updateColumnState = (physicalColumn, conditions2, conditionArgsChange, filteredRowsFactory, conditionsStack) => {
      const [firstByValueCondition] = arrayFilter(conditions2, (condition24) => condition24.name === CONDITION_NAME21);
      const state = {};
      const defaultBlankCellValue = this.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);
      if (firstByValueCondition) {
        const rowValues = unifyColumnValues(arrayMap(filteredRowsFactory(physicalColumn, conditionsStack), (row) => row.value));
        if (conditionArgsChange) {
          firstByValueCondition.args[0] = conditionArgsChange;
        }
        const selectedValues = [];
        const itemsSnapshot = intersectValues(rowValues, firstByValueCondition.args[0], defaultBlankCellValue, (item) => {
          if (item.checked) {
            selectedValues.push(item.value);
          }
        });
        const column = stateInfo.editedConditionStack.column;
        state.locale = this.hot.getCellMeta(0, column).locale;
        state.args = [selectedValues];
        state.command = getConditionDescriptor(CONDITION_NAME21);
        state.itemsSnapshot = itemsSnapshot;
      } else {
        state.args = [];
        state.command = getConditionDescriptor(CONDITION_NAME);
      }
      this.state.setValueAtIndex(physicalColumn, state);
    };
    updateColumnState(stateInfo.editedConditionStack.column, stateInfo.editedConditionStack.conditions, stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory);
    if (stateInfo.dependentConditionStacks.length) {
      updateColumnState(stateInfo.dependentConditionStacks[0].column, stateInfo.dependentConditionStacks[0].conditions, stateInfo.conditionArgsChange, stateInfo.filteredRowsFactory, stateInfo.editedConditionStack);
    }
  }
  /**
   * Get multiple select element.
   *
   * @returns {MultipleSelectUI}
   */
  getMultipleSelectElement() {
    return this.elements.filter((element) => element instanceof MultipleSelectUI)[0];
  }
  /**
   * Get object descriptor for menu item entry.
   *
   * @returns {object}
   */
  getMenuItemDescriptor() {
    return {
      key: this.id,
      name: this.name,
      isCommand: false,
      disableSelection: true,
      hidden: () => this.isHidden(),
      renderer: (hot, wrapper, row, col, prop, value) => {
        addClass(wrapper.parentNode, "htFiltersMenuValue");
        const label = this.hot.rootDocument.createElement("div");
        addClass(label, "htFiltersMenuLabel");
        label.textContent = value;
        wrapper.appendChild(label);
        arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));
        return wrapper;
      }
    };
  }
  /**
   * Reset elements to their initial state.
   */
  reset() {
    const defaultBlankCellValue = this.hot.getTranslatedPhrase(FILTERS_VALUES_BLANK_CELLS);
    const values = unifyColumnValues(this._getColumnVisibleValues());
    const items = intersectValues(values, values, defaultBlankCellValue);
    this.getMultipleSelectElement().setItems(items);
    super.reset();
    this.getMultipleSelectElement().setValue(values);
    const selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
    if (selectedColumn !== null) {
      this.getMultipleSelectElement().setLocale(this.hot.getCellMeta(0, selectedColumn.visualIndex).locale);
    }
  }
  /**
   * Get data for currently selected column.
   *
   * @returns {Array}
   * @private
   */
  _getColumnVisibleValues() {
    const selectedColumn = this.hot.getPlugin("filters").getSelectedColumn();
    if (selectedColumn === null) {
      return [];
    }
    return arrayMap(this.hot.getDataAtCol(selectedColumn.visualIndex), (v) => toEmptyString(v));
  }
};
function _onInputKeyDown23(event) {
  if (isKey(event.keyCode, "ESCAPE")) {
    this.runLocalHooks("cancel");
    stopImmediatePropagation(event);
  }
}

// node_modules/handsontable/plugins/filters/component/actionBar.mjs
var _class;
function _classPrivateMethodInitSpec22(obj, privateSet) {
  _checkPrivateRedeclaration26(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration26(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty32(obj, key, value) {
  key = _toPropertyKey32(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey32(arg) {
  var key = _toPrimitive32(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive32(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet22(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var _onButtonClick = /* @__PURE__ */ new WeakSet();
var ActionBarComponent = class _ActionBarComponent extends BaseComponent {
  static get BUTTON_OK() {
    return "ok";
  }
  static get BUTTON_CANCEL() {
    return "cancel";
  }
  constructor(hotInstance, options) {
    super(hotInstance, {
      id: options.id,
      stateless: true
    });
    _classPrivateMethodInitSpec22(this, _onButtonClick);
    _defineProperty32(this, "name", "");
    this.name = options.name;
    this.elements.push(new InputUI(this.hot, {
      type: "button",
      value: FILTERS_BUTTONS_OK,
      className: "htUIButton htUIButtonOK",
      identifier: _ActionBarComponent.BUTTON_OK
    }));
    this.elements.push(new InputUI(this.hot, {
      type: "button",
      value: FILTERS_BUTTONS_CANCEL,
      className: "htUIButton htUIButtonCancel",
      identifier: _ActionBarComponent.BUTTON_CANCEL
    }));
    this.registerHooks();
  }
  /**
   * Register all necessary hooks.
   *
   * @private
   */
  registerHooks() {
    arrayEach(this.elements, (element) => {
      element.addLocalHook("click", (event, button) => _classPrivateMethodGet22(this, _onButtonClick, _onButtonClick2).call(this, event, button));
    });
  }
  /**
   * Get menu object descriptor.
   *
   * @returns {object}
   */
  getMenuItemDescriptor() {
    return {
      key: this.id,
      name: this.name,
      isCommand: false,
      disableSelection: true,
      hidden: () => this.isHidden(),
      renderer: (hot, wrapper) => {
        addClass(wrapper.parentNode, "htFiltersMenuActionBar");
        arrayEach(this.elements, (ui) => wrapper.appendChild(ui.element));
        return wrapper;
      }
    };
  }
  /**
   * Fire accept event.
   */
  accept() {
    this.runLocalHooks("accept");
  }
  /**
   * Fire cancel event.
   */
  cancel() {
    this.runLocalHooks("cancel");
  }
};
_class = ActionBarComponent;
function _onButtonClick2(event, button) {
  if (button.options.identifier === _class.BUTTON_OK) {
    this.accept();
  } else {
    this.cancel();
  }
}

// node_modules/handsontable/plugins/filters/conditionCollection.mjs
function _defineProperty33(obj, key, value) {
  key = _toPropertyKey33(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey33(arg) {
  var key = _toPrimitive33(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive33(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var MAP_NAME = "ConditionCollection.filteringStates";
var ConditionCollection = class {
  constructor(hot) {
    let isMapRegistrable = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    _defineProperty33(this, "hot", void 0);
    _defineProperty33(this, "isMapRegistrable", void 0);
    _defineProperty33(this, "filteringStates", new LinkedPhysicalIndexToValueMap());
    this.hot = hot;
    this.isMapRegistrable = isMapRegistrable;
    if (this.isMapRegistrable === true) {
      this.hot.columnIndexMapper.registerMap(MAP_NAME, this.filteringStates);
    } else {
      this.filteringStates.init(this.hot.columnIndexMapper.getNumberOfIndexes());
    }
  }
  /**
   * Check if condition collection is empty (so no needed to filter data).
   *
   * @returns {boolean}
   */
  isEmpty() {
    return this.getFilteredColumns().length === 0;
  }
  /**
   * Check if value is matched to the criteria of conditions chain.
   *
   * @param {object} value Object with `value` and `meta` keys.
   * @param {number} column The physical column index.
   * @returns {boolean}
   */
  isMatch(value, column) {
    var _stateForColumn$condi;
    const stateForColumn = this.filteringStates.getValueAtIndex(column);
    const conditions2 = (_stateForColumn$condi = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.conditions) !== null && _stateForColumn$condi !== void 0 ? _stateForColumn$condi : [];
    const operation = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.operation;
    return this.isMatchInConditions(conditions2, value, operation);
  }
  /**
   * Check if the value is matches the conditions.
   *
   * @param {Array} conditions List of conditions.
   * @param {object} value Object with `value` and `meta` keys.
   * @param {string} [operationType='conjunction'] Type of conditions operation.
   * @returns {boolean}
   */
  isMatchInConditions(conditions2, value) {
    let operationType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OPERATION_ID;
    if (conditions2.length) {
      return getOperationFunc(operationType)(conditions2, value);
    }
    return true;
  }
  /**
   * Add condition to the collection.
   *
   * @param {number} column The physical column index.
   * @param {object} conditionDefinition Object with keys:
   *  * `command` Object, Command object with condition name as `key` property.
   *  * `args` Array, Condition arguments.
   * @param {string} [operation='conjunction'] Type of conditions operation.
   * @param {number} [position] Position to which condition will be added. When argument is undefined
   * the condition will be processed as the last condition.
   * @fires ConditionCollection#beforeAdd
   * @fires ConditionCollection#afterAdd
   */
  addCondition(column, conditionDefinition) {
    let operation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OPERATION_ID;
    let position = arguments.length > 3 ? arguments[3] : void 0;
    const localeForColumn = this.hot.getCellMeta(0, column).locale;
    const args = arrayMap(conditionDefinition.args, (v) => typeof v === "string" ? v.toLocaleLowerCase(localeForColumn) : v);
    const name = conditionDefinition.name || conditionDefinition.command.key;
    this.runLocalHooks("beforeAdd", column);
    const columnType = this.getOperation(column);
    if (columnType) {
      if (columnType !== operation) {
        throw Error(toSingleLine`The column of index ${column} has been already applied with a \`${columnType}\`\x20
        filter operation. Use \`removeConditions\` to clear the current conditions and then add new ones.\x20
        Mind that you cannot mix different types of operations (for instance, if you use \`conjunction\`,\x20
        use it consequently for a particular column).`);
      }
    } else if (isUndefined(operations[operation])) {
      throw new Error(toSingleLine`Unexpected operation named \`${operation}\`. Possible ones are\x20
        \`disjunction\` and \`conjunction\`.`);
    }
    const conditionsForColumn = this.getConditions(column);
    if (conditionsForColumn.length === 0) {
      this.filteringStates.setValueAtIndex(column, {
        operation,
        conditions: [{
          name,
          args,
          func: getCondition(name, args)
        }]
      }, position);
    } else {
      conditionsForColumn.push({
        name,
        args,
        func: getCondition(name, args)
      });
    }
    this.runLocalHooks("afterAdd", column);
  }
  /**
   * Get all added conditions from the collection at specified column index.
   *
   * @param {number} column The physical column index.
   * @returns {Array} Returns conditions collection as an array.
   */
  getConditions(column) {
    var _this$filteringStates, _this$filteringStates2;
    return (_this$filteringStates = (_this$filteringStates2 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates2 === void 0 ? void 0 : _this$filteringStates2.conditions) !== null && _this$filteringStates !== void 0 ? _this$filteringStates : [];
  }
  /**
   * Get operation for particular column.
   *
   * @param {number} column The physical column index.
   * @returns {string|undefined}
   */
  getOperation(column) {
    var _this$filteringStates3;
    return (_this$filteringStates3 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates3 === void 0 ? void 0 : _this$filteringStates3.operation;
  }
  /**
   * Get all filtered physical columns in the order in which actions are performed.
   *
   * @returns {Array}
   */
  getFilteredColumns() {
    return this.filteringStates.getEntries().map((_ref) => {
      let [physicalColumn] = _ref;
      return physicalColumn;
    });
  }
  /**
   * Gets position in the filtering states stack for the specific column.
   *
   * @param {number} column The physical column index.
   * @returns {number} Returns -1 when the column doesn't exist in the stack.
   */
  getColumnStackPosition(column) {
    return this.getFilteredColumns().indexOf(column);
  }
  /**
   * Export all previously added conditions.
   *
   * @returns {Array}
   */
  exportAllConditions() {
    return arrayReduce(this.filteringStates.getEntries(), (allConditions, _ref2) => {
      let [column, {
        operation,
        conditions: conditions2
      }] = _ref2;
      allConditions.push({
        column,
        operation,
        conditions: arrayMap(conditions2, (_ref3) => {
          let {
            name,
            args
          } = _ref3;
          return {
            name,
            args
          };
        })
      });
      return allConditions;
    }, []);
  }
  /**
   * Import conditions to the collection.
   *
   * @param {Array} conditions The collection of the conditions.
   */
  importAllConditions(conditions2) {
    this.clean();
    arrayEach(conditions2, (stack) => {
      arrayEach(stack.conditions, (condition24) => this.addCondition(stack.column, condition24));
    });
  }
  /**
   * Remove conditions at given column index.
   *
   * @param {number} column The physical column index.
   * @fires ConditionCollection#beforeRemove
   * @fires ConditionCollection#afterRemove
   */
  removeConditions(column) {
    this.runLocalHooks("beforeRemove", column);
    this.filteringStates.clearValue(column);
    this.runLocalHooks("afterRemove", column);
  }
  /**
   * Clean all conditions collection and reset order stack.
   *
   * @fires ConditionCollection#beforeClean
   * @fires ConditionCollection#afterClean
   */
  clean() {
    this.runLocalHooks("beforeClean");
    this.filteringStates.clear();
    this.runLocalHooks("afterClean");
  }
  /**
   * Check if at least one condition was added at specified column index. And if second parameter is passed then additionally
   * check if condition exists under its name.
   *
   * @param {number} column The physical column index.
   * @param {string} [name] Condition name.
   * @returns {boolean}
   */
  hasConditions(column, name) {
    const conditions2 = this.getConditions(column);
    if (name) {
      return conditions2.some((condition24) => condition24.name === name);
    }
    return conditions2.length > 0;
  }
  /**
   * Destroy object.
   */
  destroy() {
    if (this.isMapRegistrable) {
      this.hot.columnIndexMapper.unregisterMap(MAP_NAME);
    }
    this.filteringStates = null;
    this.clearLocalHooks();
  }
};
mixin(ConditionCollection, localHooks_default);
var conditionCollection_default = ConditionCollection;

// node_modules/handsontable/plugins/filters/dataFilter.mjs
function _defineProperty34(obj, key, value) {
  key = _toPropertyKey34(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey34(arg) {
  var key = _toPrimitive34(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive34(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var DataFilter = class {
  constructor(conditionCollection) {
    let columnDataFactory = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => [];
    _defineProperty34(this, "conditionCollection", void 0);
    _defineProperty34(this, "columnDataFactory", void 0);
    this.conditionCollection = conditionCollection;
    this.columnDataFactory = columnDataFactory;
  }
  /**
   * Filter data based on the conditions collection.
   *
   * @returns {Array}
   */
  filter() {
    let filteredData = [];
    arrayEach(this.conditionCollection.getFilteredColumns(), (physicalColumn, index) => {
      let columnData = this.columnDataFactory(physicalColumn);
      if (index) {
        columnData = this._getIntersectData(columnData, filteredData);
      }
      filteredData = this.filterByColumn(physicalColumn, columnData);
    });
    return filteredData;
  }
  /**
   * Filter data based on specified physical column index.
   *
   * @param {number} column The physical column index.
   * @param {Array} [dataSource] Data source as array of objects with `value` and `meta` keys (e.g. `{value: 'foo', meta: {}}`).
   * @returns {Array} Returns filtered data.
   */
  filterByColumn(column) {
    let dataSource = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const filteredData = [];
    arrayEach(dataSource, (dataRow) => {
      if (dataRow !== void 0 && this.conditionCollection.isMatch(dataRow, column)) {
        filteredData.push(dataRow);
      }
    });
    return filteredData;
  }
  /**
   * Intersect data.
   *
   * @private
   * @param {Array} data The data to intersect.
   * @param {Array} needles The collection intersected rows with the data.
   * @returns {Array}
   */
  _getIntersectData(data, needles) {
    const result = [];
    arrayEach(needles, (needleRow) => {
      const row = needleRow.meta.visualRow;
      if (data[row] !== void 0) {
        result[row] = data[row];
      }
    });
    return result;
  }
};
var dataFilter_default = DataFilter;

// node_modules/handsontable/plugins/filters/conditionUpdateObserver.mjs
function _classPrivateMethodInitSpec23(obj, privateSet) {
  _checkPrivateRedeclaration27(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration27(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty35(obj, key, value) {
  key = _toPropertyKey35(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey35(arg) {
  var key = _toPrimitive35(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive35(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet23(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var _onConditionBeforeModify = /* @__PURE__ */ new WeakSet();
var _onConditionBeforeClean = /* @__PURE__ */ new WeakSet();
var _onConditionAfterClean = /* @__PURE__ */ new WeakSet();
var ConditionUpdateObserver = class {
  constructor(hot, conditionCollection) {
    let columnDataFactory = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => [];
    _classPrivateMethodInitSpec23(this, _onConditionAfterClean);
    _classPrivateMethodInitSpec23(this, _onConditionBeforeClean);
    _classPrivateMethodInitSpec23(this, _onConditionBeforeModify);
    _defineProperty35(this, "hot", void 0);
    _defineProperty35(this, "conditionCollection", void 0);
    _defineProperty35(this, "columnDataFactory", void 0);
    _defineProperty35(this, "changes", []);
    _defineProperty35(this, "grouping", false);
    _defineProperty35(this, "latestEditedColumnPosition", -1);
    _defineProperty35(this, "latestOrderStack", []);
    this.hot = hot;
    this.conditionCollection = conditionCollection;
    this.columnDataFactory = columnDataFactory;
    this.conditionCollection.addLocalHook("beforeRemove", (column) => _classPrivateMethodGet23(this, _onConditionBeforeModify, _onConditionBeforeModify2).call(this, column));
    this.conditionCollection.addLocalHook("afterRemove", (column) => this.updateStatesAtColumn(column));
    this.conditionCollection.addLocalHook("afterAdd", (column) => this.updateStatesAtColumn(column));
    this.conditionCollection.addLocalHook("beforeClean", () => _classPrivateMethodGet23(this, _onConditionBeforeClean, _onConditionBeforeClean2).call(this));
    this.conditionCollection.addLocalHook("afterClean", () => _classPrivateMethodGet23(this, _onConditionAfterClean, _onConditionAfterClean2).call(this));
  }
  /**
   * Enable grouping changes. Grouping is helpful in situations when a lot of conditions is added in one moment. Instead of
   * trigger `update` hook for every condition by adding/removing you can group this changes and call `flush` method to trigger
   * it once.
   */
  groupChanges() {
    this.grouping = true;
  }
  /**
   * Flush all collected changes. This trigger `update` hook for every previously collected change from condition collection.
   */
  flush() {
    this.grouping = false;
    arrayEach(this.changes, (column) => {
      this.updateStatesAtColumn(column);
    });
    this.changes.length = 0;
  }
  /**
   * Update all related states which should be changed after invoking changes applied to current column.
   *
   * @param {number} column The column index.
   * @param {object} conditionArgsChange Object describing condition changes which can be handled by filters on `update` hook.
   * It contains keys `conditionKey` and `conditionValue` which refers to change specified key of condition to specified value
   * based on referred keys.
   */
  updateStatesAtColumn(column, conditionArgsChange) {
    var _this = this;
    if (this.grouping) {
      if (this.changes.indexOf(column) === -1) {
        this.changes.push(column);
      }
      return;
    }
    const allConditions = this.conditionCollection.exportAllConditions();
    let editedColumnPosition = this.conditionCollection.getColumnStackPosition(column);
    if (editedColumnPosition === -1) {
      editedColumnPosition = this.latestEditedColumnPosition;
    }
    const conditionsBefore = allConditions.slice(0, editedColumnPosition);
    const conditionsAfter = allConditions.slice(editedColumnPosition);
    if (conditionsAfter.length && conditionsAfter[0].column === column) {
      conditionsAfter.shift();
    }
    const visibleDataFactory = curry(function(curriedConditionsBefore, curriedColumn) {
      let conditionsStack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      const splitConditionCollection = new conditionCollection_default(_this.hot, false);
      const curriedConditionsBeforeArray = [].concat(curriedConditionsBefore, conditionsStack);
      splitConditionCollection.importAllConditions(curriedConditionsBeforeArray);
      const allRows = _this.columnDataFactory(curriedColumn);
      let visibleRows;
      if (splitConditionCollection.isEmpty()) {
        visibleRows = allRows;
      } else {
        visibleRows = new dataFilter_default(splitConditionCollection, (columnData) => _this.columnDataFactory(columnData)).filter();
      }
      visibleRows = arrayMap(visibleRows, (rowData) => rowData.meta.visualRow);
      const visibleRowsAssertion = createArrayAssertion(visibleRows);
      splitConditionCollection.destroy();
      return arrayFilter(allRows, (rowData) => visibleRowsAssertion(rowData.meta.visualRow));
    })(conditionsBefore);
    const editedConditions = [].concat(this.conditionCollection.getConditions(column));
    this.runLocalHooks("update", {
      editedConditionStack: {
        column,
        conditions: editedConditions
      },
      dependentConditionStacks: conditionsAfter,
      filteredRowsFactory: visibleDataFactory,
      conditionArgsChange
    });
  }
  /**
   * Destroy instance.
   */
  destroy() {
    this.clearLocalHooks();
    objectEach(this, (value, property) => {
      this[property] = null;
    });
  }
};
function _onConditionBeforeModify2(column) {
  this.latestEditedColumnPosition = this.conditionCollection.getColumnStackPosition(column);
}
function _onConditionBeforeClean2() {
  this.latestOrderStack = this.conditionCollection.getFilteredColumns();
}
function _onConditionAfterClean2() {
  arrayEach(this.latestOrderStack, (column) => {
    this.updateStatesAtColumn(column);
  });
}
mixin(ConditionUpdateObserver, localHooks_default);
var conditionUpdateObserver_default = ConditionUpdateObserver;

// node_modules/handsontable/plugins/filters/menu/focusNavigator.mjs
function createFocusNavigator(elements) {
  const navigator2 = createPaginator({
    initialPage: 0,
    size: () => elements.length,
    onItemSelect: (currentIndex, directItemChange) => {
      const element = elements[currentIndex];
      if (element instanceof MultipleSelectUI) {
        return directItemChange;
      }
      if (element.element && !isVisible(element.element)) {
        return false;
      }
      element.focus();
    }
  });
  return navigator2;
}

// node_modules/handsontable/plugins/filters/menu/focusController.mjs
var SHORTCUTS_MENU_CONTEXT = "filters";
function createMenuFocusController(mainMenu, menuItems) {
  let lastSelectedMenuItem = -1;
  const focusNavigator = createFocusNavigator(menuItems);
  const updateNavigatorPosition = (element) => () => {
    if (mainMenu.isOpened()) {
      mainMenu.getKeyboardShortcutsCtrl().listen(SHORTCUTS_MENU_CONTEXT);
    }
    focusNavigator.setCurrentPage(menuItems.indexOf(element));
  };
  menuItems.forEach((element) => {
    if (element instanceof BaseUI) {
      element.addLocalHook("click", updateNavigatorPosition(element));
      element.addLocalHook("focus", updateNavigatorPosition(element));
      element.addLocalHook("afterClose", updateNavigatorPosition(element));
    }
  });
  mainMenu.addLocalHook("afterSelectionChange", (selectedItem) => {
    if (!selectedItem.key.startsWith("filter_")) {
      focusNavigator.clear();
    }
  });
  function addKeyboardShortcuts(menu) {
    const mainMenuShortcutsCtrl = mainMenu.getKeyboardShortcutsCtrl();
    const currentMenuShortcutsCtrl = menu.getKeyboardShortcutsCtrl();
    focusNavigator.clear();
    currentMenuShortcutsCtrl.addCustomShortcuts([{
      keys: [["Tab"], ["Shift", "Tab"]],
      forwardToContext: mainMenuShortcutsCtrl.getContext(SHORTCUTS_MENU_CONTEXT),
      callback: () => {
        if (menu.isSubMenu()) {
          menu.close();
        }
        mainMenuShortcutsCtrl.listen(SHORTCUTS_MENU_CONTEXT);
      }
    }]);
    if (menu.isSubMenu()) {
      return;
    }
    mainMenuShortcutsCtrl.addCustomShortcuts([{
      keys: [["Tab"], ["Shift", "Tab"]],
      callback: (event) => {
        const menuNavigator = mainMenu.getNavigator();
        if (menuNavigator.getCurrentPage() > -1) {
          lastSelectedMenuItem = menuNavigator.getCurrentPage();
        }
        menuNavigator.clear();
        if (event.shiftKey) {
          focusNavigator.toPreviousItem();
        } else {
          focusNavigator.toNextItem();
        }
      }
    }, {
      keys: [["Escape"]],
      callback: () => {
        mainMenu.close();
      }
    }, {
      keys: [["Enter"], ["Space"]],
      preventDefault: false,
      callback: (event) => {
        const element = menuItems[focusNavigator.getCurrentPage()];
        if (element instanceof SelectUI) {
          element.openOptions();
          event.preventDefault();
        }
        if (element instanceof LinkUI) {
          element.activate();
          event.preventDefault();
        }
        if (!(element instanceof BaseUI)) {
          event.preventDefault();
        }
      }
    }], SHORTCUTS_MENU_CONTEXT);
  }
  mainMenu.addLocalHook("afterSubmenuOpen", addKeyboardShortcuts);
  mainMenu.addLocalHook("afterOpen", addKeyboardShortcuts);
  function listen() {
    mainMenu.focus();
    mainMenu.getKeyboardShortcutsCtrl().listen(SHORTCUTS_MENU_CONTEXT);
  }
  function getLastMenuPage() {
    return lastSelectedMenuItem;
  }
  return {
    ...focusNavigator,
    listen,
    getLastMenuPage
  };
}

// node_modules/handsontable/plugins/filters/filters.mjs
function _classPrivateMethodInitSpec24(obj, privateSet) {
  _checkPrivateRedeclaration28(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec14(obj, privateMap, value) {
  _checkPrivateRedeclaration28(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration28(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty36(obj, key, value) {
  key = _toPropertyKey36(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey36(arg) {
  var key = _toPrimitive36(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive36(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldSet13(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor14(receiver, privateMap, "set");
  _classApplyDescriptorSet13(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet13(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet14(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor14(receiver, privateMap, "get");
  return _classApplyDescriptorGet14(receiver, descriptor);
}
function _classExtractFieldDescriptor14(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet14(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet24(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY16 = "filters";
var PLUGIN_PRIORITY15 = 250;
var SHORTCUTS_GROUP8 = PLUGIN_KEY16;
var _menuFocusNavigator = /* @__PURE__ */ new WeakMap();
var _onAfterChange3 = /* @__PURE__ */ new WeakSet();
var _onAfterDropdownMenuShow = /* @__PURE__ */ new WeakSet();
var _onAfterDropdownMenuHide = /* @__PURE__ */ new WeakSet();
var _onAfterDropdownMenuDefaultOptions = /* @__PURE__ */ new WeakSet();
var _onActionBarSubmit = /* @__PURE__ */ new WeakSet();
var _onComponentChange = /* @__PURE__ */ new WeakSet();
var _onSelectUIClosed = /* @__PURE__ */ new WeakSet();
var _onAfterGetColHeader5 = /* @__PURE__ */ new WeakSet();
var _updateComponents = /* @__PURE__ */ new WeakSet();
var Filters = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY16;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY15;
  }
  static get PLUGIN_DEPS() {
    return ["plugin:DropdownMenu", "plugin:HiddenRows", "cell-type:checkbox"];
  }
  /**
   * Instance of {@link DropdownMenu}.
   *
   * @private
   * @type {DropdownMenu}
   */
  constructor(hotInstance) {
    super(hotInstance);
    _classPrivateMethodInitSpec24(this, _updateComponents);
    _classPrivateMethodInitSpec24(this, _onAfterGetColHeader5);
    _classPrivateMethodInitSpec24(this, _onSelectUIClosed);
    _classPrivateMethodInitSpec24(this, _onComponentChange);
    _classPrivateMethodInitSpec24(this, _onActionBarSubmit);
    _classPrivateMethodInitSpec24(this, _onAfterDropdownMenuDefaultOptions);
    _classPrivateMethodInitSpec24(this, _onAfterDropdownMenuHide);
    _classPrivateMethodInitSpec24(this, _onAfterDropdownMenuShow);
    _classPrivateMethodInitSpec24(this, _onAfterChange3);
    _defineProperty36(this, "dropdownMenuPlugin", null);
    _defineProperty36(this, "conditionCollection", null);
    _defineProperty36(this, "conditionUpdateObserver", null);
    _defineProperty36(this, "components", /* @__PURE__ */ new Map([["filter_by_condition", null], ["filter_operators", null], ["filter_by_condition2", null], ["filter_by_value", null], ["filter_action_bar", null]]));
    _defineProperty36(this, "filtersRowsMap", null);
    _classPrivateFieldInitSpec14(this, _menuFocusNavigator, {
      writable: true,
      value: void 0
    });
    this.hot.addHook("afterGetColHeader", (col, TH) => _classPrivateMethodGet24(this, _onAfterGetColHeader5, _onAfterGetColHeader24).call(this, col, TH));
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link Filters#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY16] ? true : false;
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.filtersRowsMap = this.hot.rowIndexMapper.registerMap(this.pluginName, new TrimmingMap());
    this.dropdownMenuPlugin = this.hot.getPlugin("dropdownMenu");
    const dropdownSettings = this.hot.getSettings().dropdownMenu;
    const menuContainer = dropdownSettings && dropdownSettings.uiContainer || this.hot.rootDocument.body;
    const addConfirmationHooks = (component) => {
      component.addLocalHook("accept", () => _classPrivateMethodGet24(this, _onActionBarSubmit, _onActionBarSubmit2).call(this, "accept"));
      component.addLocalHook("cancel", () => _classPrivateMethodGet24(this, _onActionBarSubmit, _onActionBarSubmit2).call(this, "cancel"));
      component.addLocalHook("change", (command) => _classPrivateMethodGet24(this, _onComponentChange, _onComponentChange2).call(this, component, command));
      return component;
    };
    const filterByConditionLabel = () => `${this.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_CONDITION)}:`;
    const filterValueLabel = () => `${this.hot.getTranslatedPhrase(FILTERS_DIVS_FILTER_BY_VALUE)}:`;
    if (!this.components.get("filter_by_condition")) {
      const conditionComponent = new ConditionComponent(this.hot, {
        id: "filter_by_condition",
        name: filterByConditionLabel,
        addSeparator: false,
        menuContainer
      });
      conditionComponent.addLocalHook("afterClose", () => _classPrivateMethodGet24(this, _onSelectUIClosed, _onSelectUIClosed2).call(this));
      this.components.set("filter_by_condition", addConfirmationHooks(conditionComponent));
    }
    if (!this.components.get("filter_operators")) {
      this.components.set("filter_operators", new OperatorsComponent(this.hot, {
        id: "filter_operators",
        name: "Operators"
      }));
    }
    if (!this.components.get("filter_by_condition2")) {
      const conditionComponent = new ConditionComponent(this.hot, {
        id: "filter_by_condition2",
        name: "",
        addSeparator: true,
        menuContainer
      });
      conditionComponent.addLocalHook("afterClose", () => _classPrivateMethodGet24(this, _onSelectUIClosed, _onSelectUIClosed2).call(this));
      this.components.set("filter_by_condition2", addConfirmationHooks(conditionComponent));
    }
    if (!this.components.get("filter_by_value")) {
      this.components.set("filter_by_value", addConfirmationHooks(new ValueComponent(this.hot, {
        id: "filter_by_value",
        name: filterValueLabel
      })));
    }
    if (!this.components.get("filter_action_bar")) {
      this.components.set("filter_action_bar", addConfirmationHooks(new ActionBarComponent(this.hot, {
        id: "filter_action_bar",
        name: "Action bar"
      })));
    }
    if (!this.conditionCollection) {
      this.conditionCollection = new conditionCollection_default(this.hot);
    }
    if (!this.conditionUpdateObserver) {
      this.conditionUpdateObserver = new conditionUpdateObserver_default(this.hot, this.conditionCollection, (physicalColumn) => this.getDataMapAtColumn(physicalColumn));
      this.conditionUpdateObserver.addLocalHook("update", (conditionState) => _classPrivateMethodGet24(this, _updateComponents, _updateComponents2).call(this, conditionState));
    }
    this.components.forEach((component) => component.show());
    this.addHook("afterDropdownMenuDefaultOptions", (defaultOptions) => _classPrivateMethodGet24(this, _onAfterDropdownMenuDefaultOptions, _onAfterDropdownMenuDefaultOptions2).call(this, defaultOptions));
    this.addHook("afterDropdownMenuShow", () => _classPrivateMethodGet24(this, _onAfterDropdownMenuShow, _onAfterDropdownMenuShow2).call(this));
    this.addHook("afterDropdownMenuHide", () => _classPrivateMethodGet24(this, _onAfterDropdownMenuHide, _onAfterDropdownMenuHide2).call(this));
    this.addHook("afterChange", (changes) => _classPrivateMethodGet24(this, _onAfterChange3, _onAfterChange22).call(this, changes));
    if (this.hot.getSettings().dropdownMenu && this.dropdownMenuPlugin) {
      this.dropdownMenuPlugin.disablePlugin();
      this.dropdownMenuPlugin.enablePlugin();
    }
    if (!_classPrivateFieldGet14(this, _menuFocusNavigator) && this.dropdownMenuPlugin.enabled) {
      const mainMenu = this.dropdownMenuPlugin.menu;
      const focusableItems = [
        // A fake menu item that once focused allows escaping from the focus navigation (using Tab keys)
        // to the menu navigation using arrow keys.
        {
          focus: () => {
            const menuNavigator = mainMenu.getNavigator();
            const lastSelectedMenuItem = _classPrivateFieldGet14(this, _menuFocusNavigator).getLastMenuPage();
            mainMenu.focus();
            if (lastSelectedMenuItem > 0) {
              menuNavigator.setCurrentPage(lastSelectedMenuItem);
            } else {
              menuNavigator.toFirstItem();
            }
          }
        },
        ...Array.from(this.components).map((_ref) => {
          let [, component] = _ref;
          return component.getElements();
        }).flat()
      ];
      _classPrivateFieldSet13(this, _menuFocusNavigator, createMenuFocusController(mainMenu, focusableItems));
      const forwardToFocusNavigation = (event) => {
        _classPrivateFieldGet14(this, _menuFocusNavigator).listen();
        event.preventDefault();
        if (isKey(event.keyCode, "TAB")) {
          if (event.shiftKey) {
            _classPrivateFieldGet14(this, _menuFocusNavigator).toPreviousItem();
          } else {
            _classPrivateFieldGet14(this, _menuFocusNavigator).toNextItem();
          }
        }
      };
      this.components.get("filter_by_value").addLocalHook("listTabKeydown", forwardToFocusNavigation);
      this.components.get("filter_by_condition").addLocalHook("selectTabKeydown", forwardToFocusNavigation);
    }
    this.registerShortcuts();
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    if (this.enabled) {
      var _this$dropdownMenuPlu;
      if ((_this$dropdownMenuPlu = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu !== void 0 && _this$dropdownMenuPlu.enabled) {
        this.dropdownMenuPlugin.menu.clearLocalHooks();
      }
      this.components.forEach((component, key) => {
        component.destroy();
        this.components.set(key, null);
      });
      this.conditionCollection.destroy();
      this.conditionCollection = null;
      this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    }
    this.unregisterShortcuts();
    super.disablePlugin();
  }
  /**
   * Register shortcuts responsible for clearing the filters.
   *
   * @private
   */
  registerShortcuts() {
    this.hot.getShortcutManager().getContext("grid").addShortcut({
      keys: [["Alt", "A"]],
      stopPropagation: true,
      callback: () => {
        const selection = this.hot.getSelected();
        this.clearConditions();
        this.filter();
        if (selection) {
          this.hot.selectCells(selection);
        }
      },
      group: SHORTCUTS_GROUP8
    });
  }
  /**
   * Unregister shortcuts responsible for clearing the filters.
   *
   * @private
   */
  unregisterShortcuts() {
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP8);
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @memberof Filters#
   * @function addCondition
   * @description
   * Adds condition to the conditions collection at specified column index.
   *
   * Possible predefined conditions:
   *  * `begins_with` - Begins with
   *  * `between` - Between
   *  * `by_value` - By value
   *  * `contains` - Contains
   *  * `date_after` - After a date
   *  * `date_before` - Before a date
   *  * `date_today` - Today
   *  * `date_tomorrow` - Tomorrow
   *  * `date_yesterday` - Yesterday
   *  * `empty` - Empty
   *  * `ends_with` - Ends with
   *  * `eq` - Equal
   *  * `gt` - Greater than
   *  * `gte` - Greater than or equal
   *  * `lt` - Less than
   *  * `lte` - Less than or equal
   *  * `none` - None (no filter)
   *  * `not_between` - Not between
   *  * `not_contains` - Not contains
   *  * `not_empty` - Not empty
   *  * `neq` - Not equal.
   *
   * Possible operations on collection of conditions:
   *  * `conjunction` - [**Conjunction**](https://en.wikipedia.org/wiki/Logical_conjunction) on conditions collection (by default), i.e. for such operation: <br/> c1 AND c2 AND c3 AND c4 ... AND cn === TRUE, where c1 ... cn are conditions.
   *  * `disjunction` - [**Disjunction**](https://en.wikipedia.org/wiki/Logical_disjunction) on conditions collection, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.
   *  * `disjunctionWithExtraCondition` - **Disjunction** on first `n - 1`\* conditions from collection with an extra requirement computed from the last condition, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn-1 AND cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.
   *
   * \* when `n` is collection size; it's used i.e. for one operation introduced from UI (when choosing from filter's drop-down menu two conditions with OR operator between them, mixed with choosing values from the multiple choice select)
   *
   * **Note**: Mind that you cannot mix different types of operations (for instance, if you use `conjunction`, use it consequently for a particular column).
   *
   * @example
   * ::: only-for javascript
   * ```js
   * const container = document.getElementById('example');
   * const hot = new Handsontable(container, {
   *   data: getData(),
   *   filters: true
   * });
   *
   * // access to filters plugin instance
   * const filtersPlugin = hot.getPlugin('filters');
   *
   * // add filter "Greater than" 95 to column at index 1
   * filtersPlugin.addCondition(1, 'gt', [95]);
   * filtersPlugin.filter();
   *
   * // add filter "By value" to column at index 1
   * // in this case all value's that don't match will be filtered.
   * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', 'as', 'on']]);
   * filtersPlugin.filter();
   *
   * // add filter "Begins with" with value "de" AND "Not contains" with value "ing"
   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');
   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');
   * filtersPlugin.filter();
   *
   * // add filter "Begins with" with value "de" OR "Not contains" with value "ing"
   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');
   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');
   * filtersPlugin.filter();
   * ```
   * :::
   *
   * ::: only-for react
   * ```jsx
   * const hotRef = useRef(null);
   *
   * ...
   *
   * <HotTable
   *   ref={hotRef}
   *   data={getData()}
   *   filters={true}
   * />
   *
   * // access to filters plugin instance
   * const hot = hotRef.current.hotInstance;
   * const filtersPlugin = hot.getPlugin('filters');
   *
   * // add filter "Greater than" 95 to column at index 1
   * filtersPlugin.addCondition(1, 'gt', [95]);
   * filtersPlugin.filter();
   *
   * // add filter "By value" to column at index 1
   * // in this case all value's that don't match will be filtered.
   * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', 'as', 'on']]);
   * filtersPlugin.filter();
   *
   * // add filter "Begins with" with value "de" AND "Not contains" with value "ing"
   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');
   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');
   * filtersPlugin.filter();
   *
   * // add filter "Begins with" with value "de" OR "Not contains" with value "ing"
   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');
   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');
   * filtersPlugin.filter();
   * ```
   * :::
   *
   * @param {number} column Visual column index.
   * @param {string} name Condition short name.
   * @param {Array} args Condition arguments.
   * @param {string} [operationId=conjunction] `id` of operation which is performed on the column.
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  addCondition(column, name, args) {
    let operationId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : OPERATION_ID;
    const physicalColumn = this.hot.toPhysicalColumn(column);
    this.conditionCollection.addCondition(physicalColumn, {
      command: {
        key: name
      },
      args
    }, operationId);
  }
  /**
   * Removes conditions at specified column index.
   *
   * @param {number} column Visual column index.
   */
  removeConditions(column) {
    const physicalColumn = this.hot.toPhysicalColumn(column);
    this.conditionCollection.removeConditions(physicalColumn);
  }
  /**
   * Clears all conditions previously added to the collection for the specified column index or, if the column index
   * was not passed, clear the conditions for all columns.
   *
   * @param {number} [column] Visual column index.
   */
  clearConditions(column) {
    if (column === void 0) {
      this.conditionCollection.clean();
    } else {
      const physicalColumn = this.hot.toPhysicalColumn(column);
      this.conditionCollection.removeConditions(physicalColumn);
    }
  }
  /**
   * Filters data based on added filter conditions.
   *
   * @fires Hooks#beforeFilter
   * @fires Hooks#afterFilter
   */
  filter() {
    const {
      navigableHeaders
    } = this.hot.getSettings();
    const dataFilter = this._createDataFilter();
    const needToFilter = !this.conditionCollection.isEmpty();
    let visibleVisualRows = [];
    const conditions2 = this.conditionCollection.exportAllConditions();
    const allowFiltering = this.hot.runHooks("beforeFilter", conditions2);
    if (allowFiltering !== false) {
      if (needToFilter) {
        const trimmedRows = [];
        this.hot.batchExecution(() => {
          this.filtersRowsMap.clear();
          visibleVisualRows = arrayMap(dataFilter.filter(), (rowData) => rowData.meta.visualRow);
          const visibleVisualRowsAssertion = createArrayAssertion(visibleVisualRows);
          rangeEach(this.hot.countSourceRows() - 1, (row) => {
            if (!visibleVisualRowsAssertion(row)) {
              trimmedRows.push(row);
            }
          });
          arrayEach(trimmedRows, (physicalRow) => {
            this.filtersRowsMap.setValueAtIndex(physicalRow, true);
          });
        }, true);
        if (!navigableHeaders && !visibleVisualRows.length) {
          this.hot.deselectCell();
        }
      } else {
        this.filtersRowsMap.clear();
      }
    }
    this.hot.runHooks("afterFilter", conditions2);
    this.hot.view.adjustElementsSize(true);
    this.hot.render();
    if (this.hot.selection.isSelected()) {
      this.hot.selectCell(navigableHeaders ? -1 : 0, this.hot.getSelectedRangeLast().highlight.col);
    }
  }
  /**
   * Gets last selected column index.
   *
   * @returns {{visualIndex: number, physicalIndex: number} | null} Returns `null` when a column is
   * not selected. Otherwise, returns an object with `visualIndex` and `physicalIndex` properties containing
   * the index of the column.
   */
  getSelectedColumn() {
    var _this$hot$getSelected;
    const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
    if (!highlight) {
      return null;
    }
    return {
      visualIndex: highlight.col,
      physicalIndex: this.hot.toPhysicalColumn(highlight.col)
    };
  }
  /**
   * Returns handsontable source data with cell meta based on current selection.
   *
   * @param {number} [column] The physical column index. By default column index accept the value of the selected column.
   * @returns {Array} Returns array of objects where keys as row index.
   */
  getDataMapAtColumn(column) {
    const visualColumn = this.hot.toVisualColumn(column);
    const data = [];
    arrayEach(this.hot.getSourceDataAtCol(visualColumn), (value, rowIndex) => {
      var _this$hot$getDataAtCe;
      const {
        row,
        col,
        visualCol,
        visualRow,
        type,
        instance,
        dateFormat,
        locale
      } = this.hot.getCellMeta(rowIndex, visualColumn);
      const dataValue = (_this$hot$getDataAtCe = this.hot.getDataAtCell(this.hot.toVisualRow(rowIndex), visualColumn)) !== null && _this$hot$getDataAtCe !== void 0 ? _this$hot$getDataAtCe : value;
      data.push({
        meta: {
          row,
          col,
          visualCol,
          visualRow,
          type,
          instance,
          dateFormat,
          locale
        },
        value: toEmptyString(dataValue)
      });
    });
    return data;
  }
  /**
   * Update the condition of ValueComponent, based on the handled changes.
   *
   * @private
   * @param {number} columnIndex Column index of handled ValueComponent condition.
   */
  updateValueComponentCondition(columnIndex) {
    const dataAtCol = this.hot.getDataAtCol(columnIndex);
    const selectedValues = unifyColumnValues(dataAtCol);
    this.conditionUpdateObserver.updateStatesAtColumn(columnIndex, selectedValues);
  }
  /**
   * Restores components to its saved state.
   *
   * @private
   * @param {Array} components List of components.
   */
  restoreComponents(components) {
    var _this$getSelectedColu;
    const physicalIndex = (_this$getSelectedColu = this.getSelectedColumn()) === null || _this$getSelectedColu === void 0 ? void 0 : _this$getSelectedColu.physicalIndex;
    components.forEach((component) => {
      if (component.isHidden()) {
        return;
      }
      component.restoreState(physicalIndex);
    });
    this.updateDependentComponentsVisibility();
  }
  /**
   * Get an operation, based on the number and types of arguments (where arguments are states of components).
   *
   * @param {string} suggestedOperation Operation which was chosen by user from UI.
   * @param {object} byConditionState1 State of first condition component.
   * @param {object} byConditionState2 State of second condition component.
   * @param {object} byValueState State of value component.
   * @private
   * @returns {string}
   */
  getOperationBasedOnArguments(suggestedOperation, byConditionState1, byConditionState2, byValueState) {
    let operation = suggestedOperation;
    if (operation === OPERATION_ID2 && byConditionState1.command.key !== CONDITION_NAME && byConditionState2.command.key !== CONDITION_NAME && byValueState.command.key !== CONDITION_NAME) {
      operation = OPERATION_ID3;
    } else if (byValueState.command.key !== CONDITION_NAME) {
      if (byConditionState1.command.key === CONDITION_NAME || byConditionState2.command.key === CONDITION_NAME) {
        operation = OPERATION_ID;
      }
    }
    return operation;
  }
  /**
   * Listen to the keyboard input on document body and forward events to instance of Handsontable
   * created by DropdownMenu plugin.
   *
   * @private
   */
  setListeningDropdownMenu() {
    if (this.dropdownMenuPlugin) {
      this.dropdownMenuPlugin.setListening();
    }
  }
  /**
   * Updates visibility of some of the components, based on the state of the parent component.
   *
   * @private
   */
  updateDependentComponentsVisibility() {
    const component = this.components.get("filter_by_condition");
    const {
      command
    } = component.getState();
    const componentsToShow = [this.components.get("filter_by_condition2"), this.components.get("filter_operators")];
    if (command.showOperators) {
      this.showComponents(...componentsToShow);
    } else {
      this.hideComponents(...componentsToShow);
    }
  }
  /**
   * Creates DataFilter instance based on condition collection.
   *
   * @private
   * @param {ConditionCollection} conditionCollection Condition collection object.
   * @returns {DataFilter}
   */
  _createDataFilter() {
    let conditionCollection = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.conditionCollection;
    return new dataFilter_default(conditionCollection, (physicalColumn) => this.getDataMapAtColumn(physicalColumn));
  }
  /**
   * Returns indexes of passed components inside list of `dropdownMenu` items.
   *
   * @private
   * @param {...BaseComponent} components List of components.
   * @returns {Array}
   */
  getIndexesOfComponents() {
    const indexes = [];
    if (!this.dropdownMenuPlugin) {
      return indexes;
    }
    const menu = this.dropdownMenuPlugin.menu;
    for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {
      components[_key] = arguments[_key];
    }
    arrayEach(components, (component) => {
      arrayEach(menu.menuItems, (item, index) => {
        if (item.key === component.getMenuItemDescriptor().key) {
          indexes.push(index);
        }
      });
    });
    return indexes;
  }
  /**
   * Changes visibility of component.
   *
   * @private
   * @param {boolean} visible Determine if components should be visible.
   * @param {...BaseComponent} components List of components.
   */
  changeComponentsVisibility() {
    let visible = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    if (!this.dropdownMenuPlugin) {
      return;
    }
    const menu = this.dropdownMenuPlugin.menu;
    const hotMenu = menu.hotMenu;
    const hiddenRows = hotMenu.getPlugin("hiddenRows");
    for (var _len2 = arguments.length, components = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      components[_key2 - 1] = arguments[_key2];
    }
    const indexes = this.getIndexesOfComponents(...components);
    if (visible) {
      hiddenRows.showRows(indexes);
    } else {
      hiddenRows.hideRows(indexes);
    }
    hotMenu.render();
  }
  /**
   * Hides components of filters `dropdownMenu`.
   *
   * @private
   * @param {...BaseComponent} components List of components.
   */
  hideComponents() {
    for (var _len3 = arguments.length, components = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      components[_key3] = arguments[_key3];
    }
    this.changeComponentsVisibility(false, ...components);
  }
  /**
   * Shows components of filters `dropdownMenu`.
   *
   * @private
   * @param {...BaseComponent} components List of components.
   */
  showComponents() {
    for (var _len4 = arguments.length, components = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      components[_key4] = arguments[_key4];
    }
    this.changeComponentsVisibility(true, ...components);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    if (this.enabled) {
      this.components.forEach((component, key) => {
        if (component !== null) {
          component.destroy();
          this.components.set(key, null);
        }
      });
      this.conditionCollection.destroy();
      this.conditionUpdateObserver.destroy();
      this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    }
    super.destroy();
  }
};
function _onAfterChange22(changes) {
  if (changes) {
    arrayEach(changes, (change) => {
      const [, prop] = change;
      const columnIndex = this.hot.propToCol(prop);
      if (this.conditionCollection.hasConditions(columnIndex)) {
        this.updateValueComponentCondition(columnIndex);
      }
    });
  }
}
function _onAfterDropdownMenuShow2() {
  this.restoreComponents(Array.from(this.components.values()));
}
function _onAfterDropdownMenuHide2() {
  this.components.get("filter_by_condition").getSelectElement().closeOptions();
  this.components.get("filter_by_condition2").getSelectElement().closeOptions();
}
function _onAfterDropdownMenuDefaultOptions2(defaultOptions) {
  defaultOptions.items.push({
    name: KEY
  });
  this.components.forEach((component) => {
    defaultOptions.items.push(component.getMenuItemDescriptor());
  });
}
function _onActionBarSubmit2(submitType) {
  var _this$dropdownMenuPlu3;
  if (submitType === "accept") {
    const selectedColumn = this.getSelectedColumn();
    if (selectedColumn === null) {
      var _this$dropdownMenuPlu2;
      (_this$dropdownMenuPlu2 = this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu2 === void 0 || _this$dropdownMenuPlu2.close();
      return;
    }
    const {
      physicalIndex
    } = selectedColumn;
    const byConditionState1 = this.components.get("filter_by_condition").getState();
    const byConditionState2 = this.components.get("filter_by_condition2").getState();
    const byValueState = this.components.get("filter_by_value").getState();
    const operation = this.getOperationBasedOnArguments(this.components.get("filter_operators").getActiveOperationId(), byConditionState1, byConditionState2, byValueState);
    this.conditionUpdateObserver.groupChanges();
    let columnStackPosition = this.conditionCollection.getColumnStackPosition(physicalIndex);
    if (columnStackPosition === -1) {
      columnStackPosition = void 0;
    }
    this.conditionCollection.removeConditions(physicalIndex);
    if (byConditionState1.command.key !== CONDITION_NAME) {
      this.conditionCollection.addCondition(physicalIndex, byConditionState1, operation, columnStackPosition);
      if (byConditionState2.command.key !== CONDITION_NAME) {
        this.conditionCollection.addCondition(physicalIndex, byConditionState2, operation, columnStackPosition);
      }
    }
    if (byValueState.command.key !== CONDITION_NAME) {
      this.conditionCollection.addCondition(physicalIndex, byValueState, operation, columnStackPosition);
    }
    this.conditionUpdateObserver.flush();
    this.components.forEach((component) => component.saveState(physicalIndex));
    this.filtersRowsMap.clear();
    this.filter();
  }
  (_this$dropdownMenuPlu3 = this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu3 === void 0 || _this$dropdownMenuPlu3.close();
}
function _onComponentChange2(component, command) {
  this.updateDependentComponentsVisibility();
  if (component.constructor === ConditionComponent && !command.inputsCount) {
    this.setListeningDropdownMenu();
  }
}
function _onSelectUIClosed2() {
  this.setListeningDropdownMenu();
}
function _onAfterGetColHeader24(col, TH) {
  const physicalColumn = this.hot.toPhysicalColumn(col);
  if (this.enabled && this.conditionCollection.hasConditions(physicalColumn)) {
    addClass(TH, "htFiltersActive");
  } else {
    removeClass(TH, "htFiltersActive");
  }
}
function _updateComponents2(conditionsState) {
  var _this$dropdownMenuPlu4;
  if (!((_this$dropdownMenuPlu4 = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu4 !== void 0 && _this$dropdownMenuPlu4.enabled)) {
    return;
  }
  const {
    editedConditionStack: {
      conditions: conditions2,
      column
    }
  } = conditionsState;
  const conditionsByValue = conditions2.filter((condition24) => condition24.name === CONDITION_NAME21);
  const conditionsWithoutByValue = conditions2.filter((condition24) => condition24.name !== CONDITION_NAME21);
  if (conditionsByValue.length >= 2 || conditionsWithoutByValue.length >= 3) {
    warn(toSingleLine`The filter conditions have been applied properly, but couldn’t be displayed visually.\x20
        The overall amount of conditions exceed the capability of the dropdown menu.\x20
        For more details see the documentation.`);
  } else {
    const operationType = this.conditionCollection.getOperation(column);
    this.components.get("filter_by_condition").updateState(conditionsWithoutByValue[0], column);
    this.components.get("filter_by_condition2").updateState(conditionsWithoutByValue[1], column);
    this.components.get("filter_operators").updateState(operationType, column);
    this.components.get("filter_by_value").updateState(conditionsState);
  }
}

// node_modules/handsontable/plugins/formulas/engine/settings.mjs
var DEFAULT_LICENSE_KEY = "internal-use-in-handsontable";
var DEFAULT_SETTINGS = {
  licenseKey: DEFAULT_LICENSE_KEY,
  useArrayArithmetic: true,
  useColumnIndex: false,
  useStats: false,
  evaluateNullToZero: true,
  precisionEpsilon: 1e-13,
  precisionRounding: 14,
  smartRounding: true,
  leapYear1900: false,
  nullDate: {
    year: 1899,
    month: 12,
    day: 30
  },
  nullYear: 30,
  dateFormats: ["DD/MM/YYYY", "DD/MM/YY"],
  timeFormats: ["hh:mm", "hh:mm:ss.sss"],
  matchWholeCell: true,
  useRegularExpressions: false,
  useWildcards: true,
  functionArgSeparator: ",",
  thousandSeparator: "",
  decimalSeparator: ".",
  language: "enGB"
};
function getEngineSettingsOverrides(hotSettings) {
  var _hotSettings$PLUGIN_K;
  return {
    maxColumns: hotSettings.maxColumns,
    maxRows: hotSettings.maxRows,
    language: (_hotSettings$PLUGIN_K = hotSettings[PLUGIN_KEY17]) === null || _hotSettings$PLUGIN_K === void 0 || (_hotSettings$PLUGIN_K = _hotSettings$PLUGIN_K.language) === null || _hotSettings$PLUGIN_K === void 0 ? void 0 : _hotSettings$PLUGIN_K.langCode
  };
}
function cleanEngineSettings(pluginSettings) {
  return Object.keys(pluginSettings).reduce((obj, key) => {
    if (key !== "hyperformula") {
      obj[key] = pluginSettings[key];
    }
    return obj;
  }, {});
}
function getEngineSettingsWithDefaultsAndOverrides(hotSettings) {
  var _pluginSettings$engin;
  const pluginSettings = hotSettings[PLUGIN_KEY17];
  const userSettings = cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && (_pluginSettings$engin = pluginSettings.engine) !== null && _pluginSettings$engin !== void 0 && _pluginSettings$engin.hyperformula ? pluginSettings.engine : {});
  const overrides = getEngineSettingsOverrides(hotSettings);
  return {
    ...DEFAULT_SETTINGS,
    ...userSettings,
    ...overrides
  };
}
function getEngineSettingsWithOverrides(hotSettings) {
  var _pluginSettings$engin2;
  const pluginSettings = hotSettings[PLUGIN_KEY17];
  const userSettings = cleanEngineSettings(pluginSettings !== null && pluginSettings !== void 0 && (_pluginSettings$engin2 = pluginSettings.engine) !== null && _pluginSettings$engin2 !== void 0 && _pluginSettings$engin2.hyperformula ? pluginSettings.engine : {});
  const overrides = getEngineSettingsOverrides(hotSettings);
  return {
    ...userSettings,
    ...overrides
  };
}
function haveEngineSettingsChanged(currentEngineSettings, newEngineSettings) {
  return Object.keys(newEngineSettings).some((settingOption) => {
    return newEngineSettings[settingOption] !== void 0 && newEngineSettings[settingOption] !== currentEngineSettings[settingOption];
  });
}

// node_modules/handsontable/plugins/formulas/engine/register.mjs
function getEngineRelationshipRegistry() {
  const registryKey = "engine_relationship";
  const pluginStaticRegistry = staticRegister(PLUGIN_KEY17);
  if (!pluginStaticRegistry.hasItem(registryKey)) {
    pluginStaticRegistry.register(registryKey, /* @__PURE__ */ new Map());
  }
  return pluginStaticRegistry.getItem(registryKey);
}
function getSharedEngineUsageRegistry() {
  const registryKey = "shared_engine_usage";
  const pluginStaticRegistry = staticRegister(PLUGIN_KEY17);
  if (!pluginStaticRegistry.hasItem(registryKey)) {
    pluginStaticRegistry.register(registryKey, /* @__PURE__ */ new Map());
  }
  return pluginStaticRegistry.getItem(registryKey);
}
function setupEngine(hotInstance) {
  const hotSettings = hotInstance.getSettings();
  const pluginSettings = hotSettings[PLUGIN_KEY17];
  const engineConfigItem = pluginSettings === null || pluginSettings === void 0 ? void 0 : pluginSettings.engine;
  if (pluginSettings === true) {
    return null;
  }
  if (isUndefined(engineConfigItem)) {
    return null;
  }
  if (typeof engineConfigItem.hyperformula === "function" || typeof engineConfigItem === "function") {
    var _engineConfigItem$hyp;
    return registerEngine((_engineConfigItem$hyp = engineConfigItem.hyperformula) !== null && _engineConfigItem$hyp !== void 0 ? _engineConfigItem$hyp : engineConfigItem, hotSettings, hotInstance);
  } else if (typeof engineConfigItem === "object" && isUndefined(engineConfigItem.hyperformula)) {
    const engineRelationship = getEngineRelationshipRegistry();
    const sharedEngineUsage = getSharedEngineUsageRegistry().get(engineConfigItem);
    if (!engineRelationship.has(engineConfigItem)) {
      engineRelationship.set(engineConfigItem, []);
    }
    engineRelationship.get(engineConfigItem).push(hotInstance);
    if (sharedEngineUsage) {
      sharedEngineUsage.push(hotInstance.guid);
    }
    if (!engineConfigItem.getConfig().licenseKey) {
      engineConfigItem.updateConfig({
        licenseKey: DEFAULT_LICENSE_KEY
      });
    }
    if (engineConfigItem.getConfig().leapYear1900 !== DEFAULT_SETTINGS.leapYear1900 || isObjectEqual(engineConfigItem.getConfig().nullDate, DEFAULT_SETTINGS.nullDate) === false) {
      warn(toSingleLine`If you use HyperFormula with Handsontable, keep the default \`leapYear1900\` and \`nullDate\` 
      settings. Otherwise, HyperFormula's dates may not sync correctly with Handsontable's dates.`);
    }
    return engineConfigItem;
  }
  return null;
}
function registerEngine(engineClass, hotSettings, hotInstance) {
  const pluginSettings = hotSettings[PLUGIN_KEY17];
  const engineSettings = getEngineSettingsWithDefaultsAndOverrides(hotSettings);
  const engineRegistry = getEngineRelationshipRegistry();
  const sharedEngineRegistry = getSharedEngineUsageRegistry();
  registerCustomFunctions(engineClass, pluginSettings.functions);
  registerLanguage(engineClass, pluginSettings.language);
  const engineInstance = engineClass.buildEmpty(engineSettings);
  engineRegistry.set(engineInstance, [hotInstance]);
  sharedEngineRegistry.set(engineInstance, [hotInstance.guid]);
  registerNamedExpressions(engineInstance, pluginSettings.namedExpressions);
  engineInstance.on("sheetAdded", () => {
    engineInstance.rebuildAndRecalculate();
  });
  engineInstance.on("sheetRemoved", () => {
    engineInstance.rebuildAndRecalculate();
  });
  return engineInstance;
}
function getRegisteredHotInstances(engine) {
  var _engineRegistry$get;
  const engineRegistry = getEngineRelationshipRegistry();
  const hotInstances = engineRegistry.size === 0 ? [] : Array.from((_engineRegistry$get = engineRegistry.get(engine)) !== null && _engineRegistry$get !== void 0 ? _engineRegistry$get : []);
  return new Map(hotInstances.map((hot) => [hot.getPlugin("formulas").sheetId, hot]));
}
function unregisterEngine(engine, hotInstance) {
  if (engine) {
    const engineRegistry = getEngineRelationshipRegistry();
    const engineHotRelationship = engineRegistry.get(engine);
    const sharedEngineRegistry = getSharedEngineUsageRegistry();
    const sharedEngineUsage = sharedEngineRegistry.get(engine);
    if (engineHotRelationship && engineHotRelationship.includes(hotInstance)) {
      engineHotRelationship.splice(engineHotRelationship.indexOf(hotInstance), 1);
      if (engineHotRelationship.length === 0) {
        engineRegistry.delete(engine);
      }
    }
    if (sharedEngineUsage && sharedEngineUsage.includes(hotInstance.guid)) {
      sharedEngineUsage.splice(sharedEngineUsage.indexOf(hotInstance.guid), 1);
      if (sharedEngineUsage.length === 0) {
        sharedEngineRegistry.delete(engine);
        engine.destroy();
      }
    }
  }
}
function registerCustomFunctions(engineClass, customFunctions) {
  if (customFunctions) {
    customFunctions.forEach((func) => {
      const {
        name,
        plugin,
        translations
      } = func;
      try {
        engineClass.registerFunction(name, plugin, translations);
      } catch (e) {
        warn(e.message);
      }
    });
  }
}
function registerLanguage(engineClass, languageSetting) {
  if (languageSetting) {
    const {
      langCode
    } = languageSetting;
    try {
      engineClass.registerLanguage(langCode, languageSetting);
    } catch (e) {
      warn(e.message);
    }
  }
}
function registerNamedExpressions(engineInstance, namedExpressions) {
  if (namedExpressions) {
    engineInstance.suspendEvaluation();
    namedExpressions.forEach((namedExp) => {
      const {
        name,
        expression,
        scope,
        options
      } = namedExp;
      try {
        engineInstance.addNamedExpression(name, expression, scope, options);
      } catch (e) {
        warn(e.message);
      }
    });
    engineInstance.resumeEvaluation();
  }
}
function setupSheet(engineInstance, sheetName) {
  if (isUndefined(sheetName) || !engineInstance.doesSheetExist(sheetName)) {
    sheetName = engineInstance.addSheet(sheetName);
  }
  return sheetName;
}

// node_modules/handsontable/plugins/formulas/utils.mjs
init_moment();
var DEFAULT_DATE_FORMAT_HYPERFORMULA = "DD/MM/YYYY";
function isEscapedFormulaExpression(expression) {
  return typeof expression === "string" && expression.charAt(0) === "'" && expression.charAt(1) === "=";
}
function unescapeFormulaExpression(expression) {
  return isEscapedFormulaExpression(expression) ? expression.substr(1) : expression;
}
function isFormula(value) {
  return typeof value === "string" && value.startsWith("=");
}
function isDate(value, cellType) {
  return typeof value === "string" && cellType === "date";
}
function isDateValid(date, dateFormat) {
  return moment_default(date, dateFormat, true).isValid();
}
function getDateInHfFormat(date, dateFormat) {
  return moment_default(date, dateFormat, true).format(DEFAULT_DATE_FORMAT_HYPERFORMULA);
}
function getDateInHotFormat(date, dateFormat) {
  return moment_default(date, DEFAULT_DATE_FORMAT_HYPERFORMULA, true).format(dateFormat);
}
function getDateFromExcelDate(numericDate, dateFormat) {
  const dateOffset = -1;
  const dateForFormatting = new Date(Date.UTC(0, 0, numericDate + dateOffset));
  return moment_default(dateForFormatting).format(dateFormat);
}

// node_modules/handsontable/plugins/formulas/indexSyncer/axisSyncer.mjs
function _classPrivateFieldInitSpec15(obj, privateMap, value) {
  _checkPrivateRedeclaration29(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration29(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet15(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor15(receiver, privateMap, "get");
  return _classApplyDescriptorGet15(receiver, descriptor);
}
function _classApplyDescriptorGet15(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet14(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor15(receiver, privateMap, "set");
  _classApplyDescriptorSet14(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor15(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet14(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _axis = /* @__PURE__ */ new WeakMap();
var _indexMapper = /* @__PURE__ */ new WeakMap();
var _indexSyncer = /* @__PURE__ */ new WeakMap();
var _indexesSequence = /* @__PURE__ */ new WeakMap();
var _movedIndexes = /* @__PURE__ */ new WeakMap();
var _finalIndex = /* @__PURE__ */ new WeakMap();
var _removedIndexes = /* @__PURE__ */ new WeakMap();
var AxisSyncer = class {
  constructor(axis, indexMapper, indexSyncer) {
    _classPrivateFieldInitSpec15(this, _axis, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec15(this, _indexMapper, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec15(this, _indexSyncer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec15(this, _indexesSequence, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec15(this, _movedIndexes, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec15(this, _finalIndex, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec15(this, _removedIndexes, {
      writable: true,
      value: []
    });
    _classPrivateFieldSet14(this, _axis, axis);
    _classPrivateFieldSet14(this, _indexMapper, indexMapper);
    _classPrivateFieldSet14(this, _indexSyncer, indexSyncer);
  }
  /**
   * Sets removed HF indexes (it should be done right before performing move on HOT).
   *
   * @param {Array<number>} removedIndexes List of removed physical indexes.
   * @returns {Array<number>} List of removed visual indexes.
   */
  setRemovedHfIndexes(removedIndexes) {
    _classPrivateFieldSet14(this, _removedIndexes, removedIndexes.map((physicalIndex) => {
      const visualIndex = _classPrivateFieldGet15(this, _indexMapper).getVisualFromPhysicalIndex(physicalIndex);
      return this.getHfIndexFromVisualIndex(visualIndex);
    }));
    return _classPrivateFieldGet15(this, _removedIndexes);
  }
  /**
   * Gets removed HF indexes (right before performing removal on HOT).
   *
   * @returns {Array<number>} List of removed HF indexes.
   */
  getRemovedHfIndexes() {
    return _classPrivateFieldGet15(this, _removedIndexes);
  }
  /**
   * Gets corresponding HyperFormula index for particular visual index. It's respecting the idea that HF's engine
   * is fed also with trimmed indexes (business requirements for formula result calculation also for trimmed elements).
   *
   * @param {number} visualIndex Visual index.
   * @returns {number}
   */
  getHfIndexFromVisualIndex(visualIndex) {
    const indexesSequence = _classPrivateFieldGet15(this, _indexMapper).getIndexesSequence();
    const notTrimmedIndexes = _classPrivateFieldGet15(this, _indexMapper).getNotTrimmedIndexes();
    return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);
  }
  /**
   * Synchronizes moves done on HOT to HF engine (based on previously calculated positions).
   *
   * @private
   * @param {Array<{from: number, to: number}>} moves Calculated HF's move positions.
   */
  syncMoves(moves) {
    const NUMBER_OF_MOVED_INDEXES = 1;
    const SYNC_MOVE_METHOD_NAME = `move${toUpperCaseFirst(_classPrivateFieldGet15(this, _axis))}s`;
    _classPrivateFieldGet15(this, _indexSyncer).getEngine().batch(() => {
      moves.forEach((move) => {
        const moveToTheSamePosition = move.from !== move.to;
        const anotherMoveWithoutEffect = move.from + 1 !== move.to;
        if (moveToTheSamePosition && anotherMoveWithoutEffect) {
          _classPrivateFieldGet15(this, _indexSyncer).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet15(this, _indexSyncer).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);
        }
      });
    });
  }
  /**
   * Stores information about performed HOT moves for purpose of calculating where to move HF elements.
   *
   * @param {Array<number>} movedVisualIndexes Sequence of moved visual indexes for certain axis.
   * @param {number} visualFinalIndex Final visual place where to move HOT indexes.
   * @param {boolean} movePossible Indicates if it's possible to move HOT indexes to the desired position.
   */
  storeMovesInformation(movedVisualIndexes, visualFinalIndex, movePossible) {
    if (movePossible === false) {
      return;
    }
    _classPrivateFieldSet14(this, _movedIndexes, movedVisualIndexes.map((index) => this.getHfIndexFromVisualIndex(index)));
    _classPrivateFieldSet14(this, _finalIndex, this.getHfIndexFromVisualIndex(visualFinalIndex));
  }
  /**
   * Gets first position where to move element (respecting the fact that some element will be sooner or later
   * taken out of the dataset in order to move them).
   *
   * @param {Array<number>} movedHfIndexes Sequence of moved HF indexes for certain axis.
   * @param {number} finalHfIndex Final HF place where to move rows.
   * @returns {number} HF's index informing where to move the first element.
   * @private
   */
  getMoveLine(movedHfIndexes, finalHfIndex) {
    const numberOfElements = _classPrivateFieldGet15(this, _indexMapper).getNumberOfIndexes();
    const notMovedElements = Array.from(Array(numberOfElements).keys()).filter((index) => movedHfIndexes.includes(index) === false);
    if (finalHfIndex === 0) {
      var _notMovedElements$fin;
      return (_notMovedElements$fin = notMovedElements[finalHfIndex]) !== null && _notMovedElements$fin !== void 0 ? _notMovedElements$fin : 0;
    }
    return notMovedElements[finalHfIndex - 1] + 1;
  }
  /**
   * Gets initially calculated HF's move positions.
   *
   * @private
   * @param {Array<number>} movedHfIndexes Sequence of moved HF indexes for certain axis.
   * @param {number} finalHfIndex Final HF place where to move rows.
   * @returns {Array<{from: number, to: number}>} Initially calculated HF's move positions.
   */
  getInitiallyCalculatedMoves(movedHfIndexes, finalHfIndex) {
    let moveLine = this.getMoveLine(movedHfIndexes, finalHfIndex);
    const moves = [];
    movedHfIndexes.forEach((movedHfIndex) => {
      const move = {
        from: movedHfIndex,
        to: moveLine
      };
      moves.forEach((previouslyMovedIndex) => {
        const isMovingFromEndToStart = previouslyMovedIndex.from > previouslyMovedIndex.to;
        const isMovingElementBefore = previouslyMovedIndex.to <= move.from;
        const isMovingAfterElement = previouslyMovedIndex.from > move.from;
        if (isMovingAfterElement && isMovingElementBefore && isMovingFromEndToStart) {
          move.from += 1;
        }
      });
      if (move.from >= moveLine) {
        moveLine += 1;
      }
      moves.push(move);
    });
    return moves;
  }
  /**
   * Gets finally calculated HF's move positions (after adjusting).
   *
   * @private
   * @param {Array<{from: number, to: number}>} moves Initially calculated HF's move positions.
   * @returns {Array<{from: number, to: number}>} Finally calculated HF's move positions (after adjusting).
   */
  adjustedCalculatedMoves(moves) {
    moves.forEach((move, index) => {
      const nextMoved = moves.slice(index + 1);
      nextMoved.forEach((nextMovedIndex) => {
        const isMovingFromStartToEnd = nextMovedIndex.from < nextMovedIndex.to;
        if (nextMovedIndex.from > move.from && isMovingFromStartToEnd) {
          nextMovedIndex.from -= 1;
        }
      });
    });
    return moves;
  }
  /**
   * Calculating where to move HF elements and performing already calculated moves.
   *
   * @param {boolean} movePossible Indicates if it was possible to move HOT indexes to the desired position.
   * @param {boolean} orderChanged Indicates if order of HOT indexes was changed by move.
   */
  calculateAndSyncMoves(movePossible, orderChanged) {
    if (_classPrivateFieldGet15(this, _indexSyncer).isPerformingUndoRedo()) {
      return;
    }
    if (movePossible === false || orderChanged === false) {
      return;
    }
    const calculatedMoves = this.adjustedCalculatedMoves(this.getInitiallyCalculatedMoves(_classPrivateFieldGet15(this, _movedIndexes), _classPrivateFieldGet15(this, _finalIndex)));
    if (_classPrivateFieldGet15(this, _indexSyncer).getSheetId() === null) {
      _classPrivateFieldGet15(this, _indexSyncer).getPostponeAction(() => this.syncMoves(calculatedMoves));
    } else {
      this.syncMoves(calculatedMoves);
    }
  }
  /**
   * Gets callback for hook triggered after performing change of indexes order.
   *
   * @returns {Function}
   */
  getIndexesChangeSyncMethod() {
    const SYNC_ORDER_CHANGE_METHOD_NAME = `set${toUpperCaseFirst(_classPrivateFieldGet15(this, _axis))}Order`;
    return (source) => {
      if (_classPrivateFieldGet15(this, _indexSyncer).isPerformingUndoRedo()) {
        return;
      }
      const newSequence = _classPrivateFieldGet15(this, _indexMapper).getIndexesSequence();
      if (source === "update") {
        const relativeTransformation = _classPrivateFieldGet15(this, _indexesSequence).map((index) => newSequence.indexOf(index));
        const sheetDimensions = _classPrivateFieldGet15(this, _indexSyncer).getEngine().getSheetDimensions(_classPrivateFieldGet15(this, _indexSyncer).getSheetId());
        let sizeForAxis;
        if (_classPrivateFieldGet15(this, _axis) === "row") {
          sizeForAxis = sheetDimensions.height;
        } else {
          sizeForAxis = sheetDimensions.width;
        }
        const numberOfReorganisedIndexes = relativeTransformation.length;
        for (let i = numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {
          relativeTransformation.push(i);
        }
        _classPrivateFieldGet15(this, _indexSyncer).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGet15(this, _indexSyncer).getSheetId(), relativeTransformation);
      }
      _classPrivateFieldSet14(this, _indexesSequence, newSequence);
    };
  }
  /**
   * Initialize the AxisSyncer.
   */
  init() {
    _classPrivateFieldSet14(this, _indexesSequence, _classPrivateFieldGet15(this, _indexMapper).getIndexesSequence());
  }
};
var axisSyncer_default = AxisSyncer;

// node_modules/handsontable/plugins/formulas/indexSyncer/index.mjs
function _classPrivateFieldInitSpec16(obj, privateMap, value) {
  _checkPrivateRedeclaration30(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration30(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet16(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor16(receiver, privateMap, "get");
  return _classApplyDescriptorGet16(receiver, descriptor);
}
function _classApplyDescriptorGet16(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet15(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor16(receiver, privateMap, "set");
  _classApplyDescriptorSet15(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor16(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet15(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _rowIndexSyncer = /* @__PURE__ */ new WeakMap();
var _columnIndexSyncer = /* @__PURE__ */ new WeakMap();
var _postponeAction = /* @__PURE__ */ new WeakMap();
var _isPerformingUndo = /* @__PURE__ */ new WeakMap();
var _isPerformingRedo = /* @__PURE__ */ new WeakMap();
var _engine = /* @__PURE__ */ new WeakMap();
var _sheetId = /* @__PURE__ */ new WeakMap();
var IndexSyncer = class {
  constructor(rowIndexMapper, columnIndexMapper, postponeAction) {
    _classPrivateFieldInitSpec16(this, _rowIndexSyncer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec16(this, _columnIndexSyncer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec16(this, _postponeAction, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec16(this, _isPerformingUndo, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec16(this, _isPerformingRedo, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec16(this, _engine, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec16(this, _sheetId, {
      writable: true,
      value: null
    });
    _classPrivateFieldSet15(this, _rowIndexSyncer, new axisSyncer_default("row", rowIndexMapper, this));
    _classPrivateFieldSet15(this, _columnIndexSyncer, new axisSyncer_default("column", columnIndexMapper, this));
    _classPrivateFieldSet15(this, _postponeAction, postponeAction);
  }
  /**
   * Gets index synchronizer for a particular axis.
   *
   * @param {'row'|'column'} indexType Type of indexes.
   * @returns {AxisSyncer}
   */
  getForAxis(indexType) {
    if (indexType === "row") {
      return _classPrivateFieldGet16(this, _rowIndexSyncer);
    }
    return _classPrivateFieldGet16(this, _columnIndexSyncer);
  }
  /**
   * Sets flag informing whether an undo action is already performed (we don't execute synchronization in such case).
   *
   * @param {boolean} flagValue Boolean value for the flag.
   */
  setPerformUndo(flagValue) {
    _classPrivateFieldSet15(this, _isPerformingUndo, flagValue);
  }
  /**
   * Sets flag informing whether a redo action is already performed (we don't execute synchronization in such case).
   *
   * @param {boolean} flagValue Boolean value for the flag.
   */
  setPerformRedo(flagValue) {
    _classPrivateFieldSet15(this, _isPerformingRedo, flagValue);
  }
  /**
   * Gets information whether redo or undo action is already performed (we don't execute synchronization in such case).
   *
   * @private
   * @returns {boolean}
   */
  isPerformingUndoRedo() {
    return _classPrivateFieldGet16(this, _isPerformingUndo) || _classPrivateFieldGet16(this, _isPerformingRedo);
  }
  /**
   * Gets HyperFormula's sheet id.
   *
   * @returns {string|null}
   */
  getSheetId() {
    return _classPrivateFieldGet16(this, _sheetId);
  }
  /**
   * Gets engine instance that will be used for handled instance of Handsontable.
   *
   * @type {HyperFormula|null}
   */
  getEngine() {
    return _classPrivateFieldGet16(this, _engine);
  }
  /**
   * Gets method which will postpone execution of some action (needed when synchronization endpoint isn't setup yet).
   *
   * @returns {Function}
   */
  getPostponeAction() {
    return _classPrivateFieldGet16(this, _postponeAction);
  }
  /**
   * Setups a synchronization endpoint.
   *
   * @param {HyperFormula|null} engine The HF's engine instance which will be synced.
   * @param {string|null} sheetId HyperFormula's sheet name.
   */
  setupSyncEndpoint(engine, sheetId) {
    _classPrivateFieldSet15(this, _engine, engine);
    _classPrivateFieldSet15(this, _sheetId, sheetId);
    _classPrivateFieldGet16(this, _rowIndexSyncer).init();
    _classPrivateFieldGet16(this, _columnIndexSyncer).init();
  }
};
var indexSyncer_default = IndexSyncer;

// node_modules/handsontable/plugins/formulas/formulas.mjs
function _classPrivateMethodInitSpec25(obj, privateSet) {
  _checkPrivateRedeclaration31(obj, privateSet);
  privateSet.add(obj);
}
function _defineProperty37(obj, key, value) {
  key = _toPropertyKey37(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey37(arg) {
  var key = _toPrimitive37(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive37(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldInitSpec17(obj, privateMap, value) {
  _checkPrivateRedeclaration31(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration31(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet16(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor17(receiver, privateMap, "set");
  _classApplyDescriptorSet16(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet16(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet17(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor17(receiver, privateMap, "get");
  return _classApplyDescriptorGet17(receiver, descriptor);
}
function _classExtractFieldDescriptor17(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet17(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet25(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY17 = "formulas";
var SETTING_KEYS4 = ["maxRows", "maxColumns", "language"];
var PLUGIN_PRIORITY16 = 260;
pluginHooks_default.getSingleton().register("afterNamedExpressionAdded");
pluginHooks_default.getSingleton().register("afterNamedExpressionRemoved");
pluginHooks_default.getSingleton().register("afterSheetAdded");
pluginHooks_default.getSingleton().register("afterSheetRemoved");
pluginHooks_default.getSingleton().register("afterSheetRenamed");
pluginHooks_default.getSingleton().register("afterFormulasValuesUpdate");
var isBlockedSource = (source) => source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto";
var _internalOperationPending = /* @__PURE__ */ new WeakMap();
var _hotWasInitializedWithEmptyData = /* @__PURE__ */ new WeakMap();
var _engineListeners = /* @__PURE__ */ new WeakMap();
var _onBeforeValidate = /* @__PURE__ */ new WeakSet();
var _onBeforeAutofill = /* @__PURE__ */ new WeakSet();
var _onBeforeLoadData = /* @__PURE__ */ new WeakSet();
var _onAfterCellMetaReset = /* @__PURE__ */ new WeakSet();
var _onAfterLoadData6 = /* @__PURE__ */ new WeakSet();
var _onModifyData = /* @__PURE__ */ new WeakSet();
var _onModifySourceData = /* @__PURE__ */ new WeakSet();
var _onAfterSetDataAtCell = /* @__PURE__ */ new WeakSet();
var _onAfterSetSourceDataAtCell = /* @__PURE__ */ new WeakSet();
var _onBeforeCreateRow = /* @__PURE__ */ new WeakSet();
var _onBeforeCreateCol = /* @__PURE__ */ new WeakSet();
var _onBeforeRemoveRow = /* @__PURE__ */ new WeakSet();
var _onBeforeRemoveCol = /* @__PURE__ */ new WeakSet();
var _onAfterCreateRow = /* @__PURE__ */ new WeakSet();
var _onAfterCreateCol = /* @__PURE__ */ new WeakSet();
var _onAfterRemoveRow = /* @__PURE__ */ new WeakSet();
var _onAfterRemoveCol = /* @__PURE__ */ new WeakSet();
var _onAfterDetachChild = /* @__PURE__ */ new WeakSet();
var _onEngineValuesUpdated = /* @__PURE__ */ new WeakSet();
var _onEngineNamedExpressionsAdded = /* @__PURE__ */ new WeakSet();
var _onEngineNamedExpressionsRemoved = /* @__PURE__ */ new WeakSet();
var _onEngineSheetAdded = /* @__PURE__ */ new WeakSet();
var _onEngineSheetRenamed = /* @__PURE__ */ new WeakSet();
var _onEngineSheetRemoved = /* @__PURE__ */ new WeakSet();
var Formulas = class extends BasePlugin {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _classPrivateMethodInitSpec25(this, _onEngineSheetRemoved);
    _classPrivateMethodInitSpec25(this, _onEngineSheetRenamed);
    _classPrivateMethodInitSpec25(this, _onEngineSheetAdded);
    _classPrivateMethodInitSpec25(this, _onEngineNamedExpressionsRemoved);
    _classPrivateMethodInitSpec25(this, _onEngineNamedExpressionsAdded);
    _classPrivateMethodInitSpec25(this, _onEngineValuesUpdated);
    _classPrivateMethodInitSpec25(this, _onAfterDetachChild);
    _classPrivateMethodInitSpec25(this, _onAfterRemoveCol);
    _classPrivateMethodInitSpec25(this, _onAfterRemoveRow);
    _classPrivateMethodInitSpec25(this, _onAfterCreateCol);
    _classPrivateMethodInitSpec25(this, _onAfterCreateRow);
    _classPrivateMethodInitSpec25(this, _onBeforeRemoveCol);
    _classPrivateMethodInitSpec25(this, _onBeforeRemoveRow);
    _classPrivateMethodInitSpec25(this, _onBeforeCreateCol);
    _classPrivateMethodInitSpec25(this, _onBeforeCreateRow);
    _classPrivateMethodInitSpec25(this, _onAfterSetSourceDataAtCell);
    _classPrivateMethodInitSpec25(this, _onAfterSetDataAtCell);
    _classPrivateMethodInitSpec25(this, _onModifySourceData);
    _classPrivateMethodInitSpec25(this, _onModifyData);
    _classPrivateMethodInitSpec25(this, _onAfterLoadData6);
    _classPrivateMethodInitSpec25(this, _onAfterCellMetaReset);
    _classPrivateMethodInitSpec25(this, _onBeforeLoadData);
    _classPrivateMethodInitSpec25(this, _onBeforeAutofill);
    _classPrivateMethodInitSpec25(this, _onBeforeValidate);
    _classPrivateFieldInitSpec17(this, _internalOperationPending, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec17(this, _hotWasInitializedWithEmptyData, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec17(this, _engineListeners, {
      writable: true,
      value: [["valuesUpdated", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _classPrivateMethodGet25(_this, _onEngineValuesUpdated, _onEngineValuesUpdated2).call(_this, ...args);
      }], ["namedExpressionAdded", function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return _classPrivateMethodGet25(_this, _onEngineNamedExpressionsAdded, _onEngineNamedExpressionsAdded2).call(_this, ...args);
      }], ["namedExpressionRemoved", function() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return _classPrivateMethodGet25(_this, _onEngineNamedExpressionsRemoved, _onEngineNamedExpressionsRemoved2).call(_this, ...args);
      }], ["sheetAdded", function() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return _classPrivateMethodGet25(_this, _onEngineSheetAdded, _onEngineSheetAdded2).call(_this, ...args);
      }], ["sheetRenamed", function() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        return _classPrivateMethodGet25(_this, _onEngineSheetRenamed, _onEngineSheetRenamed2).call(_this, ...args);
      }], ["sheetRemoved", function() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        return _classPrivateMethodGet25(_this, _onEngineSheetRemoved, _onEngineSheetRemoved2).call(_this, ...args);
      }]]
    });
    _defineProperty37(this, "staticRegister", staticRegister("formulas"));
    _defineProperty37(this, "engine", null);
    _defineProperty37(this, "sheetName", null);
    _defineProperty37(this, "indexSyncer", null);
    _defineProperty37(this, "rowAxisSyncer", null);
    _defineProperty37(this, "columnAxisSyncer", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY17;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY16;
  }
  static get SETTING_KEYS() {
    return [PLUGIN_KEY17, ...SETTING_KEYS4];
  }
  /**
   * HyperFormula's sheet id.
   *
   * @type {number|null}
   */
  get sheetId() {
    return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link Formulas#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY17] ? true : false;
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _setupEngine, _this2 = this;
    if (this.enabled) {
      return;
    }
    this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;
    if (!this.engine) {
      warn("Missing the required `engine` key in the Formulas settings. Please fill it with either an engine class or an engine instance.");
      return;
    }
    if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {
      const newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());
      if (newSheetName !== false) {
        this.sheetName = newSheetName;
      }
    }
    this.addHook("beforeLoadData", function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _classPrivateMethodGet25(_this2, _onBeforeLoadData, _onBeforeLoadData2).call(_this2, ...args);
    });
    this.addHook("afterLoadData", function() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return _classPrivateMethodGet25(_this2, _onAfterLoadData6, _onAfterLoadData25).call(_this2, ...args);
    });
    this.addHook("beforeUpdateData", function() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return _classPrivateMethodGet25(_this2, _onBeforeLoadData, _onBeforeLoadData2).call(_this2, ...args);
    });
    this.addHook("afterUpdateData", function() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return _classPrivateMethodGet25(_this2, _onAfterLoadData6, _onAfterLoadData25).call(_this2, ...args);
    });
    this.addHook("modifyData", function() {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return _classPrivateMethodGet25(_this2, _onModifyData, _onModifyData2).call(_this2, ...args);
    });
    this.addHook("modifySourceData", function() {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return _classPrivateMethodGet25(_this2, _onModifySourceData, _onModifySourceData2).call(_this2, ...args);
    });
    this.addHook("beforeValidate", function() {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return _classPrivateMethodGet25(_this2, _onBeforeValidate, _onBeforeValidate2).call(_this2, ...args);
    });
    this.addHook("afterSetSourceDataAtCell", function() {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return _classPrivateMethodGet25(_this2, _onAfterSetSourceDataAtCell, _onAfterSetSourceDataAtCell2).call(_this2, ...args);
    });
    this.addHook("afterSetDataAtCell", function() {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return _classPrivateMethodGet25(_this2, _onAfterSetDataAtCell, _onAfterSetDataAtCell2).call(_this2, ...args);
    });
    this.addHook("afterSetDataAtRowProp", function() {
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }
      return _classPrivateMethodGet25(_this2, _onAfterSetDataAtCell, _onAfterSetDataAtCell2).call(_this2, ...args);
    });
    this.addHook("beforeCreateRow", function() {
      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
        args[_key17] = arguments[_key17];
      }
      return _classPrivateMethodGet25(_this2, _onBeforeCreateRow, _onBeforeCreateRow2).call(_this2, ...args);
    });
    this.addHook("beforeCreateCol", function() {
      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        args[_key18] = arguments[_key18];
      }
      return _classPrivateMethodGet25(_this2, _onBeforeCreateCol, _onBeforeCreateCol2).call(_this2, ...args);
    });
    this.addHook("afterCreateRow", function() {
      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        args[_key19] = arguments[_key19];
      }
      return _classPrivateMethodGet25(_this2, _onAfterCreateRow, _onAfterCreateRow2).call(_this2, ...args);
    });
    this.addHook("afterCreateCol", function() {
      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        args[_key20] = arguments[_key20];
      }
      return _classPrivateMethodGet25(_this2, _onAfterCreateCol, _onAfterCreateCol2).call(_this2, ...args);
    });
    this.addHook("beforeRemoveRow", function() {
      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
        args[_key21] = arguments[_key21];
      }
      return _classPrivateMethodGet25(_this2, _onBeforeRemoveRow, _onBeforeRemoveRow2).call(_this2, ...args);
    });
    this.addHook("beforeRemoveCol", function() {
      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }
      return _classPrivateMethodGet25(_this2, _onBeforeRemoveCol, _onBeforeRemoveCol2).call(_this2, ...args);
    });
    this.addHook("afterRemoveRow", function() {
      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
        args[_key23] = arguments[_key23];
      }
      return _classPrivateMethodGet25(_this2, _onAfterRemoveRow, _onAfterRemoveRow2).call(_this2, ...args);
    });
    this.addHook("afterRemoveCol", function() {
      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
        args[_key24] = arguments[_key24];
      }
      return _classPrivateMethodGet25(_this2, _onAfterRemoveCol, _onAfterRemoveCol2).call(_this2, ...args);
    });
    this.indexSyncer = new indexSyncer_default(this.hot.rowIndexMapper, this.hot.columnIndexMapper, (postponedAction) => {
      this.hot.addHookOnce("init", () => {
        postponedAction();
      });
    });
    this.rowAxisSyncer = this.indexSyncer.getForAxis("row");
    this.columnAxisSyncer = this.indexSyncer.getForAxis("column");
    this.hot.addHook("afterRowSequenceChange", this.rowAxisSyncer.getIndexesChangeSyncMethod());
    this.hot.addHook("afterColumnSequenceChange", this.columnAxisSyncer.getIndexesChangeSyncMethod());
    this.hot.addHook("beforeRowMove", (movedRows, finalIndex, _, movePossible) => {
      this.rowAxisSyncer.storeMovesInformation(movedRows, finalIndex, movePossible);
    });
    this.hot.addHook("beforeColumnMove", (movedColumns, finalIndex, _, movePossible) => {
      this.columnAxisSyncer.storeMovesInformation(movedColumns, finalIndex, movePossible);
    });
    this.hot.addHook("afterRowMove", (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {
      this.rowAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);
    });
    this.hot.addHook("afterColumnMove", (movedColumns, finalIndex, dropIndex, movePossible, orderChanged) => {
      this.columnAxisSyncer.calculateAndSyncMoves(movePossible, orderChanged);
    });
    this.hot.addHook("beforeColumnFreeze", (column, freezePerformed) => {
      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart, freezePerformed);
    });
    this.hot.addHook("afterColumnFreeze", (_, freezePerformed) => {
      this.columnAxisSyncer.calculateAndSyncMoves(freezePerformed, freezePerformed);
    });
    this.hot.addHook("beforeColumnUnfreeze", (column, unfreezePerformed) => {
      this.columnAxisSyncer.storeMovesInformation([column], this.hot.getSettings().fixedColumnsStart - 1, unfreezePerformed);
    });
    this.hot.addHook("afterColumnUnfreeze", (_, unfreezePerformed) => {
      this.columnAxisSyncer.calculateAndSyncMoves(unfreezePerformed, unfreezePerformed);
    });
    this.addHook("afterCellMetaReset", function() {
      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
        args[_key25] = arguments[_key25];
      }
      return _classPrivateMethodGet25(_this2, _onAfterCellMetaReset, _onAfterCellMetaReset2).call(_this2, ...args);
    });
    this.addHook("beforeUndo", () => {
      this.indexSyncer.setPerformUndo(true);
      this.engine.undo();
    });
    this.addHook("beforeRedo", () => {
      this.indexSyncer.setPerformRedo(true);
      this.engine.redo();
    });
    this.addHook("afterUndo", () => {
      this.indexSyncer.setPerformUndo(false);
    });
    this.addHook("afterUndo", () => {
      this.indexSyncer.setPerformRedo(false);
    });
    this.addHook("afterDetachChild", function() {
      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
        args[_key26] = arguments[_key26];
      }
      return _classPrivateMethodGet25(_this2, _onAfterDetachChild, _onAfterDetachChild2).call(_this2, ...args);
    });
    this.addHook("beforeAutofill", function() {
      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {
        args[_key27] = arguments[_key27];
      }
      return _classPrivateMethodGet25(_this2, _onBeforeAutofill, _onBeforeAutofill2).call(_this2, ...args);
    });
    _classPrivateFieldGet17(this, _engineListeners).forEach((_ref) => {
      let [eventName, listener] = _ref;
      return this.engine.on(eventName, listener);
    });
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    _classPrivateFieldGet17(this, _engineListeners).forEach((_ref2) => {
      let [eventName, listener] = _ref2;
      return this.engine.off(eventName, listener);
    });
    unregisterEngine(this.engine, this.hot);
    this.engine = null;
    super.disablePlugin();
  }
  /**
   * Triggered on `updateSettings`.
   *
   * @private
   * @param {object} newSettings New set of settings passed to the `updateSettings` method.
   */
  updatePlugin(newSettings) {
    const newEngineSettings = getEngineSettingsWithOverrides(this.hot.getSettings());
    if (haveEngineSettingsChanged(this.engine.getConfig(), newEngineSettings)) {
      this.engine.updateConfig(newEngineSettings);
    }
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY17];
    if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {
      this.switchSheet(pluginSettings.sheetName);
    }
    if (!newSettings.data && this.sheetName === null) {
      const sheetName = this.hot.getSettings()[PLUGIN_KEY17].sheetName;
      if (sheetName && this.engine.doesSheetExist(sheetName)) {
        this.switchSheet(this.sheetName);
      } else {
        this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());
      }
    }
    super.updatePlugin(newSettings);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldGet17(this, _engineListeners).forEach((_ref3) => {
      var _this$engine;
      let [eventName, listener] = _ref3;
      return (_this$engine = this.engine) === null || _this$engine === void 0 ? void 0 : _this$engine.off(eventName, listener);
    });
    _classPrivateFieldSet16(this, _engineListeners, null);
    unregisterEngine(this.engine, this.hot);
    this.engine = null;
    super.destroy();
  }
  /**
   * Add a sheet to the shared HyperFormula instance.
   *
   * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be
   * auto-generated by HyperFormula.
   * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of
   * arrays - array of objects is not supported in this scenario.
   * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the
   * engine, the created sheet name otherwise.
   */
  addSheet(sheetName, sheetData) {
    if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {
      warn("The provided data should be an array of arrays.");
      return false;
    }
    if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {
      warn("Sheet with the provided name already exists.");
      return false;
    }
    try {
      const actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);
      if (sheetData) {
        this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);
      }
      return actualSheetName;
    } catch (e) {
      warn(e.message);
      return false;
    }
  }
  /**
   * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula
   * instance).
   *
   * @param {string} sheetName Sheet name used in the shared HyperFormula instance.
   */
  switchSheet(sheetName) {
    if (!this.engine.doesSheetExist(sheetName)) {
      error(`The sheet named \`${sheetName}\` does not exist, switch aborted.`);
      return;
    }
    this.sheetName = sheetName;
    const serialized = this.engine.getSheetSerialized(this.sheetId);
    if (serialized.length > 0) {
      this.hot.loadData(serialized, `${toUpperCaseFirst(PLUGIN_KEY17)}.switchSheet`);
    }
  }
  /**
   * Get the cell type under specified visual coordinates.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {number} [sheet] The target sheet id, defaults to the current sheet.
   * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.
   */
  getCellType(row, column) {
    let sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.sheetId;
    const physicalRow = this.hot.toPhysicalRow(row);
    const physicalColumn = this.hot.toPhysicalColumn(column);
    if (physicalRow !== null && physicalColumn !== null) {
      return this.engine.getCellType({
        sheet,
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)
      });
    } else {
      return "EMPTY";
    }
  }
  /**
   * Returns `true` if under specified visual coordinates is formula.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {number} [sheet] The target sheet id, defaults to the current sheet.
   * @returns {boolean}
   */
  isFormulaCellType(row, column) {
    let sheet = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.sheetId;
    return this.engine.doesCellHaveFormula({
      sheet,
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column)
    });
  }
  /**
   * Renders dependent sheets (handsontable instances) based on the changes - list of the
   * recalculated dependent cells.
   *
   * @private
   * @param {object[]} dependentCells The values and location of applied changes within HF engine.
   * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.
   */
  renderDependentSheets(dependentCells) {
    let renderSelf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const affectedSheetIds = /* @__PURE__ */ new Set();
    dependentCells.forEach((change) => {
      var _change$address;
      const sheetId = change === null || change === void 0 || (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;
      if (sheetId !== void 0) {
        if (!affectedSheetIds.has(sheetId)) {
          affectedSheetIds.add(sheetId);
        }
      }
    });
    getRegisteredHotInstances(this.engine).forEach((relatedHot, sheetId) => {
      if ((renderSelf || sheetId !== this.sheetId) && affectedSheetIds.has(sheetId)) {
        var _relatedHot$view;
        relatedHot.render();
        (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 || _relatedHot$view.adjustElementsSize();
      }
    });
  }
  /**
   * Validates dependent cells based on the cells that are modified by the change.
   *
   * @private
   * @param {object[]} dependentCells The values and location of applied changes within HF engine.
   * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).
   */
  validateDependentCells(dependentCells) {
    let changedCells = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const stringifyAddress = (change) => {
      var _change$address2;
      const {
        row,
        col,
        sheet
      } = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {};
      return isDefined(sheet) ? `${sheet}:${row}x${col}` : "";
    };
    const changedCellsSet = new Set(changedCells.map((change) => stringifyAddress(change)));
    dependentCells.forEach((change) => {
      var _change$address3, _change$address4;
      const {
        row,
        col
      } = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {};
      if (isDefined(row) === false || isDefined(col) === false || row >= this.hot.countRows() || col >= this.hot.countCols()) {
        return;
      }
      const sheetId = change === null || change === void 0 || (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;
      const addressId = stringifyAddress(change);
      if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {
        const boundHot = getRegisteredHotInstances(this.engine).get(sheetId);
        if (!boundHot) {
          return;
        }
        boundHot.validateCell(boundHot.getDataAtCell(row, col), boundHot.getCellMeta(row, col), () => {
        });
      }
    });
  }
  /**
   * Sync a change from the change-related hooks with the engine.
   *
   * @private
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {Handsontable.CellValue} newValue New value.
   * @returns {Array} Array of changes exported from the engine.
   */
  syncChangeWithEngine(row, column, newValue) {
    const address = {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(row),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(column),
      sheet: this.sheetId
    };
    if (!this.engine.isItPossibleToSetCellContents(address)) {
      warn(`Not possible to set cell data at ${JSON.stringify(address)}`);
      return;
    }
    const cellMeta = this.hot.getCellMeta(row, column);
    if (isDate(newValue, cellMeta.type)) {
      if (isDateValid(newValue, cellMeta.dateFormat)) {
        newValue = getDateInHfFormat(newValue, cellMeta.dateFormat);
      } else if (isFormula(newValue) === false) {
        newValue = `'${newValue}`;
      }
    }
    return this.engine.setCellContents(address, newValue);
  }
};
function _onBeforeValidate2(value, visualRow, prop) {
  const visualColumn = this.hot.propToCol(prop);
  if (this.isFormulaCellType(visualRow, visualColumn)) {
    const address = {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
      sheet: this.sheetId
    };
    const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);
    let cellValue = this.engine.getCellValue(address);
    if (cellMeta.type === "date" && isNumeric(cellValue)) {
      cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);
    }
    return typeof cellValue === "object" && cellValue !== null ? cellValue.value : cellValue;
  }
  return value;
}
function _onBeforeAutofill2(fillData, sourceRange, targetRange) {
  const {
    row: sourceTopStartRow,
    col: sourceTopStartColumn
  } = sourceRange.getTopStartCorner();
  const {
    row: sourceBottomEndRow,
    col: sourceBottomEndColumn
  } = sourceRange.getBottomEndCorner();
  const {
    row: targetTopStartRow,
    col: targetTopStartColumn
  } = targetRange.getTopStartCorner();
  const {
    row: targetBottomEndRow,
    col: targetBottomEndColumn
  } = targetRange.getBottomEndCorner();
  const engineSourceRange = {
    start: {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartRow),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceTopStartColumn),
      sheet: this.sheetId
    },
    end: {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndRow),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(sourceBottomEndColumn),
      sheet: this.sheetId
    }
  };
  const engineTargetRange = {
    start: {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetTopStartRow),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetTopStartColumn),
      sheet: this.sheetId
    },
    end: {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndRow),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(targetBottomEndColumn),
      sheet: this.sheetId
    }
  };
  if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {
    return false;
  }
  const fillRangeData = this.engine.getFillRangeData(engineSourceRange, engineTargetRange);
  const {
    row: sourceStartRow,
    col: sourceStartColumn
  } = engineSourceRange.start;
  const {
    row: sourceEndRow,
    col: sourceEndColumn
  } = engineSourceRange.end;
  const populationRowLength = sourceEndRow - sourceStartRow + 1;
  const populationColumnLength = sourceEndColumn - sourceStartColumn + 1;
  for (let populatedRowIndex = 0; populatedRowIndex < fillRangeData.length; populatedRowIndex += 1) {
    for (let populatedColumnIndex = 0; populatedColumnIndex < fillRangeData[populatedRowIndex].length; populatedColumnIndex += 1) {
      const populatedValue = fillRangeData[populatedRowIndex][populatedColumnIndex];
      const sourceRow = populatedRowIndex % populationRowLength;
      const sourceColumn = populatedColumnIndex % populationColumnLength;
      const sourceCellMeta = this.hot.getCellMeta(sourceRow, sourceColumn);
      if (isDate(populatedValue, sourceCellMeta.type)) {
        if (populatedValue.startsWith("'")) {
          fillRangeData[populatedRowIndex][populatedColumnIndex] = populatedValue.slice(1);
        } else if (this.isFormulaCellType(sourceRow, sourceColumn, this.sheetId) === false) {
          fillRangeData[populatedRowIndex][populatedColumnIndex] = getDateInHotFormat(populatedValue, sourceCellMeta.dateFormat);
        }
      }
    }
  }
  return fillRangeData;
}
function _onBeforeLoadData2(sourceData, initialLoad) {
  let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (source.includes(toUpperCaseFirst(PLUGIN_KEY17))) {
    return;
  }
  _classPrivateFieldSet16(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));
}
function _onAfterCellMetaReset2() {
  const sourceDataArray = this.hot.getSourceDataArray();
  let valueChanged = false;
  sourceDataArray.forEach((rowData, rowIndex) => {
    rowData.forEach((cellValue, columnIndex) => {
      const cellMeta = this.hot.getCellMeta(rowIndex, columnIndex);
      const dateFormat = cellMeta.dateFormat;
      if (isDate(cellValue, cellMeta.type)) {
        valueChanged = true;
        if (isDateValid(cellValue, dateFormat)) {
          sourceDataArray[rowIndex][columnIndex] = getDateInHfFormat(cellValue, dateFormat);
        } else if (this.isFormulaCellType(rowIndex, columnIndex) === false) {
          sourceDataArray[rowIndex][columnIndex] = `'${cellValue}`;
        }
      }
    });
  });
  if (valueChanged === true) {
    _classPrivateFieldSet16(this, _internalOperationPending, true);
    this.engine.setSheetContent(this.sheetId, sourceDataArray);
    _classPrivateFieldSet16(this, _internalOperationPending, false);
  }
}
function _onAfterLoadData25(sourceData, initialLoad) {
  let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (source.includes(toUpperCaseFirst(PLUGIN_KEY17))) {
    return;
  }
  this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY17].sheetName);
  if (!_classPrivateFieldGet17(this, _hotWasInitializedWithEmptyData)) {
    const sourceDataArray = this.hot.getSourceDataArray();
    if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {
      _classPrivateFieldSet16(this, _internalOperationPending, true);
      const dependentCells = this.engine.setSheetContent(this.sheetId, sourceDataArray);
      this.indexSyncer.setupSyncEndpoint(this.engine, this.sheetId);
      this.renderDependentSheets(dependentCells);
      _classPrivateFieldSet16(this, _internalOperationPending, false);
    }
  } else {
    this.switchSheet(this.sheetName);
  }
}
function _onModifyData2(physicalRow, visualColumn, valueHolder, ioMode) {
  if (ioMode !== "get" || _classPrivateFieldGet17(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {
    return;
  }
  const visualRow = this.hot.toVisualRow(physicalRow);
  if (visualRow === null || visualColumn === null) {
    return;
  }
  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);
  if (!isFormulaCellType) {
    const cellType = this.getCellType(visualRow, visualColumn);
    if (cellType !== "ARRAY") {
      if (isEscapedFormulaExpression(valueHolder.value)) {
        valueHolder.value = unescapeFormulaExpression(valueHolder.value);
      }
      return;
    }
  }
  const address = {
    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
    sheet: this.sheetId
  };
  let cellValue = this.engine.getCellValue(address);
  const cellMeta = this.hot.getCellMeta(visualRow, visualColumn);
  if (cellMeta.type === "date" && isNumeric(cellValue)) {
    cellValue = getDateFromExcelDate(cellValue, cellMeta.dateFormat);
  }
  const value = typeof cellValue === "object" && cellValue !== null ? cellValue.value : cellValue;
  valueHolder.value = value;
}
function _onModifySourceData2(row, columnOrProp, valueHolder, ioMode) {
  if (ioMode !== "get" || _classPrivateFieldGet17(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {
    return;
  }
  const visualRow = this.hot.toVisualRow(row);
  const visualColumn = this.hot.propToCol(columnOrProp);
  if (visualRow === null || visualColumn === null) {
    return;
  }
  const isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);
  if (!isFormulaCellType) {
    const cellType = this.getCellType(visualRow, visualColumn);
    if (cellType !== "ARRAY") {
      return;
    }
  }
  const dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName));
  if (dimensions.width === 0 && dimensions.height === 0) {
    return;
  }
  const address = {
    row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
    col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
    sheet: this.sheetId
  };
  valueHolder.value = this.engine.getCellSerialized(address);
}
function _onAfterSetDataAtCell2(changes, source) {
  if (isBlockedSource(source)) {
    return;
  }
  const outOfBoundsChanges = [];
  const changedCells = [];
  const dependentCells = this.engine.batch(() => {
    changes.forEach((_ref4) => {
      let [visualRow, prop, , newValue] = _ref4;
      const visualColumn = this.hot.propToCol(prop);
      const physicalRow = this.hot.toPhysicalRow(visualRow);
      const physicalColumn = this.hot.toPhysicalColumn(visualColumn);
      const address = {
        row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
        col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
        sheet: this.sheetId
      };
      if (physicalRow !== null && physicalColumn !== null) {
        this.syncChangeWithEngine(visualRow, visualColumn, newValue);
      } else {
        outOfBoundsChanges.push([visualRow, visualColumn, newValue]);
      }
      changedCells.push({
        address
      });
    });
  });
  if (outOfBoundsChanges.length) {
    this.hot.addHookOnce("afterChange", () => {
      const outOfBoundsDependentCells = this.engine.batch(() => {
        outOfBoundsChanges.forEach((_ref5) => {
          let [row, column, newValue] = _ref5;
          this.syncChangeWithEngine(row, column, newValue);
        });
      });
      this.renderDependentSheets(outOfBoundsDependentCells, true);
    });
  }
  this.renderDependentSheets(dependentCells);
  this.validateDependentCells(dependentCells, changedCells);
}
function _onAfterSetSourceDataAtCell2(changes, source) {
  if (isBlockedSource(source)) {
    return;
  }
  const dependentCells = [];
  const changedCells = [];
  changes.forEach((_ref6) => {
    let [visualRow, prop, , newValue] = _ref6;
    const visualColumn = this.hot.propToCol(prop);
    if (!isNumeric(visualColumn)) {
      return;
    }
    const address = {
      row: this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow),
      col: this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn),
      sheet: this.sheetId
    };
    if (!this.engine.isItPossibleToSetCellContents(address)) {
      warn(`Not possible to set source cell data at ${JSON.stringify(address)}`);
      return;
    }
    changedCells.push({
      address
    });
    dependentCells.push(...this.engine.setCellContents(address, newValue));
  });
  this.renderDependentSheets(dependentCells);
  this.validateDependentCells(dependentCells, changedCells);
}
function _onBeforeCreateRow2(visualRow, amount) {
  let hfRowIndex = this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow);
  if (visualRow >= this.hot.countRows()) {
    hfRowIndex = visualRow;
  }
  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [hfRowIndex, amount])) {
    return false;
  }
}
function _onBeforeCreateCol2(visualColumn, amount) {
  let hfColumnIndex = this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn);
  if (visualColumn >= this.hot.countCols()) {
    hfColumnIndex = visualColumn;
  }
  if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [hfColumnIndex, amount])) {
    return false;
  }
}
function _onBeforeRemoveRow2(row, amount, physicalRows) {
  const hfRows = this.rowAxisSyncer.setRemovedHfIndexes(physicalRows);
  const possible = hfRows.every((hfRow) => {
    return this.engine.isItPossibleToRemoveRows(this.sheetId, [hfRow, 1]);
  });
  return possible === false ? false : void 0;
}
function _onBeforeRemoveCol2(col, amount, physicalColumns) {
  const hfColumns = this.columnAxisSyncer.setRemovedHfIndexes(physicalColumns);
  const possible = hfColumns.every((hfColumn) => {
    return this.engine.isItPossibleToRemoveColumns(this.sheetId, [hfColumn, 1]);
  });
  return possible === false ? false : void 0;
}
function _onAfterCreateRow2(visualRow, amount, source) {
  if (isBlockedSource(source)) {
    return;
  }
  const changes = this.engine.addRows(this.sheetId, [this.rowAxisSyncer.getHfIndexFromVisualIndex(visualRow), amount]);
  this.renderDependentSheets(changes);
}
function _onAfterCreateCol2(visualColumn, amount, source) {
  if (isBlockedSource(source)) {
    return;
  }
  const changes = this.engine.addColumns(this.sheetId, [this.columnAxisSyncer.getHfIndexFromVisualIndex(visualColumn), amount]);
  this.renderDependentSheets(changes);
}
function _onAfterRemoveRow2(row, amount, physicalRows, source) {
  if (isBlockedSource(source)) {
    return;
  }
  const descendingHfRows = this.rowAxisSyncer.getRemovedHfIndexes().sort().reverse();
  const changes = this.engine.batch(() => {
    descendingHfRows.forEach((hfRow) => {
      this.engine.removeRows(this.sheetId, [hfRow, 1]);
    });
  });
  this.renderDependentSheets(changes);
}
function _onAfterRemoveCol2(col, amount, physicalColumns, source) {
  if (isBlockedSource(source)) {
    return;
  }
  const descendingHfColumns = this.columnAxisSyncer.getRemovedHfIndexes().sort().reverse();
  const changes = this.engine.batch(() => {
    descendingHfColumns.forEach((hfColumn) => {
      this.engine.removeColumns(this.sheetId, [hfColumn, 1]);
    });
  });
  this.renderDependentSheets(changes);
}
function _onAfterDetachChild2(parent, element, finalElementRowIndex) {
  var _element$__children;
  _classPrivateFieldSet16(this, _internalOperationPending, true);
  const rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());
  _classPrivateFieldSet16(this, _internalOperationPending, false);
  rowsData.forEach((row, relativeRowIndex) => {
    row.forEach((value, colIndex) => {
      this.engine.setCellContents({
        col: colIndex,
        row: finalElementRowIndex + relativeRowIndex,
        sheet: this.sheetId
      }, [[value]]);
    });
  });
}
function _onEngineValuesUpdated2(changes) {
  this.hot.runHooks("afterFormulasValuesUpdate", changes);
}
function _onEngineNamedExpressionsAdded2(namedExpressionName, changes) {
  this.hot.runHooks("afterNamedExpressionAdded", namedExpressionName, changes);
}
function _onEngineNamedExpressionsRemoved2(namedExpressionName, changes) {
  this.hot.runHooks("afterNamedExpressionRemoved", namedExpressionName, changes);
}
function _onEngineSheetAdded2(addedSheetDisplayName) {
  this.hot.runHooks("afterSheetAdded", addedSheetDisplayName);
}
function _onEngineSheetRenamed2(oldDisplayName, newDisplayName) {
  this.hot.runHooks("afterSheetRenamed", oldDisplayName, newDisplayName);
}
function _onEngineSheetRemoved2(removedSheetDisplayName, changes) {
  this.hot.runHooks("afterSheetRemoved", removedSheetDisplayName, changes);
}

// node_modules/handsontable/plugins/hiddenColumns/contextMenuItem/hideColumn.mjs
function hideColumnItem(hiddenColumnsPlugin) {
  return {
    key: "hidden_columns_hide",
    name() {
      const selection = this.getSelectedLast();
      let pluralForm = 0;
      if (Array.isArray(selection)) {
        const [, fromColumn, , toColumn] = selection;
        if (fromColumn - toColumn !== 0) {
          pluralForm = 1;
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_COLUMN, pluralForm);
    },
    callback() {
      const {
        from,
        to
      } = this.getSelectedRangeLast();
      const start = Math.max(Math.min(from.col, to.col), 0);
      const end = Math.max(from.col, to.col);
      const columnsToHide = [];
      for (let visualColumn = start; visualColumn <= end; visualColumn += 1) {
        columnsToHide.push(visualColumn);
      }
      hiddenColumnsPlugin.hideColumns(columnsToHide);
      const lastHiddenColumn = columnsToHide[columnsToHide.length - 1];
      const columnToSelect = this.columnIndexMapper.getNearestNotHiddenIndex(lastHiddenColumn, 1, true);
      if (Number.isInteger(columnToSelect) && columnToSelect >= 0) {
        this.selectColumns(columnToSelect);
      } else {
        this.deselectCell();
      }
      this.render();
      this.view.adjustElementsSize(true);
    },
    disabled: false,
    hidden() {
      return !(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner());
    }
  };
}

// node_modules/handsontable/plugins/hiddenColumns/contextMenuItem/showColumn.mjs
function showColumnItem(hiddenColumnsPlugin) {
  const columns = [];
  return {
    key: "hidden_columns_show",
    name() {
      const pluralForm = columns.length > 1 ? 1 : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_COLUMN, pluralForm);
    },
    callback() {
      var _this$columnIndexMapp, _this$columnIndexMapp2;
      if (columns.length === 0) {
        return;
      }
      let startVisualColumn = columns[0];
      let endVisualColumn = columns[columns.length - 1];
      startVisualColumn = (_this$columnIndexMapp = this.columnIndexMapper.getNearestNotHiddenIndex(startVisualColumn - 1, -1)) !== null && _this$columnIndexMapp !== void 0 ? _this$columnIndexMapp : 0;
      endVisualColumn = (_this$columnIndexMapp2 = this.columnIndexMapper.getNearestNotHiddenIndex(endVisualColumn + 1, 1)) !== null && _this$columnIndexMapp2 !== void 0 ? _this$columnIndexMapp2 : this.countCols() - 1;
      hiddenColumnsPlugin.showColumns(columns);
      this.render();
      this.view.adjustElementsSize(true);
      const allColumnsSelected = endVisualColumn - startVisualColumn + 1 === this.countCols();
      if (!allColumnsSelected) {
        this.selectColumns(startVisualColumn, endVisualColumn);
      }
    },
    disabled: false,
    hidden() {
      const hiddenPhysicalColumns = arrayMap(hiddenColumnsPlugin.getHiddenColumns(), (visualColumnIndex) => {
        return this.toPhysicalColumn(visualColumnIndex);
      });
      if (!(this.selection.isSelectedByColumnHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalColumns.length < 1) {
        return true;
      }
      columns.length = 0;
      const selectedRangeLast = this.getSelectedRangeLast();
      const visualStartColumn = selectedRangeLast.getTopStartCorner().col;
      const visualEndColumn = selectedRangeLast.getBottomEndCorner().col;
      const columnIndexMapper = this.columnIndexMapper;
      const renderableStartColumn = columnIndexMapper.getRenderableFromVisualIndex(visualStartColumn);
      const renderableEndColumn = columnIndexMapper.getRenderableFromVisualIndex(visualEndColumn);
      const notTrimmedColumnIndexes = columnIndexMapper.getNotTrimmedIndexes();
      const physicalColumnIndexes = [];
      if (visualStartColumn !== visualEndColumn) {
        const visualColumnsInRange = visualEndColumn - visualStartColumn + 1;
        const renderedColumnsInRange = renderableEndColumn - renderableStartColumn + 1;
        if (visualColumnsInRange > renderedColumnsInRange) {
          const physicalIndexesInRange = notTrimmedColumnIndexes.slice(visualStartColumn, visualEndColumn + 1);
          physicalColumnIndexes.push(...physicalIndexesInRange.filter((physicalIndex) => hiddenPhysicalColumns.includes(physicalIndex)));
        }
      } else if (renderableStartColumn === 0 && renderableStartColumn < visualStartColumn) {
        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, visualStartColumn));
      } else if (renderableStartColumn === null) {
        physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(0, this.countCols()));
      } else {
        const lastVisualIndex = this.countCols() - 1;
        const lastRenderableIndex = columnIndexMapper.getRenderableFromVisualIndex(columnIndexMapper.getNearestNotHiddenIndex(lastVisualIndex, -1));
        if (renderableEndColumn === lastRenderableIndex && lastVisualIndex > visualEndColumn) {
          physicalColumnIndexes.push(...notTrimmedColumnIndexes.slice(visualEndColumn + 1));
        }
      }
      arrayEach(physicalColumnIndexes, (physicalColumnIndex) => {
        columns.push(this.toVisualColumn(physicalColumnIndex));
      });
      return columns.length === 0;
    }
  };
}

// node_modules/handsontable/plugins/hiddenColumns/hiddenColumns.mjs
function _classPrivateMethodInitSpec26(obj, privateSet) {
  _checkPrivateRedeclaration32(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec18(obj, privateMap, value) {
  _checkPrivateRedeclaration32(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration32(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet26(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet18(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor18(receiver, privateMap, "get");
  return _classApplyDescriptorGet18(receiver, descriptor);
}
function _classApplyDescriptorGet18(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet17(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor18(receiver, privateMap, "set");
  _classApplyDescriptorSet17(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor18(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet17(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
pluginHooks_default.getSingleton().register("beforeHideColumns");
pluginHooks_default.getSingleton().register("afterHideColumns");
pluginHooks_default.getSingleton().register("beforeUnhideColumns");
pluginHooks_default.getSingleton().register("afterUnhideColumns");
var PLUGIN_KEY18 = "hiddenColumns";
var PLUGIN_PRIORITY17 = 310;
var _settings = /* @__PURE__ */ new WeakMap();
var _hiddenColumnsMap = /* @__PURE__ */ new WeakMap();
var _onModifyColWidth = /* @__PURE__ */ new WeakSet();
var _onAfterGetCellMeta = /* @__PURE__ */ new WeakSet();
var _onModifyCopyableRange = /* @__PURE__ */ new WeakSet();
var _onAfterGetColHeader6 = /* @__PURE__ */ new WeakSet();
var _onAfterContextMenuDefaultOptions4 = /* @__PURE__ */ new WeakSet();
var _onMapInit = /* @__PURE__ */ new WeakSet();
var HiddenColumns = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec26(this, _onMapInit);
    _classPrivateMethodInitSpec26(this, _onAfterContextMenuDefaultOptions4);
    _classPrivateMethodInitSpec26(this, _onAfterGetColHeader6);
    _classPrivateMethodInitSpec26(this, _onModifyCopyableRange);
    _classPrivateMethodInitSpec26(this, _onAfterGetCellMeta);
    _classPrivateMethodInitSpec26(this, _onModifyColWidth);
    _classPrivateFieldInitSpec18(this, _settings, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec18(this, _hiddenColumnsMap, {
      writable: true,
      value: null
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY18;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY17;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link HiddenColumns#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY18];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY18];
    if (isObject(pluginSettings)) {
      _classPrivateFieldSet17(this, _settings, pluginSettings);
      if (isUndefined(pluginSettings.copyPasteEnabled)) {
        pluginSettings.copyPasteEnabled = true;
      }
    }
    _classPrivateFieldSet17(this, _hiddenColumnsMap, new HidingMap());
    _classPrivateFieldGet18(this, _hiddenColumnsMap).addLocalHook("init", () => _classPrivateMethodGet26(this, _onMapInit, _onMapInit2).call(this));
    this.hot.columnIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet18(this, _hiddenColumnsMap));
    this.addHook("afterContextMenuDefaultOptions", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet26(_this, _onAfterContextMenuDefaultOptions4, _onAfterContextMenuDefaultOptions23).call(_this, ...args);
    });
    this.addHook("afterGetCellMeta", (row, col, cellProperties) => _classPrivateMethodGet26(this, _onAfterGetCellMeta, _onAfterGetCellMeta2).call(this, row, col, cellProperties));
    this.addHook("modifyColWidth", (width, col) => _classPrivateMethodGet26(this, _onModifyColWidth, _onModifyColWidth2).call(this, width, col));
    this.addHook("afterGetColHeader", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet26(_this, _onAfterGetColHeader6, _onAfterGetColHeader25).call(_this, ...args);
    });
    this.addHook("modifyCopyableRange", (ranges) => _classPrivateMethodGet26(this, _onModifyCopyableRange, _onModifyCopyableRange2).call(this, ranges));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`hiddenColumns`](@/api/options.md#hiddencolumns)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.columnIndexMapper.unregisterMap(this.pluginName);
    _classPrivateFieldSet17(this, _settings, {});
    super.disablePlugin();
    this.resetCellsMeta();
  }
  /**
   * Shows the provided columns.
   *
   * @param {number[]} columns Array of visual column indexes.
   */
  showColumns(columns) {
    const currentHideConfig = this.getHiddenColumns();
    const isValidConfig = this.isValidConfig(columns);
    let destinationHideConfig = currentHideConfig;
    const hidingMapValues = _classPrivateFieldGet18(this, _hiddenColumnsMap).getValues().slice();
    const isAnyColumnShowed = columns.length > 0;
    if (isValidConfig && isAnyColumnShowed) {
      const physicalColumns = columns.map((visualColumn) => this.hot.toPhysicalColumn(visualColumn));
      arrayEach(physicalColumns, (physicalColumn) => {
        hidingMapValues[physicalColumn] = false;
      });
      destinationHideConfig = arrayReduce(hidingMapValues, (hiddenIndexes, isHidden, physicalIndex) => {
        if (isHidden) {
          hiddenIndexes.push(this.hot.toVisualColumn(physicalIndex));
        }
        return hiddenIndexes;
      }, []);
    }
    const continueHiding = this.hot.runHooks("beforeUnhideColumns", currentHideConfig, destinationHideConfig, isValidConfig && isAnyColumnShowed);
    if (continueHiding === false) {
      return;
    }
    if (isValidConfig && isAnyColumnShowed) {
      _classPrivateFieldGet18(this, _hiddenColumnsMap).setValues(hidingMapValues);
    }
    this.hot.view.adjustElementsSize();
    this.hot.runHooks("afterUnhideColumns", currentHideConfig, destinationHideConfig, isValidConfig && isAnyColumnShowed, isValidConfig && destinationHideConfig.length < currentHideConfig.length);
  }
  /**
   * Shows a single column.
   *
   * @param {...number} column Visual column index.
   */
  showColumn() {
    for (var _len3 = arguments.length, column = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      column[_key3] = arguments[_key3];
    }
    this.showColumns(column);
  }
  /**
   * Hides the columns provided in the array.
   *
   * @param {number[]} columns Array of visual column indexes.
   */
  hideColumns(columns) {
    const currentHideConfig = this.getHiddenColumns();
    const isConfigValid = this.isValidConfig(columns);
    let destinationHideConfig = currentHideConfig;
    if (isConfigValid) {
      destinationHideConfig = Array.from(new Set(currentHideConfig.concat(columns)));
    }
    const continueHiding = this.hot.runHooks("beforeHideColumns", currentHideConfig, destinationHideConfig, isConfigValid);
    if (continueHiding === false) {
      return;
    }
    if (isConfigValid) {
      this.hot.batchExecution(() => {
        arrayEach(columns, (visualColumn) => {
          _classPrivateFieldGet18(this, _hiddenColumnsMap).setValueAtIndex(this.hot.toPhysicalColumn(visualColumn), true);
        });
      }, true);
    }
    this.hot.runHooks("afterHideColumns", currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && destinationHideConfig.length > currentHideConfig.length);
  }
  /**
   * Hides a single column.
   *
   * @param {...number} column Visual column index.
   */
  hideColumn() {
    for (var _len4 = arguments.length, column = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      column[_key4] = arguments[_key4];
    }
    this.hideColumns(column);
  }
  /**
   * Returns an array of visual indexes of hidden columns.
   *
   * @returns {number[]}
   */
  getHiddenColumns() {
    return arrayMap(_classPrivateFieldGet18(this, _hiddenColumnsMap).getHiddenIndexes(), (physicalColumnIndex) => {
      return this.hot.toVisualColumn(physicalColumnIndex);
    });
  }
  /**
   * Checks if the provided column is hidden.
   *
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  isHidden(column) {
    return _classPrivateFieldGet18(this, _hiddenColumnsMap).getValueAtIndex(this.hot.toPhysicalColumn(column)) || false;
  }
  /**
   * Get if trim config is valid. Check whether all of the provided column indexes are within the bounds of the table.
   *
   * @param {Array} hiddenColumns List of hidden column indexes.
   * @returns {boolean}
   */
  isValidConfig(hiddenColumns) {
    const nrOfColumns = this.hot.countCols();
    if (Array.isArray(hiddenColumns) && hiddenColumns.length > 0) {
      return hiddenColumns.every((visualColumn) => Number.isInteger(visualColumn) && visualColumn >= 0 && visualColumn < nrOfColumns);
    }
    return false;
  }
  /**
   * Reset all rendered cells meta.
   *
   * @private
   */
  resetCellsMeta() {
    arrayEach(this.hot.getCellsMeta(), (meta) => {
      if (meta) {
        meta.skipColumnOnPaste = false;
      }
    });
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldSet17(this, _settings, null);
    _classPrivateFieldSet17(this, _hiddenColumnsMap, null);
    super.destroy();
  }
};
function _onModifyColWidth2(width, column) {
  if (this.isHidden(column)) {
    return 0;
  }
  if (_classPrivateFieldGet18(this, _settings).indicators && (this.isHidden(column + 1) || this.isHidden(column - 1))) {
    if (typeof width === "number" && this.hot.hasColHeaders()) {
      return width + 15;
    }
  }
}
function _onAfterGetCellMeta2(row, column, cellProperties) {
  if (_classPrivateFieldGet18(this, _settings).copyPasteEnabled === false && this.isHidden(column)) {
    cellProperties.skipColumnOnPaste = true;
  }
  if (this.isHidden(column - 1)) {
    cellProperties.className = cellProperties.className || "";
    if (cellProperties.className.indexOf("afterHiddenColumn") === -1) {
      cellProperties.className += " afterHiddenColumn";
    }
  } else if (cellProperties.className) {
    const classArr = cellProperties.className.split(" ");
    if (classArr.length > 0) {
      const containAfterHiddenColumn = classArr.indexOf("afterHiddenColumn");
      if (containAfterHiddenColumn > -1) {
        classArr.splice(containAfterHiddenColumn, 1);
      }
      cellProperties.className = classArr.join(" ");
    }
  }
}
function _onModifyCopyableRange2(ranges) {
  if (_classPrivateFieldGet18(this, _settings).copyPasteEnabled) {
    return ranges;
  }
  const newRanges = [];
  const pushRange = (startRow, endRow, startCol, endCol) => {
    newRanges.push({
      startRow,
      endRow,
      startCol,
      endCol
    });
  };
  arrayEach(ranges, (range) => {
    let isHidden = true;
    let rangeStart = 0;
    rangeEach(range.startCol, range.endCol, (visualColumn) => {
      if (this.isHidden(visualColumn)) {
        if (!isHidden) {
          pushRange(range.startRow, range.endRow, rangeStart, visualColumn - 1);
        }
        isHidden = true;
      } else {
        if (isHidden) {
          rangeStart = visualColumn;
        }
        if (visualColumn === range.endCol) {
          pushRange(range.startRow, range.endRow, rangeStart, visualColumn);
        }
        isHidden = false;
      }
    });
  });
  return newRanges;
}
function _onAfterGetColHeader25(column, TH) {
  if (!_classPrivateFieldGet18(this, _settings).indicators || column < 0) {
    return;
  }
  const classList = [];
  if (column >= 1 && this.isHidden(column - 1)) {
    classList.push("afterHiddenColumn");
  }
  if (column < this.hot.countCols() - 1 && this.isHidden(column + 1)) {
    classList.push("beforeHiddenColumn");
  }
  addClass(TH, classList);
}
function _onAfterContextMenuDefaultOptions23(options) {
  options.items.push({
    name: KEY
  }, hideColumnItem(this), showColumnItem(this));
}
function _onMapInit2() {
  if (Array.isArray(_classPrivateFieldGet18(this, _settings).columns)) {
    this.hideColumns(_classPrivateFieldGet18(this, _settings).columns);
  }
}

// node_modules/handsontable/plugins/hiddenRows/contextMenuItem/hideRow.mjs
function hideRowItem(hiddenRowsPlugin) {
  return {
    key: "hidden_rows_hide",
    name() {
      const selection = this.getSelectedLast();
      let pluralForm = 0;
      if (Array.isArray(selection)) {
        const [fromRow, , toRow] = selection;
        if (fromRow - toRow !== 0) {
          pluralForm = 1;
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_HIDE_ROW, pluralForm);
    },
    callback() {
      const {
        from,
        to
      } = this.getSelectedRangeLast();
      const start = Math.max(Math.min(from.row, to.row), 0);
      const end = Math.max(from.row, to.row);
      const rowsToHide = [];
      for (let visualRow = start; visualRow <= end; visualRow += 1) {
        rowsToHide.push(visualRow);
      }
      hiddenRowsPlugin.hideRows(rowsToHide);
      const lastHiddenRow = rowsToHide[rowsToHide.length - 1];
      const rowToSelect = this.rowIndexMapper.getNearestNotHiddenIndex(lastHiddenRow, 1, true);
      if (Number.isInteger(rowToSelect) && rowToSelect >= 0) {
        this.selectRows(rowToSelect);
      } else {
        this.deselectCell();
      }
      this.render();
      this.view.adjustElementsSize(true);
    },
    disabled: false,
    hidden() {
      return !(this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner());
    }
  };
}

// node_modules/handsontable/plugins/hiddenRows/contextMenuItem/showRow.mjs
function showRowItem(hiddenRowsPlugin) {
  const rows = [];
  return {
    key: "hidden_rows_show",
    name() {
      const pluralForm = rows.length > 1 ? 1 : 0;
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_SHOW_ROW, pluralForm);
    },
    callback() {
      var _this$rowIndexMapper$, _this$rowIndexMapper$2;
      if (rows.length === 0) {
        return;
      }
      let startVisualRow = rows[0];
      let endVisualRow = rows[rows.length - 1];
      startVisualRow = (_this$rowIndexMapper$ = this.rowIndexMapper.getNearestNotHiddenIndex(startVisualRow - 1, -1)) !== null && _this$rowIndexMapper$ !== void 0 ? _this$rowIndexMapper$ : 0;
      endVisualRow = (_this$rowIndexMapper$2 = this.rowIndexMapper.getNearestNotHiddenIndex(endVisualRow + 1, 1)) !== null && _this$rowIndexMapper$2 !== void 0 ? _this$rowIndexMapper$2 : this.countRows() - 1;
      hiddenRowsPlugin.showRows(rows);
      this.render();
      this.view.adjustElementsSize(true);
      const allRowsSelected = endVisualRow - startVisualRow + 1 === this.countRows();
      if (!allRowsSelected) {
        this.selectRows(startVisualRow, endVisualRow);
      }
    },
    disabled: false,
    hidden() {
      const hiddenPhysicalRows = arrayMap(hiddenRowsPlugin.getHiddenRows(), (visualRowIndex) => {
        return this.toPhysicalRow(visualRowIndex);
      });
      if (!(this.selection.isSelectedByRowHeader() || this.selection.isSelectedByCorner()) || hiddenPhysicalRows.length < 1) {
        return true;
      }
      rows.length = 0;
      const selectedRangeLast = this.getSelectedRangeLast();
      const visualStartRow = selectedRangeLast.getTopStartCorner().row;
      const visualEndRow = selectedRangeLast.getBottomEndCorner().row;
      const rowIndexMapper = this.rowIndexMapper;
      const renderableStartRow = rowIndexMapper.getRenderableFromVisualIndex(visualStartRow);
      const renderableEndRow = rowIndexMapper.getRenderableFromVisualIndex(visualEndRow);
      const notTrimmedRowIndexes = rowIndexMapper.getNotTrimmedIndexes();
      const physicalRowIndexes = [];
      if (visualStartRow !== visualEndRow) {
        const visualRowsInRange = visualEndRow - visualStartRow + 1;
        const renderedRowsInRange = renderableEndRow - renderableStartRow + 1;
        if (visualRowsInRange > renderedRowsInRange) {
          const physicalIndexesInRange = notTrimmedRowIndexes.slice(visualStartRow, visualEndRow + 1);
          physicalRowIndexes.push(...physicalIndexesInRange.filter((physicalIndex) => hiddenPhysicalRows.includes(physicalIndex)));
        }
      } else if (renderableStartRow === 0 && renderableStartRow < visualStartRow) {
        physicalRowIndexes.push(...notTrimmedRowIndexes.slice(0, visualStartRow));
      } else if (renderableStartRow === null) {
        physicalRowIndexes.push(...notTrimmedRowIndexes.slice(0, this.countRows()));
      } else {
        const lastVisualIndex = this.countRows() - 1;
        const lastRenderableIndex = rowIndexMapper.getRenderableFromVisualIndex(rowIndexMapper.getNearestNotHiddenIndex(lastVisualIndex, -1));
        if (renderableEndRow === lastRenderableIndex && lastVisualIndex > visualEndRow) {
          physicalRowIndexes.push(...notTrimmedRowIndexes.slice(visualEndRow + 1));
        }
      }
      arrayEach(physicalRowIndexes, (physicalRowIndex) => {
        rows.push(this.toVisualRow(physicalRowIndex));
      });
      return rows.length === 0;
    }
  };
}

// node_modules/handsontable/plugins/hiddenRows/hiddenRows.mjs
function _classPrivateMethodInitSpec27(obj, privateSet) {
  _checkPrivateRedeclaration33(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec19(obj, privateMap, value) {
  _checkPrivateRedeclaration33(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration33(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet27(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldGet19(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor19(receiver, privateMap, "get");
  return _classApplyDescriptorGet19(receiver, descriptor);
}
function _classApplyDescriptorGet19(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet18(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor19(receiver, privateMap, "set");
  _classApplyDescriptorSet18(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor19(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet18(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
pluginHooks_default.getSingleton().register("beforeHideRows");
pluginHooks_default.getSingleton().register("afterHideRows");
pluginHooks_default.getSingleton().register("beforeUnhideRows");
pluginHooks_default.getSingleton().register("afterUnhideRows");
var PLUGIN_KEY19 = "hiddenRows";
var PLUGIN_PRIORITY18 = 320;
var _settings2 = /* @__PURE__ */ new WeakMap();
var _hiddenRowsMap = /* @__PURE__ */ new WeakMap();
var _onModifyRowHeight = /* @__PURE__ */ new WeakSet();
var _onAfterGetCellMeta3 = /* @__PURE__ */ new WeakSet();
var _onModifyCopyableRange3 = /* @__PURE__ */ new WeakSet();
var _onAfterGetRowHeader = /* @__PURE__ */ new WeakSet();
var _onAfterContextMenuDefaultOptions5 = /* @__PURE__ */ new WeakSet();
var _onMapInit3 = /* @__PURE__ */ new WeakSet();
var HiddenRows = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec27(this, _onMapInit3);
    _classPrivateMethodInitSpec27(this, _onAfterContextMenuDefaultOptions5);
    _classPrivateMethodInitSpec27(this, _onAfterGetRowHeader);
    _classPrivateMethodInitSpec27(this, _onModifyCopyableRange3);
    _classPrivateMethodInitSpec27(this, _onAfterGetCellMeta3);
    _classPrivateMethodInitSpec27(this, _onModifyRowHeight);
    _classPrivateFieldInitSpec19(this, _settings2, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec19(this, _hiddenRowsMap, {
      writable: true,
      value: null
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY19;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY18;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link HiddenRows#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY19];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY19];
    if (isObject(pluginSettings)) {
      _classPrivateFieldSet18(this, _settings2, pluginSettings);
      if (isUndefined(pluginSettings.copyPasteEnabled)) {
        pluginSettings.copyPasteEnabled = true;
      }
    }
    _classPrivateFieldSet18(this, _hiddenRowsMap, new HidingMap());
    _classPrivateFieldGet19(this, _hiddenRowsMap).addLocalHook("init", () => _classPrivateMethodGet27(this, _onMapInit3, _onMapInit22).call(this));
    this.hot.rowIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet19(this, _hiddenRowsMap));
    this.addHook("afterContextMenuDefaultOptions", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet27(_this, _onAfterContextMenuDefaultOptions5, _onAfterContextMenuDefaultOptions24).call(_this, ...args);
    });
    this.addHook("afterGetCellMeta", (row, col, cellProperties) => _classPrivateMethodGet27(this, _onAfterGetCellMeta3, _onAfterGetCellMeta22).call(this, row, col, cellProperties));
    this.addHook("modifyRowHeight", (height, row) => _classPrivateMethodGet27(this, _onModifyRowHeight, _onModifyRowHeight2).call(this, height, row));
    this.addHook("afterGetRowHeader", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet27(_this, _onAfterGetRowHeader, _onAfterGetRowHeader2).call(_this, ...args);
    });
    this.addHook("modifyCopyableRange", (ranges) => _classPrivateMethodGet27(this, _onModifyCopyableRange3, _onModifyCopyableRange22).call(this, ranges));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`hiddenRows`](@/api/options.md#hiddenrows)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    _classPrivateFieldSet18(this, _settings2, {});
    super.disablePlugin();
    this.resetCellsMeta();
  }
  /**
   * Shows the rows provided in the array.
   *
   * @param {number[]} rows Array of visual row indexes.
   */
  showRows(rows) {
    const currentHideConfig = this.getHiddenRows();
    const isValidConfig = this.isValidConfig(rows);
    let destinationHideConfig = currentHideConfig;
    const hidingMapValues = _classPrivateFieldGet19(this, _hiddenRowsMap).getValues().slice();
    const isAnyRowShowed = rows.length > 0;
    if (isValidConfig && isAnyRowShowed) {
      const physicalRows = rows.map((visualRow) => this.hot.toPhysicalRow(visualRow));
      arrayEach(physicalRows, (physicalRow) => {
        hidingMapValues[physicalRow] = false;
      });
      destinationHideConfig = arrayReduce(hidingMapValues, (hiddenIndexes, isHidden, physicalIndex) => {
        if (isHidden) {
          hiddenIndexes.push(this.hot.toVisualRow(physicalIndex));
        }
        return hiddenIndexes;
      }, []);
    }
    const continueHiding = this.hot.runHooks("beforeUnhideRows", currentHideConfig, destinationHideConfig, isValidConfig && isAnyRowShowed);
    if (continueHiding === false) {
      return;
    }
    if (isValidConfig && isAnyRowShowed) {
      _classPrivateFieldGet19(this, _hiddenRowsMap).setValues(hidingMapValues);
    }
    this.hot.runHooks("afterUnhideRows", currentHideConfig, destinationHideConfig, isValidConfig && isAnyRowShowed, isValidConfig && destinationHideConfig.length < currentHideConfig.length);
  }
  /**
   * Shows the row provided as row index (counting from 0).
   *
   * @param {...number} row Visual row index.
   */
  showRow() {
    for (var _len3 = arguments.length, row = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      row[_key3] = arguments[_key3];
    }
    this.showRows(row);
  }
  /**
   * Hides the rows provided in the array.
   *
   * @param {number[]} rows Array of visual row indexes.
   */
  hideRows(rows) {
    const currentHideConfig = this.getHiddenRows();
    const isConfigValid = this.isValidConfig(rows);
    let destinationHideConfig = currentHideConfig;
    if (isConfigValid) {
      destinationHideConfig = Array.from(new Set(currentHideConfig.concat(rows)));
    }
    const continueHiding = this.hot.runHooks("beforeHideRows", currentHideConfig, destinationHideConfig, isConfigValid);
    if (continueHiding === false) {
      return;
    }
    if (isConfigValid) {
      this.hot.batchExecution(() => {
        arrayEach(rows, (visualRow) => {
          _classPrivateFieldGet19(this, _hiddenRowsMap).setValueAtIndex(this.hot.toPhysicalRow(visualRow), true);
        });
      }, true);
    }
    this.hot.runHooks("afterHideRows", currentHideConfig, destinationHideConfig, isConfigValid, isConfigValid && destinationHideConfig.length > currentHideConfig.length);
  }
  /**
   * Hides the row provided as row index (counting from 0).
   *
   * @param {...number} row Visual row index.
   */
  hideRow() {
    for (var _len4 = arguments.length, row = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      row[_key4] = arguments[_key4];
    }
    this.hideRows(row);
  }
  /**
   * Returns an array of visual indexes of hidden rows.
   *
   * @returns {number[]}
   */
  getHiddenRows() {
    return arrayMap(_classPrivateFieldGet19(this, _hiddenRowsMap).getHiddenIndexes(), (physicalRowIndex) => {
      return this.hot.toVisualRow(physicalRowIndex);
    });
  }
  /**
   * Checks if the provided row is hidden.
   *
   * @param {number} row Visual row index.
   * @returns {boolean}
   */
  isHidden(row) {
    return _classPrivateFieldGet19(this, _hiddenRowsMap).getValueAtIndex(this.hot.toPhysicalRow(row)) || false;
  }
  /**
   * Checks whether all of the provided row indexes are within the bounds of the table.
   *
   * @param {Array} hiddenRows List of hidden visual row indexes.
   * @returns {boolean}
   */
  isValidConfig(hiddenRows) {
    const nrOfRows = this.hot.countRows();
    if (Array.isArray(hiddenRows) && hiddenRows.length > 0) {
      return hiddenRows.every((visualRow) => Number.isInteger(visualRow) && visualRow >= 0 && visualRow < nrOfRows);
    }
    return false;
  }
  /**
   * Resets all rendered cells meta.
   *
   * @private
   */
  resetCellsMeta() {
    arrayEach(this.hot.getCellsMeta(), (meta) => {
      if (meta) {
        meta.skipRowOnPaste = false;
      }
    });
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldSet18(this, _settings2, null);
    _classPrivateFieldSet18(this, _hiddenRowsMap, null);
    super.destroy();
  }
};
function _onModifyRowHeight2(height, row) {
  if (this.isHidden(row)) {
    return 0;
  }
  return height;
}
function _onAfterGetCellMeta22(row, column, cellProperties) {
  if (_classPrivateFieldGet19(this, _settings2).copyPasteEnabled === false && this.isHidden(row)) {
    cellProperties.skipRowOnPaste = true;
  }
  if (this.isHidden(row - 1)) {
    cellProperties.className = cellProperties.className || "";
    if (cellProperties.className.indexOf("afterHiddenRow") === -1) {
      cellProperties.className += " afterHiddenRow";
    }
  } else if (cellProperties.className) {
    const classArr = cellProperties.className.split(" ");
    if (classArr.length > 0) {
      const containAfterHiddenRow = classArr.indexOf("afterHiddenRow");
      if (containAfterHiddenRow > -1) {
        classArr.splice(containAfterHiddenRow, 1);
      }
      cellProperties.className = classArr.join(" ");
    }
  }
}
function _onModifyCopyableRange22(ranges) {
  if (_classPrivateFieldGet19(this, _settings2).copyPasteEnabled) {
    return ranges;
  }
  const newRanges = [];
  const pushRange = (startRow, endRow, startCol, endCol) => {
    newRanges.push({
      startRow,
      endRow,
      startCol,
      endCol
    });
  };
  arrayEach(ranges, (range) => {
    let isHidden = true;
    let rangeStart = 0;
    rangeEach(range.startRow, range.endRow, (visualRow) => {
      if (this.isHidden(visualRow)) {
        if (!isHidden) {
          pushRange(rangeStart, visualRow - 1, range.startCol, range.endCol);
        }
        isHidden = true;
      } else {
        if (isHidden) {
          rangeStart = visualRow;
        }
        if (visualRow === range.endRow) {
          pushRange(rangeStart, visualRow, range.startCol, range.endCol);
        }
        isHidden = false;
      }
    });
  });
  return newRanges;
}
function _onAfterGetRowHeader2(row, TH) {
  if (!_classPrivateFieldGet19(this, _settings2).indicators || row < 0) {
    return;
  }
  const classList = [];
  if (row >= 1 && this.isHidden(row - 1)) {
    classList.push("afterHiddenRow");
  }
  if (row < this.hot.countRows() - 1 && this.isHidden(row + 1)) {
    classList.push("beforeHiddenRow");
  }
  addClass(TH, classList);
}
function _onAfterContextMenuDefaultOptions24(options) {
  options.items.push({
    name: KEY
  }, hideRowItem(this), showRowItem(this));
}
function _onMapInit22() {
  if (Array.isArray(_classPrivateFieldGet19(this, _settings2).rows)) {
    this.hideRows(_classPrivateFieldGet19(this, _settings2).rows);
  }
}

// node_modules/handsontable/plugins/manualColumnFreeze/contextMenuItem/freezeColumn.mjs
function freezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "freeze_column",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_FREEZE_COLUMN);
    },
    callback(key, selected) {
      const [{
        start: {
          col: selectedColumn
        }
      }] = selected;
      manualColumnFreezePlugin.freezeColumn(selectedColumn);
      this.render();
      this.view.adjustElementsSize(true);
    },
    hidden() {
      const selection = this.getSelectedRange();
      let hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col <= this.getSettings().fixedColumnsStart - 1) {
        hide = true;
      }
      return hide;
    }
  };
}

// node_modules/handsontable/plugins/manualColumnFreeze/contextMenuItem/unfreezeColumn.mjs
function unfreezeColumnItem(manualColumnFreezePlugin) {
  return {
    key: "unfreeze_column",
    name() {
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNFREEZE_COLUMN);
    },
    callback(key, selected) {
      const [{
        start: {
          col: selectedColumn
        }
      }] = selected;
      manualColumnFreezePlugin.unfreezeColumn(selectedColumn);
      this.render();
      this.view.adjustElementsSize(true);
    },
    hidden() {
      const selection = this.getSelectedRange();
      let hide = false;
      if (selection === void 0) {
        hide = true;
      } else if (selection.length > 1) {
        hide = true;
      } else if (selection[0].from.col !== selection[0].to.col || selection[0].from.col >= this.getSettings().fixedColumnsStart) {
        hide = true;
      }
      return hide;
    }
  };
}

// node_modules/handsontable/plugins/manualColumnFreeze/manualColumnFreeze.mjs
function _classPrivateMethodInitSpec28(obj, privateSet) {
  _checkPrivateRedeclaration34(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec20(obj, privateMap, value) {
  _checkPrivateRedeclaration34(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration34(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet20(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor20(receiver, privateMap, "get");
  return _classApplyDescriptorGet20(receiver, descriptor);
}
function _classApplyDescriptorGet20(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet19(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor20(receiver, privateMap, "set");
  _classApplyDescriptorSet19(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor20(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet19(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateMethodGet28(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
pluginHooks_default.getSingleton().register("beforeColumnFreeze");
pluginHooks_default.getSingleton().register("afterColumnFreeze");
pluginHooks_default.getSingleton().register("beforeColumnUnfreeze");
pluginHooks_default.getSingleton().register("afterColumnUnfreeze");
var PLUGIN_KEY20 = "manualColumnFreeze";
var PLUGIN_PRIORITY19 = 110;
var _afterFirstUse = /* @__PURE__ */ new WeakMap();
var _addContextMenuEntry = /* @__PURE__ */ new WeakSet();
var _onBeforeColumnMove = /* @__PURE__ */ new WeakSet();
var ManualColumnFreeze = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec28(this, _onBeforeColumnMove);
    _classPrivateMethodInitSpec28(this, _addContextMenuEntry);
    _classPrivateFieldInitSpec20(this, _afterFirstUse, {
      writable: true,
      value: false
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY20;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY19;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualColumnFreeze#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY20];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook("afterContextMenuDefaultOptions", (options) => _classPrivateMethodGet28(this, _addContextMenuEntry, _addContextMenuEntry2).call(this, options));
    this.addHook("beforeColumnMove", (columns, finalIndex) => _classPrivateMethodGet28(this, _onBeforeColumnMove, _onBeforeColumnMove2).call(this, columns, finalIndex));
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    _classPrivateFieldSet19(this, _afterFirstUse, false);
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualColumnFreeze`](@/api/options.md#manualcolumnfreeze)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Freezes the specified column (adds it to fixed columns).
   *
   * `freezeColumn()` doesn't re-render the table,
   * so you need to call the `render()` method afterward.
   *
   * @param {number} column Visual column index.
   */
  freezeColumn(column) {
    const settings = this.hot.getSettings();
    const freezePerformed = settings.fixedColumnsStart < this.hot.countCols() && column > settings.fixedColumnsStart - 1;
    if (!_classPrivateFieldGet20(this, _afterFirstUse)) {
      _classPrivateFieldSet19(this, _afterFirstUse, true);
    }
    const beforeColumnFreezeHook = this.hot.runHooks("beforeColumnFreeze", column, freezePerformed);
    if (beforeColumnFreezeHook === false) {
      return;
    }
    if (freezePerformed) {
      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);
      settings._fixedColumnsStart += 1;
    }
    this.hot.runHooks("afterColumnFreeze", column, freezePerformed);
  }
  /**
   * Unfreezes the given column (remove it from fixed columns and bring to it's previous position).
   *
   * @param {number} column Visual column index.
   */
  unfreezeColumn(column) {
    const settings = this.hot.getSettings();
    const unfreezePerformed = settings.fixedColumnsStart > 0 && column <= settings.fixedColumnsStart - 1;
    if (!_classPrivateFieldGet20(this, _afterFirstUse)) {
      _classPrivateFieldSet19(this, _afterFirstUse, true);
    }
    const beforeColumnUnfreezeHook = this.hot.runHooks("beforeColumnUnfreeze", column, unfreezePerformed);
    if (beforeColumnUnfreezeHook === false) {
      return;
    }
    if (unfreezePerformed) {
      settings._fixedColumnsStart -= 1;
      this.hot.columnIndexMapper.moveIndexes(column, settings.fixedColumnsStart);
    }
    this.hot.runHooks("afterColumnUnfreeze", column, unfreezePerformed);
  }
};
function _addContextMenuEntry2(options) {
  options.items.push({
    name: "---------"
  }, freezeColumnItem(this), unfreezeColumnItem(this));
}
function _onBeforeColumnMove2(columns, finalIndex) {
  if (_classPrivateFieldGet20(this, _afterFirstUse)) {
    const freezeLine = this.hot.getSettings().fixedColumnsStart;
    if (finalIndex < freezeLine) {
      return false;
    }
    if (columns.some((column) => column < freezeLine)) {
      return false;
    }
  }
}

// node_modules/handsontable/plugins/manualColumnMove/ui/_base.mjs
function _defineProperty38(obj, key, value) {
  key = _toPropertyKey38(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey38(arg) {
  var key = _toPrimitive38(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive38(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var STATE_INITIALIZED = 0;
var STATE_BUILT2 = 1;
var STATE_APPENDED = 2;
var UNIT = "px";
var BaseUI2 = class {
  constructor(hotInstance) {
    _defineProperty38(this, "hot", void 0);
    _defineProperty38(this, "_element", null);
    _defineProperty38(this, "state", STATE_INITIALIZED);
    _defineProperty38(this, "inlineProperty", void 0);
    this.hot = hotInstance;
    this.inlineProperty = hotInstance.isRtl() ? "right" : "left";
  }
  /**
   * Add created UI elements to table.
   *
   * @param {HTMLElement} wrapper Element which are parent for our UI element.
   */
  appendTo(wrapper) {
    wrapper.appendChild(this._element);
    this.state = STATE_APPENDED;
  }
  /**
   * Method for create UI element. Only create, without append to table.
   */
  build() {
    if (this.state !== STATE_INITIALIZED) {
      return;
    }
    this._element = this.hot.rootDocument.createElement("div");
    this.state = STATE_BUILT2;
  }
  /**
   * Method for remove UI element.
   */
  destroy() {
    if (this.isAppended()) {
      this._element.parentElement.removeChild(this._element);
    }
    this._element = null;
    this.state = STATE_INITIALIZED;
  }
  /**
   * Check if UI element are appended.
   *
   * @returns {boolean}
   */
  isAppended() {
    return this.state === STATE_APPENDED;
  }
  /**
   * Check if UI element are built.
   *
   * @returns {boolean}
   */
  isBuilt() {
    return this.state >= STATE_BUILT2;
  }
  /**
   * Setter for position.
   *
   * @param {number} top New top position of the element.
   * @param {number} inlinePosition New left/right (depends on LTR/RTL document mode) position of the element.
   */
  setPosition(top2, inlinePosition) {
    if (isNumeric(top2)) {
      this._element.style.top = top2 + UNIT;
    }
    if (isNumeric(inlinePosition)) {
      this._element.style[this.inlineProperty] = inlinePosition + UNIT;
    }
  }
  /**
   * Getter for the element position.
   *
   * @returns {object} Object contains left and top position of the element.
   */
  getPosition() {
    const style = this._element.style;
    return {
      top: style.top ? parseInt(style.top, 10) : 0,
      start: style[this.inlineProperty] ? parseInt(style[this.inlineProperty], 10) : 0
    };
  }
  /**
   * Setter for the element size.
   *
   * @param {number} width New width of the element.
   * @param {number} height New height of the element.
   */
  setSize(width, height) {
    if (isNumeric(width)) {
      this._element.style.width = width + UNIT;
    }
    if (isNumeric(height)) {
      this._element.style.height = height + UNIT;
    }
  }
  /**
   * Getter for the element position.
   *
   * @returns {object} Object contains height and width of the element.
   */
  getSize() {
    return {
      width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
      height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
    };
  }
  /**
   * Setter for the element offset. Offset means marginTop and marginLeft of the element.
   *
   * @param {number} top New margin top of the element.
   * @param {number} inlineOffset New margin left/right (depends on LTR/RTL document mode) of the element.
   */
  setOffset(top2, inlineOffset) {
    if (isNumeric(top2)) {
      this._element.style.marginTop = top2 + UNIT;
    }
    if (isNumeric(inlineOffset)) {
      this._element.style[`margin${toUpperCaseFirst(this.inlineProperty)}`] = inlineOffset + UNIT;
    }
  }
  /**
   * Getter for the element offset.
   *
   * @returns {object} Object contains top and left offset of the element.
   */
  getOffset() {
    const style = this._element.style;
    const inlineProp = `margin${toUpperCaseFirst(this.inlineProperty)}`;
    return {
      top: style.marginTop ? parseInt(style.marginTop, 10) : 0,
      start: style[inlineProp] ? parseInt(style[inlineProp], 10) : 0
    };
  }
};
var base_default2 = BaseUI2;

// node_modules/handsontable/plugins/manualColumnMove/ui/backlight.mjs
var CSS_CLASSNAME = "ht__manualColumnMove--backlight";
var BacklightUI = class extends base_default2 {
  /**
   * Custom className on build process.
   */
  build() {
    super.build();
    addClass(this._element, CSS_CLASSNAME);
  }
};
var backlight_default = BacklightUI;

// node_modules/handsontable/plugins/manualColumnMove/ui/guideline.mjs
var CSS_CLASSNAME2 = "ht__manualColumnMove--guideline";
var GuidelineUI = class extends base_default2 {
  /**
   * Custom className on build process.
   */
  build() {
    super.build();
    addClass(this._element, CSS_CLASSNAME2);
  }
};
var guideline_default = GuidelineUI;

// node_modules/handsontable/plugins/manualColumnMove/manualColumnMove.mjs
function _classPrivateMethodInitSpec29(obj, privateSet) {
  _checkPrivateRedeclaration35(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec21(obj, privateMap, value) {
  _checkPrivateRedeclaration35(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration35(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet20(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor21(receiver, privateMap, "set");
  _classApplyDescriptorSet20(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet20(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet21(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor21(receiver, privateMap, "get");
  return _classApplyDescriptorGet21(receiver, descriptor);
}
function _classExtractFieldDescriptor21(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet21(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet29(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
pluginHooks_default.getSingleton().register("beforeColumnMove");
pluginHooks_default.getSingleton().register("afterColumnMove");
var PLUGIN_KEY21 = "manualColumnMove";
var PLUGIN_PRIORITY20 = 120;
var CSS_PLUGIN = "ht__manualColumnMove";
var CSS_SHOW_UI = "show-ui";
var CSS_ON_MOVING = "on-moving--columns";
var CSS_AFTER_SELECTION = "after-selection--columns";
var _backlight = /* @__PURE__ */ new WeakMap();
var _guideline = /* @__PURE__ */ new WeakMap();
var _columnsToMove = /* @__PURE__ */ new WeakMap();
var _countCols = /* @__PURE__ */ new WeakMap();
var _pressed = /* @__PURE__ */ new WeakMap();
var _target = /* @__PURE__ */ new WeakMap();
var _cachedDropIndex = /* @__PURE__ */ new WeakMap();
var _hoveredColumn = /* @__PURE__ */ new WeakMap();
var _rootElementOffset = /* @__PURE__ */ new WeakMap();
var _hasRowHeaders = /* @__PURE__ */ new WeakMap();
var _fixedColumnsStart = /* @__PURE__ */ new WeakMap();
var _onBeforeOnCellMouseDown4 = /* @__PURE__ */ new WeakSet();
var _onMouseMove3 = /* @__PURE__ */ new WeakSet();
var _onBeforeOnCellMouseOver = /* @__PURE__ */ new WeakSet();
var _onMouseUp4 = /* @__PURE__ */ new WeakSet();
var _onAfterScrollVertically = /* @__PURE__ */ new WeakSet();
var _onAfterLoadData7 = /* @__PURE__ */ new WeakSet();
var ManualColumnMove = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec29(this, _onAfterLoadData7);
    _classPrivateMethodInitSpec29(this, _onAfterScrollVertically);
    _classPrivateMethodInitSpec29(this, _onMouseUp4);
    _classPrivateMethodInitSpec29(this, _onBeforeOnCellMouseOver);
    _classPrivateMethodInitSpec29(this, _onMouseMove3);
    _classPrivateMethodInitSpec29(this, _onBeforeOnCellMouseDown4);
    _classPrivateFieldInitSpec21(this, _backlight, {
      writable: true,
      value: new backlight_default(this.hot)
    });
    _classPrivateFieldInitSpec21(this, _guideline, {
      writable: true,
      value: new guideline_default(this.hot)
    });
    _classPrivateFieldInitSpec21(this, _columnsToMove, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec21(this, _countCols, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec21(this, _pressed, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec21(this, _target, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec21(this, _cachedDropIndex, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec21(this, _hoveredColumn, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec21(this, _rootElementOffset, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec21(this, _hasRowHeaders, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec21(this, _fixedColumnsStart, {
      writable: true,
      value: void 0
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY21;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY20;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualColumnMove#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY21];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.addHook("beforeOnCellMouseDown", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet29(_this, _onBeforeOnCellMouseDown4, _onBeforeOnCellMouseDown23).call(_this, ...args);
    });
    this.addHook("beforeOnCellMouseOver", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet29(_this, _onBeforeOnCellMouseOver, _onBeforeOnCellMouseOver2).call(_this, ...args);
    });
    this.addHook("afterScrollVertically", () => _classPrivateMethodGet29(this, _onAfterScrollVertically, _onAfterScrollVertically2).call(this));
    this.addHook("afterLoadData", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _classPrivateMethodGet29(_this, _onAfterLoadData7, _onAfterLoadData26).call(_this, ...args);
    });
    this.buildPluginUI();
    this.registerEvents();
    addClass(this.hot.rootElement, CSS_PLUGIN);
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualColumnMove`](@/api/options.md#manualcolumnmove)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    this.moveBySettingsOrLoad();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    removeClass(this.hot.rootElement, CSS_PLUGIN);
    this.unregisterEvents();
    _classPrivateFieldGet21(this, _backlight).destroy();
    _classPrivateFieldGet21(this, _guideline).destroy();
    super.disablePlugin();
  }
  /**
   * Moves a single column.
   *
   * @param {number} column Visual column index to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @fires Hooks#beforeColumnMove
   * @fires Hooks#afterColumnMove
   * @returns {boolean}
   */
  moveColumn(column, finalIndex) {
    return this.moveColumns([column], finalIndex);
  }
  /**
   * Moves a multiple columns.
   *
   * @param {Array} columns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @fires Hooks#beforeColumnMove
   * @fires Hooks#afterColumnMove
   * @returns {boolean}
   */
  moveColumns(columns, finalIndex) {
    const dropIndex = _classPrivateFieldGet21(this, _cachedDropIndex);
    const movePossible = this.isMovePossible(columns, finalIndex);
    const beforeMoveHook = this.hot.runHooks("beforeColumnMove", columns, finalIndex, dropIndex, movePossible);
    _classPrivateFieldSet20(this, _cachedDropIndex, void 0);
    if (beforeMoveHook === false) {
      return;
    }
    if (movePossible) {
      this.hot.columnIndexMapper.moveIndexes(columns, finalIndex);
    }
    const movePerformed = movePossible && this.isColumnOrderChanged(columns, finalIndex);
    this.hot.runHooks("afterColumnMove", columns, finalIndex, dropIndex, movePossible, movePerformed);
    return movePerformed;
  }
  /**
   * Drag a single column to drop index position.
   *
   * @param {number} column Visual column index to be dragged.
   * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.
   * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @fires Hooks#beforeColumnMove
   * @fires Hooks#afterColumnMove
   * @returns {boolean}
   */
  dragColumn(column, dropIndex) {
    return this.dragColumns([column], dropIndex);
  }
  /**
   * Drag multiple columns to drop index position.
   *
   * @param {Array} columns Array of visual column indexes to be dragged.
   * @param {number} dropIndex Visual column index, being a drop index for the moved columns. Points to where we are going to drop the moved elements.
   * To check visualization of drop index please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @fires Hooks#beforeColumnMove
   * @fires Hooks#afterColumnMove
   * @returns {boolean}
   */
  dragColumns(columns, dropIndex) {
    const finalIndex = this.countFinalIndex(columns, dropIndex);
    _classPrivateFieldSet20(this, _cachedDropIndex, dropIndex);
    return this.moveColumns(columns, finalIndex);
  }
  /**
   * Indicates if it's possible to move columns to the desired position. Some of the actions aren't
   * possible, i.e. You can’t move more than one element to the last position.
   *
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @returns {boolean}
   */
  isMovePossible(movedColumns, finalIndex) {
    const length = this.hot.columnIndexMapper.getNotTrimmedIndexesLength();
    const tooHighDestinationIndex = movedColumns.length + finalIndex > length;
    const tooLowDestinationIndex = finalIndex < 0;
    const tooLowMovedColumnIndex = movedColumns.some((movedColumn) => movedColumn < 0);
    const tooHighMovedColumnIndex = movedColumns.some((movedColumn) => movedColumn >= length);
    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedColumnIndex || tooHighMovedColumnIndex) {
      return false;
    }
    return true;
  }
  /**
   * Indicates if order of columns was changed.
   *
   * @private
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} finalIndex Visual column index, being a start index for the moved columns. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/columns/column-moving.md#drag-and-move-actions-of-manualcolumnmove-plugin).
   * @returns {boolean}
   */
  isColumnOrderChanged(movedColumns, finalIndex) {
    return movedColumns.some((column, nrOfMovedElement) => column - nrOfMovedElement !== finalIndex);
  }
  /**
   * Count the final column index from the drop index.
   *
   * @private
   * @param {Array} movedColumns Array of visual column indexes to be moved.
   * @param {number} dropIndex Visual column index, being a drop index for the moved columns.
   * @returns {number} Visual column index, being a start index for the moved columns.
   */
  countFinalIndex(movedColumns, dropIndex) {
    const numberOfColumnsLowerThanDropIndex = arrayReduce(movedColumns, (numberOfColumns, currentColumnIndex) => {
      if (currentColumnIndex < dropIndex) {
        numberOfColumns += 1;
      }
      return numberOfColumns;
    }, 0);
    return dropIndex - numberOfColumnsLowerThanDropIndex;
  }
  /**
   * Gets the sum of the widths of columns in the provided range.
   *
   * @private
   * @param {number} fromColumn Visual column index.
   * @param {number} toColumn Visual column index.
   * @returns {number}
   */
  getColumnsWidth(fromColumn, toColumn) {
    const columnMapper = this.hot.columnIndexMapper;
    let columnsWidth = 0;
    for (let visualColumnIndex = fromColumn; visualColumnIndex <= toColumn; visualColumnIndex += 1) {
      const renderableIndex = columnMapper.getRenderableFromVisualIndex(visualColumnIndex);
      if (visualColumnIndex < 0) {
        columnsWidth += this.hot.view._wt.wtViewport.getRowHeaderWidth() || 0;
      } else if (renderableIndex !== null) {
        columnsWidth += this.hot.view._wt.wtTable.getStretchedColumnWidth(renderableIndex) || 0;
      }
    }
    return columnsWidth;
  }
  /**
   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.
   *
   * @private
   */
  moveBySettingsOrLoad() {
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY21];
    if (Array.isArray(pluginSettings)) {
      this.moveColumns(pluginSettings, 0);
    } else if (pluginSettings !== void 0) {
      const persistentState = this.persistentStateLoad();
      if (persistentState.length) {
        this.moveColumns(persistentState, 0);
      }
    }
  }
  /**
   * Checks if the provided column is in the fixedColumnsTop section.
   *
   * @private
   * @param {number} column Visual column index to check.
   * @returns {boolean}
   */
  isFixedColumnsStart(column) {
    return column < this.hot.getSettings().fixedColumnsStart;
  }
  /**
   * Saves the manual column positions to the persistent state (the {@link Options#persistentState} option has to be enabled).
   *
   * @private
   * @fires Hooks#persistentStateSave
   */
  persistentStateSave() {
    this.hot.runHooks("persistentStateSave", "manualColumnMove", this.hot.columnIndexMapper.getIndexesSequence());
  }
  /**
   * Loads the manual column positions from the persistent state (the {@link Options#persistentState} option has to be enabled).
   *
   * @private
   * @fires Hooks#persistentStateLoad
   * @returns {Array} Stored state.
   */
  persistentStateLoad() {
    const storedState = {};
    this.hot.runHooks("persistentStateLoad", "manualColumnMove", storedState);
    return storedState.value ? storedState.value : [];
  }
  /**
   * Prepares an array of indexes based on actual selection.
   *
   * @private
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array}
   */
  prepareColumnsToMoving(start, end) {
    const selectedColumns = [];
    rangeEach(start, end, (i) => {
      selectedColumns.push(i);
    });
    return selectedColumns;
  }
  /**
   * Update the UI visual position.
   *
   * @private
   */
  refreshPositions() {
    const firstVisible = this.hot.view.getFirstFullyVisibleColumn();
    if (this.isFixedColumnsStart(_classPrivateFieldGet21(this, _hoveredColumn)) && firstVisible > 0) {
      this.hot.scrollViewportTo({
        col: this.hot.columnIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1)
      });
    }
    const wtTable = this.hot.view._wt.wtTable;
    const scrollableElement = this.hot.view._wt.wtOverlays.scrollableElement;
    const scrollStart = typeof scrollableElement.scrollX === "number" ? scrollableElement.scrollX : scrollableElement.scrollLeft;
    let tdOffsetStart = this.hot.view.THEAD.offsetLeft + this.getColumnsWidth(0, _classPrivateFieldGet21(this, _hoveredColumn) - 1);
    const hiderWidth = wtTable.hider.offsetWidth;
    const tbodyOffsetLeft = wtTable.TBODY.offsetLeft;
    const backlightElemMarginStart = _classPrivateFieldGet21(this, _backlight).getOffset().start;
    const backlightElemWidth = _classPrivateFieldGet21(this, _backlight).getSize().width;
    let rowHeaderWidth = 0;
    let mouseOffsetStart = 0;
    if (this.hot.isRtl()) {
      const rootWindow = this.hot.rootWindow;
      const containerWidth = outerWidth(this.hot.rootElement);
      const gridMostRightPos = rootWindow.innerWidth - _classPrivateFieldGet21(this, _rootElementOffset) - containerWidth;
      mouseOffsetStart = rootWindow.innerWidth - _classPrivateFieldGet21(this, _target).eventPageX - gridMostRightPos - (scrollableElement.scrollX === void 0 ? scrollStart : 0);
    } else {
      mouseOffsetStart = _classPrivateFieldGet21(this, _target).eventPageX - (_classPrivateFieldGet21(this, _rootElementOffset) - (scrollableElement.scrollX === void 0 ? scrollStart : 0));
    }
    if (_classPrivateFieldGet21(this, _hasRowHeaders)) {
      rowHeaderWidth = this.hot.view._wt.wtOverlays.inlineStartOverlay.clone.wtTable.getColumnHeader(-1).offsetWidth;
    }
    if (this.isFixedColumnsStart(_classPrivateFieldGet21(this, _hoveredColumn))) {
      tdOffsetStart += scrollStart;
    }
    tdOffsetStart += rowHeaderWidth;
    if (_classPrivateFieldGet21(this, _hoveredColumn) < 0) {
      if (_classPrivateFieldGet21(this, _fixedColumnsStart) > 0) {
        _classPrivateFieldGet21(this, _target).col = 0;
      } else {
        _classPrivateFieldGet21(this, _target).col = firstVisible > 0 ? firstVisible - 1 : firstVisible;
      }
    } else if (_classPrivateFieldGet21(this, _target).TD.offsetWidth / 2 + tdOffsetStart <= mouseOffsetStart) {
      const newCoordsCol = _classPrivateFieldGet21(this, _hoveredColumn) >= _classPrivateFieldGet21(this, _countCols) ? _classPrivateFieldGet21(this, _countCols) - 1 : _classPrivateFieldGet21(this, _hoveredColumn);
      _classPrivateFieldGet21(this, _target).col = newCoordsCol + 1;
      tdOffsetStart += _classPrivateFieldGet21(this, _target).TD.offsetWidth;
    } else {
      _classPrivateFieldGet21(this, _target).col = _classPrivateFieldGet21(this, _hoveredColumn);
    }
    let backlightStart = mouseOffsetStart;
    let guidelineStart = tdOffsetStart;
    if (mouseOffsetStart + backlightElemWidth + backlightElemMarginStart >= hiderWidth) {
      backlightStart = hiderWidth - backlightElemWidth - backlightElemMarginStart;
    } else if (mouseOffsetStart + backlightElemMarginStart < tbodyOffsetLeft + rowHeaderWidth) {
      backlightStart = tbodyOffsetLeft + rowHeaderWidth + Math.abs(backlightElemMarginStart);
    }
    if (tdOffsetStart >= hiderWidth - 1) {
      guidelineStart = hiderWidth - 1;
    } else if (guidelineStart === 0) {
      guidelineStart = 1;
    } else if (scrollableElement.scrollX !== void 0 && _classPrivateFieldGet21(this, _hoveredColumn) < _classPrivateFieldGet21(this, _fixedColumnsStart)) {
      guidelineStart -= _classPrivateFieldGet21(this, _rootElementOffset) <= scrollableElement.scrollX ? _classPrivateFieldGet21(this, _rootElementOffset) : 0;
    }
    _classPrivateFieldGet21(this, _backlight).setPosition(null, backlightStart);
    _classPrivateFieldGet21(this, _guideline).setPosition(null, guidelineStart);
  }
  /**
   * Binds the events used by the plugin.
   *
   * @private
   */
  registerEvents() {
    const {
      documentElement
    } = this.hot.rootDocument;
    this.eventManager.addEventListener(documentElement, "mousemove", (event) => _classPrivateMethodGet29(this, _onMouseMove3, _onMouseMove22).call(this, event));
    this.eventManager.addEventListener(documentElement, "mouseup", () => _classPrivateMethodGet29(this, _onMouseUp4, _onMouseUp23).call(this));
  }
  /**
   * Unbinds the events used by the plugin.
   *
   * @private
   */
  unregisterEvents() {
    this.eventManager.clear();
  }
  /**
   * Builds the plugin's UI.
   *
   * @private
   */
  buildPluginUI() {
    _classPrivateFieldGet21(this, _backlight).build();
    _classPrivateFieldGet21(this, _guideline).build();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldGet21(this, _backlight).destroy();
    _classPrivateFieldGet21(this, _guideline).destroy();
    super.destroy();
  }
};
function _onBeforeOnCellMouseDown23(event, coords, TD, controller) {
  const wtTable = this.hot.view._wt.wtTable;
  const isHeaderSelection = this.hot.selection.isSelectedByColumnHeader();
  const selection = this.hot.getSelectedRangeLast();
  const isSortingElement = hasClass(event.target, "sortAction");
  if (!selection || !isHeaderSelection || _classPrivateFieldGet21(this, _pressed) || event.button !== 0 || isSortingElement) {
    _classPrivateFieldSet20(this, _pressed, false);
    _classPrivateFieldGet21(this, _columnsToMove).length = 0;
    removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI]);
    return;
  }
  const guidelineIsNotReady = _classPrivateFieldGet21(this, _guideline).isBuilt() && !_classPrivateFieldGet21(this, _guideline).isAppended();
  const backlightIsNotReady = _classPrivateFieldGet21(this, _backlight).isBuilt() && !_classPrivateFieldGet21(this, _backlight).isAppended();
  if (guidelineIsNotReady && backlightIsNotReady) {
    _classPrivateFieldGet21(this, _guideline).appendTo(wtTable.hider);
    _classPrivateFieldGet21(this, _backlight).appendTo(wtTable.hider);
  }
  const {
    from,
    to
  } = selection;
  const start = Math.min(from.col, to.col);
  const end = Math.max(from.col, to.col);
  if (coords.row < 0 && coords.col >= start && coords.col <= end) {
    controller.column = true;
    _classPrivateFieldSet20(this, _pressed, true);
    const eventOffsetX = TD.firstChild ? offsetRelativeTo(event, TD.firstChild).x : event.offsetX;
    _classPrivateFieldGet21(this, _target).eventPageX = event.pageX;
    _classPrivateFieldSet20(this, _hoveredColumn, coords.col);
    _classPrivateFieldGet21(this, _target).TD = TD;
    _classPrivateFieldGet21(this, _target).col = coords.col;
    _classPrivateFieldSet20(this, _columnsToMove, this.prepareColumnsToMoving(start, end));
    _classPrivateFieldSet20(this, _hasRowHeaders, !!this.hot.getSettings().rowHeaders);
    _classPrivateFieldSet20(this, _countCols, this.hot.countCols());
    _classPrivateFieldSet20(this, _fixedColumnsStart, this.hot.getSettings().fixedColumnsStart);
    _classPrivateFieldSet20(this, _rootElementOffset, offset(this.hot.rootElement).left);
    const countColumnsFrom = _classPrivateFieldGet21(this, _hasRowHeaders) ? -1 : 0;
    const topPos = wtTable.holder.scrollTop + wtTable.getColumnHeaderHeight(0) + 1;
    const fixedColumnsStart = coords.col < _classPrivateFieldGet21(this, _fixedColumnsStart);
    const horizontalScrollPosition = this.hot.view._wt.wtOverlays.inlineStartOverlay.getOverlayOffset();
    const offsetX = Math.abs(eventOffsetX - (this.hot.isRtl() ? TD.offsetWidth : 0));
    const inlineOffset = this.getColumnsWidth(start, coords.col - 1) + offsetX;
    const inlinePos = this.getColumnsWidth(countColumnsFrom, start - 1) + (fixedColumnsStart ? horizontalScrollPosition : 0) + inlineOffset;
    _classPrivateFieldGet21(this, _backlight).setPosition(topPos, inlinePos);
    _classPrivateFieldGet21(this, _backlight).setSize(this.getColumnsWidth(start, end), wtTable.hider.offsetHeight - topPos);
    _classPrivateFieldGet21(this, _backlight).setOffset(null, -inlineOffset);
    addClass(this.hot.rootElement, CSS_ON_MOVING);
  } else {
    removeClass(this.hot.rootElement, CSS_AFTER_SELECTION);
    _classPrivateFieldSet20(this, _pressed, false);
    _classPrivateFieldGet21(this, _columnsToMove).length = 0;
  }
}
function _onMouseMove22(event) {
  if (!_classPrivateFieldGet21(this, _pressed)) {
    return;
  }
  _classPrivateFieldGet21(this, _target).eventPageX = event.pageX;
  this.refreshPositions();
}
function _onBeforeOnCellMouseOver2(event, coords, TD, controller) {
  const selectedRange = this.hot.getSelectedRangeLast();
  if (!selectedRange || !_classPrivateFieldGet21(this, _pressed)) {
    return;
  }
  if (_classPrivateFieldGet21(this, _columnsToMove).indexOf(coords.col) > -1) {
    removeClass(this.hot.rootElement, CSS_SHOW_UI);
  } else {
    addClass(this.hot.rootElement, CSS_SHOW_UI);
  }
  controller.row = true;
  controller.column = true;
  controller.cell = true;
  _classPrivateFieldSet20(this, _hoveredColumn, coords.col);
  _classPrivateFieldGet21(this, _target).TD = TD;
}
function _onMouseUp23() {
  const target = _classPrivateFieldGet21(this, _target).col;
  const columnsLen = _classPrivateFieldGet21(this, _columnsToMove).length;
  _classPrivateFieldSet20(this, _hoveredColumn, void 0);
  _classPrivateFieldSet20(this, _pressed, false);
  removeClass(this.hot.rootElement, [CSS_ON_MOVING, CSS_SHOW_UI, CSS_AFTER_SELECTION]);
  if (this.hot.selection.isSelectedByColumnHeader()) {
    addClass(this.hot.rootElement, CSS_AFTER_SELECTION);
  }
  if (columnsLen < 1 || target === void 0) {
    return;
  }
  const firstMovedVisualColumn = _classPrivateFieldGet21(this, _columnsToMove)[0];
  const firstMovedPhysicalColumn = this.hot.toPhysicalColumn(firstMovedVisualColumn);
  const movePerformed = this.dragColumns(_classPrivateFieldGet21(this, _columnsToMove), target);
  _classPrivateFieldGet21(this, _columnsToMove).length = 0;
  if (movePerformed === true) {
    this.persistentStateSave();
    this.hot.render();
    this.hot.view.adjustElementsSize(true);
    const selectionStart = this.hot.toVisualColumn(firstMovedPhysicalColumn);
    const selectionEnd = selectionStart + columnsLen - 1;
    this.hot.selectColumns(selectionStart, selectionEnd);
  }
}
function _onAfterScrollVertically2() {
  const wtTable = this.hot.view._wt.wtTable;
  const headerHeight = wtTable.getColumnHeaderHeight(0) + 1;
  const scrollTop = wtTable.holder.scrollTop;
  const posTop = headerHeight + scrollTop;
  _classPrivateFieldGet21(this, _backlight).setPosition(posTop);
  _classPrivateFieldGet21(this, _backlight).setSize(null, wtTable.hider.offsetHeight - posTop);
}
function _onAfterLoadData26() {
  this.moveBySettingsOrLoad();
}

// node_modules/handsontable/plugins/manualColumnResize/manualColumnResize.mjs
function _classPrivateMethodInitSpec30(obj, privateSet) {
  _checkPrivateRedeclaration36(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec22(obj, privateMap, value) {
  _checkPrivateRedeclaration36(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration36(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet30(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldSet21(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor22(receiver, privateMap, "set");
  _classApplyDescriptorSet21(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet21(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet22(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor22(receiver, privateMap, "get");
  return _classApplyDescriptorGet22(receiver, descriptor);
}
function _classExtractFieldDescriptor22(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet22(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY22 = "manualColumnResize";
var PLUGIN_PRIORITY21 = 130;
var PERSISTENT_STATE_KEY = "manualColumnWidths";
var _currentTH = /* @__PURE__ */ new WeakMap();
var _currentCol = /* @__PURE__ */ new WeakMap();
var _selectedCols = /* @__PURE__ */ new WeakMap();
var _currentWidth = /* @__PURE__ */ new WeakMap();
var _newSize = /* @__PURE__ */ new WeakMap();
var _startY = /* @__PURE__ */ new WeakMap();
var _startWidth = /* @__PURE__ */ new WeakMap();
var _startOffset = /* @__PURE__ */ new WeakMap();
var _handle = /* @__PURE__ */ new WeakMap();
var _guide = /* @__PURE__ */ new WeakMap();
var _pressed2 = /* @__PURE__ */ new WeakMap();
var _isTriggeredByRMB = /* @__PURE__ */ new WeakMap();
var _dblclick = /* @__PURE__ */ new WeakMap();
var _autoresizeTimeout = /* @__PURE__ */ new WeakMap();
var _columnWidthsMap = /* @__PURE__ */ new WeakMap();
var _config = /* @__PURE__ */ new WeakMap();
var _onMapInit4 = /* @__PURE__ */ new WeakSet();
var _onMouseOver3 = /* @__PURE__ */ new WeakSet();
var _onMouseDown3 = /* @__PURE__ */ new WeakSet();
var _onMouseMove4 = /* @__PURE__ */ new WeakSet();
var _onMouseUp5 = /* @__PURE__ */ new WeakSet();
var _onContextMenu = /* @__PURE__ */ new WeakSet();
var _onModifyColWidth3 = /* @__PURE__ */ new WeakSet();
var _onBeforeStretchingColumnWidth = /* @__PURE__ */ new WeakSet();
var _onBeforeColumnResize3 = /* @__PURE__ */ new WeakSet();
var ManualColumnResize = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY22;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY21;
  }
  /**
   * @type {HTMLTableHeaderCellElement}
   */
  constructor(hotInstance) {
    super(hotInstance);
    _classPrivateMethodInitSpec30(this, _onBeforeColumnResize3);
    _classPrivateMethodInitSpec30(this, _onBeforeStretchingColumnWidth);
    _classPrivateMethodInitSpec30(this, _onModifyColWidth3);
    _classPrivateMethodInitSpec30(this, _onContextMenu);
    _classPrivateMethodInitSpec30(this, _onMouseUp5);
    _classPrivateMethodInitSpec30(this, _onMouseMove4);
    _classPrivateMethodInitSpec30(this, _onMouseDown3);
    _classPrivateMethodInitSpec30(this, _onMouseOver3);
    _classPrivateMethodInitSpec30(this, _onMapInit4);
    _classPrivateFieldInitSpec22(this, _currentTH, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _currentCol, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _selectedCols, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec22(this, _currentWidth, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _newSize, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _startY, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _startWidth, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _startOffset, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _handle, {
      writable: true,
      value: this.hot.rootDocument.createElement("DIV")
    });
    _classPrivateFieldInitSpec22(this, _guide, {
      writable: true,
      value: this.hot.rootDocument.createElement("DIV")
    });
    _classPrivateFieldInitSpec22(this, _pressed2, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _isTriggeredByRMB, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec22(this, _dblclick, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec22(this, _autoresizeTimeout, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec22(this, _columnWidthsMap, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec22(this, _config, {
      writable: true,
      value: void 0
    });
    addClass(_classPrivateFieldGet22(this, _handle), "manualColumnResizer");
    addClass(_classPrivateFieldGet22(this, _guide), "manualColumnResizerGuide");
  }
  /**
   * @private
   * @returns {string}
   */
  get inlineDir() {
    return this.hot.isRtl() ? "right" : "left";
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualColumnResize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY22];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    _classPrivateFieldSet21(this, _columnWidthsMap, new PhysicalIndexToValueMap());
    _classPrivateFieldGet22(this, _columnWidthsMap).addLocalHook("init", () => _classPrivateMethodGet30(this, _onMapInit4, _onMapInit23).call(this));
    this.hot.columnIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet22(this, _columnWidthsMap));
    this.addHook("modifyColWidth", (width, col) => _classPrivateMethodGet30(this, _onModifyColWidth3, _onModifyColWidth22).call(this, width, col));
    this.addHook("beforeStretchingColumnWidth", (stretchedWidth, column) => _classPrivateMethodGet30(this, _onBeforeStretchingColumnWidth, _onBeforeStretchingColumnWidth2).call(this, stretchedWidth, column));
    this.addHook("beforeColumnResize", (newSize, column, isDoubleClick) => _classPrivateMethodGet30(this, _onBeforeColumnResize3, _onBeforeColumnResize22).call(this, newSize, column, isDoubleClick));
    this.bindEvents();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualColumnResize`](@/api/options.md#manualcolumnresize)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    _classPrivateFieldSet21(this, _config, _classPrivateFieldGet22(this, _columnWidthsMap).getValues());
    this.hot.columnIndexMapper.unregisterMap(this.pluginName);
    super.disablePlugin();
  }
  /**
   * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
   *
   * @fires Hooks#persistentStateSave
   */
  saveManualColumnWidths() {
    this.hot.runHooks("persistentStateSave", PERSISTENT_STATE_KEY, _classPrivateFieldGet22(this, _columnWidthsMap).getValues());
  }
  /**
   * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option has to be enabled).
   *
   * @returns {Array}
   * @fires Hooks#persistentStateLoad
   */
  loadManualColumnWidths() {
    const storedState = {};
    this.hot.runHooks("persistentStateLoad", PERSISTENT_STATE_KEY, storedState);
    return storedState.value;
  }
  /**
   * Sets the new width for specified column index.
   *
   * @param {number} column Visual column index.
   * @param {number} width Column width (no less than 20px).
   * @returns {number} Returns new width.
   */
  setManualSize(column, width) {
    const newWidth = Math.max(width, 20);
    const physicalColumn = this.hot.toPhysicalColumn(column);
    _classPrivateFieldGet22(this, _columnWidthsMap).setValueAtIndex(physicalColumn, newWidth);
    return newWidth;
  }
  /**
   * Clears the cache for the specified column index.
   *
   * @param {number} column Visual column index.
   */
  clearManualSize(column) {
    const physicalColumn = this.hot.toPhysicalColumn(column);
    _classPrivateFieldGet22(this, _columnWidthsMap).setValueAtIndex(physicalColumn, null);
  }
  /**
   * Set the resize handle position.
   *
   * @private
   * @param {HTMLCellElement} TH TH HTML element.
   */
  setupHandlePosition(TH) {
    if (!TH.parentNode) {
      return;
    }
    _classPrivateFieldSet21(this, _currentTH, TH);
    const {
      _wt: wt
    } = this.hot.view;
    const cellCoords = wt.wtTable.getCoords(_classPrivateFieldGet22(this, _currentTH));
    const col = cellCoords.col;
    if (col < 0) {
      return;
    }
    const headerHeight = outerHeight(_classPrivateFieldGet22(this, _currentTH));
    const box = _classPrivateFieldGet22(this, _currentTH).getBoundingClientRect();
    const fixedColumn = col < wt.getSetting("fixedColumnsStart");
    let relativeHeaderPosition;
    if (fixedColumn) {
      relativeHeaderPosition = wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(_classPrivateFieldGet22(this, _currentTH), cellCoords.row, cellCoords.col);
    }
    if (!relativeHeaderPosition) {
      relativeHeaderPosition = wt.wtOverlays.topOverlay.getRelativeCellPosition(_classPrivateFieldGet22(this, _currentTH), cellCoords.row, cellCoords.col);
    }
    _classPrivateFieldSet21(this, _currentCol, this.hot.columnIndexMapper.getVisualFromRenderableIndex(col));
    _classPrivateFieldSet21(this, _selectedCols, []);
    const isFullColumnSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByColumnHeader();
    if (this.hot.selection.isSelected() && isFullColumnSelected) {
      const selectionRanges = this.hot.getSelectedRange();
      arrayEach(selectionRanges, (selectionRange) => {
        const fromColumn = selectionRange.getTopStartCorner().col;
        const toColumn = selectionRange.getBottomEndCorner().col;
        rangeEach(fromColumn, toColumn, (columnIndex) => {
          if (!_classPrivateFieldGet22(this, _selectedCols).includes(columnIndex)) {
            _classPrivateFieldGet22(this, _selectedCols).push(columnIndex);
          }
        });
      });
    }
    if (!_classPrivateFieldGet22(this, _selectedCols).includes(_classPrivateFieldGet22(this, _currentCol))) {
      _classPrivateFieldSet21(this, _selectedCols, [_classPrivateFieldGet22(this, _currentCol)]);
    }
    _classPrivateFieldSet21(this, _startOffset, relativeHeaderPosition.start - 6);
    _classPrivateFieldSet21(this, _startWidth, parseInt(box.width, 10));
    _classPrivateFieldGet22(this, _handle).style.top = `${relativeHeaderPosition.top}px`;
    _classPrivateFieldGet22(this, _handle).style[this.inlineDir] = `${_classPrivateFieldGet22(this, _startOffset) + _classPrivateFieldGet22(this, _startWidth)}px`;
    _classPrivateFieldGet22(this, _handle).style.height = `${headerHeight}px`;
    this.hot.rootElement.appendChild(_classPrivateFieldGet22(this, _handle));
  }
  /**
   * Refresh the resize handle position.
   *
   * @private
   */
  refreshHandlePosition() {
    _classPrivateFieldGet22(this, _handle).style[this.inlineDir] = `${_classPrivateFieldGet22(this, _startOffset) + _classPrivateFieldGet22(this, _currentWidth)}px`;
  }
  /**
   * Sets the resize guide position.
   *
   * @private
   */
  setupGuidePosition() {
    const handleHeight = parseInt(outerHeight(_classPrivateFieldGet22(this, _handle)), 10);
    const handleBottomPosition = parseInt(_classPrivateFieldGet22(this, _handle).style.top, 10) + handleHeight;
    const maximumVisibleElementHeight = parseInt(this.hot.view.maximumVisibleElementHeight(0), 10);
    addClass(_classPrivateFieldGet22(this, _handle), "active");
    addClass(_classPrivateFieldGet22(this, _guide), "active");
    _classPrivateFieldGet22(this, _guide).style.top = `${handleBottomPosition}px`;
    this.refreshGuidePosition();
    _classPrivateFieldGet22(this, _guide).style.height = `${maximumVisibleElementHeight - handleHeight}px`;
    this.hot.rootElement.appendChild(_classPrivateFieldGet22(this, _guide));
  }
  /**
   * Refresh the resize guide position.
   *
   * @private
   */
  refreshGuidePosition() {
    _classPrivateFieldGet22(this, _guide).style[this.inlineDir] = _classPrivateFieldGet22(this, _handle).style[this.inlineDir];
  }
  /**
   * Hides both the resize handle and resize guide.
   *
   * @private
   */
  hideHandleAndGuide() {
    removeClass(_classPrivateFieldGet22(this, _handle), "active");
    removeClass(_classPrivateFieldGet22(this, _guide), "active");
  }
  /**
   * Checks if provided element is considered a column header.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {boolean}
   */
  checkIfColumnHeader(element) {
    return !!closest(element, ["THEAD"], this.hot.rootElement);
  }
  /**
   * Gets the TH element from the provided element.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {HTMLElement}
   */
  getClosestTHParent(element) {
    if (element.tagName !== "TABLE") {
      if (element.tagName === "TH") {
        return element;
      }
      return this.getClosestTHParent(element.parentNode);
    }
    return null;
  }
  /**
   * Auto-size row after doubleclick - callback.
   *
   * @private
   * @fires Hooks#beforeColumnResize
   * @fires Hooks#afterColumnResize
   */
  afterMouseDownTimeout() {
    const render = () => {
      this.hot.forceFullRender = true;
      this.hot.view.render();
      this.hot.view.adjustElementsSize(true);
    };
    const resize = (column, forceRender) => {
      const hookNewSize = this.hot.runHooks("beforeColumnResize", _classPrivateFieldGet22(this, _newSize), column, true);
      if (hookNewSize !== void 0) {
        _classPrivateFieldSet21(this, _newSize, hookNewSize);
      }
      if (this.hot.getSettings().stretchH === "all") {
        this.clearManualSize(column);
      } else {
        this.setManualSize(column, _classPrivateFieldGet22(this, _newSize));
      }
      this.saveManualColumnWidths();
      this.hot.runHooks("afterColumnResize", _classPrivateFieldGet22(this, _newSize), column, true);
      if (forceRender) {
        render();
      }
    };
    if (_classPrivateFieldGet22(this, _dblclick) >= 2) {
      const selectedColsLength = _classPrivateFieldGet22(this, _selectedCols).length;
      if (selectedColsLength > 1) {
        arrayEach(_classPrivateFieldGet22(this, _selectedCols), (selectedCol) => {
          resize(selectedCol);
        });
        render();
      } else {
        arrayEach(_classPrivateFieldGet22(this, _selectedCols), (selectedCol) => {
          resize(selectedCol, true);
        });
      }
    }
    _classPrivateFieldSet21(this, _dblclick, 0);
    _classPrivateFieldSet21(this, _autoresizeTimeout, null);
  }
  /**
   * Binds the mouse events.
   *
   * @private
   */
  bindEvents() {
    const {
      rootWindow,
      rootElement
    } = this.hot;
    this.eventManager.addEventListener(rootElement, "mouseover", (e) => _classPrivateMethodGet30(this, _onMouseOver3, _onMouseOver22).call(this, e));
    this.eventManager.addEventListener(rootElement, "mousedown", (e) => _classPrivateMethodGet30(this, _onMouseDown3, _onMouseDown22).call(this, e));
    this.eventManager.addEventListener(rootWindow, "mousemove", (e) => _classPrivateMethodGet30(this, _onMouseMove4, _onMouseMove23).call(this, e));
    this.eventManager.addEventListener(rootWindow, "mouseup", () => _classPrivateMethodGet30(this, _onMouseUp5, _onMouseUp24).call(this));
    this.eventManager.addEventListener(_classPrivateFieldGet22(this, _handle), "contextmenu", () => _classPrivateMethodGet30(this, _onContextMenu, _onContextMenu2).call(this));
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _onMapInit23() {
  const initialSetting = this.hot.getSettings()[PLUGIN_KEY22];
  const loadedManualColumnWidths = this.loadManualColumnWidths();
  if (typeof loadedManualColumnWidths !== "undefined") {
    this.hot.batchExecution(() => {
      loadedManualColumnWidths.forEach((width, physicalIndex) => {
        _classPrivateFieldGet22(this, _columnWidthsMap).setValueAtIndex(physicalIndex, width);
      });
    }, true);
  } else if (Array.isArray(initialSetting)) {
    this.hot.batchExecution(() => {
      initialSetting.forEach((width, physicalIndex) => {
        _classPrivateFieldGet22(this, _columnWidthsMap).setValueAtIndex(physicalIndex, width);
      });
    }, true);
    _classPrivateFieldSet21(this, _config, initialSetting);
  } else if (initialSetting === true && Array.isArray(_classPrivateFieldGet22(this, _config))) {
    this.hot.batchExecution(() => {
      _classPrivateFieldGet22(this, _config).forEach((width, physicalIndex) => {
        _classPrivateFieldGet22(this, _columnWidthsMap).setValueAtIndex(physicalIndex, width);
      });
    }, true);
  }
}
function _onMouseOver22(event) {
  if (isDetached(event.target)) {
    return;
  }
  if (_classPrivateFieldGet22(this, _isTriggeredByRMB) === true) {
    return;
  }
  if (this.checkIfColumnHeader(event.target)) {
    const th = this.getClosestTHParent(event.target);
    if (!th) {
      return;
    }
    const colspan = th.getAttribute("colspan");
    if (th && (colspan === null || colspan === "1")) {
      if (!_classPrivateFieldGet22(this, _pressed2)) {
        this.setupHandlePosition(th);
      }
    }
  }
}
function _onMouseDown22(event) {
  if (hasClass(event.target, "manualColumnResizer")) {
    this.setupHandlePosition(_classPrivateFieldGet22(this, _currentTH));
    this.setupGuidePosition();
    _classPrivateFieldSet21(this, _pressed2, true);
    if (_classPrivateFieldGet22(this, _autoresizeTimeout) === null) {
      _classPrivateFieldSet21(this, _autoresizeTimeout, setTimeout(() => this.afterMouseDownTimeout(), 500));
      this.hot._registerTimeout(_classPrivateFieldGet22(this, _autoresizeTimeout));
    }
    _classPrivateFieldSet21(this, _dblclick, _classPrivateFieldGet22(this, _dblclick) + 1);
    this.startX = event.pageX;
    _classPrivateFieldSet21(this, _newSize, _classPrivateFieldGet22(this, _startWidth));
  }
}
function _onMouseMove23(event) {
  if (_classPrivateFieldGet22(this, _pressed2)) {
    const change = (event.pageX - this.startX) * this.hot.getDirectionFactor();
    _classPrivateFieldSet21(this, _currentWidth, _classPrivateFieldGet22(this, _startWidth) + change);
    arrayEach(_classPrivateFieldGet22(this, _selectedCols), (selectedCol) => {
      _classPrivateFieldSet21(this, _newSize, this.setManualSize(selectedCol, _classPrivateFieldGet22(this, _currentWidth)));
    });
    this.refreshHandlePosition();
    this.refreshGuidePosition();
  }
}
function _onMouseUp24() {
  const render = () => {
    this.hot.forceFullRender = true;
    this.hot.view.render();
    this.hot.view.adjustElementsSize(true);
  };
  const resize = (column, forceRender) => {
    this.hot.runHooks("beforeColumnResize", _classPrivateFieldGet22(this, _newSize), column, false);
    if (forceRender) {
      render();
    }
    this.saveManualColumnWidths();
    this.hot.runHooks("afterColumnResize", _classPrivateFieldGet22(this, _newSize), column, false);
  };
  if (_classPrivateFieldGet22(this, _pressed2)) {
    this.hideHandleAndGuide();
    _classPrivateFieldSet21(this, _pressed2, false);
    if (_classPrivateFieldGet22(this, _newSize) !== _classPrivateFieldGet22(this, _startWidth)) {
      const selectedColsLength = _classPrivateFieldGet22(this, _selectedCols).length;
      if (selectedColsLength > 1) {
        arrayEach(_classPrivateFieldGet22(this, _selectedCols), (selectedCol) => {
          resize(selectedCol);
        });
        render();
      } else {
        arrayEach(_classPrivateFieldGet22(this, _selectedCols), (selectedCol) => {
          resize(selectedCol, true);
        });
      }
    }
    this.setupHandlePosition(_classPrivateFieldGet22(this, _currentTH));
  }
}
function _onContextMenu2() {
  this.hideHandleAndGuide();
  this.hot.rootElement.removeChild(_classPrivateFieldGet22(this, _handle));
  this.hot.rootElement.removeChild(_classPrivateFieldGet22(this, _guide));
  _classPrivateFieldSet21(this, _pressed2, false);
  _classPrivateFieldSet21(this, _isTriggeredByRMB, true);
  this.hot._registerImmediate(() => {
    _classPrivateFieldSet21(this, _isTriggeredByRMB, false);
  });
}
function _onModifyColWidth22(width, column) {
  let newWidth = width;
  if (this.enabled) {
    const physicalColumn = this.hot.toPhysicalColumn(column);
    const columnWidth = _classPrivateFieldGet22(this, _columnWidthsMap).getValueAtIndex(physicalColumn);
    if (this.hot.getSettings()[PLUGIN_KEY22] && columnWidth) {
      newWidth = columnWidth;
    }
  }
  return newWidth;
}
function _onBeforeStretchingColumnWidth2(stretchedWidth, column) {
  let width = _classPrivateFieldGet22(this, _columnWidthsMap).getValueAtIndex(column);
  if (width === null) {
    width = stretchedWidth;
  }
  return width;
}
function _onBeforeColumnResize22() {
  this.hot.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();
}

// node_modules/handsontable/plugins/manualRowMove/ui/_base.mjs
function _defineProperty39(obj, key, value) {
  key = _toPropertyKey39(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey39(arg) {
  var key = _toPrimitive39(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive39(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var STATE_INITIALIZED2 = 0;
var STATE_BUILT3 = 1;
var STATE_APPENDED2 = 2;
var UNIT2 = "px";
var BaseUI3 = class {
  constructor(hotInstance) {
    _defineProperty39(this, "hot", void 0);
    _defineProperty39(this, "_element", null);
    _defineProperty39(this, "state", STATE_INITIALIZED2);
    this.hot = hotInstance;
  }
  /**
   * Add created UI elements to table.
   *
   * @param {HTMLElement} wrapper Element which are parent for our UI element.
   */
  appendTo(wrapper) {
    wrapper.appendChild(this._element);
    this.state = STATE_APPENDED2;
  }
  /**
   * Method for create UI element. Only create, without append to table.
   */
  build() {
    if (this.state !== STATE_INITIALIZED2) {
      return;
    }
    this._element = this.hot.rootDocument.createElement("div");
    this.state = STATE_BUILT3;
  }
  /**
   * Method for remove UI element.
   */
  destroy() {
    if (this.isAppended()) {
      this._element.parentElement.removeChild(this._element);
    }
    this._element = null;
    this.state = STATE_INITIALIZED2;
  }
  /**
   * Check if UI element are appended.
   *
   * @returns {boolean}
   */
  isAppended() {
    return this.state === STATE_APPENDED2;
  }
  /**
   * Check if UI element are built.
   *
   * @returns {boolean}
   */
  isBuilt() {
    return this.state >= STATE_BUILT3;
  }
  /**
   * Setter for position.
   *
   * @param {number} top New top position of the element.
   * @param {number} left New left position of the element.
   */
  setPosition(top2, left2) {
    if (top2 !== void 0) {
      this._element.style.top = top2 + UNIT2;
    }
    if (left2 !== void 0) {
      this._element.style.left = left2 + UNIT2;
    }
  }
  /**
   * Getter for the element position.
   *
   * @returns {object} Object contains left and top position of the element.
   */
  getPosition() {
    return {
      top: this._element.style.top ? parseInt(this._element.style.top, 10) : 0,
      left: this._element.style.left ? parseInt(this._element.style.left, 10) : 0
    };
  }
  /**
   * Setter for the element size.
   *
   * @param {number} width New width of the element.
   * @param {number} height New height of the element.
   */
  setSize(width, height) {
    if (width) {
      this._element.style.width = width + UNIT2;
    }
    if (height) {
      this._element.style.height = height + UNIT2;
    }
  }
  /**
   * Getter for the element position.
   *
   * @returns {object} Object contains height and width of the element.
   */
  getSize() {
    return {
      width: this._element.style.width ? parseInt(this._element.style.width, 10) : 0,
      height: this._element.style.height ? parseInt(this._element.style.height, 10) : 0
    };
  }
  /**
   * Setter for the element offset. Offset means marginTop and marginLeft of the element.
   *
   * @param {number} top New margin top of the element.
   * @param {number} left New margin left of the element.
   */
  setOffset(top2, left2) {
    if (top2) {
      this._element.style.marginTop = top2 + UNIT2;
    }
    if (left2) {
      this._element.style.marginLeft = left2 + UNIT2;
    }
  }
  /**
   * Getter for the element offset.
   *
   * @returns {object} Object contains top and left offset of the element.
   */
  getOffset() {
    return {
      top: this._element.style.marginTop ? parseInt(this._element.style.marginTop, 10) : 0,
      left: this._element.style.marginLeft ? parseInt(this._element.style.marginLeft, 10) : 0
    };
  }
};
var base_default3 = BaseUI3;

// node_modules/handsontable/plugins/manualRowMove/ui/backlight.mjs
var CSS_CLASSNAME3 = "ht__manualRowMove--backlight";
var BacklightUI2 = class extends base_default3 {
  /**
   * Custom className on build process.
   */
  build() {
    super.build();
    addClass(this._element, CSS_CLASSNAME3);
  }
};
var backlight_default2 = BacklightUI2;

// node_modules/handsontable/plugins/manualRowMove/ui/guideline.mjs
var CSS_CLASSNAME4 = "ht__manualRowMove--guideline";
var GuidelineUI2 = class extends base_default3 {
  /**
   * Custom className on build process.
   */
  build() {
    super.build();
    addClass(this._element, CSS_CLASSNAME4);
  }
};
var guideline_default2 = GuidelineUI2;

// node_modules/handsontable/plugins/manualRowMove/manualRowMove.mjs
function _classPrivateMethodInitSpec31(obj, privateSet) {
  _checkPrivateRedeclaration37(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec23(obj, privateMap, value) {
  _checkPrivateRedeclaration37(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration37(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet22(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor23(receiver, privateMap, "set");
  _classApplyDescriptorSet22(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet22(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet23(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor23(receiver, privateMap, "get");
  return _classApplyDescriptorGet23(receiver, descriptor);
}
function _classExtractFieldDescriptor23(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet23(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet31(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
pluginHooks_default.getSingleton().register("beforeRowMove");
pluginHooks_default.getSingleton().register("afterRowMove");
var PLUGIN_KEY23 = "manualRowMove";
var PLUGIN_PRIORITY22 = 140;
var CSS_PLUGIN2 = "ht__manualRowMove";
var CSS_SHOW_UI2 = "show-ui";
var CSS_ON_MOVING2 = "on-moving--rows";
var CSS_AFTER_SELECTION2 = "after-selection--rows";
var _backlight2 = /* @__PURE__ */ new WeakMap();
var _guideline2 = /* @__PURE__ */ new WeakMap();
var _rowsToMove = /* @__PURE__ */ new WeakMap();
var _pressed3 = /* @__PURE__ */ new WeakMap();
var _target2 = /* @__PURE__ */ new WeakMap();
var _cachedDropIndex2 = /* @__PURE__ */ new WeakMap();
var _onBeforeOnCellMouseDown5 = /* @__PURE__ */ new WeakSet();
var _onMouseMove5 = /* @__PURE__ */ new WeakSet();
var _onBeforeOnCellMouseOver3 = /* @__PURE__ */ new WeakSet();
var _onMouseUp6 = /* @__PURE__ */ new WeakSet();
var _onAfterScrollHorizontally = /* @__PURE__ */ new WeakSet();
var _onAfterLoadData8 = /* @__PURE__ */ new WeakSet();
var ManualRowMove = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec31(this, _onAfterLoadData8);
    _classPrivateMethodInitSpec31(this, _onAfterScrollHorizontally);
    _classPrivateMethodInitSpec31(this, _onMouseUp6);
    _classPrivateMethodInitSpec31(this, _onBeforeOnCellMouseOver3);
    _classPrivateMethodInitSpec31(this, _onMouseMove5);
    _classPrivateMethodInitSpec31(this, _onBeforeOnCellMouseDown5);
    _classPrivateFieldInitSpec23(this, _backlight2, {
      writable: true,
      value: new backlight_default2(this.hot)
    });
    _classPrivateFieldInitSpec23(this, _guideline2, {
      writable: true,
      value: new guideline_default2(this.hot)
    });
    _classPrivateFieldInitSpec23(this, _rowsToMove, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec23(this, _pressed3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec23(this, _target2, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec23(this, _cachedDropIndex2, {
      writable: true,
      value: void 0
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY23;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY22;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualRowMove#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY23];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.addHook("beforeOnCellMouseDown", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet31(_this, _onBeforeOnCellMouseDown5, _onBeforeOnCellMouseDown24).call(_this, ...args);
    });
    this.addHook("beforeOnCellMouseOver", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet31(_this, _onBeforeOnCellMouseOver3, _onBeforeOnCellMouseOver22).call(_this, ...args);
    });
    this.addHook("afterScrollHorizontally", () => _classPrivateMethodGet31(this, _onAfterScrollHorizontally, _onAfterScrollHorizontally2).call(this));
    this.addHook("afterLoadData", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _classPrivateMethodGet31(_this, _onAfterLoadData8, _onAfterLoadData27).call(_this, ...args);
    });
    this.buildPluginUI();
    this.registerEvents();
    addClass(this.hot.rootElement, CSS_PLUGIN2);
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualRowMove`](@/api/options.md#manualrowmove)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    this.moveBySettingsOrLoad();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    removeClass(this.hot.rootElement, CSS_PLUGIN2);
    this.unregisterEvents();
    _classPrivateFieldGet23(this, _backlight2).destroy();
    _classPrivateFieldGet23(this, _guideline2).destroy();
    super.disablePlugin();
  }
  /**
   * Moves a single row.
   *
   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).
   *
   * @param {number} row Visual row index to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @fires Hooks#beforeRowMove
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  moveRow(row, finalIndex) {
    return this.moveRows([row], finalIndex);
  }
  /**
   * Moves multiple rows.
   *
   * To see the outcome, rerender your grid by calling [`render()`](@/api/core.md#render).
   *
   * @param {Array} rows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @fires Hooks#beforeRowMove
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  moveRows(rows, finalIndex) {
    const dropIndex = _classPrivateFieldGet23(this, _cachedDropIndex2);
    const movePossible = this.isMovePossible(rows, finalIndex);
    const beforeMoveHook = this.hot.runHooks("beforeRowMove", rows, finalIndex, dropIndex, movePossible);
    _classPrivateFieldSet22(this, _cachedDropIndex2, void 0);
    if (beforeMoveHook === false) {
      return;
    }
    if (movePossible) {
      this.hot.rowIndexMapper.moveIndexes(rows, finalIndex);
    }
    const movePerformed = movePossible && this.isRowOrderChanged(rows, finalIndex);
    this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, movePerformed);
    return movePerformed;
  }
  /**
   * Drag a single row to drop index position.
   *
   * @param {number} row Visual row index to be dragged.
   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.
   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @fires Hooks#beforeRowMove
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  dragRow(row, dropIndex) {
    return this.dragRows([row], dropIndex);
  }
  /**
   * Drag multiple rows to drop index position.
   *
   * @param {Array} rows Array of visual row indexes to be dragged.
   * @param {number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we are going to drop the moved elements.
   * To check visualization of drop index please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @fires Hooks#beforeRowMove
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  dragRows(rows, dropIndex) {
    const finalIndex = this.countFinalIndex(rows, dropIndex);
    _classPrivateFieldSet22(this, _cachedDropIndex2, dropIndex);
    return this.moveRows(rows, finalIndex);
  }
  /**
   * Indicates if it's possible to move rows to the desired position. Some of the actions aren't possible, i.e. You can’t move more than one element to the last position.
   *
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @returns {boolean}
   */
  isMovePossible(movedRows, finalIndex) {
    const length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();
    const tooHighDestinationIndex = movedRows.length + finalIndex > length;
    const tooLowDestinationIndex = finalIndex < 0;
    const tooLowMovedRowIndex = movedRows.some((movedRow) => movedRow < 0);
    const tooHighMovedRowIndex = movedRows.some((movedRow) => movedRow >= length);
    if (tooHighDestinationIndex || tooLowDestinationIndex || tooLowMovedRowIndex || tooHighMovedRowIndex) {
      return false;
    }
    return true;
  }
  /**
   * Indicates if order of rows was changed.
   *
   * @private
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.
   * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving.md#drag-and-move-actions-of-manualrowmove-plugin).
   * @returns {boolean}
   */
  isRowOrderChanged(movedRows, finalIndex) {
    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);
  }
  /**
   * Count the final row index from the drop index.
   *
   * @private
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} dropIndex Visual row index, being a drop index for the moved rows.
   * @returns {number} Visual row index, being a start index for the moved rows.
   */
  countFinalIndex(movedRows, dropIndex) {
    const numberOfRowsLowerThanDropIndex = arrayReduce(movedRows, (numberOfRows, currentRowIndex) => {
      if (currentRowIndex < dropIndex) {
        numberOfRows += 1;
      }
      return numberOfRows;
    }, 0);
    return dropIndex - numberOfRowsLowerThanDropIndex;
  }
  /**
   * Gets the sum of the heights of rows in the provided range.
   *
   * @private
   * @param {number} fromRow Visual row index.
   * @param {number} toRow Visual row index.
   * @returns {number}
   */
  getRowsHeight(fromRow, toRow) {
    const rowMapper = this.hot.rowIndexMapper;
    let rowsHeight = 0;
    for (let visualRowIndex = fromRow; visualRowIndex <= toRow; visualRowIndex++) {
      const renderableIndex = rowMapper.getRenderableFromVisualIndex(visualRowIndex);
      if (renderableIndex !== null) {
        rowsHeight += this.hot.view._wt.wtTable.getRowHeight(renderableIndex) || 23;
      }
    }
    return rowsHeight;
  }
  /**
   * Loads initial settings when persistent state is saved or when plugin was initialized as an array.
   *
   * @private
   */
  moveBySettingsOrLoad() {
    const pluginSettings = this.hot.getSettings()[PLUGIN_KEY23];
    if (Array.isArray(pluginSettings)) {
      this.moveRows(pluginSettings, 0);
    } else if (pluginSettings !== void 0) {
      const persistentState = this.persistentStateLoad();
      if (persistentState.length) {
        this.moveRows(persistentState, 0);
      }
    }
  }
  /**
   * Checks if the provided row is in the fixedRowsTop section.
   *
   * @private
   * @param {number} row Visual row index to check.
   * @returns {boolean}
   */
  isFixedRowTop(row) {
    return row < this.hot.getSettings().fixedRowsTop;
  }
  /**
   * Checks if the provided row is in the fixedRowsBottom section.
   *
   * @private
   * @param {number} row Visual row index to check.
   * @returns {boolean}
   */
  isFixedRowBottom(row) {
    return row > this.hot.countRows() - 1 - this.hot.getSettings().fixedRowsBottom;
  }
  /**
   * Saves the manual row positions to the persistent state (the {@link Options#persistentState} option has to be enabled).
   *
   * @private
   * @fires Hooks#persistentStateSave
   */
  persistentStateSave() {
    this.hot.runHooks("persistentStateSave", "manualRowMove", this.hot.rowIndexMapper.getIndexesSequence());
  }
  /**
   * Loads the manual row positions from the persistent state (the {@link Options#persistentState} option has to be enabled).
   *
   * @private
   * @fires Hooks#persistentStateLoad
   * @returns {Array} Stored state.
   */
  persistentStateLoad() {
    const storedState = {};
    this.hot.runHooks("persistentStateLoad", "manualRowMove", storedState);
    return storedState.value ? storedState.value : [];
  }
  /**
   * Prepares an array of indexes based on actual selection.
   *
   * @private
   * @returns {Array}
   */
  prepareRowsToMoving() {
    const selection = this.hot.getSelectedRangeLast();
    const selectedRows = [];
    if (!selection) {
      return selectedRows;
    }
    const {
      from,
      to
    } = selection;
    const start = Math.min(from.row, to.row);
    const end = Math.max(from.row, to.row);
    rangeEach(start, end, (i) => {
      selectedRows.push(i);
    });
    return selectedRows;
  }
  /**
   * Update the UI visual position.
   *
   * @private
   */
  refreshPositions() {
    const coords = _classPrivateFieldGet23(this, _target2).coords;
    const firstVisible = this.hot.view.getFirstFullyVisibleRow();
    const lastVisible = this.hot.view.getLastFullyVisibleRow();
    const countRows = this.hot.countRows();
    if (this.isFixedRowTop(coords.row) && firstVisible > 0) {
      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(firstVisible - 1, -1));
    }
    if (this.isFixedRowBottom(coords.row) && lastVisible < countRows) {
      this.hot.scrollViewportTo(this.hot.rowIndexMapper.getNearestNotHiddenIndex(lastVisible + 1, 1), void 0, true);
    }
    const wtTable = this.hot.view._wt.wtTable;
    const TD = _classPrivateFieldGet23(this, _target2).TD;
    const rootElement = this.hot.rootElement;
    const rootElementOffset = offset(rootElement);
    const trimmingContainer = getTrimmingContainer(rootElement);
    const tableScroll = wtTable.holder.scrollTop;
    const trimmingContainerScroll = this.hot.rootWindow !== trimmingContainer ? trimmingContainer.scrollTop : 0;
    const pixelsAbove = rootElementOffset.top - trimmingContainerScroll;
    const pixelsRelToTableStart = _classPrivateFieldGet23(this, _target2).eventPageY - pixelsAbove + tableScroll;
    const hiderHeight = wtTable.hider.offsetHeight;
    const tbodyOffsetTop = wtTable.TBODY.offsetTop;
    const backlightElemMarginTop = _classPrivateFieldGet23(this, _backlight2).getOffset().top;
    const backlightElemHeight = _classPrivateFieldGet23(this, _backlight2).getSize().height;
    const tdMiddle = TD.offsetHeight / 2;
    const tdHeight = TD.offsetHeight;
    let tdStartPixel = this.hot.view.THEAD.offsetHeight + this.getRowsHeight(0, coords.row - 1);
    const isBelowTable = pixelsRelToTableStart >= tdStartPixel + tdMiddle;
    if (this.isFixedRowTop(coords.row)) {
      tdStartPixel += this.hot.view._wt.wtOverlays.topOverlay.getOverlayOffset();
    }
    if (coords.row < 0) {
      _classPrivateFieldGet23(this, _target2).row = firstVisible > 0 ? firstVisible - 1 : firstVisible;
    } else if (isBelowTable) {
      _classPrivateFieldGet23(this, _target2).row = coords.row + 1;
      tdStartPixel += coords.row === 0 ? tdHeight - 1 : tdHeight;
    } else {
      _classPrivateFieldGet23(this, _target2).row = coords.row;
    }
    let backlightTop = pixelsRelToTableStart;
    let guidelineTop = tdStartPixel;
    if (pixelsRelToTableStart + backlightElemHeight + backlightElemMarginTop >= hiderHeight) {
      backlightTop = hiderHeight - backlightElemHeight - backlightElemMarginTop;
    } else if (pixelsRelToTableStart + backlightElemMarginTop < tbodyOffsetTop) {
      backlightTop = tbodyOffsetTop + Math.abs(backlightElemMarginTop);
    }
    if (tdStartPixel >= hiderHeight - 1) {
      guidelineTop = hiderHeight - 1;
    }
    _classPrivateFieldGet23(this, _backlight2).setPosition(backlightTop);
    _classPrivateFieldGet23(this, _guideline2).setPosition(guidelineTop);
  }
  /**
   * Binds the events used by the plugin.
   *
   * @private
   */
  registerEvents() {
    const {
      documentElement
    } = this.hot.rootDocument;
    this.eventManager.addEventListener(documentElement, "mousemove", (event) => _classPrivateMethodGet31(this, _onMouseMove5, _onMouseMove24).call(this, event));
    this.eventManager.addEventListener(documentElement, "mouseup", () => _classPrivateMethodGet31(this, _onMouseUp6, _onMouseUp25).call(this));
  }
  /**
   * Unbinds the events used by the plugin.
   *
   * @private
   */
  unregisterEvents() {
    this.eventManager.clear();
  }
  /**
   * Builds the plugin's UI.
   *
   * @private
   */
  buildPluginUI() {
    _classPrivateFieldGet23(this, _backlight2).build();
    _classPrivateFieldGet23(this, _guideline2).build();
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldGet23(this, _backlight2).destroy();
    _classPrivateFieldGet23(this, _guideline2).destroy();
    super.destroy();
  }
};
function _onBeforeOnCellMouseDown24(event, coords, TD, controller) {
  const {
    wtTable,
    wtViewport
  } = this.hot.view._wt;
  const isHeaderSelection = this.hot.selection.isSelectedByRowHeader();
  const selection = this.hot.getSelectedRangeLast();
  if (!selection || !isHeaderSelection || _classPrivateFieldGet23(this, _pressed3) || event.button !== 0) {
    _classPrivateFieldSet22(this, _pressed3, false);
    _classPrivateFieldGet23(this, _rowsToMove).length = 0;
    removeClass(this.hot.rootElement, [CSS_ON_MOVING2, CSS_SHOW_UI2]);
    return;
  }
  const guidelineIsNotReady = _classPrivateFieldGet23(this, _guideline2).isBuilt() && !_classPrivateFieldGet23(this, _guideline2).isAppended();
  const backlightIsNotReady = _classPrivateFieldGet23(this, _backlight2).isBuilt() && !_classPrivateFieldGet23(this, _backlight2).isAppended();
  if (guidelineIsNotReady && backlightIsNotReady) {
    _classPrivateFieldGet23(this, _guideline2).appendTo(wtTable.hider);
    _classPrivateFieldGet23(this, _backlight2).appendTo(wtTable.hider);
  }
  const {
    from,
    to
  } = selection;
  const start = Math.min(from.row, to.row);
  const end = Math.max(from.row, to.row);
  if (coords.col < 0 && coords.row >= start && coords.row <= end) {
    controller.row = true;
    _classPrivateFieldSet22(this, _pressed3, true);
    _classPrivateFieldGet23(this, _target2).eventPageY = event.pageY;
    _classPrivateFieldGet23(this, _target2).coords = coords;
    _classPrivateFieldGet23(this, _target2).TD = TD;
    _classPrivateFieldSet22(this, _rowsToMove, this.prepareRowsToMoving());
    const leftPos = wtTable.holder.scrollLeft + wtViewport.getRowHeaderWidth();
    const topOffset = this.getRowsHeight(start, coords.row - 1) + event.offsetY;
    _classPrivateFieldGet23(this, _backlight2).setPosition(null, leftPos);
    _classPrivateFieldGet23(this, _backlight2).setSize(wtTable.hider.offsetWidth - leftPos, this.getRowsHeight(start, end));
    _classPrivateFieldGet23(this, _backlight2).setOffset(-topOffset, null);
    addClass(this.hot.rootElement, CSS_ON_MOVING2);
    this.refreshPositions();
  } else {
    removeClass(this.hot.rootElement, CSS_AFTER_SELECTION2);
    _classPrivateFieldSet22(this, _pressed3, false);
    _classPrivateFieldGet23(this, _rowsToMove).length = 0;
  }
}
function _onMouseMove24(event) {
  if (!_classPrivateFieldGet23(this, _pressed3)) {
    return;
  }
  _classPrivateFieldGet23(this, _target2).eventPageY = event.pageY;
  this.refreshPositions();
}
function _onBeforeOnCellMouseOver22(event, coords, TD, controller) {
  const selectedRange = this.hot.getSelectedRangeLast();
  if (!selectedRange || !_classPrivateFieldGet23(this, _pressed3)) {
    return;
  }
  if (_classPrivateFieldGet23(this, _rowsToMove).indexOf(coords.row) > -1) {
    removeClass(this.hot.rootElement, CSS_SHOW_UI2);
  } else {
    addClass(this.hot.rootElement, CSS_SHOW_UI2);
  }
  controller.row = true;
  controller.column = true;
  controller.cell = true;
  _classPrivateFieldGet23(this, _target2).coords = coords;
  _classPrivateFieldGet23(this, _target2).TD = TD;
}
function _onMouseUp25() {
  const target = _classPrivateFieldGet23(this, _target2).row;
  const rowsLen = _classPrivateFieldGet23(this, _rowsToMove).length;
  _classPrivateFieldSet22(this, _pressed3, false);
  removeClass(this.hot.rootElement, [CSS_ON_MOVING2, CSS_SHOW_UI2, CSS_AFTER_SELECTION2]);
  if (this.hot.selection.isSelectedByRowHeader()) {
    addClass(this.hot.rootElement, CSS_AFTER_SELECTION2);
  }
  if (rowsLen < 1 || target === void 0) {
    return;
  }
  const firstMovedVisualRow = _classPrivateFieldGet23(this, _rowsToMove)[0];
  const firstMovedPhysicalRow = this.hot.toPhysicalRow(firstMovedVisualRow);
  const movePerformed = this.dragRows(_classPrivateFieldGet23(this, _rowsToMove), target);
  _classPrivateFieldGet23(this, _rowsToMove).length = 0;
  if (movePerformed === true) {
    this.persistentStateSave();
    this.hot.render();
    this.hot.view.adjustElementsSize(true);
    const selectionStart = this.hot.toVisualRow(firstMovedPhysicalRow);
    const selectionEnd = selectionStart + rowsLen - 1;
    this.hot.selectRows(selectionStart, selectionEnd);
  }
}
function _onAfterScrollHorizontally2() {
  const wtTable = this.hot.view._wt.wtTable;
  const headerWidth = this.hot.view._wt.wtViewport.getRowHeaderWidth();
  const scrollLeft = wtTable.holder.scrollLeft;
  const posLeft = headerWidth + scrollLeft;
  _classPrivateFieldGet23(this, _backlight2).setPosition(null, posLeft);
  _classPrivateFieldGet23(this, _backlight2).setSize(wtTable.hider.offsetWidth - posLeft);
}
function _onAfterLoadData27() {
  this.moveBySettingsOrLoad();
}

// node_modules/handsontable/plugins/manualRowResize/manualRowResize.mjs
function _classPrivateMethodInitSpec32(obj, privateSet) {
  _checkPrivateRedeclaration38(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec24(obj, privateMap, value) {
  _checkPrivateRedeclaration38(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration38(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateMethodGet32(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _classPrivateFieldSet23(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor24(receiver, privateMap, "set");
  _classApplyDescriptorSet23(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet23(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet24(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor24(receiver, privateMap, "get");
  return _classApplyDescriptorGet24(receiver, descriptor);
}
function _classExtractFieldDescriptor24(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet24(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var PLUGIN_KEY24 = "manualRowResize";
var PLUGIN_PRIORITY23 = 30;
var PERSISTENT_STATE_KEY2 = "manualRowHeights";
var _currentTH2 = /* @__PURE__ */ new WeakMap();
var _currentRow = /* @__PURE__ */ new WeakMap();
var _selectedRows = /* @__PURE__ */ new WeakMap();
var _currentHeight = /* @__PURE__ */ new WeakMap();
var _newSize2 = /* @__PURE__ */ new WeakMap();
var _startY2 = /* @__PURE__ */ new WeakMap();
var _startHeight = /* @__PURE__ */ new WeakMap();
var _startOffset2 = /* @__PURE__ */ new WeakMap();
var _handle2 = /* @__PURE__ */ new WeakMap();
var _guide2 = /* @__PURE__ */ new WeakMap();
var _pressed4 = /* @__PURE__ */ new WeakMap();
var _isTriggeredByRMB2 = /* @__PURE__ */ new WeakMap();
var _dblclick2 = /* @__PURE__ */ new WeakMap();
var _autoresizeTimeout2 = /* @__PURE__ */ new WeakMap();
var _rowHeightsMap = /* @__PURE__ */ new WeakMap();
var _config2 = /* @__PURE__ */ new WeakMap();
var _onMouseOver4 = /* @__PURE__ */ new WeakSet();
var _onMouseDown4 = /* @__PURE__ */ new WeakSet();
var _onMouseMove6 = /* @__PURE__ */ new WeakSet();
var _onMouseUp7 = /* @__PURE__ */ new WeakSet();
var _onContextMenu3 = /* @__PURE__ */ new WeakSet();
var _onModifyRowHeight3 = /* @__PURE__ */ new WeakSet();
var _onMapInit5 = /* @__PURE__ */ new WeakSet();
var ManualRowResize = class extends BasePlugin {
  static get PLUGIN_KEY() {
    return PLUGIN_KEY24;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY23;
  }
  /**
   * @type {HTMLTableCellElement}
   */
  constructor(hotInstance) {
    super(hotInstance);
    _classPrivateMethodInitSpec32(this, _onMapInit5);
    _classPrivateMethodInitSpec32(this, _onModifyRowHeight3);
    _classPrivateMethodInitSpec32(this, _onContextMenu3);
    _classPrivateMethodInitSpec32(this, _onMouseUp7);
    _classPrivateMethodInitSpec32(this, _onMouseMove6);
    _classPrivateMethodInitSpec32(this, _onMouseDown4);
    _classPrivateMethodInitSpec32(this, _onMouseOver4);
    _classPrivateFieldInitSpec24(this, _currentTH2, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec24(this, _currentRow, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec24(this, _selectedRows, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec24(this, _currentHeight, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec24(this, _newSize2, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec24(this, _startY2, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec24(this, _startHeight, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec24(this, _startOffset2, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec24(this, _handle2, {
      writable: true,
      value: this.hot.rootDocument.createElement("DIV")
    });
    _classPrivateFieldInitSpec24(this, _guide2, {
      writable: true,
      value: this.hot.rootDocument.createElement("DIV")
    });
    _classPrivateFieldInitSpec24(this, _pressed4, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec24(this, _isTriggeredByRMB2, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec24(this, _dblclick2, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec24(this, _autoresizeTimeout2, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec24(this, _rowHeightsMap, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec24(this, _config2, {
      writable: true,
      value: void 0
    });
    addClass(_classPrivateFieldGet24(this, _handle2), "manualRowResizer");
    addClass(_classPrivateFieldGet24(this, _guide2), "manualRowResizerGuide");
  }
  /**
   * @private
   * @returns {string}
   */
  get inlineDir() {
    return this.hot.isRtl() ? "right" : "left";
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link ManualRowResize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY24];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    _classPrivateFieldSet23(this, _rowHeightsMap, new PhysicalIndexToValueMap());
    _classPrivateFieldGet24(this, _rowHeightsMap).addLocalHook("init", () => _classPrivateMethodGet32(this, _onMapInit5, _onMapInit24).call(this));
    this.hot.rowIndexMapper.registerMap(this.pluginName, _classPrivateFieldGet24(this, _rowHeightsMap));
    this.addHook("modifyRowHeight", (height, row) => _classPrivateMethodGet32(this, _onModifyRowHeight3, _onModifyRowHeight22).call(this, height, row));
    this.bindEvents();
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`manualRowResize`](@/api/options.md#manualrowresize)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    _classPrivateFieldSet23(this, _config2, _classPrivateFieldGet24(this, _rowHeightsMap).getValues());
    this.hot.rowIndexMapper.unregisterMap(this.pluginName);
    super.disablePlugin();
  }
  /**
   * Saves the current sizes using the persistentState plugin (the {@link Options#persistentState} option has to be
   * enabled).
   *
   * @fires Hooks#persistentStateSave
   */
  saveManualRowHeights() {
    this.hot.runHooks("persistentStateSave", PERSISTENT_STATE_KEY2, _classPrivateFieldGet24(this, _rowHeightsMap).getValues());
  }
  /**
   * Loads the previously saved sizes using the persistentState plugin (the {@link Options#persistentState} option
   * has be enabled).
   *
   * @returns {Array}
   * @fires Hooks#persistentStateLoad
   */
  loadManualRowHeights() {
    const storedState = {};
    this.hot.runHooks("persistentStateLoad", PERSISTENT_STATE_KEY2, storedState);
    return storedState.value;
  }
  /**
   * Sets the new height for specified row index.
   *
   * @param {number} row Visual row index.
   * @param {number} height Row height.
   * @returns {number} Returns new height.
   */
  setManualSize(row, height) {
    const physicalRow = this.hot.toPhysicalRow(row);
    const newHeight = Math.max(height, viewportRows_default.DEFAULT_HEIGHT);
    _classPrivateFieldGet24(this, _rowHeightsMap).setValueAtIndex(physicalRow, newHeight);
    return newHeight;
  }
  /**
   * Sets the resize handle position.
   *
   * @private
   * @param {HTMLCellElement} TH TH HTML element.
   */
  setupHandlePosition(TH) {
    _classPrivateFieldSet23(this, _currentTH2, TH);
    const {
      view
    } = this.hot;
    const {
      _wt: wt
    } = view;
    const cellCoords = wt.wtTable.getCoords(_classPrivateFieldGet24(this, _currentTH2));
    const row = cellCoords.row;
    if (row < 0) {
      return;
    }
    const headerWidth = outerWidth(_classPrivateFieldGet24(this, _currentTH2));
    const box = _classPrivateFieldGet24(this, _currentTH2).getBoundingClientRect();
    const fixedRowTop = row < wt.getSetting("fixedRowsTop");
    const fixedRowBottom = row >= view.countNotHiddenRowIndexes(0, 1) - wt.getSetting("fixedRowsBottom");
    let relativeHeaderPosition;
    if (fixedRowTop) {
      relativeHeaderPosition = wt.wtOverlays.topInlineStartCornerOverlay.getRelativeCellPosition(_classPrivateFieldGet24(this, _currentTH2), cellCoords.row, cellCoords.col);
    } else if (fixedRowBottom) {
      relativeHeaderPosition = wt.wtOverlays.bottomInlineStartCornerOverlay.getRelativeCellPosition(_classPrivateFieldGet24(this, _currentTH2), cellCoords.row, cellCoords.col);
    }
    if (!relativeHeaderPosition) {
      relativeHeaderPosition = wt.wtOverlays.inlineStartOverlay.getRelativeCellPosition(_classPrivateFieldGet24(this, _currentTH2), cellCoords.row, cellCoords.col);
    }
    _classPrivateFieldSet23(this, _currentRow, this.hot.rowIndexMapper.getVisualFromRenderableIndex(row));
    _classPrivateFieldSet23(this, _selectedRows, []);
    const isFullRowSelected = this.hot.selection.isSelectedByCorner() || this.hot.selection.isSelectedByRowHeader();
    if (this.hot.selection.isSelected() && isFullRowSelected) {
      const selectionRanges = this.hot.getSelectedRange();
      arrayEach(selectionRanges, (selectionRange) => {
        const fromRow = selectionRange.getTopStartCorner().row;
        const toRow = selectionRange.getBottomStartCorner().row;
        rangeEach(fromRow, toRow, (rowIndex) => {
          if (!_classPrivateFieldGet24(this, _selectedRows).includes(rowIndex)) {
            _classPrivateFieldGet24(this, _selectedRows).push(rowIndex);
          }
        });
      });
    }
    if (!_classPrivateFieldGet24(this, _selectedRows).includes(_classPrivateFieldGet24(this, _currentRow))) {
      _classPrivateFieldSet23(this, _selectedRows, [_classPrivateFieldGet24(this, _currentRow)]);
    }
    _classPrivateFieldSet23(this, _startOffset2, relativeHeaderPosition.top - 6);
    _classPrivateFieldSet23(this, _startHeight, parseInt(box.height, 10));
    _classPrivateFieldGet24(this, _handle2).style.top = `${_classPrivateFieldGet24(this, _startOffset2) + _classPrivateFieldGet24(this, _startHeight)}px`;
    _classPrivateFieldGet24(this, _handle2).style[this.inlineDir] = `${relativeHeaderPosition.start}px`;
    _classPrivateFieldGet24(this, _handle2).style.width = `${headerWidth}px`;
    this.hot.rootElement.appendChild(_classPrivateFieldGet24(this, _handle2));
  }
  /**
   * Refresh the resize handle position.
   *
   * @private
   */
  refreshHandlePosition() {
    _classPrivateFieldGet24(this, _handle2).style.top = `${_classPrivateFieldGet24(this, _startOffset2) + _classPrivateFieldGet24(this, _currentHeight)}px`;
  }
  /**
   * Sets the resize guide position.
   *
   * @private
   */
  setupGuidePosition() {
    const handleWidth = parseInt(outerWidth(_classPrivateFieldGet24(this, _handle2)), 10);
    const handleEndPosition = parseInt(_classPrivateFieldGet24(this, _handle2).style[this.inlineDir], 10) + handleWidth;
    const maximumVisibleElementWidth = parseInt(this.hot.view.maximumVisibleElementWidth(0), 10);
    addClass(_classPrivateFieldGet24(this, _handle2), "active");
    addClass(_classPrivateFieldGet24(this, _guide2), "active");
    _classPrivateFieldGet24(this, _guide2).style.top = _classPrivateFieldGet24(this, _handle2).style.top;
    _classPrivateFieldGet24(this, _guide2).style[this.inlineDir] = `${handleEndPosition}px`;
    _classPrivateFieldGet24(this, _guide2).style.width = `${maximumVisibleElementWidth - handleWidth}px`;
    this.hot.rootElement.appendChild(_classPrivateFieldGet24(this, _guide2));
  }
  /**
   * Refresh the resize guide position.
   *
   * @private
   */
  refreshGuidePosition() {
    _classPrivateFieldGet24(this, _guide2).style.top = _classPrivateFieldGet24(this, _handle2).style.top;
  }
  /**
   * Hides both the resize handle and resize guide.
   *
   * @private
   */
  hideHandleAndGuide() {
    removeClass(_classPrivateFieldGet24(this, _handle2), "active");
    removeClass(_classPrivateFieldGet24(this, _guide2), "active");
  }
  /**
   * Checks if provided element is considered as a row header.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {boolean}
   */
  checkIfRowHeader(element) {
    var _element$parentNode;
    const thElement = closest(element, ["TH"], this.hot.rootElement);
    return thElement && ((_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 || (_element$parentNode = _element$parentNode.parentNode) === null || _element$parentNode === void 0 ? void 0 : _element$parentNode.tagName) === "TBODY";
  }
  /**
   * Gets the TH element from the provided element.
   *
   * @private
   * @param {HTMLElement} element HTML element.
   * @returns {HTMLElement}
   */
  getClosestTHParent(element) {
    if (element.tagName !== "TABLE") {
      if (element.tagName === "TH") {
        return element;
      }
      return this.getClosestTHParent(element.parentNode);
    }
    return null;
  }
  /**
   * Returns the actual height for the provided row index.
   *
   * @private
   * @param {number} row Visual row index.
   * @returns {number} Actual row height.
   */
  getActualRowHeight(row) {
    const walkontableHeight = this.hot.view._wt.wtTable.getRowHeight(row);
    if (walkontableHeight !== void 0 && _classPrivateFieldGet24(this, _newSize2) < walkontableHeight) {
      return walkontableHeight;
    }
    return _classPrivateFieldGet24(this, _newSize2);
  }
  /**
   * Auto-size row after doubleclick - callback.
   *
   * @private
   * @fires Hooks#beforeRowResize
   * @fires Hooks#afterRowResize
   */
  afterMouseDownTimeout() {
    const render = () => {
      this.hot.forceFullRender = true;
      this.hot.view.render();
      this.hot.view.adjustElementsSize(true);
    };
    const resize = (row, forceRender) => {
      const hookNewSize = this.hot.runHooks("beforeRowResize", this.getActualRowHeight(row), row, true);
      if (hookNewSize !== void 0) {
        _classPrivateFieldSet23(this, _newSize2, hookNewSize);
      }
      this.setManualSize(row, _classPrivateFieldGet24(this, _newSize2));
      this.hot.runHooks("afterRowResize", this.getActualRowHeight(row), row, true);
      if (forceRender) {
        render();
      }
    };
    if (_classPrivateFieldGet24(this, _dblclick2) >= 2) {
      const selectedRowsLength = _classPrivateFieldGet24(this, _selectedRows).length;
      if (selectedRowsLength > 1) {
        arrayEach(_classPrivateFieldGet24(this, _selectedRows), (selectedRow) => {
          resize(selectedRow);
        });
        render();
      } else {
        arrayEach(_classPrivateFieldGet24(this, _selectedRows), (selectedRow) => {
          resize(selectedRow, true);
        });
      }
    }
    _classPrivateFieldSet23(this, _dblclick2, 0);
    _classPrivateFieldSet23(this, _autoresizeTimeout2, null);
  }
  /**
   * Binds the mouse events.
   *
   * @private
   */
  bindEvents() {
    const {
      rootElement,
      rootWindow
    } = this.hot;
    this.eventManager.addEventListener(rootElement, "mouseover", (e) => _classPrivateMethodGet32(this, _onMouseOver4, _onMouseOver23).call(this, e));
    this.eventManager.addEventListener(rootElement, "mousedown", (e) => _classPrivateMethodGet32(this, _onMouseDown4, _onMouseDown23).call(this, e));
    this.eventManager.addEventListener(rootWindow, "mousemove", (e) => _classPrivateMethodGet32(this, _onMouseMove6, _onMouseMove25).call(this, e));
    this.eventManager.addEventListener(rootWindow, "mouseup", () => _classPrivateMethodGet32(this, _onMouseUp7, _onMouseUp26).call(this));
    this.eventManager.addEventListener(_classPrivateFieldGet24(this, _handle2), "contextmenu", () => _classPrivateMethodGet32(this, _onContextMenu3, _onContextMenu22).call(this));
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _onMouseOver23(event) {
  if (isDetached(event.target)) {
    return;
  }
  if (_classPrivateFieldGet24(this, _isTriggeredByRMB2) === true) {
    return;
  }
  if (this.checkIfRowHeader(event.target)) {
    const th = this.getClosestTHParent(event.target);
    if (th) {
      if (!_classPrivateFieldGet24(this, _pressed4)) {
        this.setupHandlePosition(th);
      }
    }
  }
}
function _onMouseDown23(event) {
  if (hasClass(event.target, "manualRowResizer")) {
    this.setupHandlePosition(_classPrivateFieldGet24(this, _currentTH2));
    this.setupGuidePosition();
    _classPrivateFieldSet23(this, _pressed4, true);
    if (_classPrivateFieldGet24(this, _autoresizeTimeout2) === null) {
      _classPrivateFieldSet23(this, _autoresizeTimeout2, setTimeout(() => this.afterMouseDownTimeout(), 500));
      this.hot._registerTimeout(_classPrivateFieldGet24(this, _autoresizeTimeout2));
    }
    _classPrivateFieldSet23(this, _dblclick2, _classPrivateFieldGet24(this, _dblclick2) + 1);
    _classPrivateFieldSet23(this, _startY2, event.pageY);
    _classPrivateFieldSet23(this, _newSize2, _classPrivateFieldGet24(this, _startHeight));
  }
}
function _onMouseMove25(event) {
  if (_classPrivateFieldGet24(this, _pressed4)) {
    _classPrivateFieldSet23(this, _currentHeight, _classPrivateFieldGet24(this, _startHeight) + (event.pageY - _classPrivateFieldGet24(this, _startY2)));
    arrayEach(_classPrivateFieldGet24(this, _selectedRows), (selectedRow) => {
      _classPrivateFieldSet23(this, _newSize2, this.setManualSize(selectedRow, _classPrivateFieldGet24(this, _currentHeight)));
    });
    this.refreshHandlePosition();
    this.refreshGuidePosition();
  }
}
function _onMouseUp26() {
  const render = () => {
    this.hot.forceFullRender = true;
    this.hot.view.render();
    this.hot.view.adjustElementsSize(true);
  };
  const runHooks = (row, forceRender) => {
    this.hot.runHooks("beforeRowResize", this.getActualRowHeight(row), row, false);
    if (forceRender) {
      render();
    }
    this.saveManualRowHeights();
    this.hot.runHooks("afterRowResize", this.getActualRowHeight(row), row, false);
  };
  if (_classPrivateFieldGet24(this, _pressed4)) {
    this.hideHandleAndGuide();
    _classPrivateFieldSet23(this, _pressed4, false);
    if (_classPrivateFieldGet24(this, _newSize2) !== _classPrivateFieldGet24(this, _startHeight)) {
      const selectedRowsLength = _classPrivateFieldGet24(this, _selectedRows).length;
      if (selectedRowsLength > 1) {
        arrayEach(_classPrivateFieldGet24(this, _selectedRows), (selectedRow) => {
          runHooks(selectedRow);
        });
        render();
      } else {
        arrayEach(_classPrivateFieldGet24(this, _selectedRows), (selectedRow) => {
          runHooks(selectedRow, true);
        });
      }
    }
    this.setupHandlePosition(_classPrivateFieldGet24(this, _currentTH2));
  }
}
function _onContextMenu22() {
  this.hideHandleAndGuide();
  this.hot.rootElement.removeChild(_classPrivateFieldGet24(this, _handle2));
  this.hot.rootElement.removeChild(_classPrivateFieldGet24(this, _guide2));
  _classPrivateFieldSet23(this, _pressed4, false);
  _classPrivateFieldSet23(this, _isTriggeredByRMB2, true);
  this.hot._registerImmediate(() => {
    _classPrivateFieldSet23(this, _isTriggeredByRMB2, false);
  });
}
function _onModifyRowHeight22(height, row) {
  let newHeight = height;
  if (this.enabled) {
    const physicalRow = this.hot.toPhysicalRow(row);
    const rowHeight = _classPrivateFieldGet24(this, _rowHeightsMap).getValueAtIndex(physicalRow);
    if (this.hot.getSettings()[PLUGIN_KEY24] && rowHeight) {
      newHeight = rowHeight;
    }
  }
  return newHeight;
}
function _onMapInit24() {
  const initialSetting = this.hot.getSettings()[PLUGIN_KEY24];
  const loadedManualRowHeights = this.loadManualRowHeights();
  this.hot.batchExecution(() => {
    if (typeof loadedManualRowHeights !== "undefined") {
      loadedManualRowHeights.forEach((height, index) => {
        _classPrivateFieldGet24(this, _rowHeightsMap).setValueAtIndex(index, height);
      });
    } else if (Array.isArray(initialSetting)) {
      initialSetting.forEach((height, index) => {
        _classPrivateFieldGet24(this, _rowHeightsMap).setValueAtIndex(index, height);
      });
      _classPrivateFieldSet23(this, _config2, initialSetting);
    } else if (initialSetting === true && Array.isArray(_classPrivateFieldGet24(this, _config2))) {
      _classPrivateFieldGet24(this, _config2).forEach((height, index) => {
        _classPrivateFieldGet24(this, _rowHeightsMap).setValueAtIndex(index, height);
      });
    }
  }, true);
}

// node_modules/handsontable/plugins/mergeCells/cellCoords.mjs
function _defineProperty40(obj, key, value) {
  key = _toPropertyKey40(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey40(arg) {
  var key = _toPrimitive40(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive40(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var MergedCellCoords = class {
  constructor(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {
    _defineProperty40(this, "row", void 0);
    _defineProperty40(this, "col", void 0);
    _defineProperty40(this, "rowspan", void 0);
    _defineProperty40(this, "colspan", void 0);
    _defineProperty40(this, "removed", false);
    _defineProperty40(this, "cellCoordsFactory", void 0);
    _defineProperty40(this, "cellRangeFactory", void 0);
    this.row = row;
    this.col = column;
    this.rowspan = rowspan;
    this.colspan = colspan;
    this.cellCoordsFactory = cellCoordsFactory;
    this.cellRangeFactory = cellRangeFactory;
  }
  /**
   * Get a warning message for when the declared merged cell data contains negative values.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static NEGATIVE_VALUES_WARNING(newMergedCell) {
    return toSingleLine`The merged cell declared with {row: ${newMergedCell.row}, col: ${newMergedCell.col},\x20
      rowspan: ${newMergedCell.rowspan}, colspan: ${newMergedCell.colspan}} contains negative values, which is\x20
      not supported. It will not be added to the collection.`;
  }
  /**
   * Get a warning message for when the declared merged cell data contains values exceeding the table limits.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {
    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] is positioned\x20
      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.`;
  }
  /**
   * Get a warning message for when the declared merged cell data represents a single cell.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static IS_SINGLE_CELL(newMergedCell) {
    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] has both "rowspan"\x20
      and "colspan" declared as "1", which makes it a single cell. It cannot be added to the collection.`;
  }
  /**
   * Get a warning message for when the declared merged cell data contains "colspan" or "rowspan", that equals 0.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static ZERO_SPAN_WARNING(newMergedCell) {
    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}] has "rowspan"\x20
      or "colspan" declared as "0", which is not supported. It cannot be added to the collection.`;
  }
  /**
   * Check whether the values provided for a merged cell contain any negative values.
   *
   * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.
   * @returns {boolean}
   */
  static containsNegativeValues(mergedCellInfo) {
    return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;
  }
  /**
   * Check whether the provided merged cell information object represents a single cell.
   *
   * @private
   * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.
   * @returns {boolean}
   */
  static isSingleCell(mergedCellInfo) {
    return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;
  }
  /**
   * Check whether the provided merged cell information object contains a rowspan or colspan of 0.
   *
   * @private
   * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.
   * @returns {boolean}
   */
  static containsZeroSpan(mergedCellInfo) {
    return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;
  }
  /**
   * Check whether the provided merged cell object is to be declared out of bounds of the table.
   *
   * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.
   * @param {number} rowCount Number of rows in the table.
   * @param {number} columnCount Number of rows in the table.
   * @returns {boolean}
   */
  static isOutOfBounds(mergeCell, rowCount, columnCount) {
    return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;
  }
  /**
   * Sanitize (prevent from going outside the boundaries) the merged cell.
   *
   * @param {Core} hotInstance The Handsontable instance.
   */
  normalize(hotInstance) {
    const totalRows = hotInstance.countRows();
    const totalColumns = hotInstance.countCols();
    if (this.row < 0) {
      this.row = 0;
    } else if (this.row > totalRows - 1) {
      this.row = totalRows - 1;
    }
    if (this.col < 0) {
      this.col = 0;
    } else if (this.col > totalColumns - 1) {
      this.col = totalColumns - 1;
    }
    if (this.row + this.rowspan > totalRows - 1) {
      this.rowspan = totalRows - this.row;
    }
    if (this.col + this.colspan > totalColumns - 1) {
      this.colspan = totalColumns - this.col;
    }
  }
  /**
   * Returns `true` if the provided coordinates are inside the merged cell.
   *
   * @param {number} row The row index.
   * @param {number} column The column index.
   * @returns {boolean}
   */
  includes(row, column) {
    return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;
  }
  /**
   * Returns `true` if the provided `column` property is within the column span of the merged cell.
   *
   * @param {number} column The column index.
   * @returns {boolean}
   */
  includesHorizontally(column) {
    return this.col <= column && this.col + this.colspan - 1 >= column;
  }
  /**
   * Returns `true` if the provided `row` property is within the row span of the merged cell.
   *
   * @param {number} row Row index.
   * @returns {boolean}
   */
  includesVertically(row) {
    return this.row <= row && this.row + this.rowspan - 1 >= row;
  }
  /**
   * Shift (and possibly resize, if needed) the merged cell.
   *
   * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.
   * @param {number} indexOfChange Index of the preceding change.
   * @returns {boolean} Returns `false` if the whole merged cell was removed.
   */
  shift(shiftVector, indexOfChange) {
    const shiftValue = shiftVector[0] || shiftVector[1];
    const shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;
    const span = shiftVector[0] ? "colspan" : "rowspan";
    const index = shiftVector[0] ? "col" : "row";
    const changeStart = Math.min(indexOfChange, shiftedIndex);
    const changeEnd = Math.max(indexOfChange, shiftedIndex);
    const mergeStart = this[index];
    const mergeEnd = this[index] + this[span] - 1;
    if (mergeStart >= indexOfChange) {
      this[index] += shiftValue;
    }
    if (shiftValue > 0) {
      if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {
        this[span] += shiftValue;
      }
    } else if (shiftValue < 0) {
      if (changeStart <= mergeStart && changeEnd >= mergeEnd) {
        this.removed = true;
        return false;
      } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {
        const removedOffset = changeEnd - mergeStart + 1;
        const preRemovedOffset = Math.abs(shiftValue) - removedOffset;
        this[index] -= preRemovedOffset + shiftValue;
        this[span] -= removedOffset;
      } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {
        this[span] += shiftValue;
      } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {
        const removedPart = mergeEnd - changeStart + 1;
        this[span] -= removedPart;
      }
    }
    return true;
  }
  /**
   * Check if the second provided merged cell is "farther" in the provided direction.
   *
   * @param {MergedCellCoords} mergedCell The merged cell to check.
   * @param {string} direction Drag direction.
   * @returns {boolean|null} `true` if the second provided merged cell is "farther".
   */
  isFarther(mergedCell, direction) {
    if (!mergedCell) {
      return true;
    }
    if (direction === "down") {
      return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;
    } else if (direction === "up") {
      return mergedCell.row > this.row;
    } else if (direction === "right") {
      return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;
    } else if (direction === "left") {
      return mergedCell.col > this.col;
    }
    return null;
  }
  /**
   * Get the bottom row index of the merged cell.
   *
   * @returns {number}
   */
  getLastRow() {
    return this.row + this.rowspan - 1;
  }
  /**
   * Get the rightmost column index of the merged cell.
   *
   * @returns {number}
   */
  getLastColumn() {
    return this.col + this.colspan - 1;
  }
  /**
   * Get the range coordinates of the merged cell.
   *
   * @returns {CellRange}
   */
  getRange() {
    return this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn()));
  }
};
var cellCoords_default = MergedCellCoords;

// node_modules/handsontable/plugins/mergeCells/utils.mjs
function applySpanProperties(TD, mergedCellInfo, row, col) {
  if (mergedCellInfo) {
    if (mergedCellInfo.row === row && mergedCellInfo.col === col) {
      TD.setAttribute("rowspan", mergedCellInfo.rowspan.toString());
      TD.setAttribute("colspan", mergedCellInfo.colspan.toString());
    } else {
      TD.removeAttribute("rowspan");
      TD.removeAttribute("colspan");
      TD.style.display = "none";
    }
  } else {
    TD.removeAttribute("rowspan");
    TD.removeAttribute("colspan");
    TD.style.display = "";
  }
}

// node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs
function _defineProperty41(obj, key, value) {
  key = _toPropertyKey41(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey41(arg) {
  var key = _toPrimitive41(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive41(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var MergedCellsCollection = class _MergedCellsCollection {
  constructor(mergeCellsPlugin) {
    _defineProperty41(this, "plugin", void 0);
    _defineProperty41(this, "mergedCells", []);
    _defineProperty41(this, "hot", void 0);
    this.plugin = mergeCellsPlugin;
    this.hot = mergeCellsPlugin.hot;
  }
  /**
   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.
   *
   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.
   * @returns {string}
   */
  static IS_OVERLAPPING_WARNING(newMergedCell) {
    return toSingleLine`The merged cell declared at [${newMergedCell.row}, ${newMergedCell.col}], overlaps\x20
      with the other declared merged cell. The overlapping merged cell was not added to the table, please\x20
      fix your setup.`;
  }
  /**
   * Get a merged cell from the container, based on the provided arguments. You can provide either the "starting coordinates"
   * of a merged cell, or any coordinates from the body of the merged cell.
   *
   * @param {number} row Row index.
   * @param {number} column Column index.
   * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.
   */
  get(row, column) {
    const mergedCells = this.mergedCells;
    let result = false;
    arrayEach(mergedCells, (mergedCell) => {
      if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {
        result = mergedCell;
        return false;
      }
      return true;
    });
    return result;
  }
  /**
   * Get a merged cell containing the provided range.
   *
   * @param {CellRange|object} range The range to search merged cells for.
   * @returns {MergedCellCoords|boolean}
   */
  getByRange(range) {
    const mergedCells = this.mergedCells;
    let result = false;
    arrayEach(mergedCells, (mergedCell) => {
      if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {
        result = mergedCell;
        return result;
      }
      return true;
    });
    return result;
  }
  /**
   * Get a merged cell contained in the provided range.
   *
   * @param {CellRange|object} range The range to search merged cells in.
   * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.
   * @returns {Array|boolean} Array of found merged cells of `false` if none were found.
   */
  getWithinRange(range) {
    let countPartials = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const mergedCells = this.mergedCells;
    const foundMergedCells = [];
    let testedRange = range;
    if (!testedRange.includesRange) {
      const from = this.hot._createCellCoords(testedRange.from.row, testedRange.from.col);
      const to = this.hot._createCellCoords(testedRange.to.row, testedRange.to.col);
      testedRange = this.hot._createCellRange(from, from, to);
    }
    arrayEach(mergedCells, (mergedCell) => {
      const mergedCellTopLeft = this.hot._createCellCoords(mergedCell.row, mergedCell.col);
      const mergedCellBottomRight = this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);
      const mergedCellRange = this.hot._createCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
      if (countPartials) {
        if (testedRange.overlaps(mergedCellRange)) {
          foundMergedCells.push(mergedCell);
        }
      } else if (testedRange.includesRange(mergedCellRange)) {
        foundMergedCells.push(mergedCell);
      }
    });
    return foundMergedCells.length ? foundMergedCells : false;
  }
  /**
   * Add a merged cell to the container.
   *
   * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.
   * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.
   */
  add(mergedCellInfo) {
    const mergedCells = this.mergedCells;
    const row = mergedCellInfo.row;
    const column = mergedCellInfo.col;
    const rowspan = mergedCellInfo.rowspan;
    const colspan = mergedCellInfo.colspan;
    const newMergedCell = new cellCoords_default(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);
    const alreadyExists = this.get(row, column);
    const isOverlapping = this.isOverlapping(newMergedCell);
    if (!alreadyExists && !isOverlapping) {
      if (this.hot) {
        newMergedCell.normalize(this.hot);
      }
      mergedCells.push(newMergedCell);
      return newMergedCell;
    }
    warn(_MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));
    return false;
  }
  /**
   * Remove a merged cell from the container. You can provide either the "starting coordinates"
   * of a merged cell, or any coordinates from the body of the merged cell.
   *
   * @param {number} row Row index.
   * @param {number} column Column index.
   * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.
   */
  remove(row, column) {
    const mergedCells = this.mergedCells;
    const wantedCollection = this.get(row, column);
    const wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;
    if (wantedCollection && wantedCollectionIndex !== -1) {
      mergedCells.splice(wantedCollectionIndex, 1);
      return wantedCollection;
    }
    return false;
  }
  /**
   * Clear all the merged cells.
   */
  clear() {
    const mergedCells = this.mergedCells;
    const mergedCellParentsToClear = [];
    const hiddenCollectionElements = [];
    arrayEach(mergedCells, (mergedCell) => {
      const TD = this.hot.getCell(mergedCell.row, mergedCell.col);
      if (TD) {
        mergedCellParentsToClear.push([TD, this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);
      }
    });
    this.mergedCells.length = 0;
    arrayEach(mergedCellParentsToClear, (mergedCell, i) => {
      rangeEach(0, mergedCell.rowspan - 1, (j) => {
        rangeEach(0, mergedCell.colspan - 1, (k) => {
          if (k !== 0 || j !== 0) {
            const TD = this.hot.getCell(mergedCell.row + j, mergedCell.col + k);
            if (TD) {
              hiddenCollectionElements.push([TD, null, null, null]);
            }
          }
        });
      });
      mergedCellParentsToClear[i][1] = null;
    });
    arrayEach(mergedCellParentsToClear, (mergedCellParents) => {
      applySpanProperties(...mergedCellParents);
    });
    arrayEach(hiddenCollectionElements, (hiddenCollectionElement) => {
      applySpanProperties(...hiddenCollectionElement);
    });
  }
  /**
   * Check if the provided merged cell overlaps with the others in the container.
   *
   * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.
   * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.
   */
  isOverlapping(mergedCell) {
    const mergedCellRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(mergedCell.row, mergedCell.col), this.hot._createCellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));
    let result = false;
    arrayEach(this.mergedCells, (col) => {
      const currentRange = this.hot._createCellRange(this.hot._createCellCoords(0, 0), this.hot._createCellCoords(col.row, col.col), this.hot._createCellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));
      if (currentRange.overlaps(mergedCellRange)) {
        result = true;
        return false;
      }
      return true;
    });
    return result;
  }
  /**
   * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {boolean}
   */
  isFirstRenderableMergedCell(row, column) {
    const mergeParent = this.get(row, column);
    return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;
  }
  /**
   * Get the first renderable coords of the merged cell at the provided coordinates.
   *
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the
   *                        merged cell.
   */
  getFirstRenderableCoords(row, column) {
    const mergeParent = this.get(row, column);
    if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {
      return this.hot._createCellCoords(row, column);
    }
    const firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);
    const firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);
    return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);
  }
  /**
   * Shift the merged cell in the direction and by an offset defined in the arguments.
   *
   * @param {string} direction `right`, `left`, `up` or `down`.
   * @param {number} index Index where the change, which caused the shifting took place.
   * @param {number} count Number of rows/columns added/removed in the preceding action.
   */
  shiftCollections(direction, index, count) {
    const shiftVector = [0, 0];
    switch (direction) {
      case "right":
        shiftVector[0] += count;
        break;
      case "left":
        shiftVector[0] -= count;
        break;
      case "down":
        shiftVector[1] += count;
        break;
      case "up":
        shiftVector[1] -= count;
        break;
      default:
    }
    arrayEach(this.mergedCells, (currentMerge) => {
      currentMerge.shift(shiftVector, index);
    });
    rangeEachReverse(this.mergedCells.length - 1, 0, (i) => {
      const currentMerge = this.mergedCells[i];
      if (currentMerge && currentMerge.removed) {
        this.mergedCells.splice(this.mergedCells.indexOf(currentMerge), 1);
      }
    });
  }
};
var cellsCollection_default = MergedCellsCollection;

// node_modules/handsontable/plugins/mergeCells/calculations/autofill.mjs
function _defineProperty42(obj, key, value) {
  key = _toPropertyKey42(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey42(arg) {
  var key = _toPrimitive42(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive42(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var AutofillCalculations = class {
  constructor(plugin) {
    _defineProperty42(this, "plugin", void 0);
    _defineProperty42(this, "mergedCellsCollection", void 0);
    _defineProperty42(this, "currentFillData", null);
    this.plugin = plugin;
    this.mergedCellsCollection = this.plugin.mergedCellsCollection;
  }
  /**
   * Correct the provided selection area, so it's not selecting only a part of a merged cell.
   *
   * @param {Array} selectionArea The selection to correct.
   */
  correctSelectionAreaSize(selectionArea) {
    if (selectionArea[0] === selectionArea[2] && selectionArea[1] === selectionArea[3]) {
      const mergedCell = this.mergedCellsCollection.get(selectionArea[0], selectionArea[1]);
      if (mergedCell) {
        selectionArea[2] = selectionArea[0] + mergedCell.rowspan - 1;
        selectionArea[3] = selectionArea[1] + mergedCell.colspan - 1;
      }
    }
  }
  /**
   * Get the direction of the autofill process.
   *
   * @param {Array} selectionArea The selection area.
   * @param {Array} finalArea The final area (base + drag).
   * @returns {string} `up`, `down`, `left` or `right`.
   */
  getDirection(selectionArea, finalArea) {
    let direction = null;
    if (finalArea[0] === selectionArea[0] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
      direction = "down";
    } else if (finalArea[2] === selectionArea[2] && finalArea[1] === selectionArea[1] && finalArea[3] === selectionArea[3]) {
      direction = "up";
    } else if (finalArea[1] === selectionArea[1] && finalArea[2] === selectionArea[2]) {
      direction = "right";
    } else {
      direction = "left";
    }
    return direction;
  }
  /**
   * Snap the drag area to the farthest merged cell, so it won't clip any of the merged cells.
   *
   * @param {Array} baseArea The base selected area.
   * @param {Array} dragArea The drag area.
   * @param {string} dragDirection The autofill drag direction.
   * @param {Array} foundMergedCells MergeCellCoords found in the base selection area.
   * @returns {Array} The new drag area.
   */
  snapDragArea(baseArea, dragArea, dragDirection, foundMergedCells) {
    const newDragArea = dragArea.slice(0);
    const fillSize = this.getAutofillSize(baseArea, dragArea, dragDirection);
    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;
    const verticalDirection = ["up", "down"].indexOf(dragDirection) > -1;
    const fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
    const fulls = Math.floor(fillSize / fullCycle) * fullCycle;
    const partials = fillSize - fulls;
    const farthestCollection = this.getFarthestCollection(baseArea, dragArea, dragDirection, foundMergedCells);
    if (farthestCollection) {
      if (dragDirection === "down") {
        const fill = farthestCollection.row + farthestCollection.rowspan - baseAreaStartRow - partials;
        const newLimit = newDragArea[2] + fill;
        if (newLimit >= this.plugin.hot.countRows()) {
          newDragArea[2] -= partials;
        } else {
          newDragArea[2] += partials ? fill : 0;
        }
      } else if (dragDirection === "right") {
        const fill = farthestCollection.col + farthestCollection.colspan - baseAreaStartColumn - partials;
        const newLimit = newDragArea[3] + fill;
        if (newLimit >= this.plugin.hot.countCols()) {
          newDragArea[3] -= partials;
        } else {
          newDragArea[3] += partials ? fill : 0;
        }
      } else if (dragDirection === "up") {
        const fill = baseAreaEndRow - partials - farthestCollection.row + 1;
        const newLimit = newDragArea[0] + fill;
        if (newLimit < 0) {
          newDragArea[0] += partials;
        } else {
          newDragArea[0] -= partials ? fill : 0;
        }
      } else if (dragDirection === "left") {
        const fill = baseAreaEndColumn - partials - farthestCollection.col + 1;
        const newLimit = newDragArea[1] + fill;
        if (newLimit < 0) {
          newDragArea[1] += partials;
        } else {
          newDragArea[1] -= partials ? fill : 0;
        }
      }
    }
    this.updateCurrentFillCache({
      baseArea,
      dragDirection,
      foundMergedCells,
      fillSize,
      dragArea: newDragArea,
      cycleLength: fullCycle
    });
    return newDragArea;
  }
  /**
   * Update the current fill cache with the provided object.
   *
   * @private
   * @param {object} updateObject The current filled object cache.
   */
  updateCurrentFillCache(updateObject) {
    if (!this.currentFillData) {
      this.currentFillData = {};
    }
    extend(this.currentFillData, updateObject);
  }
  /**
   * Get the "length" of the drag area.
   *
   * @private
   * @param {Array} baseArea The base selection area.
   * @param {Array} dragArea The drag area (containing the base area).
   * @param {string} direction The drag direction.
   * @returns {number|null} The "length" (height or width, depending on the direction) of the drag.
   */
  getAutofillSize(baseArea, dragArea, direction) {
    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;
    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;
    switch (direction) {
      case "up":
        return baseAreaStartRow - dragAreaStartRow;
      case "down":
        return dragAreaEndRow - baseAreaEndRow;
      case "left":
        return baseAreaStartColumn - dragAreaStartColumn;
      case "right":
        return dragAreaEndColumn - baseAreaEndColumn;
      default:
        return null;
    }
  }
  /**
   * Trim the default drag area (containing the selection area) to the drag-only area.
   *
   * @private
   * @param {Array} baseArea The base selection area.
   * @param {Array} dragArea The base selection area extended by the drag area.
   * @param {string} direction Drag direction.
   * @returns {Array|null} Array representing the drag area coordinates.
   */
  getDragArea(baseArea, dragArea, direction) {
    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;
    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;
    switch (direction) {
      case "up":
        return [dragAreaStartRow, dragAreaStartColumn, baseAreaStartRow - 1, baseAreaEndColumn];
      case "down":
        return [baseAreaEndRow + 1, baseAreaStartColumn, dragAreaEndRow, baseAreaEndColumn];
      case "left":
        return [dragAreaStartRow, dragAreaStartColumn, baseAreaEndRow, baseAreaStartColumn - 1];
      case "right":
        return [baseAreaStartRow, baseAreaEndColumn + 1, dragAreaEndRow, dragAreaEndColumn];
      default:
        return null;
    }
  }
  /**
   * Get the to-be-farthest merged cell in the newly filled area.
   *
   * @private
   * @param {Array} baseArea The base selection area.
   * @param {Array} dragArea The drag area (containing the base area).
   * @param {string} direction The drag direction.
   * @param {Array} mergedCellArray Array of the merged cells found in the base area.
   * @returns {MergedCellCoords|null}
   */
  getFarthestCollection(baseArea, dragArea, direction, mergedCellArray) {
    const [baseAreaStartRow, baseAreaStartColumn, baseAreaEndRow, baseAreaEndColumn] = baseArea;
    const verticalDirection = ["up", "down"].indexOf(direction) > -1;
    const baseEnd = verticalDirection ? baseAreaEndRow : baseAreaEndColumn;
    const baseStart = verticalDirection ? baseAreaStartRow : baseAreaStartColumn;
    const fillSize = this.getAutofillSize(baseArea, dragArea, direction);
    const fullCycle = verticalDirection ? baseAreaEndRow - baseAreaStartRow + 1 : baseAreaEndColumn - baseAreaStartColumn + 1;
    const fulls = Math.floor(fillSize / fullCycle) * fullCycle;
    const partials = fillSize - fulls;
    let inclusionFunctionName = null;
    let farthestCollection = null;
    let endOfDragRecreationIndex = null;
    switch (direction) {
      case "up":
        inclusionFunctionName = "includesVertically";
        endOfDragRecreationIndex = baseEnd - partials + 1;
        break;
      case "left":
        inclusionFunctionName = "includesHorizontally";
        endOfDragRecreationIndex = baseEnd - partials + 1;
        break;
      case "down":
        inclusionFunctionName = "includesVertically";
        endOfDragRecreationIndex = baseStart + partials - 1;
        break;
      case "right":
        inclusionFunctionName = "includesHorizontally";
        endOfDragRecreationIndex = baseStart + partials - 1;
        break;
      default:
    }
    arrayEach(mergedCellArray, (currentCollection) => {
      if (currentCollection[inclusionFunctionName](endOfDragRecreationIndex) && currentCollection.isFarther(farthestCollection, direction)) {
        farthestCollection = currentCollection;
      }
    });
    return farthestCollection;
  }
  /**
   * Recreate the merged cells after the autofill process.
   *
   * @param {Array} changes Changes made.
   */
  recreateAfterDataPopulation(changes) {
    if (!this.currentFillData) {
      return;
    }
    const fillRange = this.getRangeFromChanges(changes);
    const foundMergedCells = this.currentFillData.foundMergedCells;
    const dragDirection = this.currentFillData.dragDirection;
    const inBounds = (current2, offset2) => {
      switch (dragDirection) {
        case "up":
          return current2.row - offset2 >= fillRange.from.row;
        case "down":
          return current2.row + current2.rowspan - 1 + offset2 <= fillRange.to.row;
        case "left":
          return current2.col - offset2 >= fillRange.from.column;
        case "right":
          return current2.col + current2.colspan - 1 + offset2 <= fillRange.to.column;
        default:
          return null;
      }
    };
    let fillOffset = 0;
    let current = null;
    let multiplier = 1;
    do {
      for (let j = 0; j < foundMergedCells.length; j += 1) {
        current = foundMergedCells[j];
        fillOffset = multiplier * this.currentFillData.cycleLength;
        if (inBounds(current, fillOffset)) {
          switch (dragDirection) {
            case "up":
              this.plugin.mergedCellsCollection.add({
                row: current.row - fillOffset,
                rowspan: current.rowspan,
                col: current.col,
                colspan: current.colspan
              });
              break;
            case "down":
              this.plugin.mergedCellsCollection.add({
                row: current.row + fillOffset,
                rowspan: current.rowspan,
                col: current.col,
                colspan: current.colspan
              });
              break;
            case "left":
              this.plugin.mergedCellsCollection.add({
                row: current.row,
                rowspan: current.rowspan,
                col: current.col - fillOffset,
                colspan: current.colspan
              });
              break;
            case "right":
              this.plugin.mergedCellsCollection.add({
                row: current.row,
                rowspan: current.rowspan,
                col: current.col + fillOffset,
                colspan: current.colspan
              });
              break;
            default:
          }
        }
        if (j === foundMergedCells.length - 1) {
          multiplier += 1;
        }
      }
    } while (inBounds(current, fillOffset));
    this.currentFillData = null;
    this.plugin.hot.render();
    if (foundMergedCells.length > 0) {
      this.plugin.ifChromeForceRepaint();
    }
  }
  /**
   * Get the drag range from the changes made.
   *
   * @private
   * @param {Array} changes The changes made.
   * @returns {object} Object with `from` and `to` properties, both containing `row` and `column` keys.
   */
  getRangeFromChanges(changes) {
    const rows = {
      min: null,
      max: null
    };
    const columns = {
      min: null,
      max: null
    };
    arrayEach(changes, (change) => {
      const rowIndex = change[0];
      const columnIndex = this.plugin.hot.propToCol(change[1]);
      if (rows.min === null || rowIndex < rows.min) {
        rows.min = rowIndex;
      }
      if (rows.max === null || rowIndex > rows.max) {
        rows.max = rowIndex;
      }
      if (columns.min === null || columnIndex < columns.min) {
        columns.min = columnIndex;
      }
      if (columns.max === null || columnIndex > columns.max) {
        columns.max = columnIndex;
      }
    });
    return {
      from: {
        row: rows.min,
        column: columns.min
      },
      to: {
        row: rows.max,
        column: columns.max
      }
    };
  }
  /**
   * Check if the drag area contains any merged cells.
   *
   * @param {Array} baseArea The base selection area.
   * @param {Array} fullArea The base area extended by the drag area.
   * @param {string} direction Drag direction.
   * @returns {boolean}
   */
  dragAreaOverlapsCollections(baseArea, fullArea, direction) {
    const dragArea = this.getDragArea(baseArea, fullArea, direction);
    const [dragAreaStartRow, dragAreaStartColumn, dragAreaEndRow, dragAreaEndColumn] = dragArea;
    const topLeft = this.plugin.hot._createCellCoords(dragAreaStartRow, dragAreaStartColumn);
    const bottomRight = this.plugin.hot._createCellCoords(dragAreaEndRow, dragAreaEndColumn);
    const dragRange = this.plugin.hot._createCellRange(topLeft, topLeft, bottomRight);
    return !!this.mergedCellsCollection.getWithinRange(dragRange, true);
  }
};
var autofill_default = AutofillCalculations;

// node_modules/handsontable/plugins/mergeCells/calculations/selection.mjs
function _defineProperty43(obj, key, value) {
  key = _toPropertyKey43(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey43(arg) {
  var key = _toPrimitive43(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive43(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var SelectionCalculations = class {
  constructor(plugin) {
    _defineProperty43(this, "plugin", void 0);
    _defineProperty43(this, "hot", void 0);
    _defineProperty43(this, "fullySelectedMergedCellClassName", "fullySelectedMergedCell");
    this.plugin = plugin;
    this.hot = plugin.hot;
  }
  /**
   * "Snap" the delta value according to defined merged cells. (In other words, compensate the rowspan -
   * e.g. Going up with `delta.row = -1` over a merged cell with `rowspan = 3`, `delta.row` should change to `-3`.).
   *
   * @param {object} delta The delta object containing `row` and `col` properties.
   * @param {CellRange} selectionRange The selection range.
   * @param {object} mergedCell A merged cell object.
   */
  snapDelta(delta, selectionRange, mergedCell) {
    const cellCoords = selectionRange.to;
    const newRow = cellCoords.row + delta.row;
    const newColumn = cellCoords.col + delta.col;
    if (delta.row) {
      this.jumpOverMergedCell(delta, mergedCell, newRow);
    } else if (delta.col) {
      this.jumpOverMergedCell(delta, mergedCell, newColumn);
    }
  }
  /**
   * "Jump" over the merged cell (compensate for the indexes within the merged cell to get past it).
   *
   * @private
   * @param {object} delta The delta object.
   * @param {MergedCellCoords} mergedCell The merge cell object.
   * @param {number} newIndex New row/column index, created with the delta.
   */
  jumpOverMergedCell(delta, mergedCell, newIndex) {
    let flatDelta = delta.row || delta.col;
    let includesIndex = null;
    let firstIndex = null;
    let lastIndex = null;
    if (delta.row) {
      includesIndex = mergedCell.includesVertically(newIndex);
      firstIndex = mergedCell.row;
      lastIndex = mergedCell.getLastRow();
    } else if (delta.col) {
      includesIndex = mergedCell.includesHorizontally(newIndex);
      firstIndex = mergedCell.col;
      lastIndex = mergedCell.getLastColumn();
    }
    if (flatDelta === 0) {
      return;
    } else if (flatDelta > 0) {
      if (includesIndex && newIndex !== firstIndex) {
        flatDelta += lastIndex - newIndex + 1;
      }
    } else if (includesIndex && newIndex !== lastIndex) {
      flatDelta -= newIndex - firstIndex + 1;
    }
    if (delta.row) {
      delta.row = flatDelta;
    } else if (delta.col) {
      delta.col = flatDelta;
    }
  }
  /**
   * Get a selection range with `to` property incremented by the provided delta.
   *
   * @param {CellRange} oldSelectionRange The base selection range.
   * @param {object} delta The delta object with `row` and `col` properties.
   * @returns {CellRange} A new `CellRange` object.
   */
  getUpdatedSelectionRange(oldSelectionRange, delta) {
    return this.hot._createCellRange(oldSelectionRange.highlight, oldSelectionRange.from, this.hot._createCellCoords(oldSelectionRange.to.row + delta.row, oldSelectionRange.to.col + delta.col));
  }
  /**
   * Generate an additional class name for the entirely-selected merged cells.
   *
   * @param {number} currentRow Visual row index of the currently processed cell.
   * @param {number} currentColumn Visual column index of the currently cell.
   * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
   * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.
   * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.
   */
  getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel) {
    const startRow = Math.min(cornersOfSelection[0], cornersOfSelection[2]);
    const startColumn = Math.min(cornersOfSelection[1], cornersOfSelection[3]);
    const endRow = Math.max(cornersOfSelection[0], cornersOfSelection[2]);
    const endColumn = Math.max(cornersOfSelection[1], cornersOfSelection[3]);
    if (layerLevel === void 0) {
      return;
    }
    const isFirstRenderableMergedCell = this.plugin.mergedCellsCollection.isFirstRenderableMergedCell(currentRow, currentColumn);
    if (!isFirstRenderableMergedCell) {
      return;
    }
    const mergedCell = this.plugin.mergedCellsCollection.get(currentRow, currentColumn);
    if (!mergedCell) {
      return;
    }
    const mergeRowEnd = mergedCell.getLastRow();
    const mergeColumnEnd = mergedCell.getLastColumn();
    const fullMergeAreaWithinSelection = startRow <= mergedCell.row && startColumn <= mergedCell.col && endRow >= mergeRowEnd && endColumn >= mergeColumnEnd;
    if (fullMergeAreaWithinSelection) {
      return `${this.fullySelectedMergedCellClassName}-${layerLevel}`;
    } else if (this.plugin.selectionCalculations.isMergeCellFullySelected(mergedCell, this.plugin.hot.getSelectedRange())) {
      return `${this.fullySelectedMergedCellClassName}-multiple`;
    }
  }
  /**
   * Check if the provided merged cell is fully selected (by one or many layers of selection).
   *
   * @param {MergedCellCoords} mergedCell The merged cell to be processed.
   * @param {CellRange[]} selectionRangesArray Array of selection ranges.
   * @returns {boolean}
   */
  isMergeCellFullySelected(mergedCell, selectionRangesArray) {
    const mergedCellIndividualCoords = [];
    if (!selectionRangesArray || !mergedCell) {
      return false;
    }
    for (let r = 0; r < mergedCell.rowspan; r += 1) {
      for (let c = 0; c < mergedCell.colspan; c += 1) {
        mergedCellIndividualCoords.push(this.hot._createCellCoords(mergedCell.row + r, mergedCell.col + c));
      }
    }
    for (let i = 0; i < mergedCellIndividualCoords.length; i += 1) {
      const insideSelections = [];
      for (let s = 0; s < selectionRangesArray.length; s += 1) {
        insideSelections[s] = selectionRangesArray[s].includes(mergedCellIndividualCoords[i]);
      }
      if (!insideSelections.includes(true)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Generate an array of the entirely-selected merged cells' class names.
   *
   * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
   */
  getSelectedMergedCellClassNameToRemove() {
    const classNames = [];
    for (let i = 0; i <= 7; i += 1) {
      classNames.push(`${this.fullySelectedMergedCellClassName}-${i}`);
    }
    classNames.push(`${this.fullySelectedMergedCellClassName}-multiple`);
    return classNames;
  }
};
var selection_default = SelectionCalculations;

// node_modules/handsontable/plugins/mergeCells/contextMenuItem/toggleMerge.mjs
function toggleMergeItem(plugin) {
  return {
    key: "mergeCells",
    name() {
      const sel = this.getSelectedLast();
      if (sel) {
        const info = plugin.mergedCellsCollection.get(sel[0], sel[1]);
        if (info.row === sel[0] && info.col === sel[1] && info.row + info.rowspan - 1 === sel[2] && info.col + info.colspan - 1 === sel[3]) {
          return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_UNMERGE_CELLS);
        }
      }
      return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_MERGE_CELLS);
    },
    callback() {
      plugin.toggleMergeOnSelection();
    },
    disabled() {
      const sel = this.getSelectedLast();
      if (!sel) {
        return true;
      }
      const isSingleCell = cellCoords_default.isSingleCell({
        row: sel[0],
        col: sel[1],
        rowspan: sel[2] - sel[0] + 1,
        colspan: sel[3] - sel[1] + 1
      });
      return isSingleCell || this.selection.isSelectedByCorner();
    },
    hidden: false
  };
}

// node_modules/handsontable/plugins/mergeCells/mergeCells.mjs
function _classPrivateMethodInitSpec33(obj, privateSet) {
  _checkPrivateRedeclaration39(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec25(obj, privateMap, value) {
  _checkPrivateRedeclaration39(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration39(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty44(obj, key, value) {
  key = _toPropertyKey44(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey44(arg) {
  var key = _toPrimitive44(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive44(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldSet24(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor25(receiver, privateMap, "set");
  _classApplyDescriptorSet24(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet24(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet25(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor25(receiver, privateMap, "get");
  return _classApplyDescriptorGet25(receiver, descriptor);
}
function _classExtractFieldDescriptor25(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet25(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet33(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
pluginHooks_default.getSingleton().register("beforeMergeCells");
pluginHooks_default.getSingleton().register("afterMergeCells");
pluginHooks_default.getSingleton().register("beforeUnmergeCells");
pluginHooks_default.getSingleton().register("afterUnmergeCells");
var PLUGIN_KEY25 = "mergeCells";
var PLUGIN_PRIORITY24 = 150;
var SHORTCUTS_GROUP9 = PLUGIN_KEY25;
var _lastDesiredCoords = /* @__PURE__ */ new WeakMap();
var _onAfterInit5 = /* @__PURE__ */ new WeakSet();
var _onAfterIsMultipleSelection = /* @__PURE__ */ new WeakSet();
var _onModifyTransformStart = /* @__PURE__ */ new WeakSet();
var _onModifyTransformEnd = /* @__PURE__ */ new WeakSet();
var _onModifyGetCellCoords = /* @__PURE__ */ new WeakSet();
var _addMergeActionsToContextMenu = /* @__PURE__ */ new WeakSet();
var _onAfterRenderer3 = /* @__PURE__ */ new WeakSet();
var _onBeforeSetRangeStart = /* @__PURE__ */ new WeakSet();
var _onBeforeSetRangeEnd = /* @__PURE__ */ new WeakSet();
var _onAfterGetCellMeta4 = /* @__PURE__ */ new WeakSet();
var _onAfterViewportRowCalculatorOverride = /* @__PURE__ */ new WeakSet();
var _onAfterViewportColumnCalculatorOverride = /* @__PURE__ */ new WeakSet();
var _onModifyAutofillRange = /* @__PURE__ */ new WeakSet();
var _onAfterCreateCol3 = /* @__PURE__ */ new WeakSet();
var _onAfterRemoveCol3 = /* @__PURE__ */ new WeakSet();
var _onAfterCreateRow3 = /* @__PURE__ */ new WeakSet();
var _onAfterRemoveRow3 = /* @__PURE__ */ new WeakSet();
var _onAfterChange4 = /* @__PURE__ */ new WeakSet();
var _onBeforeDrawAreaBorders = /* @__PURE__ */ new WeakSet();
var _onAfterModifyTransformStart = /* @__PURE__ */ new WeakSet();
var _onAfterDrawSelection = /* @__PURE__ */ new WeakSet();
var _onBeforeRemoveCellClassNames = /* @__PURE__ */ new WeakSet();
var MergeCells = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec33(this, _onBeforeRemoveCellClassNames);
    _classPrivateMethodInitSpec33(this, _onAfterDrawSelection);
    _classPrivateMethodInitSpec33(this, _onAfterModifyTransformStart);
    _classPrivateMethodInitSpec33(this, _onBeforeDrawAreaBorders);
    _classPrivateMethodInitSpec33(this, _onAfterChange4);
    _classPrivateMethodInitSpec33(this, _onAfterRemoveRow3);
    _classPrivateMethodInitSpec33(this, _onAfterCreateRow3);
    _classPrivateMethodInitSpec33(this, _onAfterRemoveCol3);
    _classPrivateMethodInitSpec33(this, _onAfterCreateCol3);
    _classPrivateMethodInitSpec33(this, _onModifyAutofillRange);
    _classPrivateMethodInitSpec33(this, _onAfterViewportColumnCalculatorOverride);
    _classPrivateMethodInitSpec33(this, _onAfterViewportRowCalculatorOverride);
    _classPrivateMethodInitSpec33(this, _onAfterGetCellMeta4);
    _classPrivateMethodInitSpec33(this, _onBeforeSetRangeEnd);
    _classPrivateMethodInitSpec33(this, _onBeforeSetRangeStart);
    _classPrivateMethodInitSpec33(this, _onAfterRenderer3);
    _classPrivateMethodInitSpec33(this, _addMergeActionsToContextMenu);
    _classPrivateMethodInitSpec33(this, _onModifyGetCellCoords);
    _classPrivateMethodInitSpec33(this, _onModifyTransformEnd);
    _classPrivateMethodInitSpec33(this, _onModifyTransformStart);
    _classPrivateMethodInitSpec33(this, _onAfterIsMultipleSelection);
    _classPrivateMethodInitSpec33(this, _onAfterInit5);
    _defineProperty44(this, "mergedCellsCollection", null);
    _defineProperty44(this, "autofillCalculations", null);
    _defineProperty44(this, "selectionCalculations", null);
    _classPrivateFieldInitSpec25(this, _lastDesiredCoords, {
      writable: true,
      value: null
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY25;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY24;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link MergeCells#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY25];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.mergedCellsCollection = new cellsCollection_default(this);
    this.autofillCalculations = new autofill_default(this);
    this.selectionCalculations = new selection_default(this);
    this.addHook("afterInit", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet33(_this, _onAfterInit5, _onAfterInit24).call(_this, ...args);
    });
    this.addHook("modifyTransformStart", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet33(_this, _onModifyTransformStart, _onModifyTransformStart2).call(_this, ...args);
    });
    this.addHook("afterModifyTransformStart", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _classPrivateMethodGet33(_this, _onAfterModifyTransformStart, _onAfterModifyTransformStart2).call(_this, ...args);
    });
    this.addHook("modifyTransformEnd", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _classPrivateMethodGet33(_this, _onModifyTransformEnd, _onModifyTransformEnd2).call(_this, ...args);
    });
    this.addHook("modifyGetCellCoords", function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _classPrivateMethodGet33(_this, _onModifyGetCellCoords, _onModifyGetCellCoords2).call(_this, ...args);
    });
    this.addHook("beforeSetRangeStart", function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _classPrivateMethodGet33(_this, _onBeforeSetRangeStart, _onBeforeSetRangeStart2).call(_this, ...args);
    });
    this.addHook("beforeSetRangeStartOnly", function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _classPrivateMethodGet33(_this, _onBeforeSetRangeStart, _onBeforeSetRangeStart2).call(_this, ...args);
    });
    this.addHook("beforeSetRangeEnd", function() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return _classPrivateMethodGet33(_this, _onBeforeSetRangeEnd, _onBeforeSetRangeEnd2).call(_this, ...args);
    });
    this.addHook("afterIsMultipleSelection", function() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return _classPrivateMethodGet33(_this, _onAfterIsMultipleSelection, _onAfterIsMultipleSelection2).call(_this, ...args);
    });
    this.addHook("afterRenderer", function() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return _classPrivateMethodGet33(_this, _onAfterRenderer3, _onAfterRenderer22).call(_this, ...args);
    });
    this.addHook("afterContextMenuDefaultOptions", function() {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return _classPrivateMethodGet33(_this, _addMergeActionsToContextMenu, _addMergeActionsToContextMenu2).call(_this, ...args);
    });
    this.addHook("afterGetCellMeta", function() {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return _classPrivateMethodGet33(_this, _onAfterGetCellMeta4, _onAfterGetCellMeta23).call(_this, ...args);
    });
    this.addHook("afterViewportRowCalculatorOverride", function() {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return _classPrivateMethodGet33(_this, _onAfterViewportRowCalculatorOverride, _onAfterViewportRowCalculatorOverride2).call(_this, ...args);
    });
    this.addHook("afterViewportColumnCalculatorOverride", function() {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return _classPrivateMethodGet33(_this, _onAfterViewportColumnCalculatorOverride, _onAfterViewportColumnCalculatorOverride2).call(_this, ...args);
    });
    this.addHook("modifyAutofillRange", function() {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return _classPrivateMethodGet33(_this, _onModifyAutofillRange, _onModifyAutofillRange2).call(_this, ...args);
    });
    this.addHook("afterCreateCol", function() {
      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
        args[_key16] = arguments[_key16];
      }
      return _classPrivateMethodGet33(_this, _onAfterCreateCol3, _onAfterCreateCol22).call(_this, ...args);
    });
    this.addHook("afterRemoveCol", function() {
      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
        args[_key17] = arguments[_key17];
      }
      return _classPrivateMethodGet33(_this, _onAfterRemoveCol3, _onAfterRemoveCol22).call(_this, ...args);
    });
    this.addHook("afterCreateRow", function() {
      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        args[_key18] = arguments[_key18];
      }
      return _classPrivateMethodGet33(_this, _onAfterCreateRow3, _onAfterCreateRow22).call(_this, ...args);
    });
    this.addHook("afterRemoveRow", function() {
      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
        args[_key19] = arguments[_key19];
      }
      return _classPrivateMethodGet33(_this, _onAfterRemoveRow3, _onAfterRemoveRow22).call(_this, ...args);
    });
    this.addHook("afterChange", function() {
      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        args[_key20] = arguments[_key20];
      }
      return _classPrivateMethodGet33(_this, _onAfterChange4, _onAfterChange23).call(_this, ...args);
    });
    this.addHook("beforeDrawBorders", function() {
      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
        args[_key21] = arguments[_key21];
      }
      return _classPrivateMethodGet33(_this, _onBeforeDrawAreaBorders, _onBeforeDrawAreaBorders2).call(_this, ...args);
    });
    this.addHook("afterDrawSelection", function() {
      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        args[_key22] = arguments[_key22];
      }
      return _classPrivateMethodGet33(_this, _onAfterDrawSelection, _onAfterDrawSelection2).call(_this, ...args);
    });
    this.addHook("beforeRemoveCellClassNames", function() {
      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
        args[_key23] = arguments[_key23];
      }
      return _classPrivateMethodGet33(_this, _onBeforeRemoveCellClassNames, _onBeforeRemoveCellClassNames2).call(_this, ...args);
    });
    this.addHook("beforeUndoStackChange", (action, source) => {
      if (source === "MergeCells") {
        return false;
      }
    });
    this.registerShortcuts();
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.clearCollections();
    this.unregisterShortcuts();
    this.hot.render();
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the
   * following configuration options:
   *  - [`mergeCells`](@/api/options.md#mergecells)
   */
  updatePlugin() {
    const settings = this.hot.getSettings()[PLUGIN_KEY25];
    this.disablePlugin();
    this.enablePlugin();
    this.generateFromSettings(settings);
    super.updatePlugin();
  }
  /**
   * If the browser is recognized as Chrome, force an additional repaint to prevent showing the effects of a Chrome bug.
   *
   * Issue described in https://github.com/handsontable/dev-handsontable/issues/521.
   *
   * @private
   */
  ifChromeForceRepaint() {
    if (!isChrome()) {
      return;
    }
    const rowsToRefresh = [];
    let rowIndexesToRefresh = [];
    this.mergedCellsCollection.mergedCells.forEach((mergedCell) => {
      const {
        row,
        rowspan
      } = mergedCell;
      for (let r = row + 1; r < row + rowspan; r++) {
        rowIndexesToRefresh.push(r);
      }
    });
    rowIndexesToRefresh = [...new Set(rowIndexesToRefresh)];
    rowIndexesToRefresh.forEach((rowIndex) => {
      const renderableRowIndex = this.hot.rowIndexMapper.getRenderableFromVisualIndex(rowIndex);
      this.hot.view._wt.wtOverlays.getOverlays(true).map((overlay) => (overlay === null || overlay === void 0 ? void 0 : overlay.name) === "master" ? overlay : overlay.clone.wtTable).forEach((wtTableRef) => {
        const rowToRefresh = wtTableRef.getRow(renderableRowIndex);
        if (rowToRefresh) {
          rowToRefresh.style.background = getStyle(rowToRefresh, "backgroundColor").replace(")", ", 0.99)");
          rowsToRefresh.push(rowToRefresh);
        }
      });
    });
    this.hot._registerTimeout(() => {
      rowsToRefresh.forEach((rowElement) => {
        rowElement.style.background = getStyle(rowElement, "backgroundColor").replace(", 0.99)", ")");
      });
    }, 1);
  }
  /**
   * Validates a single setting object, represented by a single merged cell information object.
   *
   * @private
   * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.
   * @returns {boolean}
   */
  validateSetting(setting) {
    let valid = true;
    if (!setting) {
      return false;
    }
    if (cellCoords_default.containsNegativeValues(setting)) {
      warn(cellCoords_default.NEGATIVE_VALUES_WARNING(setting));
      valid = false;
    } else if (cellCoords_default.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {
      warn(cellCoords_default.IS_OUT_OF_BOUNDS_WARNING(setting));
      valid = false;
    } else if (cellCoords_default.isSingleCell(setting)) {
      warn(cellCoords_default.IS_SINGLE_CELL(setting));
      valid = false;
    } else if (cellCoords_default.containsZeroSpan(setting)) {
      warn(cellCoords_default.ZERO_SPAN_WARNING(setting));
      valid = false;
    }
    return valid;
  }
  /**
   * Generates the merged cells from the settings provided to the plugin.
   *
   * @private
   * @param {Array|boolean} settings The settings provided to the plugin.
   */
  generateFromSettings(settings) {
    if (Array.isArray(settings)) {
      const populatedNulls = [];
      arrayEach(settings, (setting) => {
        if (!this.validateSetting(setting)) {
          return;
        }
        const highlight = this.hot._createCellCoords(setting.row, setting.col);
        const rangeEnd = this.hot._createCellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);
        const mergeRange = this.hot._createCellRange(highlight, highlight, rangeEnd);
        this.mergeRange(mergeRange, true, true);
        rangeEach(setting.row, setting.row + setting.rowspan - 1, (rowIndex) => {
          rangeEach(setting.col, setting.col + setting.colspan - 1, (columnIndex) => {
            if ((rowIndex === setting.row && columnIndex === setting.col) === false) {
              populatedNulls.push([rowIndex, columnIndex, null]);
            }
          });
        });
      });
      if (populatedNulls.length === 0) {
        return;
      }
      this.hot.setDataAtCell(populatedNulls);
    }
  }
  /**
   * Clears the merged cells from the merged cell container.
   */
  clearCollections() {
    this.mergedCellsCollection.clear();
  }
  /**
   * Returns `true` if a range is mergeable.
   *
   * @private
   * @param {object} newMergedCellInfo Merged cell information object to test.
   * @param {boolean} [auto=false] `true` if triggered at initialization.
   * @returns {boolean}
   */
  canMergeRange(newMergedCellInfo) {
    let auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return auto ? true : this.validateSetting(newMergedCellInfo);
  }
  /**
   * Merge or unmerge, based on last selected range.
   *
   * @private
   */
  toggleMergeOnSelection() {
    const currentRange = this.hot.getSelectedRangeLast();
    if (!currentRange) {
      return;
    }
    currentRange.setDirection(this.hot.isRtl() ? "NE-SW" : "NW-SE");
    const {
      from,
      to
    } = currentRange;
    this.toggleMerge(currentRange);
    this.hot.selectCell(from.row, from.col, to.row, to.col, false);
  }
  /**
   * Merges the selection provided as a cell range.
   *
   * @param {CellRange} [cellRange] Selection cell range.
   */
  mergeSelection() {
    let cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
    if (!cellRange) {
      return;
    }
    cellRange.setDirection(this.hot.isRtl() ? "NE-SW" : "NW-SE");
    const {
      from,
      to
    } = cellRange;
    this.unmergeRange(cellRange, true);
    this.mergeRange(cellRange);
    this.hot.selectCell(from.row, from.col, to.row, to.col, false);
  }
  /**
   * Unmerges the selection provided as a cell range.
   *
   * @param {CellRange} [cellRange] Selection cell range.
   */
  unmergeSelection() {
    let cellRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.hot.getSelectedRangeLast();
    if (!cellRange) {
      return;
    }
    const {
      from,
      to
    } = cellRange;
    this.unmergeRange(cellRange, true);
    this.hot.selectCell(from.row, from.col, to.row, to.col, false);
  }
  /**
   * Merges cells in the provided cell range.
   *
   * @private
   * @param {CellRange} cellRange Cell range to merge.
   * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.
   * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end,
   *   but rather return its arguments.
   * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to
   *   true. If the the merging process went successful, it returns `true`, otherwise - `false`.
   * @fires Hooks#beforeMergeCells
   * @fires Hooks#afterMergeCells
   */
  mergeRange(cellRange) {
    let auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let preventPopulation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const topStart = cellRange.getTopStartCorner();
    const bottomEnd = cellRange.getBottomEndCorner();
    const mergeParent = {
      row: topStart.row,
      col: topStart.col,
      rowspan: bottomEnd.row - topStart.row + 1,
      colspan: bottomEnd.col - topStart.col + 1
    };
    const clearedData = [];
    let populationInfo = null;
    if (!this.canMergeRange(mergeParent, auto)) {
      return false;
    }
    this.hot.runHooks("beforeMergeCells", cellRange, auto);
    rangeEach(0, mergeParent.rowspan - 1, (i) => {
      rangeEach(0, mergeParent.colspan - 1, (j) => {
        let clearedValue = null;
        if (!clearedData[i]) {
          clearedData[i] = [];
        }
        if (i === 0 && j === 0) {
          clearedValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(mergeParent.row), this.hot.toPhysicalColumn(mergeParent.col));
        } else {
          this.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, "hidden", true);
        }
        clearedData[i][j] = clearedValue;
      });
    });
    this.hot.setCellMeta(mergeParent.row, mergeParent.col, "spanned", true);
    const mergedCellAdded = this.mergedCellsCollection.add(mergeParent);
    if (mergedCellAdded) {
      if (preventPopulation) {
        populationInfo = [mergeParent.row, mergeParent.col, clearedData];
      } else {
        this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);
      }
      if (!auto) {
        this.ifChromeForceRepaint();
      }
      this.hot.runHooks("afterMergeCells", cellRange, mergeParent, auto);
      return populationInfo;
    }
    return true;
  }
  /**
   * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.
   *
   * @private
   * @param {CellRange} cellRange Selection cell range.
   * @param {boolean} [auto=false] `true` if called automatically by the plugin.
   *
   * @fires Hooks#beforeUnmergeCells
   * @fires Hooks#afterUnmergeCells
   */
  unmergeRange(cellRange) {
    let auto = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);
    if (!mergedCells) {
      return;
    }
    this.hot.runHooks("beforeUnmergeCells", cellRange, auto);
    arrayEach(mergedCells, (currentCollection) => {
      this.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);
      rangeEach(0, currentCollection.rowspan - 1, (i) => {
        rangeEach(0, currentCollection.colspan - 1, (j) => {
          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, "hidden");
          this.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, "copyable");
        });
      });
      this.hot.removeCellMeta(currentCollection.row, currentCollection.col, "spanned");
    });
    this.hot.runHooks("afterUnmergeCells", cellRange, auto);
    this.hot.render();
  }
  /**
   * Merges or unmerges, based on the cell range provided as `cellRange`.
   *
   * @private
   * @param {CellRange} cellRange The cell range to merge or unmerged.
   */
  toggleMerge(cellRange) {
    const mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);
    const mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;
    if (mergedCellCoversWholeRange) {
      this.unmergeRange(cellRange);
    } else {
      this.mergeSelection(cellRange);
    }
  }
  /**
   * Merges the specified range.
   *
   * @param {number} startRow Start row of the merged cell.
   * @param {number} startColumn Start column of the merged cell.
   * @param {number} endRow End row of the merged cell.
   * @param {number} endColumn End column of the merged cell.
   * @fires Hooks#beforeMergeCells
   * @fires Hooks#afterMergeCells
   */
  merge(startRow, startColumn, endRow, endColumn) {
    const start = this.hot._createCellCoords(startRow, startColumn);
    const end = this.hot._createCellCoords(endRow, endColumn);
    this.mergeRange(this.hot._createCellRange(start, start, end));
  }
  /**
   * Unmerges the merged cell in the provided range.
   *
   * @param {number} startRow Start row of the merged cell.
   * @param {number} startColumn Start column of the merged cell.
   * @param {number} endRow End row of the merged cell.
   * @param {number} endColumn End column of the merged cell.
   * @fires Hooks#beforeUnmergeCells
   * @fires Hooks#afterUnmergeCells
   */
  unmerge(startRow, startColumn, endRow, endColumn) {
    const start = this.hot._createCellCoords(startRow, startColumn);
    const end = this.hot._createCellCoords(endRow, endColumn);
    this.unmergeRange(this.hot._createCellRange(start, start, end));
  }
  /**
   * Register shortcuts responsible for toggling a merge.
   *
   * @private
   */
  registerShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const gridContext = shortcutManager.getContext("grid");
    gridContext.addShortcut({
      keys: [["Control", "m"]],
      callback: () => {
        const range = this.hot.getSelectedRangeLast();
        if (range && !range.isSingleHeader()) {
          this.toggleMerge(range);
          this.hot.render();
        }
      },
      runOnlyIf: (event) => !event.altKey,
      // right ALT in some systems triggers ALT+CTRL
      group: SHORTCUTS_GROUP9
    });
  }
  /**
   * Unregister shortcuts responsible for toggling a merge.
   *
   * @private
   */
  unregisterShortcuts() {
    const shortcutManager = this.hot.getShortcutManager();
    const gridContext = shortcutManager.getContext("grid");
    gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP9);
  }
  /**
   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.
   *
   * @private
   * @param {object} calc The row calculator object.
   * @param {number} nrOfColumns Number of visual columns.
   */
  modifyViewportRowStart(calc, nrOfColumns) {
    const rowMapper = this.hot.rowIndexMapper;
    const visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);
    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {
      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);
      if (isObject(mergeParentForViewportStart)) {
        const renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.row, 1));
        if (renderableIndexAtMergeStart < calc.startRow) {
          calc.startRow = renderableIndexAtMergeStart;
          this.modifyViewportRowStart(calc, nrOfColumns);
          return;
        }
      }
    }
  }
  /**
   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.
   *
   * @private
   * @param {object} calc The row calculator object.
   * @param {number} nrOfColumns Number of visual columns.
   */
  modifyViewportRowEnd(calc, nrOfColumns) {
    const rowMapper = this.hot.rowIndexMapper;
    const visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);
    for (let visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {
      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);
      if (isObject(mergeParentForViewportEnd)) {
        const mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;
        const renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(mergeEnd, -1));
        if (renderableIndexAtMergeEnd > calc.endRow) {
          calc.endRow = renderableIndexAtMergeEnd;
          this.modifyViewportRowEnd(calc, nrOfColumns);
          return;
        }
      }
    }
  }
  /**
   * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.
   *
   * @private
   * @param {object} calc The column calculator object.
   * @param {number} nrOfRows Number of visual rows.
   */
  modifyViewportColumnStart(calc, nrOfRows) {
    const columnMapper = this.hot.columnIndexMapper;
    const visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);
    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {
      const mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);
      if (isObject(mergeParentForViewportStart)) {
        const renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeParentForViewportStart.col, 1));
        if (renderableIndexAtMergeStart < calc.startColumn) {
          calc.startColumn = renderableIndexAtMergeStart;
          this.modifyViewportColumnStart(calc, nrOfRows);
          return;
        }
      }
    }
  }
  /**
   *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.
   *
   * @private
   * @param {object} calc The column calculator object.
   * @param {number} nrOfRows Number of visual rows.
   */
  modifyViewportColumnEnd(calc, nrOfRows) {
    const columnMapper = this.hot.columnIndexMapper;
    const visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);
    for (let visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {
      const mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);
      if (isObject(mergeParentForViewportEnd)) {
        const mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;
        const renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(mergeEnd, -1));
        if (renderableIndexAtMergeEnd > calc.endColumn) {
          calc.endColumn = renderableIndexAtMergeEnd;
          this.modifyViewportColumnEnd(calc, nrOfRows);
          return;
        }
      }
    }
  }
  /**
   * Translates merged cell coordinates to renderable indexes.
   *
   * @private
   * @param {number} parentRow Visual row index.
   * @param {number} rowspan Rowspan which describes shift which will be applied to parent row
   *                         to calculate renderable index which points to the most bottom
   *                         index position. Pass rowspan as `0` to calculate the most top
   *                         index position.
   * @param {number} parentColumn Visual column index.
   * @param {number} colspan Colspan which describes shift which will be applied to parent column
   *                         to calculate renderable index which points to the most right
   *                         index position. Pass colspan as `0` to calculate the most left
   *                         index position.
   * @returns {number[]}
   */
  translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {
    const {
      rowIndexMapper: rowMapper,
      columnIndexMapper: columnMapper
    } = this.hot;
    let firstNonHiddenRow;
    let firstNonHiddenColumn;
    if (rowspan === 0) {
      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow, 1);
    } else {
      firstNonHiddenRow = rowMapper.getNearestNotHiddenIndex(parentRow + rowspan - 1, -1);
    }
    if (colspan === 0) {
      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn, 1);
    } else {
      firstNonHiddenColumn = columnMapper.getNearestNotHiddenIndex(parentColumn + colspan - 1, -1);
    }
    const renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;
    const renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;
    return [renderableRow, renderableColumn];
  }
};
function _onAfterInit24() {
  this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY25]);
  this.hot.render();
}
function _onAfterIsMultipleSelection2(isMultiple) {
  if (isMultiple) {
    const mergedCells = this.mergedCellsCollection.mergedCells;
    const selectionRange = this.hot.getSelectedRangeLast();
    for (let group = 0; group < mergedCells.length; group += 1) {
      if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {
        return false;
      }
    }
  }
  return isMultiple;
}
function _onModifyTransformStart2(delta) {
  const currentlySelectedRange = this.hot.getSelectedRangeLast();
  let newDelta = {
    row: delta.row,
    col: delta.col
  };
  let nextPosition = null;
  const currentPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);
  const mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);
  if (!_classPrivateFieldGet25(this, _lastDesiredCoords)) {
    _classPrivateFieldSet24(this, _lastDesiredCoords, this.hot._createCellCoords(null, null));
  }
  if (mergedParent) {
    const mergeTopLeft = this.hot._createCellCoords(mergedParent.row, mergedParent.col);
    const mergeBottomRight = this.hot._createCellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);
    const mergeRange = this.hot._createCellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);
    if (!mergeRange.includes(_classPrivateFieldGet25(this, _lastDesiredCoords))) {
      _classPrivateFieldSet24(this, _lastDesiredCoords, this.hot._createCellCoords(null, null));
    }
    newDelta.row = _classPrivateFieldGet25(this, _lastDesiredCoords).row ? _classPrivateFieldGet25(this, _lastDesiredCoords).row - currentPosition.row : newDelta.row;
    newDelta.col = _classPrivateFieldGet25(this, _lastDesiredCoords).col ? _classPrivateFieldGet25(this, _lastDesiredCoords).col - currentPosition.col : newDelta.col;
    if (delta.row > 0) {
      newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;
    } else if (delta.row < 0) {
      newDelta.row = currentPosition.row - mergedParent.row + delta.row;
    }
    if (delta.col > 0) {
      newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;
    } else if (delta.col < 0) {
      newDelta.col = currentPosition.col - mergedParent.col + delta.col;
    }
  }
  nextPosition = this.hot._createCellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);
  const nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);
  if (nextPositionMergedCell) {
    const firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);
    _classPrivateFieldSet24(this, _lastDesiredCoords, nextPosition);
    newDelta = {
      row: firstRenderableCoords.row - currentPosition.row,
      col: firstRenderableCoords.col - currentPosition.col
    };
  }
  if (newDelta.row !== 0) {
    delta.row = newDelta.row;
  }
  if (newDelta.col !== 0) {
    delta.col = newDelta.col;
  }
}
function _onModifyTransformEnd2(delta) {
  const currentSelectionRange = this.hot.getSelectedRangeLast();
  const newDelta = clone(delta);
  const newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);
  let tempDelta = clone(newDelta);
  const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);
  do {
    tempDelta = clone(newDelta);
    this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);
    arrayEach(mergedCellsWithinRange, (mergedCell) => {
      this.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);
    });
  } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);
  delta.row = newDelta.row;
  delta.col = newDelta.col;
}
function _onModifyGetCellCoords2(row, column) {
  if (row < 0 || column < 0) {
    return;
  }
  const mergeParent = this.mergedCellsCollection.get(row, column);
  if (!mergeParent) {
    return;
  }
  const {
    row: mergeRow,
    col: mergeColumn,
    colspan,
    rowspan
  } = mergeParent;
  return [
    // Most top-left merged cell coords.
    mergeRow,
    mergeColumn,
    // Most bottom-right merged cell coords.
    mergeRow + rowspan - 1,
    mergeColumn + colspan - 1
  ];
}
function _addMergeActionsToContextMenu2(defaultOptions) {
  defaultOptions.items.push({
    name: "---------"
  }, toggleMergeItem(this));
}
function _onAfterRenderer22(TD, row, col) {
  const mergedCell = this.mergedCellsCollection.get(row, col);
  const mergedCellCopy = isObject(mergedCell) ? clone(mergedCell) : void 0;
  if (isObject(mergedCellCopy)) {
    const {
      rowIndexMapper: rowMapper,
      columnIndexMapper: columnMapper
    } = this.hot;
    const {
      row: mergeRow,
      col: mergeColumn,
      colspan,
      rowspan
    } = mergedCellCopy;
    const [lastMergedRowIndex, lastMergedColumnIndex] = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan);
    const renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);
    const renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);
    const maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1;
    const maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1;
    mergedCellCopy.row = rowMapper.getNearestNotHiddenIndex(mergedCellCopy.row, 1);
    mergedCellCopy.col = columnMapper.getNearestNotHiddenIndex(mergedCellCopy.col, 1);
    mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan);
    mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);
  }
  applySpanProperties(TD, mergedCellCopy, row, col);
}
function _onBeforeSetRangeStart2(coords) {
  if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {
    const mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);
    [coords.row, coords.col] = [mergeParent.row, mergeParent.col];
  }
}
function _onBeforeSetRangeEnd2(coords) {
  const selRange = this.hot.getSelectedRangeLast();
  selRange.highlight = this.hot._createCellCoords(selRange.highlight.row, selRange.highlight.col);
  selRange.to = coords;
  let rangeExpanded = false;
  if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {
    return;
  }
  do {
    rangeExpanded = false;
    for (let i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {
      const cellInfo = this.mergedCellsCollection.mergedCells[i];
      const mergedCellRange = cellInfo.getRange();
      if (selRange.expandByRange(mergedCellRange)) {
        coords.row = selRange.to.row;
        coords.col = selRange.to.col;
        rangeExpanded = true;
      }
    }
  } while (rangeExpanded);
}
function _onAfterGetCellMeta23(row, col, cellProperties) {
  const mergeParent = this.mergedCellsCollection.get(row, col);
  if (mergeParent) {
    if (mergeParent.row !== row || mergeParent.col !== col) {
      cellProperties.copyable = false;
    } else {
      cellProperties.rowspan = mergeParent.rowspan;
      cellProperties.colspan = mergeParent.colspan;
    }
  }
}
function _onAfterViewportRowCalculatorOverride2(calc) {
  const nrOfColumns = this.hot.countCols();
  this.modifyViewportRowStart(calc, nrOfColumns);
  this.modifyViewportRowEnd(calc, nrOfColumns);
}
function _onAfterViewportColumnCalculatorOverride2(calc) {
  const nrOfRows = this.hot.countRows();
  this.modifyViewportColumnStart(calc, nrOfRows);
  this.modifyViewportColumnEnd(calc, nrOfRows);
}
function _onModifyAutofillRange2(drag, select) {
  this.autofillCalculations.correctSelectionAreaSize(select);
  const dragDirection = this.autofillCalculations.getDirection(select, drag);
  let dragArea = drag;
  if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {
    dragArea = select;
    return dragArea;
  }
  const mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({
    from: {
      row: select[0],
      col: select[1]
    },
    to: {
      row: select[2],
      col: select[3]
    }
  });
  if (!mergedCellsWithinSelectionArea) {
    return dragArea;
  }
  dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);
  return dragArea;
}
function _onAfterCreateCol22(column, count) {
  this.mergedCellsCollection.shiftCollections("right", column, count);
}
function _onAfterRemoveCol22(column, count) {
  this.mergedCellsCollection.shiftCollections("left", column, count);
}
function _onAfterCreateRow22(row, count, source) {
  if (source === "auto") {
    return;
  }
  this.mergedCellsCollection.shiftCollections("down", row, count);
}
function _onAfterRemoveRow22(row, count) {
  this.mergedCellsCollection.shiftCollections("up", row, count);
}
function _onAfterChange23(changes, source) {
  if (source !== "Autofill.fill") {
    return;
  }
  this.autofillCalculations.recreateAfterDataPopulation(changes);
}
function _onBeforeDrawAreaBorders2(corners, className) {
  if (className && className === "area") {
    const selectedRange = this.hot.getSelectedRangeLast();
    const mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);
    arrayEach(mergedCellsWithinRange, (mergedCell) => {
      if (selectedRange.getBottomEndCorner().row === mergedCell.getLastRow() && selectedRange.getBottomEndCorner().col === mergedCell.getLastColumn()) {
        corners[2] = mergedCell.row;
        corners[3] = mergedCell.col;
      }
    });
  }
}
function _onAfterModifyTransformStart2(coords, rowTransformDir, colTransformDir) {
  if (!this.enabled) {
    return;
  }
  const mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);
  if (!mergedCellAtCoords) {
    return;
  }
  const goingDown = rowTransformDir > 0;
  const goingUp = rowTransformDir < 0;
  const goingLeft = colTransformDir < 0;
  const goingRight = colTransformDir > 0;
  const mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;
  const mergedCellOnTopEdge = mergedCellAtCoords.row === 0;
  const mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;
  const mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;
  if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {
    coords.row = mergedCellAtCoords.row;
    coords.col = mergedCellAtCoords.col;
  }
}
function _onAfterDrawSelection2(currentRow, currentColumn, cornersOfSelection, layerLevel) {
  if (!cornersOfSelection) {
    return;
  }
  return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);
}
function _onBeforeRemoveCellClassNames2() {
  return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();
}

// node_modules/handsontable/plugins/multiColumnSorting/rootComparator.mjs
function rootComparator2(sortingOrders, columnMetas) {
  return function(rowIndexWithValues, nextRowIndexWithValues) {
    const [, ...values] = rowIndexWithValues;
    const [, ...nextValues] = nextRowIndexWithValues;
    return function getCompareResult(column) {
      const sortingOrder = sortingOrders[column];
      const columnMeta = columnMetas[column];
      const value = values[column];
      const nextValue = nextValues[column];
      const pluginSettings = columnMeta.multiColumnSorting;
      const compareFunctionFactory5 = pluginSettings.compareFunctionFactory ? pluginSettings.compareFunctionFactory : getCompareFunctionFactory(columnMeta.type);
      const compareResult = compareFunctionFactory5(sortingOrder, columnMeta, pluginSettings)(value, nextValue);
      if (compareResult === DO_NOT_SWAP) {
        const nextSortedColumn = column + 1;
        if (typeof columnMetas[nextSortedColumn] !== "undefined") {
          return getCompareResult(nextSortedColumn);
        }
      }
      return compareResult;
    }(0);
  };
}

// node_modules/handsontable/plugins/multiColumnSorting/utils.mjs
function warnAboutPluginsConflict() {
  warn(toSingleLine`Plugins \`columnSorting\` and \`multiColumnSorting\` should not be enabled simultaneously. 
    Only \`multiColumnSorting\` will work.`);
}

// node_modules/handsontable/plugins/multiColumnSorting/domHelpers.mjs
var COLUMN_ORDER_PREFIX = "sort";
function getClassesToAdd2(columnStatesManager, column, showSortIndicator) {
  const cssClasses = [];
  if (showSortIndicator === false) {
    return cssClasses;
  }
  if (columnStatesManager.isColumnSorted(column) && columnStatesManager.getNumberOfSortedColumns() > 1) {
    cssClasses.push(`${COLUMN_ORDER_PREFIX}-${columnStatesManager.getIndexOfColumnInSortQueue(column) + 1}`);
  }
  return cssClasses;
}
function getClassesToRemove2(htmlElement) {
  const cssClasses = htmlElement.className.split(" ");
  const sortSequenceRegExp = new RegExp(`^${COLUMN_ORDER_PREFIX}-[0-9]{1,2}$`);
  return cssClasses.filter((cssClass) => sortSequenceRegExp.test(cssClass));
}

// node_modules/handsontable/plugins/multiColumnSorting/multiColumnSorting.mjs
function _defineProperty45(obj, key, value) {
  key = _toPropertyKey45(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey45(arg) {
  var key = _toPrimitive45(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive45(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var PLUGIN_KEY26 = "multiColumnSorting";
var PLUGIN_PRIORITY25 = 170;
var CONFLICTED_PLUGIN_KEY = "columnSorting";
var SHORTCUTS_GROUP10 = PLUGIN_KEY26;
registerRootComparator(PLUGIN_KEY26, rootComparator2);
var MultiColumnSorting = class extends ColumnSorting {
  constructor() {
    super(...arguments);
    _defineProperty45(this, "pluginKey", PLUGIN_KEY26);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY26;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY25;
  }
  /**
   * Checks if the plugin is enabled in the Handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link MultiColumnSorting#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return super.isEnabled();
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (!this.enabled && this.hot.getSettings()[this.pluginKey] && this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {
      warnAboutPluginsConflict();
    }
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
  }
  /**
   * Register shortcuts responsible for toggling column sorting functionality.
   *
   * @private
   */
  registerShortcuts() {
    super.registerShortcuts();
    this.hot.getShortcutManager().getContext("grid").addShortcut({
      keys: [["Shift", "Enter"]],
      callback: () => {
        const {
          highlight
        } = this.hot.getSelectedRangeLast();
        if (highlight.row === -1 && highlight.col >= 0) {
          this.sort(this.getNextSortConfig(highlight.col, APPEND_COLUMN_CONFIG_STRATEGY));
        }
      },
      runOnlyIf: () => {
        var _this$hot$getSelected;
        const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
        return highlight && this.hot.selection.isCellVisible(highlight) && highlight.isHeader();
      },
      group: SHORTCUTS_GROUP10
    });
  }
  /**
   * Unregister shortcuts responsible for toggling column sorting functionality.
   *
   * @private
   */
  unregisterShortcuts() {
    super.unregisterShortcuts();
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP10);
  }
  /**
   * Sorts the table by chosen columns and orders.
   *
   * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   *
   * **Note**: Please keep in mind that every call of `sort` function set an entirely new sort order. Previous sort configs aren't preserved.
   *
   * @example
   * ```js
   * // sort ascending first visual column
   * hot.getPlugin('multiColumnSorting').sort({ column: 0, sortOrder: 'asc' });
   *
   * // sort first two visual column in the defined sequence
   * hot.getPlugin('multiColumnSorting').sort([{
   *   column: 1, sortOrder: 'asc'
   * }, {
   *   column: 0, sortOrder: 'desc'
   * }]);
   * ```
   *
   * @fires Hooks#beforeColumnSort
   * @fires Hooks#afterColumnSort
   */
  sort(sortConfig) {
    super.sort(sortConfig);
  }
  /**
   * Clear the sort performed on the table.
   */
  clearSort() {
    super.clearSort();
  }
  /**
   * Checks if the table is sorted (any column have to be sorted).
   *
   * @returns {boolean}
   */
  isSorted() {
    return super.isSorted();
  }
  /**
   * Get sort configuration for particular column or for all sorted columns. Objects contain `column` and `sortOrder` properties.
   *
   * **Note**: Please keep in mind that returned objects expose **visual** column index under the `column` key. They are handled by the `sort` function.
   *
   * @param {number} [column] Visual column index.
   * @returns {undefined|object|Array}
   */
  getSortConfig(column) {
    return super.getSortConfig(column);
  }
  /**
   * @description
   * Warn: Useful mainly for providing server side sort implementation (see in the example below). It doesn't sort the data set. It just sets sort configuration for all sorted columns.
   * Note: Please keep in mind that this method doesn't re-render the table.
   *
   * @example
   * ```js
   * beforeColumnSort: function(currentSortConfig, destinationSortConfigs) {
   *   const columnSortPlugin = this.getPlugin('multiColumnSorting');
   *
   *   columnSortPlugin.setSortConfig(destinationSortConfigs);
   *
   *   // const newData = ... // Calculated data set, ie. from an AJAX call.
   *
   *   this.loadData(newData); // Load new data set and re-render the table.
   *
   *   return false; // The blockade for the default sort action.
   * }
   * ```
   *
   * @param {undefined|object|Array} sortConfig Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   */
  setSortConfig(sortConfig) {
    super.setSortConfig(sortConfig);
  }
  /**
   * Get normalized sort configs.
   *
   * @private
   * @param {object|Array} [sortConfig=[]] Single column sort configuration or full sort configuration (for all sorted columns).
   * The configuration object contains `column` and `sortOrder` properties. First of them contains visual column index, the second one contains
   * sort order (`asc` for ascending, `desc` for descending).
   * @returns {Array}
   */
  getNormalizedSortConfigs() {
    let sortConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (Array.isArray(sortConfig)) {
      return sortConfig;
    }
    return [sortConfig];
  }
  /**
   * Update header classes.
   *
   * @private
   * @param {HTMLElement} headerSpanElement Header span element.
   * @param {...*} args Extra arguments for helpers.
   */
  updateHeaderClasses(headerSpanElement) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    super.updateHeaderClasses(headerSpanElement, ...args);
    removeClass(headerSpanElement, getClassesToRemove2(headerSpanElement));
    if (this.enabled !== false) {
      addClass(headerSpanElement, getClassesToAdd2(...args));
    }
  }
  /**
   * Overwriting base plugin's `onUpdateSettings` method. Please keep in mind that `onAfterUpdateSettings` isn't called
   * for `updateSettings` in specific situations.
   *
   * @private
   * @param {object} newSettings New settings object.
   */
  onUpdateSettings(newSettings) {
    if (this.hot.getSettings()[this.pluginKey] && this.hot.getSettings()[CONFLICTED_PLUGIN_KEY]) {
      warnAboutPluginsConflict();
    }
    super.onUpdateSettings(newSettings);
  }
  /**
   * Callback for the `onAfterOnCellMouseDown` hook.
   *
   * @private
   * @param {Event} event Event which are provided by hook.
   * @param {CellCoords} coords Visual coords of the selected cell.
   */
  onAfterOnCellMouseDown(event, coords) {
    if (wasHeaderClickedProperly(coords.row, coords.col, event) === false) {
      return;
    }
    if (this.wasClickableHeaderClicked(event, coords.col)) {
      if (this.hot.getShortcutManager().isCtrlPressed()) {
        this.hot.deselectCell();
        this.hot.selectColumns(coords.col);
        this.sort(this.getNextSortConfig(coords.col, APPEND_COLUMN_CONFIG_STRATEGY));
      } else {
        this.sort(this.getColumnNextConfig(coords.col));
      }
    }
  }
};

// node_modules/handsontable/plugins/multipleSelectionHandles/multipleSelectionHandles.mjs
function _defineProperty46(obj, key, value) {
  key = _toPropertyKey46(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey46(arg) {
  var key = _toPrimitive46(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive46(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var PLUGIN_KEY27 = "multipleSelectionHandles";
var PLUGIN_PRIORITY26 = 160;
var MultipleSelectionHandles = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _defineProperty46(this, "dragged", []);
    _defineProperty46(this, "lastSetCell", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY27;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY26;
  }
  /**
   * Check if the plugin is enabled in the handsontable settings.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return isMobileBrowser();
  }
  /**
   * Enable plugin for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.registerListeners();
    super.enablePlugin();
  }
  /**
   * Bind the touch events.
   *
   * @private
   */
  registerListeners() {
    const _this = this;
    const {
      rootElement
    } = this.hot;
    function removeFromDragged(query) {
      if (_this.dragged.length === 1) {
        _this.dragged.splice(0, _this.dragged.length);
        return true;
      }
      const entryPosition = _this.dragged.indexOf(query);
      if (entryPosition === -1) {
        return false;
      } else if (entryPosition === 0) {
        _this.dragged = _this.dragged.slice(0, 1);
      } else if (entryPosition === 1) {
        _this.dragged = _this.dragged.slice(-1);
      }
    }
    this.eventManager.addEventListener(rootElement, "touchstart", (event) => {
      let selectedRange;
      if (hasClass(event.target, "topSelectionHandle-HitArea")) {
        selectedRange = _this.hot.getSelectedRangeLast();
        _this.dragged.push("top");
        _this.touchStartRange = {
          width: selectedRange.getWidth(),
          height: selectedRange.getHeight(),
          direction: selectedRange.getDirection()
        };
        event.preventDefault();
        return false;
      } else if (hasClass(event.target, "bottomSelectionHandle-HitArea")) {
        selectedRange = _this.hot.getSelectedRangeLast();
        _this.dragged.push("bottom");
        _this.touchStartRange = {
          width: selectedRange.getWidth(),
          height: selectedRange.getHeight(),
          direction: selectedRange.getDirection()
        };
        event.preventDefault();
        return false;
      }
    });
    this.eventManager.addEventListener(rootElement, "touchend", (event) => {
      if (hasClass(event.target, "topSelectionHandle-HitArea")) {
        removeFromDragged.call(_this, "top");
        _this.touchStartRange = void 0;
        event.preventDefault();
        return false;
      } else if (hasClass(event.target, "bottomSelectionHandle-HitArea")) {
        removeFromDragged.call(_this, "bottom");
        _this.touchStartRange = void 0;
        event.preventDefault();
        return false;
      }
    });
    this.eventManager.addEventListener(rootElement, "touchmove", (event) => {
      const {
        rootDocument
      } = this.hot;
      let targetCoords;
      let selectedRange;
      let rangeWidth;
      let rangeHeight;
      let rangeDirection;
      let newRangeCoords;
      if (_this.dragged.length === 0) {
        return;
      }
      const endTarget = rootDocument.elementFromPoint(event.touches[0].clientX, event.touches[0].clientY);
      if (!endTarget || endTarget === _this.lastSetCell) {
        return;
      }
      if (endTarget.nodeName === "TD" || endTarget.nodeName === "TH") {
        targetCoords = _this.hot.getCoords(endTarget);
        if (targetCoords.col === -1) {
          targetCoords.col = 0;
        }
        selectedRange = _this.hot.getSelectedRangeLast();
        rangeWidth = selectedRange.getWidth();
        rangeHeight = selectedRange.getHeight();
        rangeDirection = selectedRange.getDirection();
        if (rangeWidth === 1 && rangeHeight === 1) {
          _this.hot.selection.setRangeEnd(targetCoords);
        }
        newRangeCoords = _this.getCurrentRangeCoords(selectedRange, targetCoords, _this.touchStartRange.direction, rangeDirection, _this.dragged[0]);
        if (newRangeCoords.start !== null) {
          _this.hot.selection.setRangeStart(newRangeCoords.start);
        }
        _this.hot.selection.setRangeEnd(newRangeCoords.end);
        _this.lastSetCell = endTarget;
      }
      event.preventDefault();
    });
  }
  getCurrentRangeCoords(selectedRange, currentTouch, touchStartDirection, currentDirection, draggedHandle) {
    const topStartCorner = selectedRange.getTopStartCorner();
    const bottomEndCorner = selectedRange.getBottomEndCorner();
    const bottomStartCorner = selectedRange.getBottomStartCorner();
    const topEndCorner = selectedRange.getTopEndCorner();
    let newCoords = {
      start: null,
      end: null
    };
    switch (touchStartDirection) {
      case "NE-SW":
        switch (currentDirection) {
          case "NE-SW":
          case "NW-SE":
            if (draggedHandle === "top") {
              newCoords = {
                start: this.hot._createCellCoords(currentTouch.row, selectedRange.highlight.col),
                end: this.hot._createCellCoords(bottomStartCorner.row, currentTouch.col)
              };
            } else {
              newCoords = {
                start: this.hot._createCellCoords(selectedRange.highlight.row, currentTouch.col),
                end: this.hot._createCellCoords(currentTouch.row, topStartCorner.col)
              };
            }
            break;
          case "SE-NW":
            if (draggedHandle === "bottom") {
              newCoords = {
                start: this.hot._createCellCoords(bottomEndCorner.row, currentTouch.col),
                end: this.hot._createCellCoords(currentTouch.row, topStartCorner.col)
              };
            }
            break;
          default:
            break;
        }
        break;
      case "NW-SE":
        switch (currentDirection) {
          case "NE-SW":
            if (draggedHandle === "top") {
              newCoords = {
                start: currentTouch,
                end: bottomStartCorner
              };
            } else {
              newCoords.end = currentTouch;
            }
            break;
          case "NW-SE":
            if (draggedHandle === "top") {
              newCoords = {
                start: currentTouch,
                end: bottomEndCorner
              };
            } else {
              newCoords.end = currentTouch;
            }
            break;
          case "SE-NW":
            if (draggedHandle === "top") {
              newCoords = {
                start: currentTouch,
                end: topStartCorner
              };
            } else {
              newCoords.end = currentTouch;
            }
            break;
          case "SW-NE":
            if (draggedHandle === "top") {
              newCoords = {
                start: currentTouch,
                end: topEndCorner
              };
            } else {
              newCoords.end = currentTouch;
            }
            break;
          default:
            break;
        }
        break;
      case "SW-NE":
        switch (currentDirection) {
          case "NW-SE":
            if (draggedHandle === "bottom") {
              newCoords = {
                start: this.hot._createCellCoords(currentTouch.row, topStartCorner.col),
                end: this.hot._createCellCoords(bottomStartCorner.row, currentTouch.col)
              };
            } else {
              newCoords = {
                start: this.hot._createCellCoords(topStartCorner.row, currentTouch.col),
                end: this.hot._createCellCoords(currentTouch.row, bottomEndCorner.col)
              };
            }
            break;
          case "SW-NE":
            if (draggedHandle === "top") {
              newCoords = {
                start: this.hot._createCellCoords(selectedRange.highlight.row, currentTouch.col),
                end: this.hot._createCellCoords(currentTouch.row, bottomEndCorner.col)
              };
            } else {
              newCoords = {
                start: this.hot._createCellCoords(currentTouch.row, topStartCorner.col),
                end: this.hot._createCellCoords(topStartCorner.row, currentTouch.col)
              };
            }
            break;
          case "SE-NW":
            if (draggedHandle === "bottom") {
              newCoords = {
                start: this.hot._createCellCoords(currentTouch.row, topEndCorner.col),
                end: this.hot._createCellCoords(topStartCorner.row, currentTouch.col)
              };
            } else if (draggedHandle === "top") {
              newCoords = {
                start: bottomStartCorner,
                end: currentTouch
              };
            }
            break;
          default:
            break;
        }
        break;
      case "SE-NW":
        switch (currentDirection) {
          case "NW-SE":
          case "NE-SW":
          case "SW-NE":
            if (draggedHandle === "top") {
              newCoords.end = currentTouch;
            }
            break;
          case "SE-NW":
            if (draggedHandle === "top") {
              newCoords.end = currentTouch;
            } else {
              newCoords = {
                start: currentTouch,
                end: topStartCorner
              };
            }
            break;
          default:
            break;
        }
        break;
      default:
        break;
    }
    return newCoords;
  }
  /**
   * Check if user is currently dragging the handle.
   *
   * @returns {boolean} Dragging state.
   */
  isDragged() {
    return this.dragged.length > 0;
  }
};

// node_modules/handsontable/plugins/nestedHeaders/stateManager/utils.mjs
function createDefaultHeaderSettings() {
  let {
    label = "",
    colspan = 1,
    origColspan = 1,
    collapsible = false,
    crossHiddenColumns = [],
    isCollapsed = false,
    isHidden = false,
    isRoot = false,
    isPlaceholder = false
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return {
    label,
    colspan,
    origColspan,
    collapsible,
    isCollapsed,
    crossHiddenColumns,
    isHidden,
    isRoot,
    isPlaceholder
  };
}
function createPlaceholderHeaderSettings() {
  return {
    label: "",
    isPlaceholder: true
  };
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/settingsNormalizer.mjs
function normalizeSettings(sourceSettings) {
  let columnsLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Infinity;
  const normalizedSettings = [];
  if (columnsLimit === 0) {
    return normalizedSettings;
  }
  arrayEach(sourceSettings, (headersSettings) => {
    const columns = [];
    let columnIndex = 0;
    normalizedSettings.push(columns);
    arrayEach(headersSettings, (sourceHeaderSettings) => {
      const headerSettings = createDefaultHeaderSettings();
      if (isObject(sourceHeaderSettings)) {
        const {
          label,
          colspan
        } = sourceHeaderSettings;
        headerSettings.label = stringify(label);
        if (typeof colspan === "number" && colspan > 1) {
          headerSettings.colspan = colspan;
          headerSettings.origColspan = colspan;
        }
      } else {
        headerSettings.label = stringify(sourceHeaderSettings);
      }
      columnIndex += headerSettings.origColspan;
      let cancelProcessing = false;
      if (columnIndex >= columnsLimit) {
        headerSettings.colspan = headerSettings.origColspan - (columnIndex - columnsLimit);
        headerSettings.origColspan = headerSettings.colspan;
        cancelProcessing = true;
      }
      columns.push(headerSettings);
      if (headerSettings.colspan > 1) {
        for (let i = 0; i < headerSettings.colspan - 1; i++) {
          columns.push(createPlaceholderHeaderSettings());
        }
      }
      return !cancelProcessing;
    });
  });
  const columnsLength = Math.max(...arrayMap(normalizedSettings, (headersSettings) => headersSettings.length));
  arrayEach(normalizedSettings, (headersSettings) => {
    if (headersSettings.length < columnsLength) {
      const defaultSettings = arrayMap(new Array(columnsLength - headersSettings.length), () => createDefaultHeaderSettings());
      headersSettings.splice(headersSettings.length, 0, ...defaultSettings);
    }
  });
  return normalizedSettings;
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/sourceSettings.mjs
function _classPrivateFieldInitSpec26(obj, privateMap, value) {
  _checkPrivateRedeclaration40(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration40(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet26(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor26(receiver, privateMap, "get");
  return _classApplyDescriptorGet26(receiver, descriptor);
}
function _classApplyDescriptorGet26(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet25(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor26(receiver, privateMap, "set");
  _classApplyDescriptorSet25(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor26(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet25(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var HEADER_CONFIGURABLE_PROPS = ["label", "collapsible"];
var _data = /* @__PURE__ */ new WeakMap();
var _dataLength = /* @__PURE__ */ new WeakMap();
var _columnsLimit2 = /* @__PURE__ */ new WeakMap();
var SourceSettings = class {
  constructor() {
    _classPrivateFieldInitSpec26(this, _data, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec26(this, _dataLength, {
      writable: true,
      value: 0
    });
    _classPrivateFieldInitSpec26(this, _columnsLimit2, {
      writable: true,
      value: Infinity
    });
  }
  /**
   * Sets columns limit to the source settings will be trimmed. All headers which
   * overlap the column limit will be reduced to keep the structure solid.
   *
   * @param {number} columnsCount The number of columns to limit to.
   */
  setColumnsLimit(columnsCount) {
    _classPrivateFieldSet25(this, _columnsLimit2, columnsCount);
  }
  /**
   * Sets a new nested header configuration.
   *
   * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.
   */
  setData() {
    let nestedHeadersSettings = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classPrivateFieldSet25(this, _data, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet26(this, _columnsLimit2)));
    _classPrivateFieldSet25(this, _dataLength, _classPrivateFieldGet26(this, _data).length);
  }
  /**
   * Gets normalized source settings.
   *
   * @returns {Array[]}
   */
  getData() {
    return _classPrivateFieldGet26(this, _data);
  }
  /**
   * Merges settings with current source settings.
   *
   * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional
   *                                      properties to merge with current source settings.
   */
  mergeWith(additionalSettings) {
    arrayEach(additionalSettings, (_ref) => {
      let {
        row,
        col,
        ...rest
      } = _ref;
      const headerSettings = this.getHeaderSettings(row, col);
      if (headerSettings !== null) {
        extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);
      }
    });
  }
  /**
   * Maps the current state with a callback. For each source settings the callback function
   * is called. If the function returns value that value is merged with the source settings.
   *
   * @param {Function} callback A function that is called for every header settings.
   *                            Each time the callback is called, the returned value extends
   *                            header settings.
   */
  map(callback) {
    arrayEach(_classPrivateFieldGet26(this, _data), (header) => {
      arrayEach(header, (headerSettings) => {
        const propsToExtend = callback({
          ...headerSettings
        });
        if (isObject(propsToExtend)) {
          extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);
        }
      });
    });
  }
  /**
   * Gets source column header settings for a specified header. The returned
   * object contains information about the header label, its colspan length,
   * or if it is hidden in the header renderers.
   *
   * @param {number} headerLevel Header level (0 = most distant to the table).
   * @param {number} columnIndex A visual column index.
   * @returns {object|null}
   */
  getHeaderSettings(headerLevel, columnIndex) {
    var _headersSettings$colu;
    if (headerLevel >= _classPrivateFieldGet26(this, _dataLength) || headerLevel < 0) {
      return null;
    }
    const headersSettings = _classPrivateFieldGet26(this, _data)[headerLevel];
    if (columnIndex >= headersSettings.length) {
      return null;
    }
    return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;
  }
  /**
   * Gets source of column headers settings for specified headers. If the retrieved column
   * settings overlap the range "box" determined by "columnIndex" and "columnsLength"
   * the exception will be thrown.
   *
   * @param {number} headerLevel Header level (0 = most distant to the table).
   * @param {number} columnIndex A visual column index from which the settings will be extracted.
   * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.
   * @returns {object}
   */
  getHeadersSettings(headerLevel, columnIndex) {
    let columnsLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const headersSettingsChunks = [];
    if (headerLevel >= _classPrivateFieldGet26(this, _dataLength) || headerLevel < 0) {
      return headersSettingsChunks;
    }
    const headersSettings = _classPrivateFieldGet26(this, _data)[headerLevel];
    let currentLength = 0;
    for (let i = columnIndex; i < headersSettings.length; i++) {
      const headerSettings = headersSettings[i];
      if (headerSettings.isPlaceholder) {
        throw new Error("The first column settings cannot overlap the other header layers");
      }
      currentLength += headerSettings.colspan;
      headersSettingsChunks.push(headerSettings);
      if (headerSettings.colspan > 1) {
        i += headerSettings.colspan - 1;
      }
      if (currentLength === columnsLength) {
        break;
      }
      if (currentLength > columnsLength) {
        throw new Error("The last column settings cannot overlap the other header layers");
      }
    }
    return headersSettingsChunks;
  }
  /**
   * Gets a total number of headers levels.
   *
   * @returns {number}
   */
  getLayersCount() {
    return _classPrivateFieldGet26(this, _dataLength);
  }
  /**
   * Gets a total number of columns count.
   *
   * @returns {number}
   */
  getColumnsCount() {
    return _classPrivateFieldGet26(this, _dataLength) > 0 ? _classPrivateFieldGet26(this, _data)[0].length : 0;
  }
  /**
   * Clears the data.
   */
  clear() {
    _classPrivateFieldSet25(this, _data, []);
    _classPrivateFieldSet25(this, _dataLength, 0);
  }
};

// node_modules/handsontable/utils/dataStructures/tree.mjs
function _defineProperty47(obj, key, value) {
  key = _toPropertyKey47(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey47(arg) {
  var key = _toPrimitive47(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive47(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var TRAVERSAL_DF_PRE = "DF-pre-order";
function depthFirstPreOrder(callback, context) {
  let continueTraverse = callback.call(context, this);
  for (let i = 0; i < this.childs.length; i++) {
    if (continueTraverse === false) {
      return false;
    }
    continueTraverse = depthFirstPreOrder.call(this.childs[i], callback, context);
  }
  return continueTraverse;
}
var TRAVERSAL_DF_POST = "DF-post-order";
function depthFirstPostOrder(callback, context) {
  for (let i = 0; i < this.childs.length; i++) {
    const continueTraverse = depthFirstPostOrder.call(this.childs[i], callback, context);
    if (continueTraverse === false) {
      return false;
    }
  }
  return callback.call(context, this);
}
var TRAVERSAL_BF = "BF";
function breadthFirst(callback, context) {
  const queue = [this];
  function process() {
    if (queue.length === 0) {
      return;
    }
    const node = queue.shift();
    queue.push(...node.childs);
    if (callback.call(context, node) !== false) {
      process();
    }
  }
  process();
}
var DEFAULT_TRAVERSAL_STRATEGY = TRAVERSAL_BF;
var TRAVERSAL_STRATEGIES = /* @__PURE__ */ new Map([[TRAVERSAL_DF_PRE, depthFirstPreOrder], [TRAVERSAL_DF_POST, depthFirstPostOrder], [TRAVERSAL_BF, breadthFirst]]);
var TreeNode = class _TreeNode {
  constructor(data) {
    _defineProperty47(this, "data", {});
    _defineProperty47(this, "parent", null);
    _defineProperty47(this, "childs", []);
    this.data = data;
  }
  /**
   * Adds a node to tree leaves. Added node is linked with the parent node through "parent" property.
   *
   * @param {TreeNode} node A TreeNode to add.
   */
  addChild(node) {
    node.parent = this;
    this.childs.push(node);
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @memberof TreeNode#
   * @function cloneTree
   *
   * Clones a tree structure deeply.
   *
   * For example, for giving a tree structure:
   *      .--(B1)--.
   *   .-(C1)   .-(C2)-.----.
   *  (D1)     (D2)   (D3) (D4)
   *
   * Cloning a tree starting from C2 node creates a mirrored tree structure.
   *     .-(C2')-.-----.
   *    (D2')   (D3') (D4')
   *
   * The cloned tree can be safely modified without affecting the original structure.
   * After modification, the clone can be merged with a tree using the "replaceTreeWith" method.
   *
   * @param {TreeNode} [nodeTree=this] A TreeNode to clone.
   * @returns {TreeNode}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  cloneTree() {
    let nodeTree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
    const clonedNode = new _TreeNode({
      ...nodeTree.data
    });
    for (let i = 0; i < nodeTree.childs.length; i++) {
      clonedNode.addChild(this.cloneTree(nodeTree.childs[i]));
    }
    return clonedNode;
  }
  /**
   * Replaces the current node with a passed tree structure.
   *
   * @param {TreeNode} nodeTree A TreeNode to replace with.
   */
  replaceTreeWith(nodeTree) {
    this.data = {
      ...nodeTree.data
    };
    this.childs = [];
    for (let i = 0; i < nodeTree.childs.length; i++) {
      this.addChild(nodeTree.childs[i]);
    }
  }
  /**
   * Traverses the tree structure through node childs. The walk down traversing supports
   * a three different strategies.
   *  - Depth-first pre-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR));
   *  - Depth-first post-order strategy (https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(NLR));
   *  - Breadth-first traversal strategy (https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search_/_level_order).
   *
   * @param {Function} callback The callback function which will be called for each node.
   * @param {string} [traversalStrategy=DEFAULT_TRAVERSAL_STRATEGY] Traversing strategy.
   */
  walkDown(callback) {
    let traversalStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_TRAVERSAL_STRATEGY;
    if (!TRAVERSAL_STRATEGIES.has(traversalStrategy)) {
      throw new Error(`Traversal strategy "${traversalStrategy}" does not exist`);
    }
    TRAVERSAL_STRATEGIES.get(traversalStrategy).call(this, callback, this);
  }
  /**
   * Traverses the tree structure through node parents.
   *
   * @param {Function} callback The callback function which will be called for each node.
   */
  walkUp(callback) {
    const context = this;
    const process = (node) => {
      const continueTraverse = callback.call(context, node);
      if (continueTraverse !== false && node.parent !== null) {
        process(node.parent);
      }
    };
    process(this);
  }
};

// node_modules/handsontable/plugins/nestedHeaders/stateManager/headersTree.mjs
function _classPrivateFieldInitSpec27(obj, privateMap, value) {
  _checkPrivateRedeclaration41(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration41(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldGet27(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor27(receiver, privateMap, "get");
  return _classApplyDescriptorGet27(receiver, descriptor);
}
function _classApplyDescriptorGet27(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet26(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor27(receiver, privateMap, "set");
  _classApplyDescriptorSet26(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor27(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet26(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
var _rootNodes = /* @__PURE__ */ new WeakMap();
var _rootsIndex = /* @__PURE__ */ new WeakMap();
var _sourceSettings = /* @__PURE__ */ new WeakMap();
var HeadersTree = class {
  constructor(sourceSettings) {
    _classPrivateFieldInitSpec27(this, _rootNodes, {
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    _classPrivateFieldInitSpec27(this, _rootsIndex, {
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    _classPrivateFieldInitSpec27(this, _sourceSettings, {
      writable: true,
      value: null
    });
    _classPrivateFieldSet26(this, _sourceSettings, sourceSettings);
  }
  /**
   * Gets an array of the all root nodes.
   *
   * @returns {TreeNode[]}
   */
  getRoots() {
    return Array.from(_classPrivateFieldGet27(this, _rootNodes).values());
  }
  /**
   * Gets a root node by specified visual column index.
   *
   * @param {number} columnIndex A visual column index.
   * @returns {TreeNode|undefined}
   */
  getRootByColumn(columnIndex) {
    let node;
    if (_classPrivateFieldGet27(this, _rootsIndex).has(columnIndex)) {
      node = _classPrivateFieldGet27(this, _rootNodes).get(_classPrivateFieldGet27(this, _rootsIndex).get(columnIndex));
    }
    return node;
  }
  /**
   * Gets a tree node by its position in the grid settings.
   *
   * @param {number} headerLevel Header level index (there is support only for positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {TreeNode|undefined}
   */
  getNode(headerLevel, columnIndex) {
    const rootNode = this.getRootByColumn(columnIndex);
    if (!rootNode) {
      return;
    }
    const normColumnIndex = columnIndex - _classPrivateFieldGet27(this, _rootsIndex).get(columnIndex);
    let columnCursor = 0;
    let treeNode;
    rootNode.walkDown((node) => {
      const {
        data: {
          origColspan,
          headerLevel: nodeHeaderLevel
        }
      } = node;
      if (headerLevel === nodeHeaderLevel) {
        if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {
          treeNode = node;
          treeNode.data.isRoot = columnIndex === treeNode.data.columnIndex;
          return false;
        }
        columnCursor += origColspan;
      }
    });
    return treeNode;
  }
  /**
   * Builds (or rebuilds if called again) root nodes indexes.
   */
  rebuildTreeIndex() {
    let columnIndex = 0;
    _classPrivateFieldGet27(this, _rootsIndex).clear();
    arrayEach(_classPrivateFieldGet27(this, _rootNodes), (_ref) => {
      let [, {
        data: {
          colspan
        }
      }] = _ref;
      for (let i = columnIndex; i < columnIndex + colspan; i++) {
        _classPrivateFieldGet27(this, _rootsIndex).set(i, columnIndex);
      }
      columnIndex += colspan;
    });
  }
  /**
   * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built
   * from the previous call.
   */
  buildTree() {
    this.clear();
    const columnsCount = _classPrivateFieldGet27(this, _sourceSettings).getColumnsCount();
    let columnIndex = 0;
    while (columnIndex < columnsCount) {
      const columnSettings = _classPrivateFieldGet27(this, _sourceSettings).getHeaderSettings(0, columnIndex);
      const rootNode = new TreeNode();
      _classPrivateFieldGet27(this, _rootNodes).set(columnIndex, rootNode);
      this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);
      columnIndex += columnSettings.origColspan;
    }
    this.rebuildTreeIndex();
  }
  /**
   * Builds leaves for specified tree node.
   *
   * @param {TreeNode} parentNode A node to which the leaves applies.
   * @param {number} columnIndex A visual column index.
   * @param {number} headerLevel Currently processed header level.
   * @param {number} [extractionLength=1] Determines column extraction length for node children.
   */
  buildLeaves(parentNode, columnIndex, headerLevel) {
    let extractionLength = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    const columnsSettings = _classPrivateFieldGet27(this, _sourceSettings).getHeadersSettings(headerLevel, columnIndex, extractionLength);
    headerLevel += 1;
    arrayEach(columnsSettings, (columnSettings) => {
      const nodeData = {
        ...columnSettings,
        /**
         * The header level (tree node depth level).
         *
         * @type {number}
         */
        headerLevel: headerLevel - 1,
        /**
         * A visual column index.
         *
         * @type {number}
         */
        columnIndex
      };
      let node;
      if (headerLevel === 1) {
        parentNode.data = nodeData;
        node = parentNode;
      } else {
        node = new TreeNode(nodeData);
        parentNode.addChild(node);
      }
      if (headerLevel < _classPrivateFieldGet27(this, _sourceSettings).getLayersCount()) {
        this.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);
      }
      columnIndex += columnSettings.origColspan;
    });
  }
  /**
   * Clears the tree to the initial state.
   */
  clear() {
    _classPrivateFieldGet27(this, _rootNodes).clear();
    _classPrivateFieldGet27(this, _rootsIndex).clear();
  }
};

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/utils/tree.mjs
function traverseHiddenNodeColumnIndexes(node, callback) {
  node.walkDown((_ref) => {
    let {
      data,
      childs
    } = _ref;
    if (!data.isHidden) {
      callback(data.columnIndex);
      if (childs.length === 0) {
        for (let i = 1; i < data.colspan; i++) {
          callback(data.columnIndex + i);
        }
      }
    }
  });
}
function getFirstChildProperty(_ref2, propertyName) {
  let {
    childs
  } = _ref2;
  if (childs.length === 0) {
    return;
  }
  return childs[0].data[propertyName];
}
function isNodeReflectsFirstChildColspan(node) {
  return getFirstChildProperty(node, "origColspan") === node.data.origColspan;
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/expand.mjs
function expandNode(nodeToProcess) {
  const {
    data: nodeData,
    childs: nodeChilds
  } = nodeToProcess;
  if (!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {
    return {
      rollbackModification: () => {
      },
      affectedColumns: [],
      colspanCompensation: 0
    };
  }
  const isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);
  if (isNodeReflected) {
    return expandNode(nodeChilds[0]);
  }
  nodeData.isCollapsed = false;
  const allLeavesExceptMostLeft = nodeChilds.slice(1);
  const affectedColumns = /* @__PURE__ */ new Set();
  let colspanCompensation = 0;
  if (allLeavesExceptMostLeft.length > 0) {
    arrayEach(allLeavesExceptMostLeft, (node) => {
      node.replaceTreeWith(node.data.clonedTree);
      node.data.clonedTree = null;
      const leafData = node.data;
      colspanCompensation += leafData.colspan;
      traverseHiddenNodeColumnIndexes(node, (gridColumnIndex) => {
        affectedColumns.add(gridColumnIndex);
      });
    });
  } else {
    const {
      colspan,
      origColspan,
      columnIndex
    } = nodeData;
    colspanCompensation = origColspan - colspan;
    for (let i = 1; i < origColspan; i++) {
      affectedColumns.add(columnIndex + i);
    }
  }
  nodeToProcess.walkUp((node) => {
    const {
      data
    } = node;
    data.colspan += colspanCompensation;
    if (data.colspan >= data.origColspan) {
      data.colspan = data.origColspan;
      data.isCollapsed = false;
    } else if (isNodeReflectsFirstChildColspan(node)) {
      data.isCollapsed = getFirstChildProperty(node, "isCollapsed");
    }
  });
  return {
    rollbackModification: () => collapseNode(nodeToProcess),
    affectedColumns: Array.from(affectedColumns),
    colspanCompensation
  };
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/collapse.mjs
function collapseNode(nodeToProcess) {
  var _getFirstChildPropert;
  const {
    data: nodeData,
    childs: nodeChilds
  } = nodeToProcess;
  if (nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {
    return {
      rollbackModification: () => {
      },
      affectedColumns: [],
      colspanCompensation: 0
    };
  }
  const isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);
  if (isNodeReflected) {
    return collapseNode(nodeChilds[0]);
  }
  nodeData.isCollapsed = true;
  const allLeavesExceptMostLeft = nodeChilds.slice(1);
  const affectedColumns = /* @__PURE__ */ new Set();
  if (allLeavesExceptMostLeft.length > 0) {
    arrayEach(allLeavesExceptMostLeft, (node) => {
      traverseHiddenNodeColumnIndexes(node, (gridColumnIndex) => {
        affectedColumns.add(gridColumnIndex);
      });
      node.data.clonedTree = node.cloneTree();
      node.walkDown((_ref) => {
        let {
          data
        } = _ref;
        data.isHidden = true;
      });
    });
  } else {
    const {
      origColspan,
      columnIndex
    } = nodeData;
    for (let i = 1; i < origColspan; i++) {
      const gridColumnIndex = columnIndex + i;
      affectedColumns.add(gridColumnIndex);
    }
  }
  const colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = getFirstChildProperty(nodeToProcess, "colspan")) !== null && _getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);
  nodeToProcess.walkUp((node) => {
    const {
      data
    } = node;
    data.colspan -= colspanCompensation;
    if (data.colspan <= 1) {
      data.colspan = 1;
      data.isCollapsed = true;
    } else if (isNodeReflectsFirstChildColspan(node)) {
      data.isCollapsed = getFirstChildProperty(node, "isCollapsed");
    }
  });
  return {
    rollbackModification: () => expandNode(nodeToProcess),
    affectedColumns: Array.from(affectedColumns),
    colspanCompensation
  };
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/hideColumn.mjs
function hideColumn(nodeToProcess, gridColumnIndex) {
  if (!Number.isInteger(gridColumnIndex)) {
    throw new Error("The passed gridColumnIndex argument has invalid type.");
  }
  if (nodeToProcess.childs.length > 0) {
    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\x20
the last node, the hide column modification can be applied.`);
  }
  const {
    crossHiddenColumns
  } = nodeToProcess.data;
  if (crossHiddenColumns.includes(gridColumnIndex)) {
    return;
  }
  let isCollapsibleNode = false;
  nodeToProcess.walkUp((node) => {
    const {
      data: {
        collapsible
      }
    } = node;
    if (collapsible) {
      isCollapsibleNode = true;
      return false;
    }
  });
  if (isCollapsibleNode) {
    return;
  }
  nodeToProcess.walkUp((node) => {
    const {
      data
    } = node;
    data.crossHiddenColumns.push(gridColumnIndex);
    if (data.colspan > 1) {
      data.colspan -= 1;
    } else {
      data.isHidden = true;
    }
  });
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/showColumn.mjs
function showColumn(nodeToProcess, gridColumnIndex) {
  if (!Number.isInteger(gridColumnIndex)) {
    throw new Error("The passed gridColumnIndex argument has invalid type.");
  }
  if (nodeToProcess.childs.length > 0) {
    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\x20
the last node, the show column modification can be applied.`);
  }
  const {
    crossHiddenColumns
  } = nodeToProcess.data;
  if (!crossHiddenColumns.includes(gridColumnIndex)) {
    return;
  }
  let isCollapsibleNode = false;
  nodeToProcess.walkUp((node) => {
    const {
      data: {
        collapsible
      }
    } = node;
    if (collapsible) {
      isCollapsibleNode = true;
      return false;
    }
  });
  if (isCollapsibleNode) {
    return;
  }
  nodeToProcess.walkUp((node) => {
    const {
      data
    } = node;
    data.crossHiddenColumns.splice(data.crossHiddenColumns.indexOf(gridColumnIndex), 1);
    if (!data.isHidden && data.colspan < data.origColspan) {
      data.colspan += 1;
    }
    data.isHidden = false;
  });
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/index.mjs
var availableModifiers = /* @__PURE__ */ new Map([["collapse", collapseNode], ["expand", expandNode], ["hide-column", hideColumn], ["show-column", showColumn]]);
function triggerNodeModification(actionName, nodeToProcess, gridColumnIndex) {
  if (!availableModifiers.has(actionName)) {
    throw new Error(`The node modifier action ("${actionName}") does not exist.`);
  }
  return availableModifiers.get(actionName)(nodeToProcess, gridColumnIndex);
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/matrixGenerator.mjs
function generateMatrix(headerRoots) {
  const matrix = [];
  arrayEach(headerRoots, (rootNode) => {
    rootNode.walkDown((node) => {
      const nodeData = node.data;
      const {
        origColspan,
        columnIndex,
        headerLevel,
        crossHiddenColumns
      } = nodeData;
      const colspanHeaderLayer = createNestedArrayIfNecessary(matrix, headerLevel);
      let isRootSettingsFound = false;
      for (let i = columnIndex; i < columnIndex + origColspan; i++) {
        const isColumnHidden = crossHiddenColumns.includes(i);
        if (isColumnHidden || isRootSettingsFound) {
          colspanHeaderLayer.push(createPlaceholderHeaderSettings(nodeData));
        } else {
          const headerRootSettings = createHeaderSettings(nodeData);
          headerRootSettings.isRoot = true;
          colspanHeaderLayer.push(headerRootSettings);
          isRootSettingsFound = true;
        }
      }
    });
  });
  return matrix;
}
function createHeaderSettings(nodeData) {
  const {
    crossHiddenColumns,
    ...headerRootSettings
  } = createDefaultHeaderSettings(nodeData);
  return headerRootSettings;
}
function createNestedArrayIfNecessary(array, index) {
  let subArray;
  if (Array.isArray(array[index])) {
    subArray = array[index];
  } else {
    subArray = [];
    array[index] = subArray;
  }
  return subArray;
}

// node_modules/handsontable/plugins/nestedHeaders/stateManager/index.mjs
function _classPrivateFieldInitSpec28(obj, privateMap, value) {
  _checkPrivateRedeclaration42(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration42(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet27(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor28(receiver, privateMap, "set");
  _classApplyDescriptorSet27(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet27(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet28(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor28(receiver, privateMap, "get");
  return _classApplyDescriptorGet28(receiver, descriptor);
}
function _classExtractFieldDescriptor28(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet28(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _sourceSettings2 = /* @__PURE__ */ new WeakMap();
var _headersTree = /* @__PURE__ */ new WeakMap();
var _stateMatrix = /* @__PURE__ */ new WeakMap();
var StateManager = class {
  constructor() {
    _classPrivateFieldInitSpec28(this, _sourceSettings2, {
      writable: true,
      value: new SourceSettings()
    });
    _classPrivateFieldInitSpec28(this, _headersTree, {
      writable: true,
      value: new HeadersTree(_classPrivateFieldGet28(this, _sourceSettings2))
    });
    _classPrivateFieldInitSpec28(this, _stateMatrix, {
      writable: true,
      value: [[]]
    });
  }
  /**
   * Sets a new state for the nested headers plugin based on settings passed
   * directly to the plugin.
   *
   * @param {Array[]} nestedHeadersSettings The user-defined settings.
   * @returns {boolean} Returns `true` if the settings are processed correctly, `false` otherwise.
   */
  setState(nestedHeadersSettings) {
    _classPrivateFieldGet28(this, _sourceSettings2).setData(nestedHeadersSettings);
    let hasError = false;
    try {
      _classPrivateFieldGet28(this, _headersTree).buildTree();
    } catch (ex) {
      _classPrivateFieldGet28(this, _headersTree).clear();
      _classPrivateFieldGet28(this, _sourceSettings2).clear();
      hasError = true;
    }
    _classPrivateFieldSet27(this, _stateMatrix, generateMatrix(_classPrivateFieldGet28(this, _headersTree).getRoots()));
    return hasError;
  }
  /**
   * Sets columns limit to the state will be trimmed. All headers (colspans) which
   * overlap the column limit will be reduced to keep the structure solid.
   *
   * @param {number} columnsCount The number of columns to limit to.
   */
  setColumnsLimit(columnsCount) {
    _classPrivateFieldGet28(this, _sourceSettings2).setColumnsLimit(columnsCount);
  }
  /**
   * Merges settings with current plugin state.
   *
   * By default only foreign keys are merged with source state and passed to the tree. But only
   * known keys are exported to matrix.
   *
   * @param {object[]} settings An array of objects to merge with the current source settings.
   *                            It is a requirement that every object has `row` and `col` properties
   *                            which points to the specific header settings object.
   */
  mergeStateWith(settings) {
    const transformedSettings = arrayMap(settings, (_ref) => {
      let {
        row,
        ...rest
      } = _ref;
      return {
        row: row < 0 ? this.rowCoordsToLevel(row) : row,
        ...rest
      };
    });
    _classPrivateFieldGet28(this, _sourceSettings2).mergeWith(transformedSettings);
    _classPrivateFieldGet28(this, _headersTree).buildTree();
    _classPrivateFieldSet27(this, _stateMatrix, generateMatrix(_classPrivateFieldGet28(this, _headersTree).getRoots()));
  }
  /**
   * Maps the current state with a callback. For each header settings the callback function
   * is called. If the function returns value that value is merged with the state.
   *
   * By default only foreign keys are merged with source state and passed to the tree. But only
   * known keys are exported to matrix.
   *
   * @param {Function} callback A function that is called for every header source settings.
   *                            Each time the callback is called, the returned value extends
   *                            header settings.
   */
  mapState(callback) {
    _classPrivateFieldGet28(this, _sourceSettings2).map(callback);
    _classPrivateFieldGet28(this, _headersTree).buildTree();
    _classPrivateFieldSet27(this, _stateMatrix, generateMatrix(_classPrivateFieldGet28(this, _headersTree).getRoots()));
  }
  /**
   * Maps the current tree nodes with a callback. For each node the callback function
   * is called. If the function returns value that value is added to returned array.
   *
   * @param {Function} callback A function that is called for every tree node.
   *                            Each time the callback is called, the returned value is
   *                            added to returned array.
   * @returns {Array}
   */
  mapNodes(callback) {
    return arrayReduce(_classPrivateFieldGet28(this, _headersTree).getRoots(), (acc, rootNode) => {
      rootNode.walkDown((node) => {
        const result = callback(node.data);
        if (result !== void 0) {
          acc.push(result);
        }
      });
      return acc;
    }, []);
  }
  /**
   * Triggers an action (e.g. "collapse") from the NodeModifiers module. The module
   * modifies a tree structure in such a way as to obtain the correct structure consistent with the
   * called action.
   *
   * @param {string} action An action name to trigger.
   * @param {number} headerLevel Header level index (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {object|undefined}
   */
  triggerNodeModification(action, headerLevel, columnIndex) {
    if (headerLevel < 0) {
      headerLevel = this.rowCoordsToLevel(headerLevel);
    }
    const nodeToProcess = _classPrivateFieldGet28(this, _headersTree).getNode(headerLevel, columnIndex);
    let actionResult;
    if (nodeToProcess) {
      actionResult = triggerNodeModification(action, nodeToProcess, columnIndex);
      _classPrivateFieldSet27(this, _stateMatrix, generateMatrix(_classPrivateFieldGet28(this, _headersTree).getRoots()));
    }
    return actionResult;
  }
  /**
   * Triggers an action (e.g. "hide-column") from the NodeModifiers module. The action is
   * triggered starting from the lowest header. The module modifies a tree structure in
   * such a way as to obtain the correct structure consistent with the called action.
   *
   * @param {string} action An action name to trigger.
   * @param {number} columnIndex A visual column index.
   * @returns {object|undefined}
   */
  triggerColumnModification(action, columnIndex) {
    return this.triggerNodeModification(action, -1, columnIndex);
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @memberof StateManager#
   * @function rowCoordsToLevel
   *
   * Translates row coordinates into header level. The row coordinates counts from -1 to -N
   * and describes headers counting from most closest to most distant from the table.
   * The header levels are counted from 0 to N where 0 describes most distant header
   * from the table.
   *
   *  Row coords             Header level
   *           +--------------+
   *       -3  │ A1 │ A1      │  0
   *           +--------------+
   *       -2  │ B1 │ B2 │ B3 │  1
   *           +--------------+
   *       -1  │ C1 │ C2 │ C3 │  2
   *           +==============+
   *           │    │    │    │
   *           +--------------+
   *           │    │    │    │
   *
   * @param {number} rowIndex A visual row index.
   * @returns {number|null} Returns unsigned number.
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  rowCoordsToLevel(rowIndex) {
    if (rowIndex >= 0) {
      return null;
    }
    const headerLevel = rowIndex + Math.max(this.getLayersCount(), 1);
    if (headerLevel < 0) {
      return null;
    }
    return headerLevel;
  }
  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * @memberof StateManager#
   * @function levelToRowCoords
   *
   * Translates header level into row coordinates. The row coordinates counts from -1 to -N
   * and describes headers counting from most closest to most distant from the table.
   * The header levels are counted from 0 to N where 0 describes most distant header
   * from the table.
   *
   *  Header level            Row coords
   *           +--------------+
   *        0  │ A1 │ A1      │  -3
   *           +--------------+
   *        1  │ B1 │ B2 │ B3 │  -2
   *           +--------------+
   *        2  │ C1 │ C2 │ C3 │  -1
   *           +==============+
   *           │    │    │    │
   *           +--------------+
   *           │    │    │    │
   *
   * @param {number} headerLevel Header level index.
   * @returns {number} Returns negative number.
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  levelToRowCoords(headerLevel) {
    if (headerLevel < 0) {
      return null;
    }
    const rowIndex = headerLevel - Math.max(this.getLayersCount(), 1);
    if (rowIndex >= 0) {
      return null;
    }
    return rowIndex;
  }
  /**
   * Gets column header settings for a specified column and header index. The returned object contains
   * all information necessary for header renderers. It contains header label, colspan length, or hidden
   * flag.
   *
   * @param {number} headerLevel Header level (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {object|null}
   */
  getHeaderSettings(headerLevel, columnIndex) {
    var _classPrivateFieldGet210, _classPrivateFieldGet32;
    if (headerLevel < 0) {
      headerLevel = this.rowCoordsToLevel(headerLevel);
    }
    if (headerLevel === null || headerLevel >= this.getLayersCount()) {
      return null;
    }
    return (_classPrivateFieldGet210 = (_classPrivateFieldGet32 = _classPrivateFieldGet28(this, _stateMatrix)[headerLevel]) === null || _classPrivateFieldGet32 === void 0 ? void 0 : _classPrivateFieldGet32[columnIndex]) !== null && _classPrivateFieldGet210 !== void 0 ? _classPrivateFieldGet210 : null;
  }
  /**
   * Gets tree data that is connected to the column header. The returned object contains all information
   * necessary for modifying tree structure (column collapsing, hiding, etc.). It contains a header
   * label, colspan length, or visual column index that indicates which column index the node is rendered from.
   *
   * @param {number} headerLevel Header level (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {object|null}
   */
  getHeaderTreeNodeData(headerLevel, columnIndex) {
    const node = this.getHeaderTreeNode(headerLevel, columnIndex);
    if (!node) {
      return null;
    }
    return {
      ...node.data
    };
  }
  /**
   * Gets tree node that is connected to the column header.
   *
   * @param {number} headerLevel Header level (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {TreeNode|null}
   */
  getHeaderTreeNode(headerLevel, columnIndex) {
    if (headerLevel < 0) {
      headerLevel = this.rowCoordsToLevel(headerLevel);
    }
    if (headerLevel === null || headerLevel >= this.getLayersCount()) {
      return null;
    }
    const node = _classPrivateFieldGet28(this, _headersTree).getNode(headerLevel, columnIndex);
    if (!node) {
      return null;
    }
    return node;
  }
  /**
   * Finds the most top header level of the column header that is rendered entirely within
   * the passed visual columns range. If multiple columns headers are found within the range the
   * most top header level value will be returned.
   *
   * @param {number} columnIndexFrom A visual column index.
   * @param {number} [columnIndexTo] A visual column index.
   * @returns {number} Returns a header level in format -1 to -N.
   */
  findTopMostEntireHeaderLevel(columnIndexFrom) {
    var _headerLevel;
    let columnIndexTo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : columnIndexFrom;
    const columnsWidth = columnIndexTo - columnIndexFrom + 1;
    let atLeastOneRootFound = false;
    let headerLevel = null;
    for (let columnIndex = columnIndexFrom; columnIndex <= columnIndexTo; columnIndex++) {
      const rootNode = _classPrivateFieldGet28(this, _headersTree).getRootByColumn(columnIndex);
      if (!rootNode) {
        break;
      }
      atLeastOneRootFound = true;
      rootNode.walkDown((node) => {
        const {
          columnIndex: nodeColumnIndex,
          headerLevel: nodeHeaderLevel,
          origColspan,
          isHidden
        } = node.data;
        if (isHidden) {
          return;
        }
        if (origColspan <= columnsWidth && nodeColumnIndex >= columnIndexFrom && nodeColumnIndex + origColspan - 1 <= columnIndexTo && (headerLevel === null || nodeHeaderLevel < headerLevel)) {
          headerLevel = nodeHeaderLevel;
        }
      }, TRAVERSAL_DF_PRE);
    }
    if (atLeastOneRootFound && headerLevel === null) {
      return -1;
    }
    return this.levelToRowCoords((_headerLevel = headerLevel) !== null && _headerLevel !== void 0 ? _headerLevel : 0);
  }
  /**
   * The method is helpful in cases where the column index targets in-between currently
   * collapsed column. In that case, the method returns the left-most column index
   * where the nested header begins.
   *
   * @param {number} headerLevel Header level (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {number}
   */
  findLeftMostColumnIndex(headerLevel, columnIndex) {
    var _this$getHeaderSettin;
    const {
      isRoot
    } = (_this$getHeaderSettin = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin !== void 0 ? _this$getHeaderSettin : {
      isRoot: true
    };
    if (isRoot) {
      return columnIndex;
    }
    let stepBackColumn = columnIndex - 1;
    while (stepBackColumn >= 0) {
      var _this$getHeaderSettin2;
      const {
        isRoot: isRootNode
      } = (_this$getHeaderSettin2 = this.getHeaderSettings(headerLevel, stepBackColumn)) !== null && _this$getHeaderSettin2 !== void 0 ? _this$getHeaderSettin2 : {
        isRoot: true
      };
      if (isRootNode) {
        break;
      }
      stepBackColumn -= 1;
    }
    return stepBackColumn;
  }
  /**
   * The method is helpful in cases where the column index targets in-between currently
   * collapsed column. In that case, the method returns the right-most column index
   * where the nested header ends.
   *
   * @param {number} headerLevel Header level (there is support for negative and positive values).
   * @param {number} columnIndex A visual column index.
   * @returns {number}
   */
  findRightMostColumnIndex(headerLevel, columnIndex) {
    var _this$getHeaderSettin3;
    const {
      isRoot,
      origColspan
    } = (_this$getHeaderSettin3 = this.getHeaderSettings(headerLevel, columnIndex)) !== null && _this$getHeaderSettin3 !== void 0 ? _this$getHeaderSettin3 : {
      isRoot: true,
      origColspan: 1
    };
    if (isRoot) {
      return columnIndex + origColspan - 1;
    }
    let stepForthColumn = columnIndex + 1;
    while (stepForthColumn < this.getColumnsCount()) {
      var _this$getHeaderSettin4;
      const {
        isRoot: isRootNode
      } = (_this$getHeaderSettin4 = this.getHeaderSettings(headerLevel, stepForthColumn)) !== null && _this$getHeaderSettin4 !== void 0 ? _this$getHeaderSettin4 : {
        isRoot: true
      };
      if (isRootNode) {
        break;
      }
      stepForthColumn += 1;
    }
    return stepForthColumn - 1;
  }
  /**
   * Gets a total number of headers levels.
   *
   * @returns {number}
   */
  getLayersCount() {
    return _classPrivateFieldGet28(this, _sourceSettings2).getLayersCount();
  }
  /**
   * Gets a total number of columns count.
   *
   * @returns {number}
   */
  getColumnsCount() {
    return _classPrivateFieldGet28(this, _sourceSettings2).getColumnsCount();
  }
  /**
   * Clears the column state manager to the initial state.
   */
  clear() {
    _classPrivateFieldSet27(this, _stateMatrix, []);
    _classPrivateFieldGet28(this, _sourceSettings2).clear();
    _classPrivateFieldGet28(this, _headersTree).clear();
  }
};

// node_modules/handsontable/plugins/nestedHeaders/utils/ghostTable.mjs
function _defineProperty48(obj, key, value) {
  key = _toPropertyKey48(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey48(arg) {
  var key = _toPrimitive48(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive48(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var GhostTable2 = class {
  constructor(hot, nestedHeaderSettingsGetter) {
    _defineProperty48(this, "hot", void 0);
    _defineProperty48(this, "nestedHeaderSettingsGetter", void 0);
    _defineProperty48(this, "layersCount", 0);
    _defineProperty48(this, "container", void 0);
    _defineProperty48(this, "widthsMap", void 0);
    this.hot = hot;
    this.nestedHeaderSettingsGetter = nestedHeaderSettingsGetter;
    this.widthsMap = this.hot.columnIndexMapper.createAndRegisterIndexMap("nestedHeaders.widthsMap", "physicalIndexToValue");
  }
  /**
   * Sets the number of nested headers layers count.
   *
   * @param {number} layersCount Total number of headers levels.
   * @returns {GhostTable}
   */
  setLayersCount(layersCount) {
    this.layersCount = layersCount;
    return this;
  }
  /**
   * Gets the column width based on the visual column index.
   *
   * @param {number} visualColumn Visual column index.
   * @returns {number|null}
   */
  getWidth(visualColumn) {
    return this.widthsMap.getValueAtIndex(this.hot.toPhysicalColumn(visualColumn));
  }
  /**
   * Build cache of the headers widths.
   */
  buildWidthsMap() {
    this.container = this.hot.rootDocument.createElement("div");
    this.container.classList.add("handsontable", "htGhostTable", "htAutoSize");
    this._buildGhostTable(this.container);
    this.hot.rootDocument.body.appendChild(this.container);
    const columns = this.container.querySelectorAll("tr:last-of-type th");
    const maxColumns = columns.length;
    this.widthsMap.clear();
    for (let column = 0; column < maxColumns; column++) {
      const visualColumnsIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(column);
      const physicalColumnIndex = this.hot.toPhysicalColumn(visualColumnsIndex);
      this.widthsMap.setValueAtIndex(physicalColumnIndex, columns[column].offsetWidth);
    }
    this.container.parentNode.removeChild(this.container);
    this.container = null;
  }
  /**
   * Build temporary table for getting minimal columns widths.
   *
   * @private
   * @param {HTMLElement} container The element where the DOM nodes are injected.
   */
  _buildGhostTable(container) {
    const {
      rootDocument,
      columnIndexMapper
    } = this.hot;
    const fragment = rootDocument.createDocumentFragment();
    const table = rootDocument.createElement("table");
    const isDropdownEnabled = !!this.hot.getSettings().dropdownMenu;
    const maxRenderedCols = columnIndexMapper.getRenderableIndexesLength();
    for (let row = 0; row < this.layersCount; row++) {
      const tr = rootDocument.createElement("tr");
      for (let col = 0; col < maxRenderedCols; col++) {
        let visualColumnsIndex = columnIndexMapper.getVisualFromRenderableIndex(col);
        if (visualColumnsIndex === null) {
          visualColumnsIndex = col;
        }
        const th = rootDocument.createElement("th");
        const headerSettings = this.nestedHeaderSettingsGetter(row, visualColumnsIndex);
        if (headerSettings && (!headerSettings.isPlaceholder || headerSettings.isHidden)) {
          let label = headerSettings.label;
          if (isDropdownEnabled) {
            label += '<button class="changeType"></button>';
          }
          fastInnerHTML(th, label);
          th.colSpan = headerSettings.colspan;
          tr.appendChild(th);
        }
      }
      table.appendChild(tr);
    }
    fragment.appendChild(table);
    container.appendChild(fragment);
  }
  /**
   * Clear the widths cache.
   */
  clear() {
    this.widthsMap.clear();
    this.container = null;
  }
};
var ghostTable_default2 = GhostTable2;

// node_modules/handsontable/plugins/nestedHeaders/nestedHeaders.mjs
function _classPrivateMethodInitSpec34(obj, privateSet) {
  _checkPrivateRedeclaration43(obj, privateSet);
  privateSet.add(obj);
}
function _defineProperty49(obj, key, value) {
  key = _toPropertyKey49(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey49(arg) {
  var key = _toPrimitive49(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive49(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldInitSpec29(obj, privateMap, value) {
  _checkPrivateRedeclaration43(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration43(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet28(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor29(receiver, privateMap, "set");
  _classApplyDescriptorSet28(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet28(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet29(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor29(receiver, privateMap, "get");
  return _classApplyDescriptorGet29(receiver, descriptor);
}
function _classExtractFieldDescriptor29(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet29(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateMethodGet34(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY28 = "nestedHeaders";
var PLUGIN_PRIORITY27 = 280;
var _stateManager = /* @__PURE__ */ new WeakMap();
var _hidingIndexMapObserver = /* @__PURE__ */ new WeakMap();
var _focusInitialCoords = /* @__PURE__ */ new WeakMap();
var _isColumnsSelectionInProgress = /* @__PURE__ */ new WeakMap();
var _updateFocusHighlightPosition = /* @__PURE__ */ new WeakSet();
var _onBeforeViewportScrollHorizontally = /* @__PURE__ */ new WeakSet();
var _onBeforeHighlightingColumnHeader = /* @__PURE__ */ new WeakSet();
var _onBeforeCopy = /* @__PURE__ */ new WeakSet();
var _onBeforeOnCellMouseDown6 = /* @__PURE__ */ new WeakSet();
var _onAfterOnCellMouseDown = /* @__PURE__ */ new WeakSet();
var _onBeforeOnCellMouseOver4 = /* @__PURE__ */ new WeakSet();
var _onBeforeOnCellMouseUp = /* @__PURE__ */ new WeakSet();
var _onBeforeSelectionHighlightSet = /* @__PURE__ */ new WeakSet();
var _onModifyTransformStart3 = /* @__PURE__ */ new WeakSet();
var _onBeforeSelectColumns = /* @__PURE__ */ new WeakSet();
var _onAfterGetColumnHeaderRenderers = /* @__PURE__ */ new WeakSet();
var _onAfterViewportColumnCalculatorOverride3 = /* @__PURE__ */ new WeakSet();
var _onModifyColWidth4 = /* @__PURE__ */ new WeakSet();
var _onModifyColumnHeaderValue = /* @__PURE__ */ new WeakSet();
var _onModifyFocusedElement = /* @__PURE__ */ new WeakSet();
var _onInit3 = /* @__PURE__ */ new WeakSet();
var _onAfterLoadData9 = /* @__PURE__ */ new WeakSet();
var NestedHeaders = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec34(this, _onAfterLoadData9);
    _classPrivateMethodInitSpec34(this, _onInit3);
    _classPrivateMethodInitSpec34(this, _onModifyFocusedElement);
    _classPrivateMethodInitSpec34(this, _onModifyColumnHeaderValue);
    _classPrivateMethodInitSpec34(this, _onModifyColWidth4);
    _classPrivateMethodInitSpec34(this, _onAfterViewportColumnCalculatorOverride3);
    _classPrivateMethodInitSpec34(this, _onAfterGetColumnHeaderRenderers);
    _classPrivateMethodInitSpec34(this, _onBeforeSelectColumns);
    _classPrivateMethodInitSpec34(this, _onModifyTransformStart3);
    _classPrivateMethodInitSpec34(this, _onBeforeSelectionHighlightSet);
    _classPrivateMethodInitSpec34(this, _onBeforeOnCellMouseUp);
    _classPrivateMethodInitSpec34(this, _onBeforeOnCellMouseOver4);
    _classPrivateMethodInitSpec34(this, _onAfterOnCellMouseDown);
    _classPrivateMethodInitSpec34(this, _onBeforeOnCellMouseDown6);
    _classPrivateMethodInitSpec34(this, _onBeforeCopy);
    _classPrivateMethodInitSpec34(this, _onBeforeHighlightingColumnHeader);
    _classPrivateMethodInitSpec34(this, _onBeforeViewportScrollHorizontally);
    _classPrivateMethodInitSpec34(this, _updateFocusHighlightPosition);
    _classPrivateFieldInitSpec29(this, _stateManager, {
      writable: true,
      value: new StateManager()
    });
    _classPrivateFieldInitSpec29(this, _hidingIndexMapObserver, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec29(this, _focusInitialCoords, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec29(this, _isColumnsSelectionInProgress, {
      writable: true,
      value: false
    });
    _defineProperty49(this, "ghostTable", new ghostTable_default2(this.hot, (row, column) => this.getHeaderSettings(row, column)));
    _defineProperty49(this, "detectedOverlappedHeaders", false);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY28;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY27;
  }
  /**
   * Check if plugin is enabled.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY28];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const {
      nestedHeaders
    } = this.hot.getSettings();
    if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {
      warn(toSingleLine`Your Nested Headers plugin configuration is invalid. The settings has to be\x20
                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]`);
    }
    this.addHook("init", () => _classPrivateMethodGet34(this, _onInit3, _onInit22).call(this));
    this.addHook("afterLoadData", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet34(_this, _onAfterLoadData9, _onAfterLoadData28).call(_this, ...args);
    });
    this.addHook("beforeOnCellMouseDown", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet34(_this, _onBeforeOnCellMouseDown6, _onBeforeOnCellMouseDown25).call(_this, ...args);
    });
    this.addHook("afterOnCellMouseDown", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _classPrivateMethodGet34(_this, _onAfterOnCellMouseDown, _onAfterOnCellMouseDown2).call(_this, ...args);
    });
    this.addHook("beforeOnCellMouseOver", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _classPrivateMethodGet34(_this, _onBeforeOnCellMouseOver4, _onBeforeOnCellMouseOver23).call(_this, ...args);
    });
    this.addHook("beforeOnCellMouseUp", function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _classPrivateMethodGet34(_this, _onBeforeOnCellMouseUp, _onBeforeOnCellMouseUp2).call(_this, ...args);
    });
    this.addHook("beforeSelectionHighlightSet", function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _classPrivateMethodGet34(_this, _onBeforeSelectionHighlightSet, _onBeforeSelectionHighlightSet2).call(_this, ...args);
    });
    this.addHook("modifyTransformStart", function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _classPrivateMethodGet34(_this, _onModifyTransformStart3, _onModifyTransformStart22).call(_this, ...args);
    });
    this.addHook("afterSelection", () => _classPrivateMethodGet34(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));
    this.addHook("beforeViewportScrollHorizontally", function() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return _classPrivateMethodGet34(_this, _onBeforeViewportScrollHorizontally, _onBeforeViewportScrollHorizontally2).call(_this, ...args);
    });
    this.addHook("afterGetColumnHeaderRenderers", (array) => _classPrivateMethodGet34(this, _onAfterGetColumnHeaderRenderers, _onAfterGetColumnHeaderRenderers2).call(this, array));
    this.addHook("modifyColWidth", function() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return _classPrivateMethodGet34(_this, _onModifyColWidth4, _onModifyColWidth23).call(_this, ...args);
    });
    this.addHook("modifyColumnHeaderValue", function() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return _classPrivateMethodGet34(_this, _onModifyColumnHeaderValue, _onModifyColumnHeaderValue2).call(_this, ...args);
    });
    this.addHook("beforeHighlightingColumnHeader", function() {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return _classPrivateMethodGet34(_this, _onBeforeHighlightingColumnHeader, _onBeforeHighlightingColumnHeader2).call(_this, ...args);
    });
    this.addHook("beforeCopy", function() {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return _classPrivateMethodGet34(_this, _onBeforeCopy, _onBeforeCopy2).call(_this, ...args);
    });
    this.addHook("beforeSelectColumns", function() {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return _classPrivateMethodGet34(_this, _onBeforeSelectColumns, _onBeforeSelectColumns2).call(_this, ...args);
    });
    this.addHook("afterViewportColumnCalculatorOverride", function() {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return _classPrivateMethodGet34(_this, _onAfterViewportColumnCalculatorOverride3, _onAfterViewportColumnCalculatorOverride22).call(_this, ...args);
    });
    this.addHook("modifyFocusedElement", function() {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return _classPrivateMethodGet34(_this, _onModifyFocusedElement, _onModifyFocusedElement2).call(_this, ...args);
    });
    this.hot.columnIndexMapper.addLocalHook("cacheUpdated", () => _classPrivateMethodGet34(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));
    this.hot.rowIndexMapper.addLocalHook("cacheUpdated", () => _classPrivateMethodGet34(this, _updateFocusHighlightPosition, _updateFocusHighlightPosition2).call(this));
    super.enablePlugin();
    this.updatePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`nestedHeaders`](@/api/options.md#nestedheaders)
   */
  updatePlugin() {
    if (!this.hot.view) {
      return;
    }
    const {
      nestedHeaders
    } = this.hot.getSettings();
    _classPrivateFieldGet29(this, _stateManager).setColumnsLimit(this.hot.countCols());
    if (Array.isArray(nestedHeaders)) {
      this.detectedOverlappedHeaders = _classPrivateFieldGet29(this, _stateManager).setState(nestedHeaders);
    }
    if (this.detectedOverlappedHeaders) {
      warn(toSingleLine`Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\x20
                        is currently not supported.`);
    }
    if (this.enabled) {
      this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach((isColumnHidden, physicalColumnIndex) => {
        const actionName = isColumnHidden === true ? "hide-column" : "show-column";
        _classPrivateFieldGet29(this, _stateManager).triggerColumnModification(actionName, physicalColumnIndex);
      });
    }
    if (!_classPrivateFieldGet29(this, _hidingIndexMapObserver) && this.enabled) {
      _classPrivateFieldSet28(this, _hidingIndexMapObserver, this.hot.columnIndexMapper.createChangesObserver("hiding").subscribe((changes) => {
        changes.forEach((_ref) => {
          let {
            op,
            index: columnIndex,
            newValue
          } = _ref;
          if (op === "replace") {
            const actionName = newValue === true ? "hide-column" : "show-column";
            _classPrivateFieldGet29(this, _stateManager).triggerColumnModification(actionName, columnIndex);
          }
        });
        this.ghostTable.buildWidthsMap();
      }));
    }
    this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.clearColspans();
    _classPrivateFieldGet29(this, _stateManager).clear();
    _classPrivateFieldGet29(this, _hidingIndexMapObserver).unsubscribe();
    _classPrivateFieldSet28(this, _hidingIndexMapObserver, null);
    this.ghostTable.clear();
    super.disablePlugin();
  }
  /**
   * Returns an instance of the internal state manager of the plugin.
   *
   * @private
   * @returns {StateManager}
   */
  getStateManager() {
    return _classPrivateFieldGet29(this, _stateManager);
  }
  /**
   * Gets a total number of headers levels.
   *
   * @private
   * @returns {number}
   */
  getLayersCount() {
    return _classPrivateFieldGet29(this, _stateManager).getLayersCount();
  }
  /**
   * Gets column settings for a specified header. The returned object contains
   * information about the header label, its colspan length, or if it is hidden
   * in the header renderers.
   *
   * @private
   * @param {number} headerLevel Header level (0 = most distant to the table).
   * @param {number} columnIndex A visual column index.
   * @returns {object}
   */
  getHeaderSettings(headerLevel, columnIndex) {
    return _classPrivateFieldGet29(this, _stateManager).getHeaderSettings(headerLevel, columnIndex);
  }
  /**
   * Clear the colspans remaining after plugin usage.
   *
   * @private
   */
  clearColspans() {
    if (!this.hot.view) {
      return;
    }
    const {
      _wt: wt
    } = this.hot.view;
    const headerLevels = wt.getSetting("columnHeaders").length;
    const mainHeaders = wt.wtTable.THEAD;
    const topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;
    const topLeftCornerHeaders = wt.wtOverlays.topInlineStartCornerOverlay ? wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;
    for (let i = 0; i < headerLevels; i++) {
      const masterLevel = mainHeaders.childNodes[i];
      if (!masterLevel) {
        break;
      }
      const topLevel = topHeaders.childNodes[i];
      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;
      for (let j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {
        masterLevel.childNodes[j].removeAttribute("colspan");
        removeClass(masterLevel.childNodes[j], "hiddenHeader");
        if (topLevel && topLevel.childNodes[j]) {
          topLevel.childNodes[j].removeAttribute("colspan");
          removeClass(topLevel.childNodes[j], "hiddenHeader");
        }
        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {
          topLeftCornerLevel.childNodes[j].removeAttribute("colspan");
          removeClass(topLeftCornerLevel.childNodes[j], "hiddenHeader");
        }
      }
    }
  }
  /**
   * Generates the appropriate header renderer for a header row.
   *
   * @private
   * @param {number} headerLevel The index of header level counting from the top (positive
   *                             values counting from 0 to N).
   * @returns {Function}
   * @fires Hooks#afterGetColHeader
   */
  headerRendererFactory(headerLevel) {
    var _this2 = this;
    const fixedColumnsStart = this.hot.view._wt.getSetting("fixedColumnsStart");
    return (renderedColumnIndex, TH) => {
      var _classPrivateFieldGet210;
      const {
        columnIndexMapper,
        view
      } = this.hot;
      let visualColumnIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);
      if (visualColumnIndex === null) {
        visualColumnIndex = renderedColumnIndex;
      }
      TH.removeAttribute("colspan");
      removeClass(TH, "hiddenHeader");
      const {
        colspan,
        isHidden,
        isPlaceholder
      } = (_classPrivateFieldGet210 = _classPrivateFieldGet29(this, _stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet210 !== void 0 ? _classPrivateFieldGet210 : {
        label: ""
      };
      if (isPlaceholder || isHidden) {
        addClass(TH, "hiddenHeader");
      } else if (colspan > 1) {
        var _wtOverlays$topInline, _wtOverlays$inlineSta;
        const {
          wtOverlays
        } = view._wt;
        const isTopInlineStartOverlay = (_wtOverlays$topInline = wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);
        const isInlineStartOverlay = (_wtOverlays$inlineSta = wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);
        const correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;
        if (correctedColspan > 1) {
          TH.setAttribute("colspan", correctedColspan);
        }
      }
      this.hot.view.appendColHeader(visualColumnIndex, TH, function() {
        return _this2.getColumnHeaderValue(...arguments);
      }, headerLevel);
    };
  }
  /**
   * Returns the column header value for specified column and header level index.
   *
   * @private
   * @param {number} visualColumnIndex Visual column index.
   * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)
   *                             and negative (-1 to -N) values. For positive values, 0 points to the
   *                             top most header, and for negative direction, -1 points to the most bottom
   *                             header (the header closest to the cells).
   * @returns {string} Returns the column header value to update.
   */
  getColumnHeaderValue(visualColumnIndex, headerLevel) {
    var _classPrivateFieldGet32;
    const {
      isHidden,
      isPlaceholder
    } = (_classPrivateFieldGet32 = _classPrivateFieldGet29(this, _stateManager).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet32 !== void 0 ? _classPrivateFieldGet32 : {};
    if (isPlaceholder || isHidden) {
      return "";
    }
    return this.hot.getColHeader(visualColumnIndex, headerLevel);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    _classPrivateFieldSet28(this, _stateManager, null);
    if (_classPrivateFieldGet29(this, _hidingIndexMapObserver) !== null) {
      _classPrivateFieldGet29(this, _hidingIndexMapObserver).unsubscribe();
      _classPrivateFieldSet28(this, _hidingIndexMapObserver, null);
    }
    super.destroy();
  }
  /**
   * Gets the tree data that belongs to the column headers pointed by the passed coordinates.
   *
   * @private
   * @param {CellCoords} coords The CellCoords instance.
   * @returns {object|undefined}
   */
  _getHeaderTreeNodeDataByCoords(coords) {
    if (coords.row >= 0 || coords.col < 0) {
      return;
    }
    return _classPrivateFieldGet29(this, _stateManager).getHeaderTreeNodeData(coords.row, coords.col);
  }
};
function _updateFocusHighlightPosition2() {
  var _this$hot;
  const selection = (_this$hot = this.hot) === null || _this$hot === void 0 ? void 0 : _this$hot.getSelectedRangeLast();
  if (!selection) {
    return;
  }
  const {
    highlight
  } = selection;
  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;
  if (isNestedHeadersRange) {
    const columnIndex = _classPrivateFieldGet29(this, _stateManager).findLeftMostColumnIndex(highlight.row, highlight.col);
    const focusHighlight = this.hot.selection.highlight.getFocus();
    focusHighlight.visualCellRange.highlight.col = columnIndex;
    focusHighlight.visualCellRange.from.col = columnIndex;
    focusHighlight.visualCellRange.to.col = columnIndex;
    focusHighlight.commit();
  }
}
function _onBeforeViewportScrollHorizontally2(visualColumn) {
  const selection = this.hot.getSelectedRangeLast();
  if (!selection) {
    return visualColumn;
  }
  const {
    highlight
  } = selection;
  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;
  if (!isNestedHeadersRange) {
    return visualColumn;
  }
  const firstColumn = this.hot.view.getFirstFullyVisibleColumn();
  const lastColumn = this.hot.view.getLastFullyVisibleColumn();
  const mostLeftColumnIndex = _classPrivateFieldGet29(this, _stateManager).findLeftMostColumnIndex(highlight.row, highlight.col);
  const mostRightColumnIndex = _classPrivateFieldGet29(this, _stateManager).findRightMostColumnIndex(highlight.row, highlight.col);
  if (mostLeftColumnIndex < firstColumn && mostRightColumnIndex > lastColumn) {
    return visualColumn;
  }
  return mostLeftColumnIndex < firstColumn ? mostLeftColumnIndex : mostRightColumnIndex;
}
function _onBeforeHighlightingColumnHeader2(visualColumn, headerLevel, highlightMeta) {
  const headerNodeData = _classPrivateFieldGet29(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumn);
  if (!headerNodeData) {
    return visualColumn;
  }
  const {
    columnCursor,
    selectionType,
    selectionWidth
  } = highlightMeta;
  const {
    isRoot,
    colspan
  } = _classPrivateFieldGet29(this, _stateManager).getHeaderSettings(headerLevel, visualColumn);
  if (selectionType === HEADER_TYPE) {
    if (!isRoot) {
      return headerNodeData.columnIndex;
    }
  } else if (selectionType === ACTIVE_HEADER_TYPE) {
    if (colspan > selectionWidth - columnCursor || !isRoot) {
      return null;
    }
  }
  return visualColumn;
}
function _onBeforeCopy2(data, copyableRanges, _ref2) {
  let {
    columnHeadersCount
  } = _ref2;
  if (columnHeadersCount === 0) {
    return;
  }
  for (let rangeIndex = 0; rangeIndex < copyableRanges.length; rangeIndex++) {
    const {
      startRow,
      startCol,
      endRow,
      endCol
    } = copyableRanges[rangeIndex];
    const rowsCount = endRow - startRow + 1;
    const columnsCount = startCol - endCol + 1;
    if (startRow >= 0 || columnsCount === 1) {
      break;
    }
    for (let column = startCol; column <= endCol; column++) {
      for (let row = startRow; row <= endRow; row++) {
        var _classPrivateFieldGet42;
        const zeroBasedColumnHeaderLevel = rowsCount + row;
        const zeroBasedColumnIndex = column - startCol;
        if (zeroBasedColumnIndex === 0) {
          continue;
        }
        const isRoot = (_classPrivateFieldGet42 = _classPrivateFieldGet29(this, _stateManager).getHeaderTreeNodeData(row, column)) === null || _classPrivateFieldGet42 === void 0 ? void 0 : _classPrivateFieldGet42.isRoot;
        if (isRoot === false) {
          data[zeroBasedColumnHeaderLevel][zeroBasedColumnIndex] = "";
        }
      }
    }
  }
}
function _onBeforeOnCellMouseDown25(event, coords, TD, controller) {
  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
  if (headerNodeData) {
    controller.column = true;
  }
}
function _onAfterOnCellMouseDown2(event, coords) {
  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
  if (!headerNodeData) {
    return;
  }
  _classPrivateFieldSet28(this, _focusInitialCoords, coords.clone());
  _classPrivateFieldSet28(this, _isColumnsSelectionInProgress, true);
  const {
    selection
  } = this.hot;
  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
  const columnsToSelect = [];
  const {
    columnIndex,
    origColspan
  } = headerNodeData;
  const allowRightClickSelection = !selection.inInSelection(coords);
  if (event.shiftKey && currentSelection) {
    if (coords.col < currentSelection.from.col) {
      columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, coords.row);
    } else if (coords.col > currentSelection.from.col) {
      columnsToSelect.push(currentSelection.getTopStartCorner().col, columnIndex + origColspan - 1, coords.row);
    } else {
      columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);
    }
  } else if (isLeftClick(event) || isRightClick(event) && allowRightClickSelection) {
    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);
  }
  selection.selectColumns(...columnsToSelect);
}
function _onBeforeOnCellMouseOver23(event, coords, TD, controller) {
  if (!this.hot.view.isMouseDown()) {
    return;
  }
  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);
  if (!headerNodeData) {
    return;
  }
  const {
    columnIndex,
    origColspan
  } = headerNodeData;
  const selectedRange = this.hot.getSelectedRangeLast();
  const topStartCoords = selectedRange.getTopStartCorner();
  const bottomEndCoords = selectedRange.getBottomEndCorner();
  const {
    from
  } = selectedRange;
  controller.column = true;
  controller.cell = true;
  const columnsToSelect = [];
  const headerLevel = clamp(coords.row, -Infinity, -1);
  if (coords.col < from.col) {
    columnsToSelect.push(bottomEndCoords.col, columnIndex, headerLevel);
  } else if (coords.col > from.col) {
    columnsToSelect.push(topStartCoords.col, columnIndex + origColspan - 1, headerLevel);
  } else {
    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, headerLevel);
  }
  this.hot.selection.selectColumns(...columnsToSelect);
}
function _onBeforeOnCellMouseUp2() {
  _classPrivateFieldSet28(this, _isColumnsSelectionInProgress, false);
}
function _onBeforeSelectionHighlightSet2() {
  const {
    navigableHeaders
  } = this.hot.getSettings();
  if (!this.hot.view.isMouseDown() || !_classPrivateFieldGet29(this, _isColumnsSelectionInProgress) || !navigableHeaders) {
    return;
  }
  const selectedRange = this.hot.getSelectedRangeLast();
  const columnStart = selectedRange.getTopStartCorner().col;
  const columnEnd = selectedRange.getBottomEndCorner().col;
  const {
    columnIndex,
    origColspan
  } = _classPrivateFieldGet29(this, _stateManager).getHeaderTreeNodeData(_classPrivateFieldGet29(this, _focusInitialCoords).row, _classPrivateFieldGet29(this, _focusInitialCoords).col);
  selectedRange.setHighlight(_classPrivateFieldGet29(this, _focusInitialCoords));
  if (origColspan > selectedRange.getWidth() || columnIndex < columnStart || columnIndex + origColspan - 1 > columnEnd) {
    const headerLevel = _classPrivateFieldGet29(this, _stateManager).findTopMostEntireHeaderLevel(clamp(columnStart, columnIndex, columnIndex + origColspan - 1), clamp(columnEnd, columnIndex, columnIndex + origColspan - 1));
    selectedRange.highlight.row = headerLevel;
    selectedRange.highlight.col = selectedRange.from.col;
  }
}
function _onModifyTransformStart22(delta) {
  const {
    highlight
  } = this.hot.getSelectedRangeLast();
  const nextCoords = this.hot._createCellCoords(highlight.row + delta.row, highlight.col + delta.col);
  const isNestedHeadersRange = nextCoords.isHeader() && nextCoords.col >= 0;
  if (!isNestedHeadersRange) {
    return;
  }
  const visualColumnIndexStart = _classPrivateFieldGet29(this, _stateManager).findLeftMostColumnIndex(nextCoords.row, nextCoords.col);
  const visualColumnIndexEnd = _classPrivateFieldGet29(this, _stateManager).findRightMostColumnIndex(nextCoords.row, nextCoords.col);
  if (delta.col < 0) {
    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexStart - 1 : visualColumnIndexEnd;
    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);
    if (notHiddenColumnIndex === null) {
      delta.col = -this.hot.view.countRenderableColumnsInRange(0, highlight.col);
    } else {
      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, highlight.col) - 1, 1);
    }
  } else if (delta.col > 0) {
    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexEnd + 1 : visualColumnIndexStart;
    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);
    if (notHiddenColumnIndex === null) {
      delta.col = this.hot.view.countRenderableColumnsInRange(highlight.col, this.hot.countCols());
    } else {
      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(highlight.col, notHiddenColumnIndex) - 1, 1);
    }
  }
}
function _onBeforeSelectColumns2(from, to) {
  const headerLevel = from.row;
  const startNodeData = this._getHeaderTreeNodeDataByCoords({
    row: headerLevel,
    col: from.col
  });
  const endNodeData = this._getHeaderTreeNodeDataByCoords({
    row: headerLevel,
    col: to.col
  });
  if (to.col < from.col) {
    if (startNodeData) {
      from.col = startNodeData.columnIndex + startNodeData.origColspan - 1;
    }
    if (endNodeData) {
      to.col = endNodeData.columnIndex;
    }
  } else if (to.col >= from.col) {
    if (startNodeData) {
      from.col = startNodeData.columnIndex;
    }
    if (endNodeData) {
      to.col = endNodeData.columnIndex + endNodeData.origColspan - 1;
    }
  }
}
function _onAfterGetColumnHeaderRenderers2(renderersArray) {
  renderersArray.length = 0;
  for (let headerLayer = 0; headerLayer < _classPrivateFieldGet29(this, _stateManager).getLayersCount(); headerLayer++) {
    renderersArray.push(this.headerRendererFactory(headerLayer));
  }
}
function _onAfterViewportColumnCalculatorOverride22(calc) {
  const headerLayersCount = _classPrivateFieldGet29(this, _stateManager).getLayersCount();
  let newStartColumn = calc.startColumn;
  let nonRenderable = !!headerLayersCount;
  for (let headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {
    const startColumn = _classPrivateFieldGet29(this, _stateManager).findLeftMostColumnIndex(headerLayer, calc.startColumn);
    const renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);
    if (startColumn >= 0) {
      nonRenderable = false;
    }
    if (isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) {
      newStartColumn = renderedStartColumn;
      break;
    }
  }
  calc.startColumn = nonRenderable ? _classPrivateFieldGet29(this, _stateManager).getHeaderTreeNodeData(0, newStartColumn).columnIndex : newStartColumn;
}
function _onModifyColWidth23(width, column) {
  const cachedWidth = this.ghostTable.getWidth(column);
  return width > cachedWidth ? width : cachedWidth;
}
function _onModifyColumnHeaderValue2(value, visualColumnIndex, headerLevel) {
  var _classPrivateFieldGet52;
  const {
    label
  } = (_classPrivateFieldGet52 = _classPrivateFieldGet29(this, _stateManager).getHeaderTreeNodeData(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet52 !== void 0 ? _classPrivateFieldGet52 : {
    label: ""
  };
  return label;
}
function _onModifyFocusedElement2(row, column) {
  if (row < 0) {
    return this.hot.getCell(row, _classPrivateFieldGet29(this, _stateManager).findLeftMostColumnIndex(row, column), true);
  }
}
function _onInit22() {
  this.updatePlugin();
}
function _onAfterLoadData28(sourceData, initialLoad) {
  if (!initialLoad) {
    this.updatePlugin();
  }
}

// node_modules/handsontable/plugins/nestedRows/data/dataManager.mjs
function _defineProperty50(obj, key, value) {
  key = _toPropertyKey50(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey50(arg) {
  var key = _toPrimitive50(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive50(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var DataManager = class {
  constructor(nestedRowsPlugin, hotInstance) {
    _defineProperty50(this, "hot", void 0);
    _defineProperty50(this, "data", null);
    _defineProperty50(this, "plugin", void 0);
    _defineProperty50(this, "parentReference", /* @__PURE__ */ new WeakMap());
    _defineProperty50(this, "cache", {
      levels: [],
      levelCount: 0,
      rows: [],
      nodeInfo: /* @__PURE__ */ new WeakMap()
    });
    this.hot = hotInstance;
    this.plugin = nestedRowsPlugin;
  }
  /**
   * Set the data for the manager.
   *
   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.
   */
  setData(data) {
    this.data = data;
  }
  /**
   * Get the data cached in the manager.
   *
   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}
   */
  getData() {
    return this.data;
  }
  /**
   * Load the "raw" source data, without NestedRows' modifications.
   *
   * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}
   */
  getRawSourceData() {
    let rawSourceData = null;
    this.plugin.disableCoreAPIModifiers();
    rawSourceData = this.hot.getSourceData();
    this.plugin.enableCoreAPIModifiers();
    return rawSourceData;
  }
  /**
   * Update the Data Manager with new data and refresh cache.
   *
   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.
   */
  updateWithData(data) {
    this.setData(data);
    this.rewriteCache();
  }
  /**
   * Rewrite the nested structure cache.
   *
   * @private
   */
  rewriteCache() {
    this.cache = {
      levels: [],
      levelCount: 0,
      rows: [],
      nodeInfo: /* @__PURE__ */ new WeakMap()
    };
    rangeEach(0, this.data.length - 1, (i) => {
      this.cacheNode(this.data[i], 0, null);
    });
  }
  /**
   * Cache a data node.
   *
   * @private
   * @param {object} node Node to cache.
   * @param {number} level Level of the node.
   * @param {object} parent Parent of the node.
   */
  cacheNode(node, level, parent) {
    if (!this.cache.levels[level]) {
      this.cache.levels[level] = [];
      this.cache.levelCount += 1;
    }
    this.cache.levels[level].push(node);
    this.cache.rows.push(node);
    this.cache.nodeInfo.set(node, {
      parent,
      row: this.cache.rows.length - 1,
      level
    });
    if (this.hasChildren(node)) {
      arrayEach(node.__children, (elem) => {
        this.cacheNode(elem, level + 1, node);
      });
    }
  }
  /**
   * Get the date for the provided visual row number.
   *
   * @param {number} row Row index.
   * @returns {object}
   */
  getDataObject(row) {
    return row === null || row === void 0 ? null : this.cache.rows[row];
  }
  /**
   * Read the row tree in search for a specific row index or row object.
   *
   * @private
   * @param {object} parent The initial parent object.
   * @param {number} readCount Number of read nodes.
   * @param {number} neededIndex The row index we search for.
   * @param {object} neededObject The row object we search for.
   * @returns {number|object}
   */
  readTreeNodes(parent, readCount, neededIndex, neededObject) {
    let rootLevel = false;
    let readNodesCount = readCount;
    if (isNaN(readNodesCount) && readNodesCount.end) {
      return readNodesCount;
    }
    let parentObj = parent;
    if (!parentObj) {
      parentObj = {
        __children: this.data
      };
      rootLevel = true;
      readNodesCount -= 1;
    }
    if (neededIndex !== null && neededIndex !== void 0 && readNodesCount === neededIndex) {
      return {
        result: parentObj,
        end: true
      };
    }
    if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {
      return {
        result: readNodesCount,
        end: true
      };
    }
    readNodesCount += 1;
    if (parentObj.__children) {
      arrayEach(parentObj.__children, (val) => {
        this.parentReference.set(val, rootLevel ? null : parentObj);
        readNodesCount = this.readTreeNodes(val, readNodesCount, neededIndex, neededObject);
        if (isNaN(readNodesCount) && readNodesCount.end) {
          return false;
        }
      });
    }
    return readNodesCount;
  }
  /**
   * Mock a parent node.
   *
   * @private
   * @returns {*}
   */
  mockParent() {
    const fakeParent = this.mockNode();
    fakeParent.__children = this.data;
    return fakeParent;
  }
  /**
   * Mock a data node.
   *
   * @private
   * @returns {{}}
   */
  mockNode() {
    const fakeNode = {};
    objectEach(this.data[0], (val, key) => {
      fakeNode[key] = null;
    });
    return fakeNode;
  }
  /**
   * Get the row index for the provided row object.
   *
   * @param {object} rowObj The row object.
   * @returns {number} Row index.
   */
  getRowIndex(rowObj) {
    return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;
  }
  /**
   * Get the index of the provided row index/row object within its parent.
   *
   * @param {number|object} row Row index / row object.
   * @returns {number}
   */
  getRowIndexWithinParent(row) {
    let rowObj = null;
    if (isNaN(row)) {
      rowObj = row;
    } else {
      rowObj = this.getDataObject(row);
    }
    const parent = this.getRowParent(row);
    if (parent === null || parent === void 0) {
      return this.data.indexOf(rowObj);
    }
    return parent.__children.indexOf(rowObj);
  }
  /**
   * Count all rows (including all parents and children).
   *
   * @returns {number}
   */
  countAllRows() {
    const rootNodeMock = {
      __children: this.data
    };
    return this.countChildren(rootNodeMock);
  }
  /**
   * Count children of the provided parent.
   *
   * @param {object|number} parent Parent node.
   * @returns {number} Children count.
   */
  countChildren(parent) {
    let rowCount = 0;
    let parentNode = parent;
    if (!isNaN(parentNode)) {
      parentNode = this.getDataObject(parentNode);
    }
    if (!parentNode || !parentNode.__children) {
      return 0;
    }
    arrayEach(parentNode.__children, (elem) => {
      rowCount += 1;
      if (elem.__children) {
        rowCount += this.countChildren(elem);
      }
    });
    return rowCount;
  }
  /**
   * Get the parent of the row at the provided index.
   *
   * @param {number|object} row Physical row index.
   * @returns {object}
   */
  getRowParent(row) {
    let rowObject;
    if (isNaN(row)) {
      rowObject = row;
    } else {
      rowObject = this.getDataObject(row);
    }
    return this.getRowObjectParent(rowObject);
  }
  /**
   * Get the parent of the provided row object.
   *
   * @private
   * @param {object} rowObject The row object (tree node).
   * @returns {object|null}
   */
  getRowObjectParent(rowObject) {
    if (!rowObject || typeof rowObject !== "object") {
      return null;
    }
    return this.cache.nodeInfo.get(rowObject).parent;
  }
  /**
   * Get the nesting level for the row with the provided row index.
   *
   * @param {number} row Row index.
   * @returns {number|null} Row level or null, when row doesn't exist.
   */
  getRowLevel(row) {
    let rowObject = null;
    if (isNaN(row)) {
      rowObject = row;
    } else {
      rowObject = this.getDataObject(row);
    }
    return rowObject ? this.getRowObjectLevel(rowObject) : null;
  }
  /**
   * Get the nesting level for the row with the provided row index.
   *
   * @private
   * @param {object} rowObject Row object.
   * @returns {number} Row level.
   */
  getRowObjectLevel(rowObject) {
    return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;
  }
  /**
   * Check if the provided row/row element has children.
   *
   * @param {number|object} row Row number or row element.
   * @returns {boolean}
   */
  hasChildren(row) {
    let rowObj = row;
    if (!isNaN(rowObj)) {
      rowObj = this.getDataObject(rowObj);
    }
    return !!(rowObj.__children && rowObj.__children.length);
  }
  /**
   * Returns `true` if the row at the provided index has a parent.
   *
   * @param {number} index Row index.
   * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.
   */
  isChild(index) {
    return this.getRowParent(index) !== null;
  }
  /**
   * Get child at a provided index from the parent element.
   *
   * @param {object} parent The parent row object.
   * @param {number} index Index of the child element to be retrieved.
   * @returns {object|null} The child element or `null` if the child doesn't exist.
   */
  getChild(parent, index) {
    var _parent$__children;
    return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;
  }
  /**
   * Return `true` of the row at the provided index is located at the topmost level.
   *
   * @param {number} index Row index.
   * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.
   */
  isRowHighestLevel(index) {
    return !this.isChild(index);
  }
  /**
   * Return `true` if the provided row index / row object represents a parent in the nested structure.
   *
   * @param {number|object} row Row index / row object.
   * @returns {boolean} `true` if the row is a parent, `false` otherwise.
   */
  isParent(row) {
    var _rowObj$__children;
    let rowObj = row;
    if (!isNaN(rowObj)) {
      rowObj = this.getDataObject(rowObj);
    }
    return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;
  }
  /**
   * Add a child to the provided parent. It's optional to add a row object as the "element".
   *
   * @param {object} parent The parent row object.
   * @param {object} [element] The element to add as a child.
   */
  addChild(parent, element) {
    let childElement = element;
    this.hot.runHooks("beforeAddChild", parent, childElement);
    let parentIndex = null;
    if (parent) {
      parentIndex = this.getRowIndex(parent);
    }
    this.hot.runHooks("beforeCreateRow", parentIndex + this.countChildren(parent) + 1, 1);
    let functionalParent = parent;
    if (!parent) {
      functionalParent = this.mockParent();
    }
    if (!functionalParent.__children) {
      functionalParent.__children = [];
    }
    if (!childElement) {
      childElement = this.mockNode();
    }
    functionalParent.__children.push(childElement);
    this.rewriteCache();
    const newRowIndex = this.getRowIndex(childElement);
    this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);
    this.hot.runHooks("afterCreateRow", newRowIndex, 1);
    this.hot.runHooks("afterAddChild", parent, childElement);
  }
  /**
   * Add a child node to the provided parent at a specified index.
   *
   * @param {object} parent Parent node.
   * @param {number} index Index to insert the child element at.
   * @param {object} [element] Element (node) to insert.
   */
  addChildAtIndex(parent, index, element) {
    let childElement = element;
    let flattenedIndex;
    if (!childElement) {
      childElement = this.mockNode();
    }
    this.hot.runHooks("beforeAddChild", parent, childElement, index);
    if (parent) {
      const parentIndex = this.getRowIndex(parent);
      const finalChildIndex = parentIndex + index + 1;
      this.hot.runHooks("beforeCreateRow", finalChildIndex, 1);
      parent.__children.splice(index, null, childElement);
      this.rewriteCache();
      this.plugin.disableCoreAPIModifiers();
      this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), "__children", parent.__children, "NestedRows.addChildAtIndex");
      this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);
      this.plugin.enableCoreAPIModifiers();
      this.hot.runHooks("afterCreateRow", finalChildIndex, 1);
      flattenedIndex = finalChildIndex;
    } else {
      this.plugin.disableCoreAPIModifiers();
      this.hot.alter("insert_row_above", index, 1, "NestedRows.addChildAtIndex");
      this.plugin.enableCoreAPIModifiers();
      flattenedIndex = this.getRowIndex(this.data[index]);
    }
    childElement = this.getDataObject(flattenedIndex);
    this.hot.runHooks("afterAddChild", parent, childElement, index);
  }
  /**
   * Add a sibling element at the specified index.
   *
   * @param {number} index New element sibling's index.
   * @param {('above'|'below')} where Direction in which the sibling is to be created.
   */
  addSibling(index) {
    let where = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "below";
    const translatedIndex = this.translateTrimmedRow(index);
    const parent = this.getRowParent(translatedIndex);
    const indexWithinParent = this.getRowIndexWithinParent(translatedIndex);
    switch (where) {
      case "below":
        this.addChildAtIndex(parent, indexWithinParent + 1, null);
        break;
      case "above":
        this.addChildAtIndex(parent, indexWithinParent, null);
        break;
      default:
        break;
    }
  }
  /**
   * Detach the provided element from its parent and add it right after it.
   *
   * @param {object|Array} elements Row object or an array of selected coordinates.
   * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.
   */
  detachFromParent(elements) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let element = null;
    const rowObjects = [];
    if (Array.isArray(elements)) {
      rangeEach(elements[0], elements[2], (i) => {
        const translatedIndex = this.translateTrimmedRow(i);
        rowObjects.push(this.getDataObject(translatedIndex));
      });
      rangeEach(0, rowObjects.length - 2, (i) => {
        this.detachFromParent(rowObjects[i], false);
      });
      element = rowObjects[rowObjects.length - 1];
    } else {
      element = elements;
    }
    const childRowIndex = this.getRowIndex(element);
    const childCount = this.countChildren(element);
    const indexWithinParent = this.getRowIndexWithinParent(element);
    const parent = this.getRowParent(element);
    const grandparent = this.getRowParent(parent);
    const grandparentRowIndex = this.getRowIndex(grandparent);
    let movedElementRowIndex = null;
    this.hot.runHooks("beforeDetachChild", parent, element);
    if (indexWithinParent !== null && indexWithinParent !== void 0) {
      const removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));
      this.hot.runHooks("beforeRemoveRow", childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);
      parent.__children.splice(indexWithinParent, 1);
      this.rewriteCache();
      this.hot.runHooks("afterRemoveRow", childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);
      if (grandparent) {
        movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);
        const lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);
        const lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);
        this.hot.runHooks("beforeCreateRow", lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);
        grandparent.__children.push(element);
      } else {
        movedElementRowIndex = this.hot.countRows() + 1;
        this.hot.runHooks("beforeCreateRow", movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);
        this.data.push(element);
      }
    }
    this.rewriteCache();
    this.hot.runHooks("afterCreateRow", movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);
    this.hot.runHooks("afterDetachChild", parent, element, this.getRowIndex(element));
    if (forceRender) {
      this.hot.render();
    }
  }
  /**
   * Filter the data by the `logicRows` array.
   *
   * @private
   * @param {number} index Index of the first row to remove.
   * @param {number} amount Number of elements to remove.
   * @param {Array} logicRows Array of indexes to remove.
   */
  filterData(index, amount, logicRows) {
    const elementsToRemove = [];
    arrayEach(logicRows, (elem) => {
      elementsToRemove.push(this.getDataObject(elem));
    });
    arrayEach(elementsToRemove, (elem) => {
      const indexWithinParent = this.getRowIndexWithinParent(elem);
      const tempParent = this.getRowParent(elem);
      if (tempParent === null) {
        this.data.splice(indexWithinParent, 1);
      } else {
        tempParent.__children.splice(indexWithinParent, 1);
      }
    });
    this.rewriteCache();
  }
  /**
   * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the
   * default script.
   *
   * @private
   * @param {number} index Physical index of the element at the splice beginning.
   * @param {number} amount Number of elements to be removed.
   * @param {object[]} elements Array of row objects to add.
   */
  spliceData(index, amount, elements) {
    const previousElement = this.getDataObject(index - 1);
    let newRowParent = null;
    let indexWithinParent = index;
    if (previousElement && previousElement.__children && previousElement.__children.length === 0) {
      newRowParent = previousElement;
      indexWithinParent = 0;
    } else if (index < this.countAllRows()) {
      newRowParent = this.getRowParent(index);
      indexWithinParent = this.getRowIndexWithinParent(index);
    }
    if (newRowParent) {
      if (elements) {
        newRowParent.__children.splice(indexWithinParent, amount, ...elements);
      } else {
        newRowParent.__children.splice(indexWithinParent, amount);
      }
    } else if (elements) {
      this.data.splice(indexWithinParent, amount, ...elements);
    } else {
      this.data.splice(indexWithinParent, amount);
    }
    this.rewriteCache();
  }
  /**
   * Update the `__children` key of the upmost parent of the provided row object.
   *
   * @private
   * @param {object} rowElement Row object.
   */
  syncRowWithRawSource(rowElement) {
    let upmostParent = rowElement;
    let tempParent = null;
    do {
      tempParent = this.getRowParent(tempParent);
      if (tempParent !== null) {
        upmostParent = tempParent;
      }
    } while (tempParent !== null);
    this.plugin.disableCoreAPIModifiers();
    this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), "__children", upmostParent.__children, "NestedRows.syncRowWithRawSource");
    this.plugin.enableCoreAPIModifiers();
  }
  /* eslint-disable jsdoc/require-param */
  /**
   * Move a single row.
   *
   * @param {number} fromIndex Index of the row to be moved.
   * @param {number} toIndex Index of the destination.
   * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.
   * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.
   */
  /* eslint-enable jsdoc/require-param */
  moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {
    const moveToLastRow = toIndex === this.hot.countRows();
    const fromParent = this.getRowParent(fromIndex);
    const indexInFromParent = this.getRowIndexWithinParent(fromIndex);
    const elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);
    const movingUp = fromIndex > toIndex;
    let toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);
    if (toParent === null || toParent === void 0) {
      toParent = this.getRowParent(toIndex - 1);
    }
    if (toParent === null || toParent === void 0) {
      toParent = this.getDataObject(toIndex - 1);
    }
    if (!toParent) {
      toParent = this.getDataObject(toIndex);
      toParent.__children = [];
    } else if (!toParent.__children) {
      toParent.__children = [];
    }
    const indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);
    const sameParent = fromParent === toParent;
    toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);
    fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1);
    this.syncRowWithRawSource(fromParent);
    if (!sameParent) {
      this.syncRowWithRawSource(toParent);
    }
  }
  /**
   * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number}
   */
  translateTrimmedRow(row) {
    if (this.plugin.collapsingUI) {
      return this.plugin.collapsingUI.translateTrimmedRow(row);
    }
    return row;
  }
  /**
   * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number}
   */
  untranslateTrimmedRow(row) {
    if (this.plugin.collapsingUI) {
      return this.plugin.collapsingUI.untranslateTrimmedRow(row);
    }
    return row;
  }
};
var dataManager_default = DataManager;

// node_modules/handsontable/plugins/nestedRows/ui/_base.mjs
function _defineProperty51(obj, key, value) {
  key = _toPropertyKey51(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey51(arg) {
  var key = _toPrimitive51(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive51(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var BaseUI4 = class {
  constructor(pluginInstance, hotInstance) {
    _defineProperty51(this, "hot", void 0);
    _defineProperty51(this, "plugin", void 0);
    this.hot = hotInstance;
    this.plugin = pluginInstance;
  }
};
var base_default4 = BaseUI4;

// node_modules/handsontable/plugins/nestedRows/ui/headers.mjs
var HeadersUI = class _HeadersUI extends base_default4 {
  /**
   * CSS classes used in the row headers.
   *
   * @type {object}
   */
  static get CSS_CLASSES() {
    return {
      indicatorContainer: "ht_nestingLevels",
      parent: "ht_nestingParent",
      indicator: "ht_nestingLevel",
      emptyIndicator: "ht_nestingLevel_empty",
      button: "ht_nestingButton",
      expandButton: "ht_nestingExpand",
      collapseButton: "ht_nestingCollapse"
    };
  }
  constructor(nestedRowsPlugin, hotInstance) {
    super(nestedRowsPlugin, hotInstance);
    this.dataManager = this.plugin.dataManager;
    this.collapsingUI = this.plugin.collapsingUI;
    this.rowHeaderWidthCache = null;
  }
  /**
   * Append nesting indicators and buttons to the row headers.
   *
   * @private
   * @param {number} row Row index.
   * @param {HTMLElement} TH TH 3element.
   */
  appendLevelIndicators(row, TH) {
    const rowIndex = this.hot.toPhysicalRow(row);
    const rowLevel = this.dataManager.getRowLevel(rowIndex);
    const rowObject = this.dataManager.getDataObject(rowIndex);
    const innerDiv = TH.getElementsByTagName("DIV")[0];
    const innerSpan = innerDiv.querySelector("span.rowHeader");
    const previousIndicators = innerDiv.querySelectorAll('[class^="ht_nesting"]');
    const ariaEnabled = this.hot.getSettings().ariaTags;
    arrayEach(previousIndicators, (elem) => {
      if (elem) {
        innerDiv.removeChild(elem);
      }
    });
    addClass(TH, _HeadersUI.CSS_CLASSES.indicatorContainer);
    if (rowLevel) {
      const {
        rootDocument
      } = this.hot;
      const initialContent = innerSpan.cloneNode(true);
      innerDiv.innerHTML = "";
      rangeEach(0, rowLevel - 1, () => {
        const levelIndicator = rootDocument.createElement("SPAN");
        addClass(levelIndicator, _HeadersUI.CSS_CLASSES.emptyIndicator);
        innerDiv.appendChild(levelIndicator);
      });
      innerDiv.appendChild(initialContent);
    }
    if (this.dataManager.hasChildren(rowObject)) {
      const buttonsContainer = this.hot.rootDocument.createElement("DIV");
      if (ariaEnabled) {
        setAttribute(buttonsContainer, [A11Y_HIDDEN()]);
      }
      addClass(TH, _HeadersUI.CSS_CLASSES.parent);
      if (this.collapsingUI.areChildrenCollapsed(rowIndex)) {
        addClass(buttonsContainer, `${_HeadersUI.CSS_CLASSES.button} ${_HeadersUI.CSS_CLASSES.expandButton}`);
        if (ariaEnabled) {
          setAttribute(TH, [A11Y_EXPANDED(false)]);
        }
      } else {
        addClass(buttonsContainer, `${_HeadersUI.CSS_CLASSES.button} ${_HeadersUI.CSS_CLASSES.collapseButton}`);
        if (ariaEnabled) {
          setAttribute(TH, [A11Y_EXPANDED(true)]);
        }
      }
      innerDiv.appendChild(buttonsContainer);
    }
  }
  /**
   * Update the row header width according to number of levels in the dataset.
   *
   * @private
   * @param {number} deepestLevel Cached deepest level of nesting.
   */
  updateRowHeaderWidth(deepestLevel) {
    let deepestLevelIndex = deepestLevel;
    if (!deepestLevelIndex) {
      deepestLevelIndex = this.dataManager.cache.levelCount;
    }
    this.rowHeaderWidthCache = Math.max(50, 11 + 10 * deepestLevelIndex + 25);
    this.hot.render();
  }
};
var headers_default = HeadersUI;

// node_modules/handsontable/plugins/nestedRows/ui/collapsing.mjs
var CollapsingUI = class extends base_default4 {
  constructor(nestedRowsPlugin, hotInstance) {
    var _this;
    super(nestedRowsPlugin, hotInstance);
    _this = this;
    this.dataManager = this.plugin.dataManager;
    this.collapsedRows = [];
    this.collapsedRowsStash = {
      stash: function() {
        let forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        _this.lastCollapsedRows = _this.collapsedRows.slice(0);
        _this.expandMultipleChildren(_this.lastCollapsedRows, forceRender);
      },
      shiftStash: function(baseIndex, targetIndex) {
        let delta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        if (targetIndex === null || targetIndex === void 0) {
          targetIndex = Infinity;
        }
        arrayEach(_this.lastCollapsedRows, (elem, i) => {
          if (elem >= baseIndex && elem < targetIndex) {
            _this.lastCollapsedRows[i] = elem + delta;
          }
        });
      },
      applyStash: function() {
        let forceRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        _this.collapseMultipleChildren(_this.lastCollapsedRows, forceRender);
        _this.lastCollapsedRows = void 0;
      },
      trimStash: (realElementIndex, amount) => {
        rangeEach(realElementIndex, realElementIndex + amount - 1, (i) => {
          const indexOfElement = this.lastCollapsedRows.indexOf(i);
          if (indexOfElement > -1) {
            this.lastCollapsedRows.splice(indexOfElement, 1);
          }
        });
      }
    };
  }
  /**
   * Collapse the children of the row passed as an argument.
   *
   * @param {number|object} row The parent row.
   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   * @returns {Array}
   */
  collapseChildren(row) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const rowsToCollapse = [];
    let rowObject = null;
    let rowIndex = null;
    let rowsToTrim = null;
    if (isNaN(row)) {
      rowObject = row;
      rowIndex = this.dataManager.getRowIndex(rowObject);
    } else {
      rowObject = this.dataManager.getDataObject(row);
      rowIndex = row;
    }
    if (this.dataManager.hasChildren(rowObject)) {
      arrayEach(rowObject.__children, (elem) => {
        rowsToCollapse.push(this.dataManager.getRowIndex(elem));
      });
    }
    rowsToTrim = this.collapseRows(rowsToCollapse, true, false);
    if (doTrimming) {
      this.trimRows(rowsToTrim);
    }
    if (forceRender) {
      this.renderAndAdjust();
    }
    if (this.collapsedRows.indexOf(rowIndex) === -1) {
      this.collapsedRows.push(rowIndex);
    }
    return rowsToTrim;
  }
  /**
   * Collapse multiple children.
   *
   * @param {Array} rows Rows to collapse (including their children).
   * @param {boolean} [forceRender=true] `true` if the table should be rendered after finishing the function.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   */
  collapseMultipleChildren(rows) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const rowsToTrim = [];
    arrayEach(rows, (elem) => {
      rowsToTrim.push(...this.collapseChildren(elem, false, false));
    });
    if (doTrimming) {
      this.trimRows(rowsToTrim);
    }
    if (forceRender) {
      this.renderAndAdjust();
    }
  }
  /**
   * Collapse a single row.
   *
   * @param {number} rowIndex Index of the row to collapse.
   * @param {boolean} [recursive=true] `true` if it should collapse the row's children.
   */
  collapseRow(rowIndex) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    this.collapseRows([rowIndex], recursive);
  }
  /**
   * Collapse multiple rows.
   *
   * @param {Array} rowIndexes Array of row indexes to collapse.
   * @param {boolean} [recursive=true] `true` if it should collapse the rows' children.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   * @returns {Array} Rows prepared for trimming (or trimmed, if doTrimming == true).
   */
  collapseRows(rowIndexes) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const rowsToTrim = [];
    arrayEach(rowIndexes, (elem) => {
      rowsToTrim.push(elem);
      if (recursive) {
        this.collapseChildRows(elem, rowsToTrim);
      }
    });
    if (doTrimming) {
      this.trimRows(rowsToTrim);
    }
    return rowsToTrim;
  }
  /**
   * Collapse child rows of the row at the provided index.
   *
   * @param {number} parentIndex Index of the parent node.
   * @param {Array} [rowsToTrim=[]] Array of rows to trim. Defaults to an empty array.
   * @param {boolean} [recursive] `true` if the collapsing process should be recursive.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   */
  collapseChildRows(parentIndex) {
    let rowsToTrim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let recursive = arguments.length > 2 ? arguments[2] : void 0;
    let doTrimming = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (this.dataManager.hasChildren(parentIndex)) {
      const parentObject = this.dataManager.getDataObject(parentIndex);
      arrayEach(parentObject.__children, (elem) => {
        const elemIndex = this.dataManager.getRowIndex(elem);
        rowsToTrim.push(elemIndex);
        this.collapseChildRows(elemIndex, rowsToTrim);
      });
    }
    if (doTrimming) {
      this.trimRows(rowsToTrim);
    }
  }
  /**
   * Expand a single row.
   *
   * @param {number} rowIndex Index of the row to expand.
   * @param {boolean} [recursive=true] `true` if it should expand the row's children recursively.
   */
  expandRow(rowIndex) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    this.expandRows([rowIndex], recursive);
  }
  /**
   * Expand multiple rows.
   *
   * @param {Array} rowIndexes Array of indexes of the rows to expand.
   * @param {boolean} [recursive=true] `true` if it should expand the rows' children recursively.
   * @param {boolean} [doTrimming=true] I determine whether collapsing should envolve trimming rows.
   * @returns {Array} Array of row indexes to be untrimmed.
   */
  expandRows(rowIndexes) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const rowsToUntrim = [];
    arrayEach(rowIndexes, (elem) => {
      rowsToUntrim.push(elem);
      if (recursive) {
        this.expandChildRows(elem, rowsToUntrim);
      }
    });
    if (doTrimming) {
      this.untrimRows(rowsToUntrim);
    }
    return rowsToUntrim;
  }
  /**
   * Expand child rows of the provided index.
   *
   * @param {number} parentIndex Index of the parent row.
   * @param {Array} [rowsToUntrim=[]] Array of the rows to be untrimmed.
   * @param {boolean} [recursive] `true` if it should expand the rows' children recursively.
   * @param {boolean} [doTrimming=false] I determine whether collapsing should envolve trimming rows.
   */
  expandChildRows(parentIndex) {
    let rowsToUntrim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let recursive = arguments.length > 2 ? arguments[2] : void 0;
    let doTrimming = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (this.dataManager.hasChildren(parentIndex)) {
      const parentObject = this.dataManager.getDataObject(parentIndex);
      arrayEach(parentObject.__children, (elem) => {
        if (!this.isAnyParentCollapsed(elem)) {
          const elemIndex = this.dataManager.getRowIndex(elem);
          rowsToUntrim.push(elemIndex);
          this.expandChildRows(elemIndex, rowsToUntrim);
        }
      });
    }
    if (doTrimming) {
      this.untrimRows(rowsToUntrim);
    }
  }
  /**
   * Expand the children of the row passed as an argument.
   *
   * @param {number|object} row Parent row.
   * @param {boolean} [forceRender=true] Whether to render the table after the function ends.
   * @param {boolean} [doTrimming=true] If set to `true`, the trimming will be applied when the function finishes.
   * @returns {number[]}
   */
  expandChildren(row) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const rowsToExpand = [];
    let rowObject = null;
    let rowIndex = null;
    let rowsToUntrim = null;
    if (isNaN(row)) {
      rowObject = row;
      rowIndex = this.dataManager.getRowIndex(row);
    } else {
      rowObject = this.dataManager.getDataObject(row);
      rowIndex = row;
    }
    this.collapsedRows.splice(this.collapsedRows.indexOf(rowIndex), 1);
    if (this.dataManager.hasChildren(rowObject)) {
      arrayEach(rowObject.__children, (elem) => {
        const childIndex = this.dataManager.getRowIndex(elem);
        rowsToExpand.push(childIndex);
      });
    }
    rowsToUntrim = this.expandRows(rowsToExpand, true, false);
    if (doTrimming) {
      this.untrimRows(rowsToUntrim);
    }
    if (forceRender) {
      this.renderAndAdjust();
    }
    return rowsToUntrim;
  }
  /**
   * Expand multiple rows' children.
   *
   * @param {Array} rows Array of rows which children are about to be expanded.
   * @param {boolean} [forceRender=true] `true` if the table should render after finishing the function.
   * @param {boolean} [doTrimming=true] `true` if the rows should be untrimmed after finishing the function.
   */
  expandMultipleChildren(rows) {
    let forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let doTrimming = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const rowsToUntrim = [];
    arrayEach(rows, (elem) => {
      rowsToUntrim.push(...this.expandChildren(elem, false, false));
    });
    if (doTrimming) {
      this.untrimRows(rowsToUntrim);
    }
    if (forceRender) {
      this.renderAndAdjust();
    }
  }
  /**
   * Collapse all collapsable rows.
   */
  collapseAll() {
    const data = this.dataManager.getData();
    const parentsToCollapse = [];
    arrayEach(data, (elem) => {
      if (this.dataManager.hasChildren(elem)) {
        parentsToCollapse.push(elem);
      }
    });
    this.collapseMultipleChildren(parentsToCollapse);
    this.renderAndAdjust();
  }
  /**
   * Expand all collapsable rows.
   */
  expandAll() {
    const data = this.dataManager.getData();
    const parentsToExpand = [];
    arrayEach(data, (elem) => {
      if (this.dataManager.hasChildren(elem)) {
        parentsToExpand.push(elem);
      }
    });
    this.expandMultipleChildren(parentsToExpand);
    this.renderAndAdjust();
  }
  /**
   * Trim rows.
   *
   * @param {Array} rows Physical row indexes.
   */
  trimRows(rows) {
    this.hot.batchExecution(() => {
      arrayEach(rows, (physicalRow) => {
        this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, true);
      });
    }, true);
  }
  /**
   * Untrim rows.
   *
   * @param {Array} rows Physical row indexes.
   */
  untrimRows(rows) {
    this.hot.batchExecution(() => {
      arrayEach(rows, (physicalRow) => {
        this.plugin.collapsedRowsMap.setValueAtIndex(physicalRow, false);
      });
    }, true);
  }
  /**
   * Check if all child rows are collapsed.
   *
   * @private
   * @param {number|object|null} row The parent row. `null` for the top level.
   * @returns {boolean}
   */
  areChildrenCollapsed(row) {
    let rowObj = isNaN(row) ? row : this.dataManager.getDataObject(row);
    let allCollapsed = true;
    if (rowObj === null) {
      rowObj = {
        __children: this.dataManager.data
      };
    }
    if (this.dataManager.hasChildren(rowObj)) {
      arrayEach(rowObj.__children, (elem) => {
        const rowIndex = this.dataManager.getRowIndex(elem);
        if (!this.plugin.collapsedRowsMap.getValueAtIndex(rowIndex)) {
          allCollapsed = false;
          return false;
        }
      });
    }
    return allCollapsed;
  }
  /**
   * Check if any of the row object parents are collapsed.
   *
   * @private
   * @param {object} rowObj Row object.
   * @returns {boolean}
   */
  isAnyParentCollapsed(rowObj) {
    let parent = rowObj;
    while (parent !== null) {
      parent = this.dataManager.getRowParent(parent);
      const parentIndex = this.dataManager.getRowIndex(parent);
      if (this.collapsedRows.indexOf(parentIndex) > -1) {
        return true;
      }
    }
    return false;
  }
  /**
   * Toggle collapsed state. Callback for the `beforeOnCellMousedown` hook.
   *
   * @private
   * @param {MouseEvent} event `mousedown` event.
   * @param {object} coords Coordinates of the clicked cell/header.
   */
  toggleState(event, coords) {
    if (coords.col >= 0) {
      return;
    }
    const row = this.translateTrimmedRow(coords.row);
    if (hasClass(event.target, headers_default.CSS_CLASSES.button)) {
      if (this.areChildrenCollapsed(row)) {
        this.expandChildren(row);
      } else {
        this.collapseChildren(row);
      }
      stopImmediatePropagation(event);
    }
  }
  /**
   * Translate visual row after trimming to physical base row index.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number} Base row index.
   */
  translateTrimmedRow(row) {
    return this.hot.toPhysicalRow(row);
  }
  /**
   * Translate physical row after trimming to visual base row index.
   *
   * @private
   * @param {number} row Row index.
   * @returns {number} Base row index.
   */
  untranslateTrimmedRow(row) {
    return this.hot.toVisualRow(row);
  }
  /**
   * Helper function to render the table and call the `adjustElementsSize` method.
   *
   * @private
   */
  renderAndAdjust() {
    this.hot.render();
    this.hot.view.adjustElementsSize();
  }
};
var collapsing_default = CollapsingUI;

// node_modules/handsontable/plugins/nestedRows/ui/contextMenu.mjs
function _classPrivateFieldInitSpec30(obj, privateMap, value) {
  _checkPrivateRedeclaration44(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration44(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty52(obj, key, value) {
  key = _toPropertyKey52(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey52(arg) {
  var key = _toPrimitive52(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive52(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet30(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor30(receiver, privateMap, "get");
  return _classApplyDescriptorGet30(receiver, descriptor);
}
function _classExtractFieldDescriptor30(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet30(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
var _menuEntries = /* @__PURE__ */ new WeakMap();
var ContextMenuUI = class extends base_default4 {
  constructor() {
    super(...arguments);
    _defineProperty52(this, "dataManager", this.plugin.dataManager);
    _classPrivateFieldInitSpec30(this, _menuEntries, {
      writable: true,
      value: {
        row_above: (key, selection) => {
          const lastSelection = selection[selection.length - 1];
          this.dataManager.addSibling(lastSelection.start.row, "above");
        },
        row_below: (key, selection) => {
          const lastSelection = selection[selection.length - 1];
          this.dataManager.addSibling(lastSelection.start.row, "below");
        }
      }
    });
  }
  /**
   * Append options to the context menu. (Propagated from the `afterContextMenuDefaultOptions` hook callback)
   * f.
   *
   * @private
   * @param {object} defaultOptions Default context menu options.
   * @returns {*}
   */
  appendOptions(defaultOptions) {
    const newEntries = [{
      key: "add_child",
      name() {
        return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD);
      },
      callback: () => {
        const translatedRowIndex = this.dataManager.translateTrimmedRow(this.hot.getSelectedLast()[0]);
        const parent = this.dataManager.getDataObject(translatedRowIndex);
        this.dataManager.addChild(parent);
      },
      disabled: () => {
        const selected = this.hot.getSelectedLast();
        return !selected || selected[0] < 0 || this.hot.selection.isSelectedByColumnHeader() || this.hot.countRows() >= this.hot.getSettings().maxRows;
      }
    }, {
      key: "detach_from_parent",
      name() {
        return this.getTranslatedPhrase(CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD);
      },
      callback: () => {
        this.dataManager.detachFromParent(this.hot.getSelectedLast());
      },
      disabled: () => {
        const selected = this.hot.getSelectedLast();
        const translatedRowIndex = this.dataManager.translateTrimmedRow(selected[0]);
        const parent = this.dataManager.getRowParent(translatedRowIndex);
        return !parent || !selected || selected[0] < 0 || this.hot.selection.isSelectedByColumnHeader() || this.hot.countRows() >= this.hot.getSettings().maxRows;
      }
    }, {
      name: "---------"
    }];
    rangeEach(0, defaultOptions.items.length - 1, (i) => {
      if (i === 0) {
        arrayEach(newEntries, (val, j) => {
          defaultOptions.items.splice(i + j, 0, val);
        });
        return false;
      }
    });
    return this.modifyRowInsertingOptions(defaultOptions);
  }
  /**
   * Modify how the row inserting options work.
   *
   * @private
   * @param {object} defaultOptions Default context menu items.
   * @returns {*}
   */
  modifyRowInsertingOptions(defaultOptions) {
    rangeEach(0, defaultOptions.items.length - 1, (i) => {
      const option = _classPrivateFieldGet30(this, _menuEntries)[defaultOptions.items[i].key];
      if (option !== null && option !== void 0) {
        defaultOptions.items[i].callback = option;
      }
    });
    return defaultOptions;
  }
};
var contextMenu_default = ContextMenuUI;

// node_modules/handsontable/plugins/nestedRows/utils/rowMoveController.mjs
function _defineProperty53(obj, key, value) {
  key = _toPropertyKey53(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey53(arg) {
  var key = _toPrimitive53(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive53(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var RowMoveController = class {
  constructor(plugin) {
    _defineProperty53(this, "plugin", void 0);
    _defineProperty53(this, "hot", void 0);
    _defineProperty53(this, "dataManager", void 0);
    _defineProperty53(this, "collapsingUI", void 0);
    this.plugin = plugin;
    this.hot = plugin.hot;
    this.dataManager = plugin.dataManager;
    this.collapsingUI = plugin.collapsingUI;
  }
  /**
   * `beforeRowMove` hook callback.
   *
   * @param {Array} rows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements
   *   will be placed after the moving action. To check the visualization of the final index, please take a look at
   *   [documentation](@/guides/rows/row-moving.md).
   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we
   *   are going to drop the moved elements. To check visualization of drop index please take a look at
   *   [documentation](@/guides/rows/row-moving.md).
   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
   * @fires Hooks#afterRowMove
   * @returns {boolean}
   */
  onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {
    const improperUsage = this.displayAPICompatibilityWarning({
      rows,
      finalIndex,
      dropIndex,
      movePossible
    });
    if (improperUsage) {
      return false;
    }
    this.movedToCollapsed = false;
    const dropToLastRow = dropIndex === this.hot.countRows();
    const physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);
    let allowMove = true;
    const physicalStartIndexes = rows.map((rowIndex) => {
      if (!allowMove) {
        return false;
      }
      const physicalRowIndex = this.dataManager.translateTrimmedRow(rowIndex);
      allowMove = this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);
      return physicalRowIndex;
    });
    const willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;
    if (!allowMove || !willDataChange) {
      return false;
    }
    const baseParent = this.getBaseParent(physicalStartIndexes);
    const targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);
    const sameParent = baseParent === targetParent;
    this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);
    this.collapsingUI.collapsedRowsStash.stash();
    this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);
    this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);
    this.dataManager.rewriteCache();
    this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);
    this.collapsingUI.collapsedRowsStash.applyStash(false);
    this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));
    this.hot.render();
    this.selectCells(rows, dropIndex);
    return false;
  }
  /**
   * Display a `dragRows`/`moveRows` method compatibility warning if needed.
   *
   * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.
   * @returns {boolean} `true` if is a result of an improper usage of the moving API.
   */
  displayAPICompatibilityWarning(beforeMoveRowHookArgs) {
    const {
      rows,
      finalIndex,
      dropIndex,
      movePossible
    } = beforeMoveRowHookArgs;
    let shouldTerminate = false;
    if (isUndefined(dropIndex)) {
      warn(toSingleLine`Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\x20
      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.`);
      this.hot.runHooks("afterRowMove", rows, finalIndex, dropIndex, movePossible, false);
      shouldTerminate = true;
    }
    return shouldTerminate;
  }
  /**
   * Check if the moving action should be allowed.
   *
   * @param {number} physicalRowIndex Physical start row index.
   * @param {number} physicalDropIndex Physical drop index.
   * @returns {boolean} `true` if it should continue with the moving action.
   */
  shouldAllowMoving(physicalRowIndex, physicalDropIndex) {
    return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);
  }
  /**
   * Get the base row parent.
   *
   * @param {number} physicalStartIndexes Physical start row index.
   * @returns {object|null} The base row parent.
   */
  getBaseParent(physicalStartIndexes) {
    return this.dataManager.getRowParent(physicalStartIndexes[0]);
  }
  /**
   * Get the target row parent.
   *
   * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.
   * @param {number} physicalDropIndex Physical drop row index.
   * @returns {object|null} The target row parent.
   */
  getTargetParent(dropToLastRow, physicalDropIndex) {
    let targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);
    if (targetParent === null || targetParent === void 0) {
      targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);
    }
    return targetParent;
  }
  /**
   * Shift the cached collapsible rows position according to the move action.
   *
   * @param {number[]} physicalStartIndexes Physical start row indexes.
   * @param {number} physicalDropIndex Physical drop index.
   * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.
   */
  shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {
    if (!sameParent) {
      if (Math.max(...physicalStartIndexes) <= physicalDropIndex) {
        this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);
      } else {
        this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);
      }
    }
  }
  /**
   * Move the rows at the provided coordinates.
   *
   * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.
   * @param {number} physicalDropIndex Physical drop index.
   * @param {object} targetParent Parent of the destination row.
   */
  moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {
    const moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;
    this.hot.batchRender(() => {
      physicalStartIndexes.forEach((physicalStartIndex) => {
        this.dataManager.moveRow(physicalStartIndex, physicalDropIndex, this.movedToCollapsed, moveToLastChild);
      });
    });
  }
  /**
   * Move the cell meta for multiple rows.
   *
   * @param {number[]} baseIndexes Array of indexes for the rows being moved.
   * @param {number} targetIndex Index of the destination of the move.
   */
  moveCellsMeta(baseIndexes, targetIndex) {
    const rowsOfMeta = [];
    const movingDown = Math.max(...baseIndexes) < targetIndex;
    baseIndexes.forEach((baseIndex) => {
      rowsOfMeta.push(this.hot.getCellMetaAtRow(baseIndex));
    });
    this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);
    this.hot.spliceCellsMeta(targetIndex - (movingDown ? rowsOfMeta.length : 0), 0, ...rowsOfMeta);
  }
  /**
   * Select cells after the move.
   *
   * @param {Array} rows Array of visual row indexes to be moved.
   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we
   *   are going to drop the moved elements. To check visualization of drop index please take a look at
   *   [documentation](@/guides/rows/row-moving.md).
   */
  selectCells(rows, dropIndex) {
    const rowsLen = rows.length;
    let startRow = 0;
    let endRow = 0;
    let selection = null;
    let lastColIndex = null;
    if (this.movedToCollapsed) {
      let physicalDropIndex = null;
      if (rows[rowsLen - 1] < dropIndex) {
        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);
      } else {
        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);
      }
      const parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);
      const parentIndex = this.dataManager.getRowIndex(parentObject);
      startRow = this.dataManager.untranslateTrimmedRow(parentIndex);
      endRow = startRow;
    } else if (rows[rowsLen - 1] < dropIndex) {
      endRow = dropIndex - 1;
      startRow = endRow - rowsLen + 1;
    } else {
      startRow = dropIndex;
      endRow = startRow + rowsLen - 1;
    }
    selection = this.hot.selection;
    lastColIndex = this.hot.countCols() - 1;
    selection.setRangeStart(this.hot._createCellCoords(startRow, 0));
    selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), true);
  }
  // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.
  /**
   * Indicates if order of rows was changed.
   *
   * @param {Array} movedRows Array of visual row indexes to be moved.
   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements
   *   will be placed after the moving action. To check the visualization of the final index, please take a look at
   *   [documentation](@/guides/rows/row-moving.md).
   * @returns {boolean}
   */
  isRowOrderChanged(movedRows, finalIndex) {
    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);
  }
};

// node_modules/handsontable/plugins/nestedRows/nestedRows.mjs
function _classPrivateMethodInitSpec35(obj, privateSet) {
  _checkPrivateRedeclaration45(obj, privateSet);
  privateSet.add(obj);
}
function _classPrivateFieldInitSpec31(obj, privateMap, value) {
  _checkPrivateRedeclaration45(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration45(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty54(obj, key, value) {
  key = _toPropertyKey54(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey54(arg) {
  var key = _toPrimitive54(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive54(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateFieldGet31(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor31(receiver, privateMap, "get");
  return _classApplyDescriptorGet31(receiver, descriptor);
}
function _classApplyDescriptorGet31(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classPrivateFieldSet29(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor31(receiver, privateMap, "set");
  _classApplyDescriptorSet29(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor31(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorSet29(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateMethodGet35(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY29 = "nestedRows";
var PLUGIN_PRIORITY28 = 300;
var SHORTCUTS_GROUP11 = PLUGIN_KEY29;
var WRONG_DATA_TYPE_ERROR = "The Nested Rows plugin requires an Array of Objects as a dataset to be provided. The plugin has been disabled.";
var _skipRender = /* @__PURE__ */ new WeakMap();
var _skipCoreAPIModifiers = /* @__PURE__ */ new WeakMap();
var _onBeforeRowMove = /* @__PURE__ */ new WeakSet();
var _onBeforeOnCellMouseDown7 = /* @__PURE__ */ new WeakSet();
var _onFilterData = /* @__PURE__ */ new WeakSet();
var _onAfterContextMenuDefaultOptions6 = /* @__PURE__ */ new WeakSet();
var _onAfterGetRowHeader3 = /* @__PURE__ */ new WeakSet();
var _onModifyRowHeaderWidth = /* @__PURE__ */ new WeakSet();
var _onAfterRemoveRow4 = /* @__PURE__ */ new WeakSet();
var _onBeforeRemoveRow3 = /* @__PURE__ */ new WeakSet();
var _onBeforeAddChild = /* @__PURE__ */ new WeakSet();
var _onAfterAddChild = /* @__PURE__ */ new WeakSet();
var _onBeforeDetachChild = /* @__PURE__ */ new WeakSet();
var _onAfterDetachChild3 = /* @__PURE__ */ new WeakSet();
var _onAfterCreateRow4 = /* @__PURE__ */ new WeakSet();
var _onAfterInit6 = /* @__PURE__ */ new WeakSet();
var _onBeforeViewRender4 = /* @__PURE__ */ new WeakSet();
var _onBeforeLoadData3 = /* @__PURE__ */ new WeakSet();
var NestedRows = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec35(this, _onBeforeLoadData3);
    _classPrivateMethodInitSpec35(this, _onBeforeViewRender4);
    _classPrivateMethodInitSpec35(this, _onAfterInit6);
    _classPrivateMethodInitSpec35(this, _onAfterCreateRow4);
    _classPrivateMethodInitSpec35(this, _onAfterDetachChild3);
    _classPrivateMethodInitSpec35(this, _onBeforeDetachChild);
    _classPrivateMethodInitSpec35(this, _onAfterAddChild);
    _classPrivateMethodInitSpec35(this, _onBeforeAddChild);
    _classPrivateMethodInitSpec35(this, _onBeforeRemoveRow3);
    _classPrivateMethodInitSpec35(this, _onAfterRemoveRow4);
    _classPrivateMethodInitSpec35(this, _onModifyRowHeaderWidth);
    _classPrivateMethodInitSpec35(this, _onAfterGetRowHeader3);
    _classPrivateMethodInitSpec35(this, _onAfterContextMenuDefaultOptions6);
    _classPrivateMethodInitSpec35(this, _onFilterData);
    _classPrivateMethodInitSpec35(this, _onBeforeOnCellMouseDown7);
    _classPrivateMethodInitSpec35(this, _onBeforeRowMove);
    _defineProperty54(this, "dataManager", null);
    _defineProperty54(this, "headersUI", null);
    _defineProperty54(this, "collapsedRowsMap", null);
    _classPrivateFieldInitSpec31(this, _skipRender, {
      writable: true,
      value: false
    });
    _classPrivateFieldInitSpec31(this, _skipCoreAPIModifiers, {
      writable: true,
      value: false
    });
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY29;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY28;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link NestedRows#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY29];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    this.collapsedRowsMap = this.hot.rowIndexMapper.registerMap("nestedRows", new TrimmingMap());
    this.dataManager = new dataManager_default(this, this.hot);
    this.collapsingUI = new collapsing_default(this, this.hot);
    this.headersUI = new headers_default(this, this.hot);
    this.contextMenuUI = new contextMenu_default(this, this.hot);
    this.rowMoveController = new RowMoveController(this);
    this.addHook("afterInit", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet35(_this, _onAfterInit6, _onAfterInit25).call(_this, ...args);
    });
    this.addHook("beforeViewRender", function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet35(_this, _onBeforeViewRender4, _onBeforeViewRender23).call(_this, ...args);
    });
    this.addHook("modifyRowData", function() {
      return _this.onModifyRowData(...arguments);
    });
    this.addHook("modifySourceLength", function() {
      return _this.onModifySourceLength(...arguments);
    });
    this.addHook("beforeDataSplice", function() {
      return _this.onBeforeDataSplice(...arguments);
    });
    this.addHook("filterData", function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _classPrivateMethodGet35(_this, _onFilterData, _onFilterData2).call(_this, ...args);
    });
    this.addHook("afterContextMenuDefaultOptions", function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _classPrivateMethodGet35(_this, _onAfterContextMenuDefaultOptions6, _onAfterContextMenuDefaultOptions25).call(_this, ...args);
    });
    this.addHook("afterGetRowHeader", function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _classPrivateMethodGet35(_this, _onAfterGetRowHeader3, _onAfterGetRowHeader22).call(_this, ...args);
    });
    this.addHook("beforeOnCellMouseDown", function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _classPrivateMethodGet35(_this, _onBeforeOnCellMouseDown7, _onBeforeOnCellMouseDown26).call(_this, ...args);
    });
    this.addHook("beforeRemoveRow", function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _classPrivateMethodGet35(_this, _onBeforeRemoveRow3, _onBeforeRemoveRow22).call(_this, ...args);
    });
    this.addHook("afterRemoveRow", function() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return _classPrivateMethodGet35(_this, _onAfterRemoveRow4, _onAfterRemoveRow23).call(_this, ...args);
    });
    this.addHook("beforeAddChild", function() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return _classPrivateMethodGet35(_this, _onBeforeAddChild, _onBeforeAddChild2).call(_this, ...args);
    });
    this.addHook("afterAddChild", function() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return _classPrivateMethodGet35(_this, _onAfterAddChild, _onAfterAddChild2).call(_this, ...args);
    });
    this.addHook("beforeDetachChild", function() {
      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        args[_key11] = arguments[_key11];
      }
      return _classPrivateMethodGet35(_this, _onBeforeDetachChild, _onBeforeDetachChild2).call(_this, ...args);
    });
    this.addHook("afterDetachChild", function() {
      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        args[_key12] = arguments[_key12];
      }
      return _classPrivateMethodGet35(_this, _onAfterDetachChild3, _onAfterDetachChild22).call(_this, ...args);
    });
    this.addHook("modifyRowHeaderWidth", function() {
      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }
      return _classPrivateMethodGet35(_this, _onModifyRowHeaderWidth, _onModifyRowHeaderWidth2).call(_this, ...args);
    });
    this.addHook("afterCreateRow", function() {
      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        args[_key14] = arguments[_key14];
      }
      return _classPrivateMethodGet35(_this, _onAfterCreateRow4, _onAfterCreateRow23).call(_this, ...args);
    });
    this.addHook("beforeRowMove", function() {
      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        args[_key15] = arguments[_key15];
      }
      return _classPrivateMethodGet35(_this, _onBeforeRowMove, _onBeforeRowMove2).call(_this, ...args);
    });
    this.addHook("beforeLoadData", (data) => _classPrivateMethodGet35(this, _onBeforeLoadData3, _onBeforeLoadData22).call(this, data));
    this.addHook("beforeUpdateData", (data) => _classPrivateMethodGet35(this, _onBeforeLoadData3, _onBeforeLoadData22).call(this, data));
    this.registerShortcuts();
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.rowIndexMapper.unregisterMap("nestedRows");
    this.unregisterShortcuts();
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`nestedRows`](@/api/options.md#nestedrows)
   */
  updatePlugin() {
    this.disablePlugin();
    const currentSourceData = this.dataManager.getData();
    this.enablePlugin();
    this.dataManager.updateWithData(currentSourceData);
    super.updatePlugin();
  }
  /**
   * Register shortcuts responsible for toggling collapsible columns.
   *
   * @private
   */
  registerShortcuts() {
    this.hot.getShortcutManager().getContext("grid").addShortcut({
      keys: [["Enter"]],
      callback: () => {
        const {
          highlight
        } = this.hot.getSelectedRangeLast();
        if (highlight.col === -1 && highlight.row >= 0) {
          const row = this.collapsingUI.translateTrimmedRow(highlight.row);
          if (this.collapsingUI.areChildrenCollapsed(row)) {
            this.collapsingUI.expandChildren(row);
          } else {
            this.collapsingUI.collapseChildren(row);
          }
        }
      },
      runOnlyIf: () => {
        var _this$hot$getSelected;
        const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
        return highlight && this.hot.selection.isCellVisible(highlight) && highlight.isHeader();
      },
      group: SHORTCUTS_GROUP11
    });
  }
  /**
   * Unregister shortcuts responsible for toggling collapsible columns.
   *
   * @private
   */
  unregisterShortcuts() {
    this.hot.getShortcutManager().getContext("grid").removeShortcutsByGroup(SHORTCUTS_GROUP11);
  }
  /**
   * Enable the modify hook skipping flag - allows retrieving the data from Handsontable without this plugin's
   * modifications.
   *
   * @private
   */
  disableCoreAPIModifiers() {
    _classPrivateFieldSet29(this, _skipCoreAPIModifiers, true);
  }
  /**
   * Disable the modify hook skipping flag.
   *
   * @private
   */
  enableCoreAPIModifiers() {
    _classPrivateFieldSet29(this, _skipCoreAPIModifiers, false);
  }
  /**
   * The modifyRowData hook callback.
   *
   * @private
   * @param {number} row Visual row index.
   * @returns {boolean}
   */
  onModifyRowData(row) {
    if (_classPrivateFieldGet31(this, _skipCoreAPIModifiers)) {
      return;
    }
    return this.dataManager.getDataObject(row);
  }
  /**
   * Modify the source data length to match the length of the nested structure.
   *
   * @private
   * @returns {number}
   */
  onModifySourceLength() {
    if (_classPrivateFieldGet31(this, _skipCoreAPIModifiers)) {
      return;
    }
    return this.dataManager.countAllRows();
  }
  /**
   * @private
   * @param {number} index The index where the data was spliced.
   * @param {number} amount An amount of items to remove.
   * @param {object} element An element to add.
   * @returns {boolean}
   */
  onBeforeDataSplice(index, amount, element) {
    if (_classPrivateFieldGet31(this, _skipCoreAPIModifiers) || this.dataManager.isRowHighestLevel(index)) {
      return true;
    }
    this.dataManager.spliceData(index, amount, element);
    return false;
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _onBeforeRowMove2(rows, finalIndex, dropIndex, movePossible) {
  return this.rowMoveController.onBeforeRowMove(rows, finalIndex, dropIndex, movePossible);
}
function _onBeforeOnCellMouseDown26(event, coords, TD) {
  this.collapsingUI.toggleState(event, coords, TD);
}
function _onFilterData2(index, amount, physicalRows) {
  this.collapsingUI.collapsedRowsStash.stash();
  this.collapsingUI.collapsedRowsStash.trimStash(physicalRows[0], amount);
  this.collapsingUI.collapsedRowsStash.shiftStash(physicalRows[0], null, -1 * amount);
  this.dataManager.filterData(index, amount, physicalRows);
  _classPrivateFieldSet29(this, _skipRender, true);
  return this.dataManager.getData().slice();
}
function _onAfterContextMenuDefaultOptions25(defaultOptions) {
  return this.contextMenuUI.appendOptions(defaultOptions);
}
function _onAfterGetRowHeader22(row, TH) {
  this.headersUI.appendLevelIndicators(row, TH);
}
function _onModifyRowHeaderWidth2(rowHeaderWidth) {
  return Math.max(this.headersUI.rowHeaderWidthCache, rowHeaderWidth);
}
function _onAfterRemoveRow23(index, amount, logicRows, source) {
  if (source === this.pluginName) {
    return;
  }
  this.hot._registerTimeout(() => {
    _classPrivateFieldSet29(this, _skipRender, false);
    this.headersUI.updateRowHeaderWidth();
    this.collapsingUI.collapsedRowsStash.applyStash();
  });
}
function _onBeforeRemoveRow22(index, amount, physicalRows) {
  const modifiedPhysicalRows = Array.from(physicalRows.reduce((removedRows, physicalIndex) => {
    if (this.dataManager.isParent(physicalIndex)) {
      const children = this.dataManager.getDataObject(physicalIndex).__children;
      removedRows.add(physicalIndex);
      if (Array.isArray(children)) {
        children.forEach((child) => removedRows.add(this.dataManager.getRowIndex(child)));
      }
      return removedRows;
    }
    return removedRows.add(physicalIndex);
  }, /* @__PURE__ */ new Set()));
  physicalRows.length = 0;
  physicalRows.push(...modifiedPhysicalRows);
}
function _onBeforeAddChild2() {
  this.collapsingUI.collapsedRowsStash.stash();
}
function _onAfterAddChild2(parent, element) {
  this.collapsingUI.collapsedRowsStash.shiftStash(this.dataManager.getRowIndex(element));
  this.collapsingUI.collapsedRowsStash.applyStash();
  this.headersUI.updateRowHeaderWidth();
}
function _onBeforeDetachChild2() {
  this.collapsingUI.collapsedRowsStash.stash();
}
function _onAfterDetachChild22(parent, element, finalElementRowIndex) {
  this.collapsingUI.collapsedRowsStash.shiftStash(finalElementRowIndex, null, -1);
  this.collapsingUI.collapsedRowsStash.applyStash();
  this.headersUI.updateRowHeaderWidth();
}
function _onAfterCreateRow23() {
  this.dataManager.rewriteCache();
}
function _onAfterInit25() {
  this.headersUI.updateRowHeaderWidth();
}
function _onBeforeViewRender23(force, skipRender) {
  if (_classPrivateFieldGet31(this, _skipRender)) {
    skipRender.skipRender = true;
  }
}
function _onBeforeLoadData22(data) {
  if (!isArrayOfObjects(data)) {
    error(WRONG_DATA_TYPE_ERROR);
    this.hot.getSettings()[PLUGIN_KEY29] = false;
    this.disablePlugin();
    return;
  }
  this.dataManager.setData(data);
  this.dataManager.rewriteCache();
}

// node_modules/handsontable/plugins/persistentState/storage.mjs
function _defineProperty55(obj, key, value) {
  key = _toPropertyKey55(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey55(arg) {
  var key = _toPrimitive55(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive55(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var Storage = class {
  // eslint-disable-next-line no-restricted-globals
  constructor(prefix) {
    let rootWindow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window;
    _defineProperty55(this, "rootWindow", void 0);
    _defineProperty55(this, "prefix", void 0);
    _defineProperty55(this, "savedKeys", []);
    this.rootWindow = rootWindow;
    this.prefix = prefix;
    this.loadSavedKeys();
  }
  /**
   * Save data to localStorage.
   *
   * @param {string} key Key string.
   * @param {Mixed} value Value to save.
   */
  saveValue(key, value) {
    this.rootWindow.localStorage.setItem(`${this.prefix}_${key}`, JSON.stringify(value));
    if (this.savedKeys.indexOf(key) === -1) {
      this.savedKeys.push(key);
      this.saveSavedKeys();
    }
  }
  /**
   * Load data from localStorage.
   *
   * @param {string} key Key string.
   * @param {object} defaultValue Object containing the loaded data.
   *
   * @returns {object|undefined}
   */
  loadValue(key, defaultValue) {
    const itemKey = typeof key === "undefined" ? defaultValue : key;
    const value = this.rootWindow.localStorage.getItem(`${this.prefix}_${itemKey}`);
    return value === null ? void 0 : JSON.parse(value);
  }
  /**
   * Reset given data from localStorage.
   *
   * @param {string} key Key string.
   */
  reset(key) {
    this.rootWindow.localStorage.removeItem(`${this.prefix}_${key}`);
  }
  /**
   * Reset all data from localStorage.
   *
   */
  resetAll() {
    arrayEach(this.savedKeys, (value, index) => {
      this.rootWindow.localStorage.removeItem(`${this.prefix}_${this.savedKeys[index]}`);
    });
    this.clearSavedKeys();
  }
  /**
   * Load and save all keys from localStorage.
   *
   * @private
   */
  loadSavedKeys() {
    const keysJSON = this.rootWindow.localStorage.getItem(`${this.prefix}__persistentStateKeys`);
    const keys = typeof keysJSON === "string" ? JSON.parse(keysJSON) : void 0;
    this.savedKeys = keys || [];
  }
  /**
   * Save saved key in localStorage.
   *
   * @private
   */
  saveSavedKeys() {
    this.rootWindow.localStorage.setItem(`${this.prefix}__persistentStateKeys`, JSON.stringify(this.savedKeys));
  }
  /**
   * Clear saved key from localStorage.
   *
   * @private
   */
  clearSavedKeys() {
    this.savedKeys.length = 0;
    this.saveSavedKeys();
  }
};
var storage_default = Storage;

// node_modules/handsontable/plugins/persistentState/persistentState.mjs
function _defineProperty56(obj, key, value) {
  key = _toPropertyKey56(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey56(arg) {
  var key = _toPrimitive56(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive56(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
pluginHooks_default.getSingleton().register("persistentStateSave");
pluginHooks_default.getSingleton().register("persistentStateLoad");
pluginHooks_default.getSingleton().register("persistentStateReset");
var PLUGIN_KEY30 = "persistentState";
var PLUGIN_PRIORITY29 = 0;
var PersistentState = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _defineProperty56(this, "storage", void 0);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY30;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY29;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link PersistentState#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY30];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    if (!this.storage) {
      this.storage = new storage_default(this.hot.rootElement.id, this.hot.rootWindow);
    }
    this.addHook("persistentStateSave", (key, value) => this.saveValue(key, value));
    this.addHook("persistentStateLoad", (key, saveTo) => this.loadValue(key, saveTo));
    this.addHook("persistentStateReset", () => this.resetValue());
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.storage = void 0;
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`persistentState`](@/api/options.md#persistentstate)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Loads the value from local storage.
   *
   * @param {string} key Storage key.
   * @param {object} saveTo Saved value from local storage.
   */
  loadValue(key, saveTo) {
    saveTo.value = this.storage.loadValue(key);
  }
  /**
   * Saves the data to local storage.
   *
   * @param {string} key Storage key.
   * @param {Mixed} value Value to save.
   */
  saveValue(key, value) {
    this.storage.saveValue(key, value);
  }
  /**
   * Resets the data or all data from local storage.
   *
   * @param {string} key [optional] Storage key.
   */
  resetValue(key) {
    if (typeof key === "undefined") {
      this.storage.resetAll();
    } else {
      this.storage.reset(key);
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};

// node_modules/handsontable/plugins/search/search.mjs
function _classPrivateMethodInitSpec36(obj, privateSet) {
  _checkPrivateRedeclaration46(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration46(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty57(obj, key, value) {
  key = _toPropertyKey57(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey57(arg) {
  var key = _toPrimitive57(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive57(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet36(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY31 = "search";
var PLUGIN_PRIORITY30 = 190;
var DEFAULT_SEARCH_RESULT_CLASS = "htSearchResult";
var DEFAULT_CALLBACK = function(instance, row, col, data, testResult) {
  instance.getCellMeta(row, col).isSearchResult = testResult;
};
var DEFAULT_QUERY_METHOD = function(query, value, cellProperties) {
  if (isUndefined(query) || query === null || !query.toLocaleLowerCase || query.length === 0) {
    return false;
  }
  if (isUndefined(value) || value === null) {
    return false;
  }
  return value.toString().toLocaleLowerCase(cellProperties.locale).indexOf(query.toLocaleLowerCase(cellProperties.locale)) !== -1;
};
var _onBeforeRenderer = /* @__PURE__ */ new WeakSet();
var Search = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec36(this, _onBeforeRenderer);
    _defineProperty57(this, "callback", DEFAULT_CALLBACK);
    _defineProperty57(this, "queryMethod", DEFAULT_QUERY_METHOD);
    _defineProperty57(this, "searchResultClass", DEFAULT_SEARCH_RESULT_CLASS);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY31;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY30;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return this.hot.getSettings()[PLUGIN_KEY31];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    var _this = this;
    if (this.enabled) {
      return;
    }
    const searchSettings = this.hot.getSettings()[PLUGIN_KEY31];
    this.updatePluginSettings(searchSettings);
    this.addHook("beforeRenderer", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _classPrivateMethodGet36(_this, _onBeforeRenderer, _onBeforeRenderer2).call(_this, ...args);
    });
    super.enablePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    var _this2 = this;
    const beforeRendererCallback = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _classPrivateMethodGet36(_this2, _onBeforeRenderer, _onBeforeRenderer2).call(_this2, ...args);
    };
    this.hot.addHook("beforeRenderer", beforeRendererCallback);
    this.hot.addHookOnce("afterViewRender", () => {
      this.hot.removeHook("beforeRenderer", beforeRendererCallback);
    });
    super.disablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`search`](@/api/options.md#search)
   */
  updatePlugin() {
    this.disablePlugin();
    this.enablePlugin();
    super.updatePlugin();
  }
  /**
   * Makes the query.
   *
   * @param {string} queryStr Value to be search.
   * @param {Function} [callback] Callback function performed on cells with values which matches to the searched query.
   * @param {Function} [queryMethod] Query function responsible for determining whether a query matches the value stored in a cell.
   * @returns {object[]} Return an array of objects with `row`, `col`, `data` properties or empty array.
   */
  query(queryStr) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getCallback();
    let queryMethod = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getQueryMethod();
    const rowCount = this.hot.countRows();
    const colCount = this.hot.countCols();
    const queryResult = [];
    const instance = this.hot;
    rangeEach(0, rowCount - 1, (rowIndex) => {
      rangeEach(0, colCount - 1, (colIndex) => {
        const cellData = this.hot.getDataAtCell(rowIndex, colIndex);
        const cellProperties = this.hot.getCellMeta(rowIndex, colIndex);
        const cellCallback = cellProperties.search.callback || callback;
        const cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
        const testResult = cellQueryMethod(queryStr, cellData, cellProperties);
        if (testResult) {
          const singleResult = {
            row: rowIndex,
            col: colIndex,
            data: cellData
          };
          queryResult.push(singleResult);
        }
        if (cellCallback) {
          cellCallback(instance, rowIndex, colIndex, cellData, testResult);
        }
      });
    });
    return queryResult;
  }
  /**
   * Gets the callback function.
   *
   * @returns {Function} Return the callback function.
   */
  getCallback() {
    return this.callback;
  }
  /**
   * Sets the callback function. This function will be called during querying for each cell.
   *
   * @param {Function} newCallback A callback function.
   */
  setCallback(newCallback) {
    this.callback = newCallback;
  }
  /**
   * Gets the query method function.
   *
   * @returns {Function} Return the query method.
   */
  getQueryMethod() {
    return this.queryMethod;
  }
  /**
   * Sets the query method function. The function is responsible for determining whether a query matches the value stored in a cell.
   *
   * @param {Function} newQueryMethod A function with specific match logic.
   */
  setQueryMethod(newQueryMethod) {
    this.queryMethod = newQueryMethod;
  }
  /**
   * Gets search result cells class name.
   *
   * @returns {string} Return the cell class name.
   */
  getSearchResultClass() {
    return this.searchResultClass;
  }
  /**
   * Sets search result cells class name. This class name will be added to each cell that belongs to the searched query.
   *
   * @param {string} newElementClass CSS class name.
   */
  setSearchResultClass(newElementClass) {
    this.searchResultClass = newElementClass;
  }
  /**
   * Updates the settings of the plugin.
   *
   * @param {object} searchSettings The plugin settings, taken from Handsontable configuration.
   * @private
   */
  updatePluginSettings(searchSettings) {
    if (isObject(searchSettings)) {
      if (searchSettings.searchResultClass) {
        this.setSearchResultClass(searchSettings.searchResultClass);
      }
      if (searchSettings.queryMethod) {
        this.setQueryMethod(searchSettings.queryMethod);
      }
      if (searchSettings.callback) {
        this.setCallback(searchSettings.callback);
      }
    }
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _onBeforeRenderer2(TD, row, col, prop, value, cellProperties) {
  const className = cellProperties.className || [];
  let classArray = [];
  if (typeof className === "string") {
    classArray = className.split(" ");
  } else {
    classArray.push(...className);
  }
  if (this.isEnabled() && cellProperties.isSearchResult) {
    if (!classArray.includes(this.searchResultClass)) {
      classArray.push(`${this.searchResultClass}`);
    }
  } else if (classArray.includes(this.searchResultClass)) {
    classArray.splice(classArray.indexOf(this.searchResultClass), 1);
  }
  cellProperties.className = classArray.join(" ");
}

// node_modules/handsontable/plugins/touchScroll/touchScroll.mjs
function _classPrivateMethodInitSpec37(obj, privateSet) {
  _checkPrivateRedeclaration47(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration47(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty58(obj, key, value) {
  key = _toPropertyKey58(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey58(arg) {
  var key = _toPrimitive58(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive58(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet37(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY32 = "touchScroll";
var PLUGIN_PRIORITY31 = 200;
var _onAfterViewRender = /* @__PURE__ */ new WeakSet();
var _onBeforeTouchScroll = /* @__PURE__ */ new WeakSet();
var _onAfterMomentumScroll = /* @__PURE__ */ new WeakSet();
var TouchScroll = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec37(this, _onAfterMomentumScroll);
    _classPrivateMethodInitSpec37(this, _onBeforeTouchScroll);
    _classPrivateMethodInitSpec37(this, _onAfterViewRender);
    _defineProperty58(this, "scrollbars", []);
    _defineProperty58(this, "clones", []);
    _defineProperty58(this, "lockedCollection", false);
    _defineProperty58(this, "freezeOverlays", false);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY32;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY31;
  }
  static get SETTING_KEYS() {
    return true;
  }
  /**
   * Check if plugin is enabled.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return isTouchSupported();
  }
  /**
   * Enable the plugin.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.addHook("afterViewRender", () => _classPrivateMethodGet37(this, _onAfterViewRender, _onAfterViewRender2).call(this));
    this.registerEvents();
    super.enablePlugin();
  }
  /**
   * Updates the plugin to use the latest options you have specified.
   */
  updatePlugin() {
    this.lockedCollection = false;
    super.updatePlugin();
  }
  /**
   * Disable plugin for this Handsontable instance.
   */
  disablePlugin() {
    super.disablePlugin();
  }
  /**
   * Register all necessary events.
   *
   * @private
   */
  registerEvents() {
    this.addHook("beforeTouchScroll", () => _classPrivateMethodGet37(this, _onBeforeTouchScroll, _onBeforeTouchScroll2).call(this));
    this.addHook("afterMomentumScroll", () => _classPrivateMethodGet37(this, _onAfterMomentumScroll, _onAfterMomentumScroll2).call(this));
  }
};
function _onAfterViewRender2() {
  if (this.lockedCollection) {
    return;
  }
  const {
    topOverlay,
    bottomOverlay,
    inlineStartOverlay,
    topInlineStartCornerOverlay,
    bottomInlineStartCornerOverlay
  } = this.hot.view._wt.wtOverlays;
  this.lockedCollection = true;
  this.scrollbars.length = 0;
  this.scrollbars.push(topOverlay);
  if (bottomOverlay.clone) {
    this.scrollbars.push(bottomOverlay);
  }
  this.scrollbars.push(inlineStartOverlay);
  if (topInlineStartCornerOverlay) {
    this.scrollbars.push(topInlineStartCornerOverlay);
  }
  if (bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {
    this.scrollbars.push(bottomInlineStartCornerOverlay);
  }
  this.clones = [];
  if (topOverlay.needFullRender) {
    this.clones.push(topOverlay.clone.wtTable.holder.parentNode);
  }
  if (bottomOverlay.needFullRender) {
    this.clones.push(bottomOverlay.clone.wtTable.holder.parentNode);
  }
  if (inlineStartOverlay.needFullRender) {
    this.clones.push(inlineStartOverlay.clone.wtTable.holder.parentNode);
  }
  if (topInlineStartCornerOverlay) {
    this.clones.push(topInlineStartCornerOverlay.clone.wtTable.holder.parentNode);
  }
  if (bottomInlineStartCornerOverlay && bottomInlineStartCornerOverlay.clone) {
    this.clones.push(bottomInlineStartCornerOverlay.clone.wtTable.holder.parentNode);
  }
}
function _onBeforeTouchScroll2() {
  this.freezeOverlays = true;
  arrayEach(this.clones, (clone2) => {
    addClass(clone2, "hide-tween");
  });
}
function _onAfterMomentumScroll2() {
  this.freezeOverlays = false;
  arrayEach(this.clones, (clone2) => {
    removeClass(clone2, "hide-tween");
    addClass(clone2, "show-tween");
  });
  this.hot._registerTimeout(() => {
    arrayEach(this.clones, (clone2) => {
      removeClass(clone2, "show-tween");
    });
  }, 400);
  arrayEach(this.scrollbars, (scrollbar) => {
    scrollbar.refresh();
    scrollbar.resetFixedPosition();
  });
  this.hot.view._wt.wtOverlays.syncScrollWithMaster();
}

// node_modules/handsontable/plugins/trimRows/trimRows.mjs
function _classPrivateMethodInitSpec38(obj, privateSet) {
  _checkPrivateRedeclaration48(obj, privateSet);
  privateSet.add(obj);
}
function _checkPrivateRedeclaration48(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _defineProperty59(obj, key, value) {
  key = _toPropertyKey59(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey59(arg) {
  var key = _toPrimitive59(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive59(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _classPrivateMethodGet38(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
var PLUGIN_KEY33 = "trimRows";
var PLUGIN_PRIORITY32 = 330;
var _onMapInit6 = /* @__PURE__ */ new WeakSet();
var TrimRows = class extends BasePlugin {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec38(this, _onMapInit6);
    _defineProperty59(this, "trimmedRowsMap", null);
  }
  static get PLUGIN_KEY() {
    return PLUGIN_KEY33;
  }
  static get PLUGIN_PRIORITY() {
    return PLUGIN_PRIORITY32;
  }
  /**
   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}
   * hook and if it returns `true` then the {@link AutoRowSize#enablePlugin} method is called.
   *
   * @returns {boolean}
   */
  isEnabled() {
    return !!this.hot.getSettings()[PLUGIN_KEY33];
  }
  /**
   * Enables the plugin functionality for this Handsontable instance.
   */
  enablePlugin() {
    if (this.enabled) {
      return;
    }
    this.trimmedRowsMap = this.hot.rowIndexMapper.registerMap("trimRows", new TrimmingMap());
    this.trimmedRowsMap.addLocalHook("init", () => _classPrivateMethodGet38(this, _onMapInit6, _onMapInit25).call(this));
    super.enablePlugin();
  }
  /**
   * Updates the plugin's state.
   *
   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:
   *  - [`trimRows`](@/api/options.md#trimrows)
   */
  updatePlugin() {
    const trimmedRows = this.hot.getSettings()[PLUGIN_KEY33];
    if (Array.isArray(trimmedRows)) {
      this.hot.batchExecution(() => {
        this.trimmedRowsMap.clear();
        arrayEach(trimmedRows, (physicalRow) => {
          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);
        });
      }, true);
    }
    super.updatePlugin();
  }
  /**
   * Disables the plugin functionality for this Handsontable instance.
   */
  disablePlugin() {
    this.hot.rowIndexMapper.unregisterMap("trimRows");
    super.disablePlugin();
  }
  /**
   * Get list of trimmed rows.
   *
   * @returns {Array} Physical rows.
   */
  getTrimmedRows() {
    return this.trimmedRowsMap.getTrimmedIndexes();
  }
  /**
   * Trims the rows provided in the array.
   *
   * @param {number[]} rows Array of physical row indexes.
   * @fires Hooks#beforeTrimRow
   * @fires Hooks#afterTrimRow
   */
  trimRows(rows) {
    const currentTrimConfig = this.getTrimmedRows();
    const isValidConfig = this.isValidConfig(rows);
    let destinationTrimConfig = currentTrimConfig;
    if (isValidConfig) {
      destinationTrimConfig = Array.from(new Set(currentTrimConfig.concat(rows)));
    }
    const allowTrimRow = this.hot.runHooks("beforeTrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig);
    if (allowTrimRow === false) {
      return;
    }
    if (isValidConfig) {
      this.hot.batchExecution(() => {
        arrayEach(rows, (physicalRow) => {
          this.trimmedRowsMap.setValueAtIndex(physicalRow, true);
        });
      }, true);
    }
    this.hot.runHooks("afterTrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig, isValidConfig && destinationTrimConfig.length > currentTrimConfig.length);
  }
  /**
   * Trims the row provided as a physical row index (counting from 0).
   *
   * @param {...number} row Physical row index.
   */
  trimRow() {
    for (var _len = arguments.length, row = new Array(_len), _key = 0; _key < _len; _key++) {
      row[_key] = arguments[_key];
    }
    this.trimRows(row);
  }
  /**
   * Untrims the rows provided in the array.
   *
   * @param {number[]} rows Array of physical row indexes.
   * @fires Hooks#beforeUntrimRow
   * @fires Hooks#afterUntrimRow
   */
  untrimRows(rows) {
    const currentTrimConfig = this.getTrimmedRows();
    const isValidConfig = this.isValidConfig(rows);
    let destinationTrimConfig = currentTrimConfig;
    const trimmingMapValues = this.trimmedRowsMap.getValues().slice();
    const isAnyRowUntrimmed = rows.length > 0;
    if (isValidConfig && isAnyRowUntrimmed) {
      arrayEach(rows, (physicalRow) => {
        trimmingMapValues[physicalRow] = false;
      });
      destinationTrimConfig = arrayReduce(trimmingMapValues, (trimmedIndexes, isTrimmed, physicalIndex) => {
        if (isTrimmed) {
          trimmedIndexes.push(physicalIndex);
        }
        return trimmedIndexes;
      }, []);
    }
    const allowUntrimRow = this.hot.runHooks("beforeUntrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed);
    if (allowUntrimRow === false) {
      return;
    }
    if (isValidConfig && isAnyRowUntrimmed) {
      this.trimmedRowsMap.setValues(trimmingMapValues);
    }
    this.hot.runHooks("afterUntrimRow", currentTrimConfig, destinationTrimConfig, isValidConfig && isAnyRowUntrimmed, isValidConfig && destinationTrimConfig.length < currentTrimConfig.length);
  }
  /**
   * Untrims the row provided as a physical row index (counting from 0).
   *
   * @param {...number} row Physical row index.
   */
  untrimRow() {
    for (var _len2 = arguments.length, row = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      row[_key2] = arguments[_key2];
    }
    this.untrimRows(row);
  }
  /**
   * Checks if given row is hidden.
   *
   * @param {number} physicalRow Physical row index.
   * @returns {boolean}
   */
  isTrimmed(physicalRow) {
    return this.trimmedRowsMap.getValueAtIndex(physicalRow) || false;
  }
  /**
   * Untrims all trimmed rows.
   */
  untrimAll() {
    this.untrimRows(this.getTrimmedRows());
  }
  /**
   * Get if trim config is valid. Check whether all of the provided physical row indexes are within source data.
   *
   * @param {Array} trimmedRows List of physical row indexes.
   * @returns {boolean}
   */
  isValidConfig(trimmedRows) {
    const sourceRows = this.hot.countSourceRows();
    return trimmedRows.every((trimmedRow) => Number.isInteger(trimmedRow) && trimmedRow >= 0 && trimmedRow < sourceRows);
  }
  /**
   * Destroys the plugin instance.
   */
  destroy() {
    super.destroy();
  }
};
function _onMapInit25() {
  const trimmedRows = this.hot.getSettings()[PLUGIN_KEY33];
  if (Array.isArray(trimmedRows)) {
    this.hot.batchExecution(() => {
      arrayEach(trimmedRows, (physicalRow) => {
        this.trimmedRowsMap.setValueAtIndex(physicalRow, true);
      });
    }, true);
  }
}

// node_modules/handsontable/plugins/undoRedo/undoRedo.mjs
var SHORTCUTS_GROUP12 = "undoRedo";
var PLUGIN_KEY34 = "undoRedo";
function UndoRedo(instance) {
  const plugin = this;
  this.instance = instance;
  this.doneActions = [];
  this.undoneActions = [];
  this.ignoreNewActions = false;
  this.enabled = false;
  instance.addHook("afterChange", function(changes, source) {
    const changesLen = changes && changes.length;
    if (!changesLen) {
      return;
    }
    const hasDifferences = changes.find((change) => {
      const [, , oldValue, newValue] = change;
      return oldValue !== newValue;
    });
    if (!hasDifferences) {
      return;
    }
    const wrappedAction = () => {
      const clonedChanges = changes.reduce((arr, change) => {
        arr.push([...change]);
        return arr;
      }, []);
      arrayEach(clonedChanges, (change) => {
        change[1] = instance.propToCol(change[1]);
      });
      const selected = changesLen > 1 ? this.getSelected() : [[clonedChanges[0][0], clonedChanges[0][1]]];
      return new UndoRedo.ChangeAction(clonedChanges, selected);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("afterCreateRow", (index, amount, source) => {
    plugin.done(() => new UndoRedo.CreateRowAction(index, amount), source);
  });
  instance.addHook("beforeRemoveRow", (index, amount, logicRows, source) => {
    const wrappedAction = () => {
      const physicalRowIndex = instance.toPhysicalRow(index);
      const removedData = deepClone(plugin.instance.getSourceData(physicalRowIndex, 0, physicalRowIndex + amount - 1, plugin.instance.countSourceCols() - 1));
      return new UndoRedo.RemoveRowAction(physicalRowIndex, removedData, instance.getSettings().fixedRowsBottom, instance.getSettings().fixedRowsTop, instance.rowIndexMapper.getIndexesSequence());
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("afterCreateCol", (index, amount, source) => {
    plugin.done(() => new UndoRedo.CreateColumnAction(index, amount), source);
  });
  instance.addHook("beforeRemoveCol", (index, amount, logicColumns, source) => {
    const wrappedAction = () => {
      const originalData = plugin.instance.getSourceDataArray();
      const columnIndex = (plugin.instance.countCols() + index) % plugin.instance.countCols();
      const removedData = [];
      const headers = [];
      const indexes = [];
      rangeEach(originalData.length - 1, (i) => {
        const column = [];
        const origRow = originalData[i];
        rangeEach(columnIndex, columnIndex + (amount - 1), (j) => {
          column.push(origRow[instance.toPhysicalColumn(j)]);
        });
        removedData.push(column);
      });
      rangeEach(amount - 1, (i) => {
        indexes.push(instance.toPhysicalColumn(columnIndex + i));
      });
      if (Array.isArray(instance.getSettings().colHeaders)) {
        rangeEach(amount - 1, (i) => {
          headers.push(instance.getSettings().colHeaders[instance.toPhysicalColumn(columnIndex + i)] || null);
        });
      }
      const columnsMap = instance.columnIndexMapper.getIndexesSequence();
      const rowsMap = instance.rowIndexMapper.getIndexesSequence();
      return new UndoRedo.RemoveColumnAction(columnIndex, indexes, removedData, headers, columnsMap, rowsMap, instance.getSettings().fixedColumnsStart);
    };
    plugin.done(wrappedAction, source);
  });
  instance.addHook("beforeCellAlignment", (stateBefore, range, type, alignment) => {
    plugin.done(() => new UndoRedo.CellAlignmentAction(stateBefore, range, type, alignment));
  });
  instance.addHook("beforeFilter", (conditionsStack) => {
    plugin.done(() => new UndoRedo.FiltersAction(conditionsStack));
  });
  instance.addHook("beforeRowMove", (rows, finalIndex) => {
    if (rows === false) {
      return;
    }
    plugin.done(() => new UndoRedo.RowMoveAction(rows, finalIndex));
  });
  instance.addHook("beforeMergeCells", (cellRange, auto) => {
    if (auto) {
      return;
    }
    plugin.done(() => new UndoRedo.MergeCellsAction(instance, cellRange));
  });
  instance.addHook("afterUnmergeCells", (cellRange, auto) => {
    if (auto) {
      return;
    }
    plugin.done(() => new UndoRedo.UnmergeCellsAction(instance, cellRange));
  });
  instance.addHook("afterInit", () => {
    plugin.init();
  });
}
UndoRedo.prototype.done = function(wrappedAction, source) {
  if (this.ignoreNewActions) {
    return;
  }
  const isBlockedByDefault = source === "UndoRedo.undo" || source === "UndoRedo.redo" || source === "auto";
  if (isBlockedByDefault) {
    return;
  }
  const doneActionsCopy = this.doneActions.slice();
  const continueAction = this.instance.runHooks("beforeUndoStackChange", doneActionsCopy, source);
  if (continueAction === false) {
    return;
  }
  const newAction = wrappedAction();
  const undoneActionsCopy = this.undoneActions.slice();
  this.doneActions.push(newAction);
  this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
  this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
  this.undoneActions.length = 0;
  this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
};
UndoRedo.prototype.undo = function() {
  if (this.isUndoAvailable()) {
    const doneActionsCopy = this.doneActions.slice();
    this.instance.runHooks("beforeUndoStackChange", doneActionsCopy);
    const action = this.doneActions.pop();
    this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
    const actionClone = deepClone(action);
    const continueAction = this.instance.runHooks("beforeUndo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    const that = this;
    const undoneActionsCopy = this.undoneActions.slice();
    this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
    action.undo(this.instance, () => {
      that.ignoreNewActions = false;
      that.undoneActions.push(action);
    });
    this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
    this.instance.runHooks("afterUndo", actionClone);
  }
};
UndoRedo.prototype.redo = function() {
  if (this.isRedoAvailable()) {
    const undoneActionsCopy = this.undoneActions.slice();
    this.instance.runHooks("beforeRedoStackChange", undoneActionsCopy);
    const action = this.undoneActions.pop();
    this.instance.runHooks("afterRedoStackChange", undoneActionsCopy, this.undoneActions.slice());
    const actionClone = deepClone(action);
    const continueAction = this.instance.runHooks("beforeRedo", actionClone);
    if (continueAction === false) {
      return;
    }
    this.ignoreNewActions = true;
    const that = this;
    const doneActionsCopy = this.doneActions.slice();
    this.instance.runHooks("beforeUndoStackChange", doneActionsCopy);
    action.redo(this.instance, () => {
      that.ignoreNewActions = false;
      that.doneActions.push(action);
    });
    this.instance.runHooks("afterUndoStackChange", doneActionsCopy, this.doneActions.slice());
    this.instance.runHooks("afterRedo", actionClone);
  }
};
UndoRedo.prototype.isUndoAvailable = function() {
  return this.doneActions.length > 0;
};
UndoRedo.prototype.isRedoAvailable = function() {
  return this.undoneActions.length > 0;
};
UndoRedo.prototype.clear = function() {
  this.doneActions.length = 0;
  this.undoneActions.length = 0;
};
UndoRedo.prototype.isEnabled = function() {
  return this.enabled;
};
UndoRedo.prototype.enable = function() {
  if (this.isEnabled()) {
    return;
  }
  const hot = this.instance;
  this.enabled = true;
  exposeUndoRedoMethods(hot);
  this.registerShortcuts();
  hot.addHook("afterChange", onAfterChange);
};
UndoRedo.prototype.disable = function() {
  if (!this.isEnabled()) {
    return;
  }
  const hot = this.instance;
  this.enabled = false;
  removeExposedUndoRedoMethods(hot);
  this.unregisterShortcuts();
  hot.removeHook("afterChange", onAfterChange);
};
UndoRedo.prototype.destroy = function() {
  this.clear();
  this.instance = null;
  this.doneActions = null;
  this.undoneActions = null;
};
UndoRedo.Action = function() {
};
UndoRedo.Action.prototype.undo = function() {
};
UndoRedo.Action.prototype.redo = function() {
};
UndoRedo.ChangeAction = function(changes, selected) {
  this.changes = changes;
  this.selected = selected;
  this.actionType = "change";
};
inherit(UndoRedo.ChangeAction, UndoRedo.Action);
UndoRedo.ChangeAction.prototype.undo = function(instance, undoneCallback) {
  const data = deepClone(this.changes);
  const emptyRowsAtTheEnd = instance.countEmptyRows(true);
  const emptyColsAtTheEnd = instance.countEmptyCols(true);
  for (let i = 0, len = data.length; i < len; i++) {
    data[i].splice(3, 1);
  }
  instance.addHookOnce("afterChange", undoneCallback);
  instance.setDataAtCell(data, null, null, "UndoRedo.undo");
  for (let i = 0, len = data.length; i < len; i++) {
    const [row, column] = data[i];
    if (instance.getSettings().minSpareRows && row + 1 + instance.getSettings().minSpareRows === instance.countRows() && emptyRowsAtTheEnd === instance.getSettings().minSpareRows) {
      instance.alter("remove_row", parseInt(row + 1, 10), instance.getSettings().minSpareRows);
      instance.undoRedo.doneActions.pop();
    }
    if (instance.getSettings().minSpareCols && column + 1 + instance.getSettings().minSpareCols === instance.countCols() && emptyColsAtTheEnd === instance.getSettings().minSpareCols) {
      instance.alter("remove_col", parseInt(column + 1, 10), instance.getSettings().minSpareCols);
      instance.undoRedo.doneActions.pop();
    }
  }
  instance.selectCells(this.selected, false, false);
};
UndoRedo.ChangeAction.prototype.redo = function(instance, onFinishCallback) {
  const data = deepClone(this.changes);
  for (let i = 0, len = data.length; i < len; i++) {
    data[i].splice(2, 1);
  }
  instance.addHookOnce("afterChange", onFinishCallback);
  instance.setDataAtCell(data, null, null, "UndoRedo.redo");
  if (this.selected) {
    instance.selectCells(this.selected, false, false);
  }
};
UndoRedo.CreateRowAction = function(index, amount) {
  this.index = index;
  this.amount = amount;
  this.actionType = "insert_row";
};
inherit(UndoRedo.CreateRowAction, UndoRedo.Action);
UndoRedo.CreateRowAction.prototype.undo = function(instance, undoneCallback) {
  const rowCount = instance.countRows();
  const minSpareRows = instance.getSettings().minSpareRows;
  if (this.index >= rowCount && this.index - minSpareRows < rowCount) {
    this.index -= minSpareRows;
  }
  instance.addHookOnce("afterRemoveRow", undoneCallback);
  instance.alter("remove_row", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateRow", redoneCallback);
  instance.alter("insert_row_above", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveRowAction = function(index, data, fixedRowsBottom, fixedRowsTop, rowIndexesSequence) {
  this.index = index;
  this.data = data;
  this.actionType = "remove_row";
  this.fixedRowsBottom = fixedRowsBottom;
  this.fixedRowsTop = fixedRowsTop;
  this.rowIndexesSequence = rowIndexesSequence;
};
inherit(UndoRedo.RemoveRowAction, UndoRedo.Action);
UndoRedo.RemoveRowAction.prototype.undo = function(instance, undoneCallback) {
  const settings = instance.getSettings();
  const changes = [];
  settings.fixedRowsBottom = this.fixedRowsBottom;
  settings.fixedRowsTop = this.fixedRowsTop;
  this.data.forEach((dataRow, rowIndexDelta) => {
    Object.keys(dataRow).forEach((columnProp) => {
      const columnIndex = parseInt(columnProp, 10);
      changes.push([this.index + rowIndexDelta, isNaN(columnIndex) ? columnProp : columnIndex, dataRow[columnProp]]);
    });
  });
  instance.alter("insert_row_above", this.index, this.data.length, "UndoRedo.undo");
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.setSourceDataAtCell(changes, null, null, "UndoRedo.undo");
  instance.rowIndexMapper.setIndexesSequence(this.rowIndexesSequence);
};
UndoRedo.RemoveRowAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveRow", redoneCallback);
  instance.alter("remove_row", this.index, this.data.length, "UndoRedo.redo");
};
UndoRedo.CreateColumnAction = function(index, amount) {
  this.index = index;
  this.amount = amount;
  this.actionType = "insert_col";
};
inherit(UndoRedo.CreateColumnAction, UndoRedo.Action);
UndoRedo.CreateColumnAction.prototype.undo = function(instance, undoneCallback) {
  instance.addHookOnce("afterRemoveCol", undoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.undo");
};
UndoRedo.CreateColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterCreateCol", redoneCallback);
  instance.alter("insert_col_start", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.RemoveColumnAction = function(index, indexes, data, headers, columnPositions, rowPositions, fixedColumnsStart) {
  this.index = index;
  this.indexes = indexes;
  this.data = data;
  this.amount = this.data[0].length;
  this.headers = headers;
  this.columnPositions = columnPositions.slice(0);
  this.rowPositions = rowPositions.slice(0);
  this.actionType = "remove_col";
  this.fixedColumnsStart = fixedColumnsStart;
};
inherit(UndoRedo.RemoveColumnAction, UndoRedo.Action);
UndoRedo.RemoveColumnAction.prototype.undo = function(instance, undoneCallback) {
  const settings = instance.getSettings();
  settings.fixedColumnsStart = this.fixedColumnsStart;
  const ascendingIndexes = this.indexes.slice(0).sort();
  const sortByIndexes = (elem, j, arr) => arr[this.indexes.indexOf(ascendingIndexes[j])];
  const removedDataLength = this.data.length;
  const sortedData = [];
  for (let rowIndex = 0; rowIndex < removedDataLength; rowIndex++) {
    sortedData.push(arrayMap(this.data[rowIndex], sortByIndexes));
  }
  const sortedHeaders = arrayMap(this.headers, sortByIndexes);
  const changes = [];
  instance.alter("insert_col_start", this.indexes[0], this.indexes.length, "UndoRedo.undo");
  arrayEach(instance.getSourceDataArray(), (rowData, rowIndex) => {
    arrayEach(ascendingIndexes, (changedIndex, contiquesIndex) => {
      rowData[changedIndex] = sortedData[rowIndex][contiquesIndex];
      changes.push([rowIndex, changedIndex, rowData[changedIndex]]);
    });
  });
  instance.setSourceDataAtCell(changes, void 0, void 0, "UndoRedo.undo");
  if (typeof this.headers !== "undefined") {
    arrayEach(sortedHeaders, (headerData, columnIndex) => {
      instance.getSettings().colHeaders[ascendingIndexes[columnIndex]] = headerData;
    });
  }
  instance.batchExecution(() => {
    instance.rowIndexMapper.setIndexesSequence(this.rowPositions);
    instance.columnIndexMapper.setIndexesSequence(this.columnPositions);
  }, true);
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.RemoveColumnAction.prototype.redo = function(instance, redoneCallback) {
  instance.addHookOnce("afterRemoveCol", redoneCallback);
  instance.alter("remove_col", this.index, this.amount, "UndoRedo.redo");
};
UndoRedo.CellAlignmentAction = function(stateBefore, range, type, alignment) {
  this.stateBefore = stateBefore;
  this.range = range;
  this.type = type;
  this.alignment = alignment;
};
UndoRedo.CellAlignmentAction.prototype.undo = function(instance, undoneCallback) {
  arrayEach(this.range, (range) => {
    range.forAll((row, col) => {
      if (row >= 0 && col >= 0) {
        instance.setCellMeta(row, col, "className", this.stateBefore[row][col] || " htLeft");
      }
    });
  });
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.CellAlignmentAction.prototype.redo = function(instance, undoneCallback) {
  align(this.range, this.type, this.alignment, (row, col) => instance.getCellMeta(row, col), (row, col, key, value) => instance.setCellMeta(row, col, key, value));
  instance.addHookOnce("afterViewRender", undoneCallback);
  instance.render();
};
UndoRedo.FiltersAction = function(conditionsStack) {
  this.conditionsStack = conditionsStack;
  this.actionType = "filter";
};
inherit(UndoRedo.FiltersAction, UndoRedo.Action);
UndoRedo.FiltersAction.prototype.undo = function(instance, undoneCallback) {
  const filters = instance.getPlugin("filters");
  instance.addHookOnce("afterViewRender", undoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack.slice(0, this.conditionsStack.length - 1));
  filters.filter();
};
UndoRedo.FiltersAction.prototype.redo = function(instance, redoneCallback) {
  const filters = instance.getPlugin("filters");
  instance.addHookOnce("afterViewRender", redoneCallback);
  filters.conditionCollection.importAllConditions(this.conditionsStack);
  filters.filter();
};
var MergeCellsAction = class extends UndoRedo.Action {
  constructor(instance, cellRange) {
    super();
    this.cellRange = cellRange;
    const topStartCorner = this.cellRange.getTopStartCorner();
    const bottomEndCorner = this.cellRange.getBottomEndCorner();
    this.rangeData = instance.getData(topStartCorner.row, topStartCorner.col, bottomEndCorner.row, bottomEndCorner.col);
  }
  undo(instance, undoneCallback) {
    const mergeCellsPlugin = instance.getPlugin("mergeCells");
    instance.addHookOnce("afterViewRender", undoneCallback);
    mergeCellsPlugin.unmergeRange(this.cellRange, true);
    const topStartCorner = this.cellRange.getTopStartCorner();
    instance.populateFromArray(topStartCorner.row, topStartCorner.col, this.rangeData, void 0, void 0, "MergeCells");
  }
  redo(instance, redoneCallback) {
    const mergeCellsPlugin = instance.getPlugin("mergeCells");
    instance.addHookOnce("afterViewRender", redoneCallback);
    mergeCellsPlugin.mergeRange(this.cellRange);
  }
};
UndoRedo.MergeCellsAction = MergeCellsAction;
var UnmergeCellsAction = class extends UndoRedo.Action {
  constructor(instance, cellRange) {
    super();
    this.cellRange = cellRange;
  }
  undo(instance, undoneCallback) {
    const mergeCellsPlugin = instance.getPlugin("mergeCells");
    instance.addHookOnce("afterViewRender", undoneCallback);
    mergeCellsPlugin.mergeRange(this.cellRange, true);
  }
  redo(instance, redoneCallback) {
    const mergeCellsPlugin = instance.getPlugin("mergeCells");
    instance.addHookOnce("afterViewRender", redoneCallback);
    mergeCellsPlugin.unmergeRange(this.cellRange, true);
    instance.render();
  }
};
UndoRedo.UnmergeCellsAction = UnmergeCellsAction;
UndoRedo.RowMoveAction = function(rows, finalIndex) {
  this.rows = rows.slice();
  this.finalIndex = finalIndex;
  this.actionType = "row_move";
};
inherit(UndoRedo.RowMoveAction, UndoRedo.Action);
UndoRedo.RowMoveAction.prototype.undo = function(instance, undoneCallback) {
  const manualRowMove = instance.getPlugin("manualRowMove");
  const copyOfRows = [].concat(this.rows);
  const rowsMovedUp = copyOfRows.filter((a) => a > this.finalIndex);
  const rowsMovedDown = copyOfRows.filter((a) => a <= this.finalIndex);
  const allMovedRows = rowsMovedUp.sort((a, b) => b - a).concat(rowsMovedDown.sort((a, b) => a - b));
  instance.addHookOnce("afterViewRender", undoneCallback);
  for (let i = 0; i < allMovedRows.length; i += 1) {
    const newPhysicalRow = instance.toVisualRow(allMovedRows[i]);
    manualRowMove.moveRow(newPhysicalRow, allMovedRows[i]);
  }
  instance.render();
  instance.deselectCell();
  instance.selectRows(this.rows[0], this.rows[0] + this.rows.length - 1);
};
UndoRedo.RowMoveAction.prototype.redo = function(instance, redoneCallback) {
  const manualRowMove = instance.getPlugin("manualRowMove");
  instance.addHookOnce("afterViewRender", redoneCallback);
  manualRowMove.moveRows(this.rows.slice(), this.finalIndex);
  instance.render();
  instance.deselectCell();
  instance.selectRows(this.finalIndex, this.finalIndex + this.rows.length - 1);
};
UndoRedo.prototype.init = function() {
  const settings = this.instance.getSettings().undo;
  const pluginEnabled = typeof settings === "undefined" || settings;
  if (!this.instance.undoRedo) {
    this.instance.undoRedo = this;
  }
  if (pluginEnabled) {
    this.instance.undoRedo.enable();
  } else {
    this.instance.undoRedo.disable();
  }
};
UndoRedo.prototype.registerShortcuts = function() {
  const shortcutManager = this.instance.getShortcutManager();
  const gridContext = shortcutManager.getContext("grid");
  const runOnlyIf = (event) => {
    return !event.altKey;
  };
  const config = {
    runOnlyIf,
    group: SHORTCUTS_GROUP12
  };
  gridContext.addShortcuts([{
    keys: [["Control/Meta", "z"]],
    callback: () => {
      this.undo();
    }
  }, {
    keys: [["Control/Meta", "y"], ["Control/Meta", "Shift", "z"]],
    callback: () => {
      this.redo();
    }
  }], config);
};
UndoRedo.prototype.unregisterShortcuts = function() {
  const shortcutManager = this.instance.getShortcutManager();
  const gridContext = shortcutManager.getContext("grid");
  gridContext.removeShortcutsByGroup(SHORTCUTS_GROUP12);
};
function onAfterChange(changes, source) {
  const instance = this;
  if (source === "loadData") {
    return instance.undoRedo.clear();
  }
}
function exposeUndoRedoMethods(instance) {
  instance.undo = function() {
    return instance.undoRedo.undo();
  };
  instance.redo = function() {
    return instance.undoRedo.redo();
  };
  instance.isUndoAvailable = function() {
    return instance.undoRedo.isUndoAvailable();
  };
  instance.isRedoAvailable = function() {
    return instance.undoRedo.isRedoAvailable();
  };
  instance.clearUndo = function() {
    return instance.undoRedo.clear();
  };
}
function removeExposedUndoRedoMethods(instance) {
  delete instance.undo;
  delete instance.redo;
  delete instance.isUndoAvailable;
  delete instance.isRedoAvailable;
  delete instance.clearUndo;
}
var hook = pluginHooks_default.getSingleton();
hook.add("afterUpdateSettings", function() {
  var _this$getPlugin;
  (_this$getPlugin = this.getPlugin("undoRedo")) === null || _this$getPlugin === void 0 || _this$getPlugin.init();
});
hook.register("beforeUndo");
hook.register("afterUndo");
hook.register("beforeRedo");
hook.register("afterRedo");
UndoRedo.PLUGIN_KEY = PLUGIN_KEY34;
UndoRedo.SETTING_KEYS = true;
var undoRedo_default = UndoRedo;

// node_modules/handsontable/plugins/index.mjs
function registerAllPlugins() {
  registerPlugin(AutoColumnSize);
  registerPlugin(Autofill);
  registerPlugin(AutoRowSize);
  registerPlugin(BindRowsWithHeaders);
  registerPlugin(CollapsibleColumns);
  registerPlugin(ColumnSorting);
  registerPlugin(ColumnSummary);
  registerPlugin(Comments);
  registerPlugin(ContextMenu);
  registerPlugin(CopyPaste);
  registerPlugin(CustomBorders);
  registerPlugin(DragToScroll);
  registerPlugin(DropdownMenu);
  registerPlugin(ExportFile);
  registerPlugin(Filters);
  registerPlugin(Formulas);
  registerPlugin(HiddenColumns);
  registerPlugin(HiddenRows);
  registerPlugin(ManualColumnFreeze);
  registerPlugin(ManualColumnMove);
  registerPlugin(ManualColumnResize);
  registerPlugin(ManualRowMove);
  registerPlugin(ManualRowResize);
  registerPlugin(MergeCells);
  registerPlugin(MultiColumnSorting);
  registerPlugin(MultipleSelectionHandles);
  registerPlugin(NestedHeaders);
  registerPlugin(NestedRows);
  registerPlugin(PersistentState);
  registerPlugin(Search);
  registerPlugin(TouchScroll);
  registerPlugin(TrimRows);
  registerPlugin(undoRedo_default);
}

export {
  BasePlugin,
  ghostTable_default,
  AutoColumnSize,
  Autofill,
  AutoRowSize,
  BindRowsWithHeaders,
  CollapsibleColumns,
  ColumnSorting,
  ColumnSummary,
  Comments,
  ContextMenu,
  CopyPaste,
  CustomBorders,
  DragToScroll,
  DropdownMenu,
  ExportFile,
  Filters,
  Formulas,
  HiddenColumns,
  HiddenRows,
  ManualColumnFreeze,
  ManualColumnMove,
  ManualColumnResize,
  ManualRowMove,
  ManualRowResize,
  MergeCells,
  MultiColumnSorting,
  MultipleSelectionHandles,
  NestedHeaders,
  NestedRows,
  PersistentState,
  Search,
  TouchScroll,
  TrimRows,
  undoRedo_default,
  registerAllPlugins
};
//# sourceMappingURL=chunk-ARCBLE22.js.map
