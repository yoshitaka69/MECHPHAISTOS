{
  "version": 3,
  "sources": ["../../handsontable/utils/parseTable.mjs", "../../handsontable/helpers/data.mjs", "../../handsontable/translations/maps/indexMap.mjs", "../../handsontable/translations/maps/utils/physicallyIndexed.mjs", "../../handsontable/translations/maps/physicalIndexToValueMap.mjs", "../../handsontable/translations/maps/hidingMap.mjs", "../../handsontable/translations/maps/trimmingMap.mjs", "../../handsontable/translations/maps/utils/indexesSequence.mjs", "../../handsontable/translations/maps/utils/actionsOnIndexes.mjs", "../../handsontable/translations/maps/utils/index.mjs", "../../handsontable/translations/maps/indexesSequence.mjs", "../../handsontable/translations/maps/linkedPhysicalIndexToValueMap.mjs", "../../handsontable/translations/maps/index.mjs", "../../handsontable/translations/mapCollections/mapCollection.mjs", "../../handsontable/translations/mapCollections/aggregatedCollection.mjs", "../../handsontable/translations/changesObservable/observer.mjs", "../../handsontable/translations/changesObservable/utils.mjs", "../../handsontable/translations/changesObservable/observable.mjs", "../../handsontable/translations/indexMapper.mjs", "../../handsontable/selection/highlight/visualSelection.mjs", "../../handsontable/selection/highlight/types/activeHeader.mjs", "../../handsontable/selection/highlight/types/areaLayered.mjs", "../../handsontable/selection/highlight/types/area.mjs", "../../handsontable/selection/highlight/types/column.mjs", "../../handsontable/selection/highlight/types/focus.mjs", "../../handsontable/selection/highlight/types/customSelection.mjs", "../../handsontable/selection/highlight/types/fill.mjs", "../../handsontable/selection/highlight/types/header.mjs", "../../handsontable/selection/highlight/types/row.mjs", "../../handsontable/selection/highlight/highlight.mjs", "../../handsontable/selection/range.mjs", "../../handsontable/selection/transformation.mjs", "../../handsontable/selection/selection.mjs", "../../handsontable/selection/mouseEventHandler.mjs", "../../handsontable/3rdparty/SheetClip/SheetClip.mjs"],
  "sourcesContent": ["import \"core-js/modules/es.array.push.js\";\nimport { isEmpty } from \"./../helpers/mixed.mjs\";\nconst ESCAPED_HTML_CHARS = {\n  '&nbsp;': '\\x20',\n  '&amp;': '&',\n  '&lt;': '<',\n  '&gt;': '>'\n};\nconst regEscapedChars = new RegExp(Object.keys(ESCAPED_HTML_CHARS).map(key => `(${key})`).join('|'), 'gi');\n\n/**\n * Verifies if node is an HTMLTable element.\n *\n * @param {Node} element Node to verify if it's an HTMLTable.\n * @returns {boolean}\n */\nfunction isHTMLTable(element) {\n  return (element && element.nodeName || '') === 'TABLE';\n}\n\n/**\n * Converts Handsontable into HTMLTableElement.\n *\n * @param {Core} instance The Handsontable instance.\n * @returns {string} OuterHTML of the HTMLTableElement.\n */\nexport function instanceToHTML(instance) {\n  const hasColumnHeaders = instance.hasColHeaders();\n  const hasRowHeaders = instance.hasRowHeaders();\n  const coords = [hasColumnHeaders ? -1 : 0, hasRowHeaders ? -1 : 0, instance.countRows() - 1, instance.countCols() - 1];\n  const data = instance.getData(...coords);\n  const countRows = data.length;\n  const countCols = countRows > 0 ? data[0].length : 0;\n  const TABLE = ['<table>', '</table>'];\n  const THEAD = hasColumnHeaders ? ['<thead>', '</thead>'] : [];\n  const TBODY = ['<tbody>', '</tbody>'];\n  const rowModifier = hasRowHeaders ? 1 : 0;\n  const columnModifier = hasColumnHeaders ? 1 : 0;\n  for (let row = 0; row < countRows; row += 1) {\n    const isColumnHeadersRow = hasColumnHeaders && row === 0;\n    const CELLS = [];\n    for (let column = 0; column < countCols; column += 1) {\n      const isRowHeadersColumn = !isColumnHeadersRow && hasRowHeaders && column === 0;\n      let cell = '';\n      if (isColumnHeadersRow) {\n        cell = `<th>${instance.getColHeader(column - rowModifier)}</th>`;\n      } else if (isRowHeadersColumn) {\n        cell = `<th>${instance.getRowHeader(row - columnModifier)}</th>`;\n      } else {\n        const cellData = data[row][column];\n        const {\n          hidden,\n          rowspan,\n          colspan\n        } = instance.getCellMeta(row - columnModifier, column - rowModifier);\n        if (!hidden) {\n          const attrs = [];\n          if (rowspan) {\n            attrs.push(`rowspan=\"${rowspan}\"`);\n          }\n          if (colspan) {\n            attrs.push(`colspan=\"${colspan}\"`);\n          }\n          if (isEmpty(cellData)) {\n            cell = `<td ${attrs.join(' ')}></td>`;\n          } else {\n            const value = cellData.toString().replace('<', '&lt;').replace('>', '&gt;').replace(/(<br(\\s*|\\/)>(\\r\\n|\\n)?|\\r\\n|\\n)/g, '<br>\\r\\n').replace(/\\x20/gi, '&nbsp;').replace(/\\t/gi, '&#9;');\n            cell = `<td ${attrs.join(' ')}>${value}</td>`;\n          }\n        }\n      }\n      CELLS.push(cell);\n    }\n    const TR = ['<tr>', ...CELLS, '</tr>'].join('');\n    if (isColumnHeadersRow) {\n      THEAD.splice(1, 0, TR);\n    } else {\n      TBODY.splice(-1, 0, TR);\n    }\n  }\n  TABLE.splice(1, 0, THEAD.join(''), TBODY.join(''));\n  return TABLE.join('');\n}\n\n/**\n * Converts 2D array into HTMLTableElement.\n *\n * @param {Array} input Input array which will be converted to HTMLTable.\n * @returns {string} OuterHTML of the HTMLTableElement.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function _dataToHTML(input) {\n  const inputLen = input.length;\n  const result = ['<table>'];\n  for (let row = 0; row < inputLen; row += 1) {\n    const rowData = input[row];\n    const columnsLen = rowData.length;\n    const columnsResult = [];\n    if (row === 0) {\n      result.push('<tbody>');\n    }\n    for (let column = 0; column < columnsLen; column += 1) {\n      const cellData = rowData[column];\n      const parsedCellData = isEmpty(cellData) ? '' : cellData.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/(<br(\\s*|\\/)>(\\r\\n|\\n)?|\\r\\n|\\n)/g, '<br>\\r\\n').replace(/\\x20{2,}/gi, substring => {\n        // The way how Excel serializes data with at least two spaces.\n        return `<span style=\"mso-spacerun: yes\">${'&nbsp;'.repeat(substring.length - 1)} </span>`;\n      }).replace(/\\t/gi, '&#9;');\n      columnsResult.push(`<td>${parsedCellData}</td>`);\n    }\n    result.push('<tr>', ...columnsResult, '</tr>');\n    if (row + 1 === inputLen) {\n      result.push('</tbody>');\n    }\n  }\n  result.push('</table>');\n  return result.join('');\n}\n\n/**\n * Converts HTMLTable or string into Handsontable configuration object.\n *\n * @param {Element|string} element Node element which should contain `<table>...</table>`.\n * @param {Document} [rootDocument] The document window owner.\n * @returns {object} Return configuration object. Contains keys as DefaultSettings.\n */\n// eslint-disable-next-line no-restricted-globals\nexport function htmlToGridSettings(element) {\n  let rootDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  const settingsObj = {};\n  const fragment = rootDocument.createDocumentFragment();\n  const tempElem = rootDocument.createElement('div');\n  fragment.appendChild(tempElem);\n  let checkElement = element;\n  if (typeof checkElement === 'string') {\n    const escapedAdjacentHTML = checkElement.replace(/<td\\b[^>]*?>([\\s\\S]*?)<\\/\\s*td>/g, cellFragment => {\n      const openingTag = cellFragment.match(/<td\\b[^>]*?>/g)[0];\n      const cellValue = cellFragment.substring(openingTag.length, cellFragment.lastIndexOf('<')).replace(/(<(?!br)([^>]+)>)/gi, '');\n      const closingTag = '</td>';\n      return `${openingTag}${cellValue}${closingTag}`;\n    });\n    tempElem.insertAdjacentHTML('afterbegin', `${escapedAdjacentHTML}`);\n    checkElement = tempElem.querySelector('table');\n  }\n  if (!checkElement || !isHTMLTable(checkElement)) {\n    return;\n  }\n  const generator = tempElem.querySelector('meta[name$=\"enerator\"]');\n  const hasRowHeaders = checkElement.querySelector('tbody th') !== null;\n  const trElement = checkElement.querySelector('tr');\n  const countCols = !trElement ? 0 : Array.from(trElement.cells).reduce((cols, cell) => cols + cell.colSpan, 0) - (hasRowHeaders ? 1 : 0);\n  const fixedRowsBottom = checkElement.tFoot && Array.from(checkElement.tFoot.rows) || [];\n  const fixedRowsTop = [];\n  let hasColHeaders = false;\n  let thRowsLen = 0;\n  let countRows = 0;\n  if (checkElement.tHead) {\n    const thRows = Array.from(checkElement.tHead.rows).filter(tr => {\n      const isDataRow = tr.querySelector('td') !== null;\n      if (isDataRow) {\n        fixedRowsTop.push(tr);\n      }\n      return !isDataRow;\n    });\n    thRowsLen = thRows.length;\n    hasColHeaders = thRowsLen > 0;\n    if (thRowsLen > 1) {\n      settingsObj.nestedHeaders = Array.from(thRows).reduce((rows, row) => {\n        const headersRow = Array.from(row.cells).reduce((headers, header, currentIndex) => {\n          if (hasRowHeaders && currentIndex === 0) {\n            return headers;\n          }\n          const {\n            colSpan: colspan,\n            innerHTML\n          } = header;\n          const nextHeader = colspan > 1 ? {\n            label: innerHTML,\n            colspan\n          } : innerHTML;\n          headers.push(nextHeader);\n          return headers;\n        }, []);\n        rows.push(headersRow);\n        return rows;\n      }, []);\n    } else if (hasColHeaders) {\n      settingsObj.colHeaders = Array.from(thRows[0].children).reduce((headers, header, index) => {\n        if (hasRowHeaders && index === 0) {\n          return headers;\n        }\n        headers.push(header.innerHTML);\n        return headers;\n      }, []);\n    }\n  }\n  if (fixedRowsTop.length) {\n    settingsObj.fixedRowsTop = fixedRowsTop.length;\n  }\n  if (fixedRowsBottom.length) {\n    settingsObj.fixedRowsBottom = fixedRowsBottom.length;\n  }\n  const dataRows = [...fixedRowsTop, ...Array.from(checkElement.tBodies).reduce((sections, section) => {\n    sections.push(...Array.from(section.rows));\n    return sections;\n  }, []), ...fixedRowsBottom];\n  countRows = dataRows.length;\n  const dataArr = new Array(countRows);\n  for (let r = 0; r < countRows; r++) {\n    dataArr[r] = new Array(countCols);\n  }\n  const mergeCells = [];\n  const rowHeaders = [];\n  for (let row = 0; row < countRows; row++) {\n    const tr = dataRows[row];\n    const cells = Array.from(tr.cells);\n    const cellsLen = cells.length;\n    for (let cellId = 0; cellId < cellsLen; cellId++) {\n      const cell = cells[cellId];\n      const {\n        nodeName,\n        innerHTML,\n        rowSpan: rowspan,\n        colSpan: colspan\n      } = cell;\n      const col = dataArr[row].findIndex(value => value === undefined);\n      if (nodeName === 'TD') {\n        if (rowspan > 1 || colspan > 1) {\n          for (let rstart = row; rstart < row + rowspan; rstart++) {\n            if (rstart < countRows) {\n              for (let cstart = col; cstart < col + colspan; cstart++) {\n                dataArr[rstart][cstart] = null;\n              }\n            }\n          }\n          const styleAttr = cell.getAttribute('style');\n          const ignoreMerge = styleAttr && styleAttr.includes('mso-ignore:colspan');\n          if (!ignoreMerge) {\n            mergeCells.push({\n              col,\n              row,\n              rowspan,\n              colspan\n            });\n          }\n        }\n        let cellValue = '';\n        if (generator && /excel/gi.test(generator.content)) {\n          cellValue = innerHTML.replace(/[\\r\\n][\\x20]{0,2}/g, '\\x20').replace(/<br(\\s*|\\/)>[\\r\\n]?[\\x20]{0,3}/gim, '\\r\\n');\n        } else {\n          cellValue = innerHTML.replace(/<br(\\s*|\\/)>[\\r\\n]?/gim, '\\r\\n');\n        }\n        dataArr[row][col] = cellValue.replace(regEscapedChars, match => ESCAPED_HTML_CHARS[match]);\n      } else {\n        rowHeaders.push(innerHTML);\n      }\n    }\n  }\n  if (mergeCells.length) {\n    settingsObj.mergeCells = mergeCells;\n  }\n  if (rowHeaders.length) {\n    settingsObj.rowHeaders = rowHeaders;\n  }\n  if (dataArr.length) {\n    settingsObj.data = dataArr;\n  }\n  return settingsObj;\n}", "import \"core-js/modules/es.array.push.js\";\nimport { deepObjectSize, isObject } from \"./object.mjs\";\nconst COLUMN_LABEL_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nconst COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;\n\n/**\n * Generates spreadsheet-like column names: A, B, C, ..., Z, AA, AB, etc.\n *\n * @param {number} index Column index.\n * @returns {string}\n */\nexport function spreadsheetColumnLabel(index) {\n  let dividend = index + 1;\n  let columnLabel = '';\n  let modulo;\n  while (dividend > 0) {\n    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;\n    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;\n    dividend = parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);\n  }\n  return columnLabel;\n}\n\n/**\n * Generates spreadsheet-like column index from theirs labels: A, B, C ...., Z, AA, AB, etc.\n *\n * @param {string} label Column label.\n * @returns {number}\n */\nexport function spreadsheetColumnIndex(label) {\n  let result = 0;\n  if (label) {\n    for (let i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {\n      result += COLUMN_LABEL_BASE_LENGTH ** j * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);\n    }\n  }\n  result -= 1;\n  return result;\n}\n\n/**\n * Creates 2D array of Excel-like values \"A1\", \"A2\", ...\n *\n * @param {number} rows Number of rows to generate.\n * @param {number} columns Number of columns to generate.\n * @returns {Array}\n */\nexport function createSpreadsheetData() {\n  let rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n  let columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  const _rows = [];\n  let i;\n  let j;\n  for (i = 0; i < rows; i++) {\n    const row = [];\n    for (j = 0; j < columns; j++) {\n      row.push(spreadsheetColumnLabel(j) + (i + 1));\n    }\n    _rows.push(row);\n  }\n  return _rows;\n}\n\n/**\n * Creates 2D array of Excel-like values \"A1\", \"A2\", as an array of objects.\n *\n * @param {number} rows Number of rows to generate.\n * @param {number} colCount Number of columns to generate.\n * @returns {Array}\n */\nexport function createSpreadsheetObjectData() {\n  let rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n  let colCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  const _rows = [];\n  let i;\n  let j;\n  for (i = 0; i < rows; i++) {\n    const row = {};\n    for (j = 0; j < colCount; j++) {\n      row[`prop${j}`] = spreadsheetColumnLabel(j) + (i + 1);\n    }\n    _rows.push(row);\n  }\n  return _rows;\n}\n\n/**\n * Generates an empty data object.\n *\n * @param {number} rows Number of rows to generate.\n * @param {number} columns Number of columns to generate.\n * @returns {Array}\n */\nexport function createEmptySpreadsheetData(rows, columns) {\n  const data = [];\n  let row;\n  for (let i = 0; i < rows; i++) {\n    row = [];\n    for (let j = 0; j < columns; j++) {\n      row.push('');\n    }\n    data.push(row);\n  }\n  return data;\n}\n\n/**\n * Transform a data row (either an array or an object) or an array of data rows to array of changes in a form of `[row,\n * prop/col, value]`. Convenient to use with `setDataAtRowProp` and `setSourceDataAtCell` methods.\n *\n * @param {Array|object} dataRow Object of row data, array of row data or an array of either.\n * @param {number} rowOffset Row offset to be passed to the resulting change list. Defaults to `0`.\n * @returns {Array} Array of changes (in a form of an array).\n */\nexport function dataRowToChangesArray(dataRow) {\n  let rowOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let dataRows = dataRow;\n  const changesArray = [];\n  if (!Array.isArray(dataRow) || !Array.isArray(dataRow[0])) {\n    dataRows = [dataRow];\n  }\n  dataRows.forEach((row, rowIndex) => {\n    if (Array.isArray(row)) {\n      row.forEach((value, column) => {\n        changesArray.push([rowIndex + rowOffset, column, value]);\n      });\n    } else {\n      Object.keys(row).forEach(propName => {\n        changesArray.push([rowIndex + rowOffset, propName, row[propName]]);\n      });\n    }\n  });\n  return changesArray;\n}\n\n/**\n * Count the number of keys (or, basically, columns when the data is an array or arrays) in the first row of the\n * provided dataset.\n *\n * @param {Array} data The dataset.\n * @returns {number} Number of keys in the first row of the dataset.\n */\nexport function countFirstRowKeys(data) {\n  let result = 0;\n  if (Array.isArray(data)) {\n    if (data[0] && Array.isArray(data[0])) {\n      result = data[0].length;\n    } else if (data[0] && isObject(data[0])) {\n      result = deepObjectSize(data[0]);\n    }\n  }\n  return result;\n}\n\n/**\n * Check whether the provided dataset is a *non-empty* array of arrays.\n *\n * @param {Array} data Dataset to be checked.\n * @returns {boolean} `true` if data is an array of arrays, `false` otherwise.\n */\nexport function isArrayOfArrays(data) {\n  return !!(Array.isArray(data) && data.length && data.every(el => Array.isArray(el)));\n}\n\n/**\n * Check whether the provided dataset is a *non-empty* array of objects.\n *\n * @param {Array} data Dataset to be checked.\n * @returns {boolean} `true` if data is an array of objects, `false` otherwise.\n */\nexport function isArrayOfObjects(data) {\n  return !!(Array.isArray(data) && data.length && data.every(el => typeof el === 'object' && !Array.isArray(el) && el !== null));\n}", "import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\nimport { isFunction } from \"../../helpers/function.mjs\";\nimport localHooks from \"../../mixins/localHooks.mjs\";\n/**\n * Map for storing mappings from an index to a value.\n *\n * @class IndexMap\n */\nexport class IndexMap {\n  constructor() {\n    let initValueOrFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    /**\n     * List of values for particular indexes.\n     *\n     * @private\n     * @type {Array}\n     */\n    _defineProperty(this, \"indexedValues\", []);\n    /**\n     * Initial value or function for each existing index.\n     *\n     * @private\n     * @type {*}\n     */\n    _defineProperty(this, \"initValueOrFn\", void 0);\n    this.initValueOrFn = initValueOrFn;\n  }\n\n  /**\n   * Get full list of values for particular indexes.\n   *\n   * @returns {Array}\n   */\n  getValues() {\n    return this.indexedValues;\n  }\n\n  /**\n   * Get value for the particular index.\n   *\n   * @param {number} index Index for which value is got.\n   * @returns {*}\n   */\n  getValueAtIndex(index) {\n    const values = this.indexedValues;\n    if (index < values.length) {\n      return values[index];\n    }\n  }\n\n  /**\n   * Set new values for particular indexes.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @param {Array} values List of set values.\n   */\n  setValues(values) {\n    this.indexedValues = values.slice();\n    this.runLocalHooks('change');\n  }\n\n  /**\n   * Set new value for the particular index.\n   *\n   * @param {number} index The index.\n   * @param {*} value The value to save.\n   *\n   * Note: Please keep in mind that it is not possible to set value beyond the map (not respecting already set\n   * map's size). Please use the `setValues` method when you would like to extend the map.\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @returns {boolean}\n   */\n  setValueAtIndex(index, value) {\n    if (index < this.indexedValues.length) {\n      this.indexedValues[index] = value;\n      this.runLocalHooks('change');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear all values to the defaults.\n   */\n  clear() {\n    this.setDefaultValues();\n  }\n\n  /**\n   * Get length of the index map.\n   *\n   * @returns {number}\n   */\n  getLength() {\n    return this.getValues().length;\n  }\n\n  /**\n   * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @private\n   * @param {number} [length] Length of list.\n   */\n  setDefaultValues() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.indexedValues.length;\n    this.indexedValues.length = 0;\n    if (isFunction(this.initValueOrFn)) {\n      rangeEach(length - 1, index => this.indexedValues.push(this.initValueOrFn(index)));\n    } else {\n      rangeEach(length - 1, () => this.indexedValues.push(this.initValueOrFn));\n    }\n    this.runLocalHooks('change');\n  }\n\n  /**\n   * Initialize list with default values for particular indexes.\n   *\n   * @private\n   * @param {number} length New length of indexed list.\n   * @returns {IndexMap}\n   */\n  init(length) {\n    this.setDefaultValues(length);\n    this.runLocalHooks('init');\n    return this;\n  }\n\n  /**\n   * Add values to the list.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @private\n   */\n  insert() {\n    this.runLocalHooks('change');\n  }\n\n  /**\n   * Remove values from the list.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @private\n   */\n  remove() {\n    this.runLocalHooks('change');\n  }\n\n  /**\n   * Destroys the Map instance.\n   */\n  destroy() {\n    this.clearLocalHooks();\n    this.indexedValues = null;\n    this.initValueOrFn = null;\n  }\n}\nmixin(IndexMap, localHooks);", "import { isFunction } from \"../../../helpers/function.mjs\";\nimport { arrayFilter } from \"../../../helpers/array.mjs\";\n/**\n * Insert new items to the list.\n *\n * @private\n * @param {Array} indexedValues List of values for particular indexes.\n * @param {number} insertionIndex Position inside the actual list.\n * @param {Array} insertedIndexes List of inserted indexes.\n * @param {*} insertedValuesMapping Mapping which may provide value or function returning value for the specific parameters.\n * @returns {Array} List with new mappings.\n */\nexport function getListWithInsertedItems(indexedValues, insertionIndex, insertedIndexes, insertedValuesMapping) {\n  const firstInsertedIndex = insertedIndexes.length ? insertedIndexes[0] : undefined;\n  return [...indexedValues.slice(0, firstInsertedIndex), ...insertedIndexes.map((insertedIndex, ordinalNumber) => {\n    if (isFunction(insertedValuesMapping)) {\n      return insertedValuesMapping(insertedIndex, ordinalNumber);\n    }\n    return insertedValuesMapping;\n  }), ...(firstInsertedIndex === undefined ? [] : indexedValues.slice(firstInsertedIndex))];\n}\n\n/**\n * Filter items from the list.\n *\n * @private\n * @param {Array} indexedValues List of values for particular indexes.\n * @param {Array} removedIndexes List of removed indexes.\n * @returns {Array} Reduced list of mappings.\n */\nexport function getListWithRemovedItems(indexedValues, removedIndexes) {\n  return arrayFilter(indexedValues, (_, index) => removedIndexes.includes(index) === false);\n}", "import { IndexMap } from \"./indexMap.mjs\";\nimport { getListWithRemovedItems, getListWithInsertedItems } from \"./utils/physicallyIndexed.mjs\";\n/**\n * Map for storing mappings from an physical index to a value.\n *\n * Does not update stored values on remove/add row or column action.\n *\n * @class PhysicalIndexToValueMap\n */\nexport class PhysicalIndexToValueMap extends IndexMap {\n  /**\n   * Add values to list and reorganize.\n   *\n   * @private\n   * @param {number} insertionIndex Position inside the list.\n   * @param {Array} insertedIndexes List of inserted indexes.\n   */\n  insert(insertionIndex, insertedIndexes) {\n    this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);\n    super.insert(insertionIndex, insertedIndexes);\n  }\n\n  /**\n   * Remove values from the list and reorganize.\n   *\n   * @private\n   * @param {Array} removedIndexes List of removed indexes.\n   */\n  remove(removedIndexes) {\n    this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);\n    super.remove(removedIndexes);\n  }\n}", "import \"core-js/modules/es.array.push.js\";\nimport { PhysicalIndexToValueMap } from \"./physicalIndexToValueMap.mjs\";\nimport { arrayReduce } from \"../../helpers/array.mjs\";\n/**\n * Map for storing mappings from an physical index to a boolean value. It stores information whether physical index is\n * included in a dataset, but skipped in the process of rendering.\n *\n * @class HidingMap\n */\nexport class HidingMap extends PhysicalIndexToValueMap {\n  constructor() {\n    let initValueOrFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    super(initValueOrFn);\n  }\n\n  /**\n   * Get physical indexes which are hidden.\n   *\n   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.\n   *\n   * @returns {Array}\n   */\n  getHiddenIndexes() {\n    return arrayReduce(this.getValues(), (indexesList, isHidden, physicalIndex) => {\n      if (isHidden) {\n        indexesList.push(physicalIndex);\n      }\n      return indexesList;\n    }, []);\n  }\n}", "import \"core-js/modules/es.array.push.js\";\nimport { PhysicalIndexToValueMap } from \"./physicalIndexToValueMap.mjs\";\nimport { arrayReduce } from \"../../helpers/array.mjs\";\n/**\n * Map for storing mappings from an physical index to a boolean value. It stores information whether physical index is\n * NOT included in a dataset and skipped in the process of rendering.\n *\n * @class TrimmingMap\n */\nexport class TrimmingMap extends PhysicalIndexToValueMap {\n  constructor() {\n    let initValueOrFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    super(initValueOrFn);\n  }\n\n  /**\n   * Get physical indexes which are trimmed.\n   *\n   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.\n   *\n   * @returns {Array}\n   */\n  getTrimmedIndexes() {\n    return arrayReduce(this.getValues(), (indexesList, isTrimmed, physicalIndex) => {\n      if (isTrimmed) {\n        indexesList.push(physicalIndex);\n      }\n      return indexesList;\n    }, []);\n  }\n}", "import { arrayFilter } from \"../../../helpers/array.mjs\";\n/**\n * Insert new items to the list.\n *\n * @private\n * @param {Array} indexedValues List of values for particular indexes.\n * @param {number} insertionIndex Position inside the actual list.\n * @param {Array} insertedIndexes List of inserted indexes.\n * @returns {Array} List with new mappings.\n */\nexport function getListWithInsertedItems(indexedValues, insertionIndex, insertedIndexes) {\n  return [...indexedValues.slice(0, insertionIndex), ...insertedIndexes, ...indexedValues.slice(insertionIndex)];\n}\n\n/**\n * Filter items from the list.\n *\n * @private\n * @param {Array} indexedValues List of values for particular indexes.\n * @param {Array} removedIndexes List of removed indexes.\n * @returns {Array} Reduced list of mappings.\n */\nexport function getListWithRemovedItems(indexedValues, removedIndexes) {\n  return arrayFilter(indexedValues, index => {\n    return removedIndexes.includes(index) === false;\n  });\n}", "import { arrayMap } from \"../../../helpers/array.mjs\";\n/**\n * Transform mappings after removal.\n *\n * @private\n * @param {Array} indexedValues List of values for particular indexes.\n * @param {Array} removedIndexes List of removed indexes.\n * @returns {Array} List with decreased indexes.\n */\nexport function getDecreasedIndexes(indexedValues, removedIndexes) {\n  return arrayMap(indexedValues, index => index - removedIndexes.filter(removedIndex => removedIndex < index).length);\n}\n\n/**\n * Transform mappings after insertion.\n *\n * @private\n * @param {Array} indexedValues List of values for particular indexes.\n * @param {Array} insertedIndexes List of inserted indexes.\n * @returns {Array} List with increased indexes.\n */\nexport function getIncreasedIndexes(indexedValues, insertedIndexes) {\n  const firstInsertedIndex = insertedIndexes[0];\n  const amountOfIndexes = insertedIndexes.length;\n  return arrayMap(indexedValues, index => {\n    if (index >= firstInsertedIndex) {\n      return index + amountOfIndexes;\n    }\n    return index;\n  });\n}", "import \"core-js/modules/es.error.cause.js\";\nimport { getDecreasedIndexes, getIncreasedIndexes } from \"./actionsOnIndexes.mjs\";\nimport { getListWithInsertedItems as sequenceStrategyInsert, getListWithRemovedItems as sequenceStrategyRemove } from \"./indexesSequence.mjs\";\nimport { getListWithInsertedItems as physicalStrategyInsert, getListWithRemovedItems as physicalStrategyRemove } from \"./physicallyIndexed.mjs\";\nconst alterStrategies = new Map([['indexesSequence', {\n  getListWithInsertedItems: sequenceStrategyInsert,\n  getListWithRemovedItems: sequenceStrategyRemove\n}], ['physicallyIndexed', {\n  getListWithInsertedItems: physicalStrategyInsert,\n  getListWithRemovedItems: physicalStrategyRemove\n}]]);\nconst alterUtilsFactory = indexationStrategy => {\n  if (alterStrategies.has(indexationStrategy) === false) {\n    throw new Error(`Alter strategy with ID '${indexationStrategy}' does not exist.`);\n  }\n  return alterStrategies.get(indexationStrategy);\n};\nexport { getDecreasedIndexes, getIncreasedIndexes, alterUtilsFactory };", "import { IndexMap } from \"./indexMap.mjs\";\nimport { getListWithRemovedItems, getListWithInsertedItems } from \"./utils/indexesSequence.mjs\";\nimport { getDecreasedIndexes, getIncreasedIndexes } from \"./utils/index.mjs\";\n/**\n * Map for storing mappings from an index to a physical index.\n *\n * It also updates the physical indexes (remaining in the map) on remove/add row or column action.\n *\n * @class IndexesSequence\n */\nexport class IndexesSequence extends IndexMap {\n  constructor() {\n    // Not handling custom init function or init value.\n    super(index => index);\n  }\n\n  /**\n   * Add values to list and reorganize.\n   *\n   * @private\n   * @param {number} insertionIndex Position inside the list.\n   * @param {Array} insertedIndexes List of inserted indexes.\n   */\n  insert(insertionIndex, insertedIndexes) {\n    const listAfterUpdate = getIncreasedIndexes(this.indexedValues, insertedIndexes);\n    this.indexedValues = getListWithInsertedItems(listAfterUpdate, insertionIndex, insertedIndexes);\n    super.insert(insertionIndex, insertedIndexes);\n  }\n\n  /**\n   * Remove values from the list and reorganize.\n   *\n   * @private\n   * @param {Array} removedIndexes List of removed indexes.\n   */\n  remove(removedIndexes) {\n    const listAfterUpdate = getListWithRemovedItems(this.indexedValues, removedIndexes);\n    this.indexedValues = getDecreasedIndexes(listAfterUpdate, removedIndexes);\n    super.remove(removedIndexes);\n  }\n}", "import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { IndexMap } from \"./indexMap.mjs\";\nimport { getListWithRemovedItems, getListWithInsertedItems } from \"./utils/physicallyIndexed.mjs\";\nimport { getListWithRemovedItems as getListWithoutIndexes } from \"./utils/indexesSequence.mjs\";\nimport { getDecreasedIndexes, getIncreasedIndexes } from \"./utils/actionsOnIndexes.mjs\";\nimport { isFunction } from \"../../helpers/function.mjs\";\n/**\n * Map for storing mappings from an physical index to a value. Those entries are linked and stored in a certain order.\n *\n * It does not update stored values on remove/add row or column action. Otherwise, order of entries is updated after\n * such changes.\n *\n * @class LinkedPhysicalIndexToValueMap\n */\nexport class LinkedPhysicalIndexToValueMap extends IndexMap {\n  constructor() {\n    super(...arguments);\n    /**\n     * Indexes and values corresponding to them (entries) are stored in a certain order.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _defineProperty(this, \"orderOfIndexes\", []);\n  }\n  /**\n   * Get full list of ordered values for particular indexes.\n   *\n   * @returns {Array}\n   */\n  getValues() {\n    return this.orderOfIndexes.map(physicalIndex => this.indexedValues[physicalIndex]);\n  }\n\n  /**\n   * Set new values for particular indexes. Entries are linked and stored in a certain order.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @param {Array} values List of set values.\n   */\n  setValues(values) {\n    this.orderOfIndexes = [...Array(values.length).keys()];\n    super.setValues(values);\n  }\n\n  /**\n   * Set value at index and add it to the linked list of entries. Entries are stored in a certain order.\n   *\n   * Note: Value will be added at the end of the queue.\n   *\n   * @param {number} index The index.\n   * @param {*} value The value to save.\n   * @param {number} position Position to which entry will be added.\n   *\n   * @returns {boolean}\n   */\n  setValueAtIndex(index, value) {\n    let position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.orderOfIndexes.length;\n    if (index < this.indexedValues.length) {\n      this.indexedValues[index] = value;\n      if (this.orderOfIndexes.includes(index) === false) {\n        this.orderOfIndexes.splice(position, 0, index);\n      }\n      this.runLocalHooks('change');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear value for particular index.\n   *\n   * @param {number} physicalIndex Physical index.\n   */\n  clearValue(physicalIndex) {\n    this.orderOfIndexes = getListWithoutIndexes(this.orderOfIndexes, [physicalIndex]);\n    if (isFunction(this.initValueOrFn)) {\n      super.setValueAtIndex(physicalIndex, this.initValueOrFn(physicalIndex));\n    } else {\n      super.setValueAtIndex(physicalIndex, this.initValueOrFn);\n    }\n  }\n\n  /**\n   * Get length of the index map.\n   *\n   * @returns {number}\n   */\n  getLength() {\n    return this.orderOfIndexes.length;\n  }\n\n  /**\n   * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.\n   *\n   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.\n   *\n   * @private\n   * @param {number} [length] Length of list.\n   */\n  setDefaultValues() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.indexedValues.length;\n    this.orderOfIndexes.length = 0;\n    super.setDefaultValues(length);\n  }\n\n  /**\n   * Add values to list and reorganize. It updates list of indexes related to ordered values.\n   *\n   * @private\n   * @param {number} insertionIndex Position inside the list.\n   * @param {Array} insertedIndexes List of inserted indexes.\n   */\n  insert(insertionIndex, insertedIndexes) {\n    this.indexedValues = getListWithInsertedItems(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);\n    this.orderOfIndexes = getIncreasedIndexes(this.orderOfIndexes, insertedIndexes);\n    super.insert(insertionIndex, insertedIndexes);\n  }\n\n  /**\n   * Remove values from the list and reorganize. It updates list of indexes related to ordered values.\n   *\n   * @private\n   * @param {Array} removedIndexes List of removed indexes.\n   */\n  remove(removedIndexes) {\n    this.indexedValues = getListWithRemovedItems(this.indexedValues, removedIndexes);\n    this.orderOfIndexes = getListWithoutIndexes(this.orderOfIndexes, removedIndexes);\n    this.orderOfIndexes = getDecreasedIndexes(this.orderOfIndexes, removedIndexes);\n    super.remove(removedIndexes);\n  }\n\n  /**\n   * Get every entry containing index and value, respecting order of indexes.\n   *\n   * @returns {Array}\n   */\n  getEntries() {\n    return this.orderOfIndexes.map(physicalIndex => [physicalIndex, this.getValueAtIndex(physicalIndex)]);\n  }\n}", "import \"core-js/modules/es.error.cause.js\";\nimport { HidingMap } from \"./hidingMap.mjs\";\nimport { IndexMap } from \"./indexMap.mjs\";\nimport { LinkedPhysicalIndexToValueMap } from \"./linkedPhysicalIndexToValueMap.mjs\";\nimport { PhysicalIndexToValueMap } from \"./physicalIndexToValueMap.mjs\";\nimport { TrimmingMap } from \"./trimmingMap.mjs\";\nexport * from \"./indexesSequence.mjs\";\nexport * from \"./utils/indexesSequence.mjs\";\nexport { HidingMap, IndexMap, LinkedPhysicalIndexToValueMap, PhysicalIndexToValueMap, TrimmingMap };\nconst availableIndexMapTypes = new Map([['hiding', HidingMap], ['index', IndexMap], ['linkedPhysicalIndexToValue', LinkedPhysicalIndexToValueMap], ['physicalIndexToValue', PhysicalIndexToValueMap], ['trimming', TrimmingMap]]);\n\n/**\n * Creates and returns new IndexMap instance.\n *\n * @param {string} mapType The type of the map.\n * @param {*} [initValueOrFn=null] Initial value or function for index map.\n * @returns {IndexMap}\n */\nexport function createIndexMap(mapType) {\n  let initValueOrFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!availableIndexMapTypes.has(mapType)) {\n    throw new Error(`The provided map type (\"${mapType}\") does not exist.`);\n  }\n  return new (availableIndexMapTypes.get(mapType))(initValueOrFn);\n}", "import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isUndefined, isDefined } from \"../../helpers/mixed.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\nimport localHooks from \"../../mixins/localHooks.mjs\"; // Counter for checking if there is a memory leak.\nlet registeredMaps = 0;\n\n/**\n * Collection of index maps having unique names. It allow us to perform bulk operations such as init, remove, insert on all index maps that have been registered in the collection.\n */\nexport class MapCollection {\n  constructor() {\n    /**\n     * Collection of index maps.\n     *\n     * @type {Map<string, IndexMap>}\n     */\n    _defineProperty(this, \"collection\", new Map());\n  }\n  /**\n   * Register custom index map.\n   *\n   * @param {string} uniqueName Unique name of the index map.\n   * @param {IndexMap} indexMap Index map containing miscellaneous (i.e. Meta data, indexes sequence), updated after remove and insert data actions.\n   */\n  register(uniqueName, indexMap) {\n    if (this.collection.has(uniqueName) === false) {\n      this.collection.set(uniqueName, indexMap);\n      indexMap.addLocalHook('change', () => this.runLocalHooks('change', indexMap));\n      registeredMaps += 1;\n    }\n  }\n\n  /**\n   * Unregister custom index map.\n   *\n   * @param {string} name Name of the index map.\n   */\n  unregister(name) {\n    const indexMap = this.collection.get(name);\n    if (isDefined(indexMap)) {\n      indexMap.destroy();\n      this.collection.delete(name);\n      this.runLocalHooks('change', indexMap);\n      registeredMaps -= 1;\n    }\n  }\n\n  /**\n   * Unregisters and destroys all collected index map instances.\n   */\n  unregisterAll() {\n    this.collection.forEach((indexMap, name) => this.unregister(name));\n    this.collection.clear();\n  }\n\n  /**\n   * Get index map for the provided name.\n   *\n   * @param {string} [name] Name of the index map.\n   * @returns {Array|IndexMap}\n   */\n  get(name) {\n    if (isUndefined(name)) {\n      return Array.from(this.collection.values());\n    }\n    return this.collection.get(name);\n  }\n\n  /**\n   * Get collection size.\n   *\n   * @returns {number}\n   */\n  getLength() {\n    return this.collection.size;\n  }\n\n  /**\n   * Remove some indexes and corresponding mappings and update values of the others within all collection's index maps.\n   *\n   * @private\n   * @param {Array} removedIndexes List of removed indexes.\n   */\n  removeFromEvery(removedIndexes) {\n    this.collection.forEach(indexMap => {\n      indexMap.remove(removedIndexes);\n    });\n  }\n\n  /**\n   * Insert new indexes and corresponding mapping and update values of the others all collection's index maps.\n   *\n   * @private\n   * @param {number} insertionIndex Position inside the actual list.\n   * @param {Array} insertedIndexes List of inserted indexes.\n   */\n  insertToEvery(insertionIndex, insertedIndexes) {\n    this.collection.forEach(indexMap => {\n      indexMap.insert(insertionIndex, insertedIndexes);\n    });\n  }\n\n  /**\n   * Set default values to index maps within collection.\n   *\n   * @param {number} length Destination length for all stored maps.\n   */\n  initEvery(length) {\n    this.collection.forEach(indexMap => {\n      indexMap.init(length);\n    });\n  }\n}\nmixin(MapCollection, localHooks);\n\n/**\n * @returns {number}\n */\nexport function getRegisteredMapsCounter() {\n  return registeredMaps;\n}", "import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { MapCollection } from \"./mapCollection.mjs\";\nimport { arrayMap } from \"../../helpers/array.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\n/**\n * Collection of maps. This collection aggregate maps with the same type of values. Values from the registered maps\n * can be used to calculate a single result for particular index.\n */\nexport class AggregatedCollection extends MapCollection {\n  constructor(aggregationFunction, fallbackValue) {\n    super();\n    /**\n     * List of merged values. Value for each index is calculated using values inside registered maps.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"mergedValuesCache\", []);\n    /**\n     * Function which do aggregation on the values for particular index.\n     */\n    _defineProperty(this, \"aggregationFunction\", void 0);\n    /**\n     * Fallback value when there is no calculated value for particular index.\n     */\n    _defineProperty(this, \"fallbackValue\", void 0);\n    this.aggregationFunction = aggregationFunction;\n    this.fallbackValue = fallbackValue;\n  }\n\n  /**\n   * Get merged values for all indexes.\n   *\n   * @param {boolean} [readFromCache=true] Determine if read results from the cache.\n   * @returns {Array}\n   */\n  getMergedValues() {\n    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (readFromCache === true) {\n      return this.mergedValuesCache;\n    }\n    if (this.getLength() === 0) {\n      return [];\n    }\n\n    // Below variable stores values for every particular map. Example describing situation when we have 2 registered maps,\n    // with length equal to 5.\n    //\n    // +---------+---------------------------------------------+\n    // |         |                  indexes                    |\n    // +---------+---------------------------------------------+\n    // |   maps  |     0    |   1   |    2  |   3   |    4     |\n    // +---------+----------+-------+-------+-------+----------+\n    // |    0    | [[ value,  value,  value,  value,  value ], |\n    // |    1    | [  value,  value,  value,  value,  value ]] |\n    // +---------+----------+-------+-------+-------+----------+\n    const mapsValuesMatrix = arrayMap(this.get(), map => map.getValues());\n    // Below variable stores values for every particular index. Example describing situation when we have 2 registered maps,\n    // with length equal to 5.\n    //\n    // +---------+---------------------+\n    // |         |         maps        |\n    // +---------+---------------------+\n    // | indexes |     0    |    1     |\n    // +---------+----------+----------+\n    // |    0    | [[ value,  value ], |\n    // |    1    | [  value,  value ], |\n    // |    2    | [  value,  value ], |\n    // |    3    | [  value,  value ], |\n    // |    4    | [  value,  value ]] |\n    // +---------+----------+----------+\n    const indexesValuesMatrix = [];\n    const mapsLength = isDefined(mapsValuesMatrix[0]) && mapsValuesMatrix[0].length || 0;\n    for (let index = 0; index < mapsLength; index += 1) {\n      const valuesForIndex = [];\n      for (let mapIndex = 0; mapIndex < this.getLength(); mapIndex += 1) {\n        valuesForIndex.push(mapsValuesMatrix[mapIndex][index]);\n      }\n      indexesValuesMatrix.push(valuesForIndex);\n    }\n    return arrayMap(indexesValuesMatrix, this.aggregationFunction);\n  }\n\n  /**\n   * Get merged value for particular index.\n   *\n   * @param {number} index Index for which we calculate single result.\n   * @param {boolean} [readFromCache=true] Determine if read results from the cache.\n   * @returns {*}\n   */\n  getMergedValueAtIndex(index, readFromCache) {\n    const valueAtIndex = this.getMergedValues(readFromCache)[index];\n    return isDefined(valueAtIndex) ? valueAtIndex : this.fallbackValue;\n  }\n\n  /**\n   * Rebuild cache for the collection.\n   */\n  updateCache() {\n    this.mergedValuesCache = this.getMergedValues(false);\n  }\n}", "import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nimport { mixin } from \"../../helpers/object.mjs\";\nimport localHooks from \"../../mixins/localHooks.mjs\";\n/**\n * The ChangesObserver module is an object that represents a disposable resource\n * provided by the ChangesObservable module.\n *\n * @class ChangesObserver\n */\nvar _currentInitialChanges = /*#__PURE__*/new WeakMap();\nexport class ChangesObserver {\n  constructor() {\n    /**\n     * The field holds initial changes that will be used to notify the callbacks added using\n     * subscribe method. Regardless of the moment of listening for changes, the subscriber\n     * will be notified once with all changes made before subscribing.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _currentInitialChanges, {\n      writable: true,\n      value: []\n    });\n  }\n  /**\n   * Subscribes to the observer.\n   *\n   * @param {Function} callback A function that will be called when the new changes will appear.\n   * @returns {ChangesObserver}\n   */\n  subscribe(callback) {\n    this.addLocalHook('change', callback);\n    this._write(_classPrivateFieldGet(this, _currentInitialChanges));\n    return this;\n  }\n\n  /**\n   * Unsubscribes all subscriptions. After the method call, the observer would not produce\n   * any new events.\n   *\n   * @returns {ChangesObserver}\n   */\n  unsubscribe() {\n    this.runLocalHooks('unsubscribe');\n    this.clearLocalHooks();\n    return this;\n  }\n\n  /**\n   * The write method is executed by the ChangesObservable module. The module produces all\n   * changes events that are distributed further by the observer.\n   *\n   * @private\n   * @param {object} changes The chunk of changes produced by the ChangesObservable module.\n   * @returns {ChangesObserver}\n   */\n  _write(changes) {\n    if (changes.length > 0) {\n      this.runLocalHooks('change', changes);\n    }\n    return this;\n  }\n\n  /**\n   * The write method is executed by the ChangesObservable module. The module produces initial\n   * changes that will be used to notify new subscribers.\n   *\n   * @private\n   * @param {object} initialChanges The chunk of changes produced by the ChangesObservable module.\n   */\n  _writeInitialChanges(initialChanges) {\n    _classPrivateFieldSet(this, _currentInitialChanges, initialChanges);\n  }\n}\nmixin(ChangesObserver, localHooks);", "import \"core-js/modules/es.array.push.js\";\n/**\n * An array diff implementation. The function iterates through the arrays and depends\n * on the diff results, collect the changes as a list of the objects.\n *\n * Each object contains information about the differences in the indexes of the arrays.\n * The changes also contain data about the new and previous array values.\n *\n * @private\n * @param {Array} baseArray The base array to diff from.\n * @param {Array} newArray The new array to compare with.\n * @returns {Array}\n */\nexport function arrayDiff(baseArray, newArray) {\n  const changes = [];\n  let i = 0;\n  let j = 0;\n\n  /* eslint-disable no-plusplus */\n  for (; i < baseArray.length && j < newArray.length; i++, j++) {\n    if (baseArray[i] !== newArray[j]) {\n      changes.push({\n        op: 'replace',\n        index: j,\n        oldValue: baseArray[i],\n        newValue: newArray[j]\n      });\n    }\n  }\n  for (; i < newArray.length; i++) {\n    changes.push({\n      op: 'insert',\n      index: i,\n      oldValue: undefined,\n      newValue: newArray[i]\n    });\n  }\n  for (; j < baseArray.length; j++) {\n    changes.push({\n      op: 'remove',\n      index: j,\n      oldValue: baseArray[j],\n      newValue: undefined\n    });\n  }\n  return changes;\n}", "import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { ChangesObserver } from \"./observer.mjs\";\nimport { arrayDiff } from \"./utils.mjs\";\n/**\n * The ChangesObservable module is an object that represents a resource that provides\n * the ability to observe the changes that happened in the index map indexes during\n * the code running.\n *\n * @private\n * @class ChangesObservable\n */\nvar _observers = /*#__PURE__*/new WeakMap();\nvar _indexMatrix = /*#__PURE__*/new WeakMap();\nvar _currentIndexState = /*#__PURE__*/new WeakMap();\nvar _isMatrixIndexesInitialized = /*#__PURE__*/new WeakMap();\nvar _initialIndexValue = /*#__PURE__*/new WeakMap();\nexport class ChangesObservable {\n  constructor() {\n    let {\n      initialIndexValue\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /**\n     * The list of registered ChangesObserver instances.\n     *\n     * @type {ChangesObserver[]}\n     */\n    _classPrivateFieldInitSpec(this, _observers, {\n      writable: true,\n      value: new Set()\n    });\n    /**\n     * An array with default values that act as a base array that will be compared with\n     * the last saved index state. The changes are generated and immediately send through\n     * the newly created ChangesObserver object. Thanks to that, the observer initially has\n     * all information about what indexes are currently changed.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _indexMatrix, {\n      writable: true,\n      value: []\n    });\n    /**\n     * An array that holds the indexes state that is currently valid. The value is changed on every\n     * index mapper cache update.\n     *\n     * @type {Array}\n     */\n    _classPrivateFieldInitSpec(this, _currentIndexState, {\n      writable: true,\n      value: []\n    });\n    /**\n     * The flag determines if the observable is initialized or not. Not initialized object creates\n     * index matrix once while emitting new changes.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isMatrixIndexesInitialized, {\n      writable: true,\n      value: false\n    });\n    /**\n     * The initial index value allows control from what value the index matrix array will be created.\n     * Changing that value changes how the array diff generates the changes for the initial data\n     * sent to the subscribers. For example, the changes can be triggered by detecting the changes\n     * from `false` to `true` value or vice versa. Generally, it depends on which index map type\n     * the Observable will work with. For \"hiding\" or \"trimming\" index types, it will be boolean\n     * values. For various index maps, it can be anything, but I suspect that the most appropriate\n     * initial value will be \"undefined\" in that case.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _initialIndexValue, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldSet(this, _initialIndexValue, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Creates and returns a new instance of the ChangesObserver object. The resource\n   * allows subscribing to the index changes that during the code running may change.\n   * Changes are emitted as an array of the index change. Each change is represented\n   * separately as an object with `op`, `index`, `oldValue`, and `newValue` props.\n   *\n   * For example:\n   * ```\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'replace', index: 3, oldValue: false, newValue: true },\n   *   { op: 'insert', index: 4, oldValue: false, newValue: true },\n   * ]\n   * // or when the new index map changes have less indexes\n   * [\n   *   { op: 'replace', index: 1, oldValue: false, newValue: true },\n   *   { op: 'remove', index: 4, oldValue: false, newValue: true },\n   * ]\n   * ```\n   *\n   * @returns {ChangesObserver}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  createObserver() {\n    const observer = new ChangesObserver();\n    _classPrivateFieldGet(this, _observers).add(observer);\n    observer.addLocalHook('unsubscribe', () => {\n      _classPrivateFieldGet(this, _observers).delete(observer);\n    });\n    observer._writeInitialChanges(arrayDiff(_classPrivateFieldGet(this, _indexMatrix), _classPrivateFieldGet(this, _currentIndexState)));\n    return observer;\n  }\n\n  /**\n   * The method is an entry point for triggering new index map changes. Emitting the\n   * changes triggers comparing algorithm which compares last saved state with a new\n   * state. When there are some differences, the changes are sent to all subscribers.\n   *\n   * @param {Array} indexesState An array with index map state.\n   */\n  emit(indexesState) {\n    let currentIndexState = _classPrivateFieldGet(this, _currentIndexState);\n    if (!_classPrivateFieldGet(this, _isMatrixIndexesInitialized) || _classPrivateFieldGet(this, _indexMatrix).length !== indexesState.length) {\n      if (indexesState.length === 0) {\n        indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet(this, _initialIndexValue));\n      } else {\n        _classPrivateFieldSet(this, _indexMatrix, new Array(indexesState.length).fill(_classPrivateFieldGet(this, _initialIndexValue)));\n      }\n      if (!_classPrivateFieldGet(this, _isMatrixIndexesInitialized)) {\n        _classPrivateFieldSet(this, _isMatrixIndexesInitialized, true);\n        currentIndexState = _classPrivateFieldGet(this, _indexMatrix);\n      }\n    }\n    const changes = arrayDiff(currentIndexState, indexesState);\n    _classPrivateFieldGet(this, _observers).forEach(observer => observer._write(changes));\n    _classPrivateFieldSet(this, _currentIndexState, indexesState);\n  }\n}", "import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { arrayMap } from \"../helpers/array.mjs\";\nimport { createIndexMap, getListWithInsertedItems, getListWithRemovedItems, HidingMap, IndexesSequence, TrimmingMap } from \"./maps/index.mjs\";\nimport { AggregatedCollection, MapCollection } from \"./mapCollections/index.mjs\";\nimport localHooks from \"../mixins/localHooks.mjs\";\nimport { mixin } from \"../helpers/object.mjs\";\nimport { isDefined } from \"../helpers/mixed.mjs\";\nimport { ChangesObservable } from \"./changesObservable/observable.mjs\";\n/**\n * A set of deprecated feature names.\n *\n * @type {Set<string>}\n */\n// eslint-disable-next-line no-unused-vars\nconst deprecationWarns = new Set();\n\n/**\n * @class IndexMapper\n * @description\n *\n * Index mapper stores, registers and manages the indexes on the basis of calculations collected from the subsidiary maps.\n * It should be seen as a single source of truth (regarding row and column indexes, for example, their sequence, information if they are skipped in the process of rendering (hidden or trimmed), values linked to them)\n * for any operation that considers CRUD actions such as **insertion**, **movement**, **removal** etc, and is used to properly calculate physical and visual indexes translations in both ways.\n * It has a built-in cache that is updated only when the data or structure changes.\n *\n * **Physical index** is a type of an index from the sequence of indexes assigned to the data source rows or columns\n *  (from 0 to n, where n is number of the cells on the axis of data set).\n * **Visual index** is a type of an index from the sequence of indexes assigned to rows or columns existing in {@link DataMap} (from 0 to n, where n is number of the cells on the axis of data set).\n * **Renderable index** is a type of an index from the sequence of indexes assigned to rows or columns whose may be rendered (when they are in a viewport; from 0 to n, where n is number of the cells renderable on the axis).\n *\n * There are different kinds of index maps which may be registered in the collections and can be used by a reference.\n * They also expose public API and trigger two local hooks such as `init` (on initialization) and `change` (on change).\n *\n * These are: {@link IndexesSequence}, {@link PhysicalIndexToValueMap}, {@link LinkedPhysicalIndexToValueMap}, {@link HidingMap}, and {@link TrimmingMap}.\n */\nexport class IndexMapper {\n  constructor() {\n    /**\n     * Map for storing the sequence of indexes.\n     *\n     * It is registered by default and may be used from API methods.\n     *\n     * @private\n     * @type {IndexesSequence}\n     */\n    _defineProperty(this, \"indexesSequence\", new IndexesSequence());\n    /**\n     * Collection for different trimming maps. Indexes marked as trimmed in any map WILL NOT be included in\n     * the {@link DataMap} and won't be rendered.\n     *\n     * @private\n     * @type {MapCollection}\n     */\n    _defineProperty(this, \"trimmingMapsCollection\", new AggregatedCollection(valuesForIndex => valuesForIndex.some(value => value === true), false));\n    /**\n     * Collection for different hiding maps. Indexes marked as hidden in any map WILL be included in the {@link DataMap},\n     * but won't be rendered.\n     *\n     * @private\n     * @type {MapCollection}\n     */\n    _defineProperty(this, \"hidingMapsCollection\", new AggregatedCollection(valuesForIndex => valuesForIndex.some(value => value === true), false));\n    /**\n     * Collection for another kind of maps. There are stored mappings from indexes (visual or physical) to values.\n     *\n     * @private\n     * @type {MapCollection}\n     */\n    _defineProperty(this, \"variousMapsCollection\", new MapCollection());\n    /**\n     * The class instance collects row and column index changes that happen while the Handsontable\n     * is running. The object allows creating observers that you can subscribe. Each event represents\n     * the index change (e.g., insert, removing, change index value), which can be consumed by a\n     * developer to update its logic.\n     *\n     * @private\n     * @type {ChangesObservable}\n     */\n    _defineProperty(this, \"hidingChangesObservable\", new ChangesObservable({\n      initialIndexValue: false\n    }));\n    /**\n     * Cache for list of not trimmed indexes, respecting the indexes sequence (physical indexes).\n     *\n     * Note: Please keep in mind that trimmed index can be also hidden.\n     *\n     * @private\n     * @type {Array}\n     */\n    _defineProperty(this, \"notTrimmedIndexesCache\", []);\n    /**\n     * Cache for list of not hidden indexes, respecting the indexes sequence (physical indexes).\n     *\n     * Note: Please keep in mind that hidden index can be also trimmed.\n     *\n     * @private\n     * @type {Array}\n     */\n    _defineProperty(this, \"notHiddenIndexesCache\", []);\n    /**\n     * Flag determining whether actions performed on index mapper have been batched. It's used for cache management.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isBatched\", false);\n    /**\n     * Flag determining whether any action on indexes sequence has been performed. It's used for cache management.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"indexesSequenceChanged\", false);\n    /**\n     * Flag informing about source of the change.\n     *\n     * @type {undefined|string}\n     */\n    _defineProperty(this, \"indexesChangeSource\", undefined);\n    /**\n     * Flag determining whether any action on trimmed indexes has been performed. It's used for cache management.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"trimmedIndexesChanged\", false);\n    /**\n     * Flag determining whether any action on hidden indexes has been performed. It's used for cache management.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hiddenIndexesChanged\", false);\n    /**\n     * Physical indexes (respecting the sequence of indexes) which may be rendered (when they are in a viewport).\n     *\n     * @private\n     * @type {Array}\n     */\n    _defineProperty(this, \"renderablePhysicalIndexesCache\", []);\n    /**\n     * Visual indexes (native map's value) corresponding to physical indexes (native map's index).\n     *\n     * @private\n     * @type {Map}\n     */\n    _defineProperty(this, \"fromPhysicalToVisualIndexesCache\", new Map());\n    /**\n     * Visual indexes (native map's value) corresponding to physical indexes (native map's index).\n     *\n     * @private\n     * @type {Map}\n     */\n    _defineProperty(this, \"fromVisualToRenderableIndexesCache\", new Map());\n    this.indexesSequence.addLocalHook('change', () => {\n      this.indexesSequenceChanged = true;\n\n      // Sequence of stored indexes might change.\n      this.updateCache();\n      this.runLocalHooks('indexesSequenceChange', this.indexesChangeSource);\n      this.runLocalHooks('change', this.indexesSequence, null);\n    });\n    this.trimmingMapsCollection.addLocalHook('change', changedMap => {\n      this.trimmedIndexesChanged = true;\n\n      // Number of trimmed indexes might change.\n      this.updateCache();\n      this.runLocalHooks('change', changedMap, this.trimmingMapsCollection);\n    });\n    this.hidingMapsCollection.addLocalHook('change', changedMap => {\n      this.hiddenIndexesChanged = true;\n\n      // Number of hidden indexes might change.\n      this.updateCache();\n      this.runLocalHooks('change', changedMap, this.hidingMapsCollection);\n    });\n    this.variousMapsCollection.addLocalHook('change', changedMap => {\n      this.runLocalHooks('change', changedMap, this.variousMapsCollection);\n    });\n  }\n\n  /**\n   * Suspends the cache update for this map. The method is helpful to group multiple\n   * operations, which affects the cache. In this case, the cache will be updated once after\n   * calling the `resumeOperations` method.\n   */\n  suspendOperations() {\n    this.isBatched = true;\n  }\n\n  /**\n   * Resumes the cache update for this map. It recalculates the cache and restores the\n   * default behavior where each map modification updates the cache.\n   */\n  resumeOperations() {\n    this.isBatched = false;\n    this.updateCache();\n  }\n\n  /**\n   * It creates and returns the new instance of the ChangesObserver object. The object\n   * allows listening to the index changes that happen while the Handsontable is running.\n   *\n   * @param {string} indexMapType The index map type which we want to observe.\n   *                              Currently, only the 'hiding' index map types are observable.\n   * @returns {ChangesObserver}\n   */\n  createChangesObserver(indexMapType) {\n    if (indexMapType !== 'hiding') {\n      throw new Error(`Unsupported index map type \"${indexMapType}\".`);\n    }\n    return this.hidingChangesObservable.createObserver();\n  }\n\n  /**\n   * Creates and registers a new `IndexMap` for a specified `IndexMapper` instance.\n   *\n   * @param {string} indexName A unique index name.\n   * @param {string} mapType The index map type (e.g., \"hiding\", \"trimming\", \"physicalIndexToValue\").\n   * @param {*} [initValueOrFn] The initial value for the index map.\n   * @returns {IndexMap}\n   */\n  createAndRegisterIndexMap(indexName, mapType, initValueOrFn) {\n    return this.registerMap(indexName, createIndexMap(mapType, initValueOrFn));\n  }\n\n  /**\n   * Register map which provide some index mappings. Type of map determining to which collection it will be added.\n   *\n   * @param {string} uniqueName Name of the index map. It should be unique.\n   * @param {IndexMap} indexMap Registered index map updated on items removal and insertion.\n   * @returns {IndexMap}\n   */\n  registerMap(uniqueName, indexMap) {\n    if (this.trimmingMapsCollection.get(uniqueName) || this.hidingMapsCollection.get(uniqueName) || this.variousMapsCollection.get(uniqueName)) {\n      throw Error(`Map with name \"${uniqueName}\" has been already registered.`);\n    }\n    if (indexMap instanceof TrimmingMap) {\n      this.trimmingMapsCollection.register(uniqueName, indexMap);\n    } else if (indexMap instanceof HidingMap) {\n      this.hidingMapsCollection.register(uniqueName, indexMap);\n    } else {\n      this.variousMapsCollection.register(uniqueName, indexMap);\n    }\n    const numberOfIndexes = this.getNumberOfIndexes();\n\n    /*\n      We initialize map ony when we have full information about number of indexes and the dataset is not empty.\n      Otherwise it's unnecessary. Initialization of empty array would not give any positive changes. After initializing\n      it with number of indexes equal to 0 the map would be still empty. What's more there would be triggered\n      not needed hook (no real change have occurred). Number of indexes is known after loading data (the `loadData`\n      function from the `Core`).\n     */\n    if (numberOfIndexes > 0) {\n      indexMap.init(numberOfIndexes);\n    }\n    return indexMap;\n  }\n\n  /**\n   * Unregister a map with given name.\n   *\n   * @param {string} name Name of the index map.\n   */\n  unregisterMap(name) {\n    this.trimmingMapsCollection.unregister(name);\n    this.hidingMapsCollection.unregister(name);\n    this.variousMapsCollection.unregister(name);\n  }\n\n  /**\n   * Unregisters all collected index map instances from all map collection types.\n   */\n  unregisterAll() {\n    this.trimmingMapsCollection.unregisterAll();\n    this.hidingMapsCollection.unregisterAll();\n    this.variousMapsCollection.unregisterAll();\n  }\n\n  /**\n   * Get a physical index corresponding to the given visual index.\n   *\n   * @param {number} visualIndex Visual index.\n   * @returns {number|null} Returns translated index mapped by passed visual index.\n   */\n  getPhysicalFromVisualIndex(visualIndex) {\n    // Index in the table boundaries provided by the `DataMap`.\n    const physicalIndex = this.notTrimmedIndexesCache[visualIndex];\n    if (isDefined(physicalIndex)) {\n      return physicalIndex;\n    }\n    return null;\n  }\n\n  /**\n   * Get a physical index corresponding to the given renderable index.\n   *\n   * @param {number} renderableIndex Renderable index.\n   * @returns {null|number}\n   */\n  getPhysicalFromRenderableIndex(renderableIndex) {\n    const physicalIndex = this.renderablePhysicalIndexesCache[renderableIndex];\n\n    // Index in the renderable table boundaries.\n    if (isDefined(physicalIndex)) {\n      return physicalIndex;\n    }\n    return null;\n  }\n\n  /**\n   * Get a visual index corresponding to the given physical index.\n   *\n   * @param {number} physicalIndex Physical index to search.\n   * @returns {number|null} Returns a visual index of the index mapper.\n   */\n  getVisualFromPhysicalIndex(physicalIndex) {\n    const visualIndex = this.fromPhysicalToVisualIndexesCache.get(physicalIndex);\n\n    // Index in the table boundaries provided by the `DataMap`.\n    if (isDefined(visualIndex)) {\n      return visualIndex;\n    }\n    return null;\n  }\n\n  /**\n   * Get a visual index corresponding to the given renderable index.\n   *\n   * @param {number} renderableIndex Renderable index.\n   * @returns {null|number}\n   */\n  getVisualFromRenderableIndex(renderableIndex) {\n    return this.getVisualFromPhysicalIndex(this.getPhysicalFromRenderableIndex(renderableIndex));\n  }\n\n  /**\n   * Get a renderable index corresponding to the given visual index.\n   *\n   * @param {number} visualIndex Visual index.\n   * @returns {null|number}\n   */\n  getRenderableFromVisualIndex(visualIndex) {\n    const renderableIndex = this.fromVisualToRenderableIndexesCache.get(visualIndex);\n\n    // Index in the renderable table boundaries.\n    if (isDefined(renderableIndex)) {\n      return renderableIndex;\n    }\n    return null;\n  }\n\n  /**\n   * Search for the nearest not-hidden row or column.\n   *\n   * @param {number} fromVisualIndex The visual index of the row or column from which the search starts.<br><br>\n   * If the row or column from which the search starts is not hidden, the method simply returns the `fromVisualIndex` number.\n   * @param {number} searchDirection The search direction.<br><br>`1`: search from `fromVisualIndex` to the end of the dataset.<br><br>\n   * `-1`: search from `fromVisualIndex` to the beginning of the dataset (i.e., to the row or column at visual index `0`).\n   * @param {boolean} searchAlsoOtherWayAround `true`: if a search in a first direction failed, try the opposite direction.<br><br>\n   * `false`: search in one direction only.\n   *\n   * @returns {number|null} A visual index of a row or column, or `null`.\n   */\n  getNearestNotHiddenIndex(fromVisualIndex, searchDirection) {\n    let searchAlsoOtherWayAround = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const physicalIndex = this.getPhysicalFromVisualIndex(fromVisualIndex);\n    if (physicalIndex === null) {\n      return null;\n    }\n    if (this.fromVisualToRenderableIndexesCache.has(fromVisualIndex)) {\n      return fromVisualIndex;\n    }\n    const visibleIndexes = Array.from(this.fromVisualToRenderableIndexesCache.keys());\n    let index = -1;\n    if (searchDirection > 0) {\n      index = visibleIndexes.findIndex(visualIndex => visualIndex > fromVisualIndex);\n    } else {\n      index = visibleIndexes.reverse().findIndex(visualIndex => visualIndex < fromVisualIndex);\n    }\n    if (index === -1) {\n      if (searchAlsoOtherWayAround) {\n        return this.getNearestNotHiddenIndex(fromVisualIndex, -searchDirection, false);\n      }\n      return null;\n    }\n    return visibleIndexes[index];\n  }\n\n  /**\n   * Set default values for all indexes in registered index maps.\n   *\n   * @param {number} [length] Destination length for all stored index maps.\n   */\n  initToLength() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNumberOfIndexes();\n    this.notTrimmedIndexesCache = [...new Array(length).keys()];\n    this.notHiddenIndexesCache = [...new Array(length).keys()];\n    this.suspendOperations();\n    this.indexesChangeSource = 'init';\n    this.indexesSequence.init(length);\n    this.indexesChangeSource = undefined;\n    this.trimmingMapsCollection.initEvery(length);\n    this.resumeOperations();\n\n    // We move initialization of hidden collection to next batch for purpose of working on sequence of already trimmed indexes.\n    this.suspendOperations();\n    this.hidingMapsCollection.initEvery(length);\n\n    // It shouldn't reset the cache.\n    this.variousMapsCollection.initEvery(length);\n    this.resumeOperations();\n    this.runLocalHooks('init');\n  }\n\n  /**\n   * Trim/extend the mappers to fit the desired length.\n   *\n   * @param {number} length New mapper length.\n   */\n  fitToLength(length) {\n    const currentIndexCount = this.getNumberOfIndexes();\n    if (length < currentIndexCount) {\n      const indexesToBeRemoved = [...Array(this.getNumberOfIndexes() - length).keys()].map(i => i + length);\n      this.removeIndexes(indexesToBeRemoved);\n    } else {\n      this.insertIndexes(currentIndexCount, length - currentIndexCount);\n    }\n  }\n\n  /**\n   * Get sequence of indexes.\n   *\n   * @returns {Array} Physical indexes.\n   */\n  getIndexesSequence() {\n    return this.indexesSequence.getValues();\n  }\n\n  /**\n   * Set completely new indexes sequence.\n   *\n   * @param {Array} indexes Physical indexes.\n   */\n  setIndexesSequence(indexes) {\n    if (this.indexesChangeSource === undefined) {\n      this.indexesChangeSource = 'update';\n    }\n    this.indexesSequence.setValues(indexes);\n    if (this.indexesChangeSource === 'update') {\n      this.indexesChangeSource = undefined;\n    }\n  }\n\n  /**\n   * Get all NOT trimmed indexes.\n   *\n   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.\n   *\n   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.\n   * @returns {Array} List of physical indexes. Index of this native array is a \"visual index\",\n   * value of this native array is a \"physical index\".\n   */\n  getNotTrimmedIndexes() {\n    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (readFromCache === true) {\n      return this.notTrimmedIndexesCache;\n    }\n    const indexesSequence = this.getIndexesSequence();\n    return indexesSequence.filter(physicalIndex => this.isTrimmed(physicalIndex) === false);\n  }\n\n  /**\n   * Get length of all NOT trimmed indexes.\n   *\n   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.\n   *\n   * @returns {number}\n   */\n  getNotTrimmedIndexesLength() {\n    return this.getNotTrimmedIndexes().length;\n  }\n\n  /**\n   * Get all NOT hidden indexes.\n   *\n   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.\n   *\n   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.\n   * @returns {Array} List of physical indexes. Please keep in mind that index of this native array IS NOT a \"visual index\".\n   */\n  getNotHiddenIndexes() {\n    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (readFromCache === true) {\n      return this.notHiddenIndexesCache;\n    }\n    const indexesSequence = this.getIndexesSequence();\n    return indexesSequence.filter(physicalIndex => this.isHidden(physicalIndex) === false);\n  }\n\n  /**\n   * Get length of all NOT hidden indexes.\n   *\n   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.\n   *\n   * @returns {number}\n   */\n  getNotHiddenIndexesLength() {\n    return this.getNotHiddenIndexes().length;\n  }\n\n  /**\n   * Get list of physical indexes (respecting the sequence of indexes) which may be rendered (when they are in a viewport).\n   *\n   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.\n   * @returns {Array} List of physical indexes. Index of this native array is a \"renderable index\",\n   * value of this native array is a \"physical index\".\n   */\n  getRenderableIndexes() {\n    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (readFromCache === true) {\n      return this.renderablePhysicalIndexesCache;\n    }\n    const notTrimmedIndexes = this.getNotTrimmedIndexes();\n    return notTrimmedIndexes.filter(physicalIndex => this.isHidden(physicalIndex) === false);\n  }\n\n  /**\n   * Get length of all NOT trimmed and NOT hidden indexes.\n   *\n   * @returns {number}\n   */\n  getRenderableIndexesLength() {\n    return this.getRenderableIndexes().length;\n  }\n\n  /**\n   * Get number of all indexes.\n   *\n   * @returns {number}\n   */\n  getNumberOfIndexes() {\n    return this.getIndexesSequence().length;\n  }\n\n  /**\n   * Move indexes in the index mapper.\n   *\n   * @param {number|Array} movedIndexes Visual index(es) to move.\n   * @param {number} finalIndex Visual index being a start index for the moved elements.\n   */\n  moveIndexes(movedIndexes, finalIndex) {\n    if (typeof movedIndexes === 'number') {\n      movedIndexes = [movedIndexes];\n    }\n    const physicalMovedIndexes = arrayMap(movedIndexes, visualIndex => this.getPhysicalFromVisualIndex(visualIndex));\n    const notTrimmedIndexesLength = this.getNotTrimmedIndexesLength();\n    const movedIndexesLength = movedIndexes.length;\n\n    // Removing moved indexes without re-indexing.\n    const notMovedIndexes = getListWithRemovedItems(this.getIndexesSequence(), physicalMovedIndexes);\n    const notTrimmedNotMovedItems = notMovedIndexes.filter(index => this.isTrimmed(index) === false);\n\n    // When item(s) are moved after the last visible item we assign the last possible index.\n    let destinationPosition = notMovedIndexes.indexOf(notTrimmedNotMovedItems[notTrimmedNotMovedItems.length - 1]) + 1;\n\n    // Otherwise, we find proper index for inserted item(s).\n    if (finalIndex + movedIndexesLength < notTrimmedIndexesLength) {\n      // Physical index at final index position.\n      const physicalIndex = notTrimmedNotMovedItems[finalIndex];\n      destinationPosition = notMovedIndexes.indexOf(physicalIndex);\n    }\n    this.indexesChangeSource = 'move';\n\n    // Adding indexes without re-indexing.\n    this.setIndexesSequence(getListWithInsertedItems(notMovedIndexes, destinationPosition, physicalMovedIndexes));\n    this.indexesChangeSource = undefined;\n  }\n\n  /**\n   * Get whether index is trimmed. Index marked as trimmed isn't included in a {@link DataMap} and isn't rendered.\n   *\n   * @param {number} physicalIndex Physical index.\n   * @returns {boolean}\n   */\n  isTrimmed(physicalIndex) {\n    return this.trimmingMapsCollection.getMergedValueAtIndex(physicalIndex);\n  }\n\n  /**\n   * Get whether index is hidden. Index marked as hidden is included in a {@link DataMap}, but isn't rendered.\n   *\n   * @param {number} physicalIndex Physical index.\n   * @returns {boolean}\n   */\n  isHidden(physicalIndex) {\n    return this.hidingMapsCollection.getMergedValueAtIndex(physicalIndex);\n  }\n\n  /**\n   * Insert new indexes and corresponding mapping and update values of the others, for all stored index maps.\n   *\n   * @private\n   * @param {number} firstInsertedVisualIndex First inserted visual index.\n   * @param {number} amountOfIndexes Amount of inserted indexes.\n   */\n  insertIndexes(firstInsertedVisualIndex, amountOfIndexes) {\n    const nthVisibleIndex = this.getNotTrimmedIndexes()[firstInsertedVisualIndex];\n    const firstInsertedPhysicalIndex = isDefined(nthVisibleIndex) ? nthVisibleIndex : this.getNumberOfIndexes();\n    const insertionIndex = this.getIndexesSequence().includes(nthVisibleIndex) ? this.getIndexesSequence().indexOf(nthVisibleIndex) : this.getNumberOfIndexes();\n    const insertedIndexes = arrayMap(new Array(amountOfIndexes).fill(firstInsertedPhysicalIndex), (nextIndex, stepsFromStart) => nextIndex + stepsFromStart);\n    this.suspendOperations();\n    this.indexesChangeSource = 'insert';\n    this.indexesSequence.insert(insertionIndex, insertedIndexes);\n    this.indexesChangeSource = undefined;\n    this.trimmingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);\n    this.hidingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);\n    this.variousMapsCollection.insertToEvery(insertionIndex, insertedIndexes);\n    this.resumeOperations();\n  }\n\n  /**\n   * Remove some indexes and corresponding mappings and update values of the others, for all stored index maps.\n   *\n   * @private\n   * @param {Array} removedIndexes List of removed indexes.\n   */\n  removeIndexes(removedIndexes) {\n    this.suspendOperations();\n    this.indexesChangeSource = 'remove';\n    this.indexesSequence.remove(removedIndexes);\n    this.indexesChangeSource = undefined;\n    this.trimmingMapsCollection.removeFromEvery(removedIndexes);\n    this.hidingMapsCollection.removeFromEvery(removedIndexes);\n    this.variousMapsCollection.removeFromEvery(removedIndexes);\n    this.resumeOperations();\n  }\n\n  /**\n   * Rebuild cache for some indexes. Every action on indexes sequence or indexes skipped in the process of rendering\n   * by default reset cache, thus batching some index maps actions is recommended.\n   *\n   * @private\n   * @param {boolean} [force=false] Determine if force cache update.\n   */\n  updateCache() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const anyCachedIndexChanged = this.indexesSequenceChanged || this.trimmedIndexesChanged || this.hiddenIndexesChanged;\n    if (force === true || this.isBatched === false && anyCachedIndexChanged === true) {\n      this.trimmingMapsCollection.updateCache();\n      this.hidingMapsCollection.updateCache();\n      this.notTrimmedIndexesCache = this.getNotTrimmedIndexes(false);\n      this.notHiddenIndexesCache = this.getNotHiddenIndexes(false);\n      this.renderablePhysicalIndexesCache = this.getRenderableIndexes(false);\n      this.cacheFromPhysicalToVisualIndexes();\n      this.cacheFromVisualToRenderableIndexes();\n\n      // Currently there's support only for the \"hiding\" map type.\n      if (this.hiddenIndexesChanged) {\n        this.hidingChangesObservable.emit(this.hidingMapsCollection.getMergedValues());\n      }\n      this.runLocalHooks('cacheUpdated', {\n        indexesSequenceChanged: this.indexesSequenceChanged,\n        trimmedIndexesChanged: this.trimmedIndexesChanged,\n        hiddenIndexesChanged: this.hiddenIndexesChanged\n      });\n      this.indexesSequenceChanged = false;\n      this.trimmedIndexesChanged = false;\n      this.hiddenIndexesChanged = false;\n    }\n  }\n\n  /**\n   * Update cache for translations from physical to visual indexes.\n   *\n   * @private\n   */\n  cacheFromPhysicalToVisualIndexes() {\n    const nrOfNotTrimmedIndexes = this.getNotTrimmedIndexesLength();\n    this.fromPhysicalToVisualIndexesCache.clear();\n    for (let visualIndex = 0; visualIndex < nrOfNotTrimmedIndexes; visualIndex += 1) {\n      const physicalIndex = this.getPhysicalFromVisualIndex(visualIndex);\n\n      // Every visual index have corresponding physical index, but some physical indexes may don't have\n      // corresponding visual indexes (physical indexes may represent trimmed indexes, beyond the table boundaries)\n      this.fromPhysicalToVisualIndexesCache.set(physicalIndex, visualIndex);\n    }\n  }\n\n  /**\n   * Update cache for translations from visual to renderable indexes.\n   *\n   * @private\n   */\n  cacheFromVisualToRenderableIndexes() {\n    const nrOfRenderableIndexes = this.getRenderableIndexesLength();\n    this.fromVisualToRenderableIndexesCache.clear();\n    for (let renderableIndex = 0; renderableIndex < nrOfRenderableIndexes; renderableIndex += 1) {\n      // Can't use getRenderableFromVisualIndex here because we're building the cache here\n      const physicalIndex = this.getPhysicalFromRenderableIndex(renderableIndex);\n      const visualIndex = this.getVisualFromPhysicalIndex(physicalIndex);\n      this.fromVisualToRenderableIndexesCache.set(visualIndex, renderableIndex);\n    }\n  }\n}\nmixin(IndexMapper, localHooks);", "import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { Selection } from \"./../../3rdparty/walkontable/src/index.mjs\";\nclass VisualSelection extends Selection {\n  constructor(settings, visualCellRange) {\n    super(settings, null);\n    /**\n     * Range of selection visually. Visual representation may have representation in a rendered selection.\n     *\n     * @type {null|CellRange}\n     */\n    _defineProperty(this, \"visualCellRange\", null);\n    this.visualCellRange = visualCellRange || null;\n    this.commit();\n  }\n  /**\n   * Adds a cell coords to the selection.\n   *\n   * @param {CellCoords} coords Visual coordinates of a cell.\n   * @returns {VisualSelection}\n   */\n  add(coords) {\n    if (this.visualCellRange === null) {\n      this.visualCellRange = this.settings.createCellRange(coords);\n    } else {\n      this.visualCellRange.expand(coords);\n    }\n    return this;\n  }\n\n  /**\n   * Clears visual and renderable selection.\n   *\n   * @returns {VisualSelection}\n   */\n  clear() {\n    this.visualCellRange = null;\n    return super.clear();\n  }\n\n  /**\n   * Trims the passed cell range object by removing all coordinates that points to the hidden rows\n   * or columns. The result is a new cell range object that points only to the visible indexes or `null`.\n   *\n   * @private\n   * @param {CellRange} cellRange Cells range object to be trimmed.\n   * @returns {CellRange} Visual non-hidden cells range coordinates.\n   */\n  trimToVisibleCellsRangeOnly(_ref) {\n    let {\n      from,\n      to\n    } = _ref;\n    let visibleFromCoords = this.getNearestNotHiddenCoords(from, 1);\n    let visibleToCoords = this.getNearestNotHiddenCoords(to, -1);\n    if (visibleFromCoords === null || visibleToCoords === null) {\n      return null;\n    }\n    if (visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > visibleToCoords.col) {\n      visibleFromCoords = from;\n      visibleToCoords = to;\n    }\n    return this.settings.createCellRange(visibleFromCoords, visibleFromCoords, visibleToCoords);\n  }\n\n  /**\n   * Gets nearest coordinates that points to the visible row and column indexes. If there are no visible\n   * rows and/or columns the `null` value is returned.\n   *\n   * @private\n   * @param {CellCoords} coords The coords object as starting point for finding the nearest visible coordinates.\n   * @param {1|-1} rowSearchDirection The search direction. For value 1, it means searching from top to bottom for\n   *                                  rows and from left to right for columns. For -1, it is the other way around.\n   * @param {1|-1} columnSearchDirection The same as above but for rows.\n   * @returns {CellCoords|null} Visual cell coordinates.\n   */\n  getNearestNotHiddenCoords(coords, rowSearchDirection) {\n    let columnSearchDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rowSearchDirection;\n    const nextVisibleRow = this.getNearestNotHiddenIndex(this.settings.rowIndexMapper, coords.row, rowSearchDirection);\n\n    // There are no more visual rows in the range.\n    if (nextVisibleRow === null) {\n      return null;\n    }\n    const nextVisibleColumn = this.getNearestNotHiddenIndex(this.settings.columnIndexMapper, coords.col, columnSearchDirection);\n\n    // There are no more visual columns in the range.\n    if (nextVisibleColumn === null) {\n      return null;\n    }\n    return this.settings.createCellCoords(nextVisibleRow, nextVisibleColumn);\n  }\n\n  /**\n   * Gets nearest visual index. If there are no visible rows or columns the `null` value is returned.\n   *\n   * @private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} visualIndex The index as starting point for finding the nearest visible index.\n   * @param {1|-1} searchDirection The search direction. For value 1, it means searching from top to bottom for\n   *                               rows and from left to right for columns. For -1, it is the other way around.\n   * @returns {number|null} Visual row/column index.\n   */\n  getNearestNotHiddenIndex(indexMapper, visualIndex, searchDirection) {\n    if (visualIndex < 0) {\n      return visualIndex;\n    }\n    return indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);\n  }\n\n  /**\n   * Override internally stored visual indexes added by the Selection's `add` function. It should be executed\n   * at the end of process of adding visual selection coordinates.\n   *\n   * @returns {VisualSelection}\n   */\n  commit() {\n    // There is no information about visual ranges, thus no selection may be displayed.\n    if (this.visualCellRange === null) {\n      return this;\n    }\n    const trimmedCellRange = this.trimToVisibleCellsRangeOnly(this.visualCellRange);\n\n    // There is no visual start point (and also visual end point) in the range.\n    if (trimmedCellRange === null) {\n      this.cellRange = null;\n    } else {\n      this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, trimmedCellRange.to);\n    }\n    return this;\n  }\n\n  /**\n   * Some selection may be a part of broader cell range. This function sync coordinates of current selection\n   * and the broader cell range when needed (current selection can't be presented visually).\n   *\n   * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.\n   * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.\n   *\n   * Warn: Please keep in mind that this function may change coordinates of the handled broader range.\n   *\n   * @returns {VisualSelection}\n   */\n  syncWith(broaderCellRange) {\n    const coordsFrom = broaderCellRange.from.clone().normalize();\n    const rowDirection = broaderCellRange.getVerticalDirection() === 'N-S' ? 1 : -1;\n    const columnDirection = broaderCellRange.getHorizontalDirection() === 'W-E' ? 1 : -1;\n    const renderableHighlight = this.settings.visualToRenderableCoords(this.visualCellRange.highlight);\n    let cellCoordsVisual = null;\n    if (renderableHighlight === null || renderableHighlight.col === null || renderableHighlight.row === null) {\n      cellCoordsVisual = this.getNearestNotHiddenCoords(coordsFrom, rowDirection, columnDirection);\n    }\n    if (cellCoordsVisual !== null && broaderCellRange.overlaps(cellCoordsVisual)) {\n      const currentHighlight = broaderCellRange.highlight.clone();\n      if (currentHighlight.row >= 0) {\n        currentHighlight.row = cellCoordsVisual.row;\n      }\n      if (currentHighlight.col >= 0) {\n        currentHighlight.col = cellCoordsVisual.col;\n      }\n\n      // We can't show selection visually now, but we found first visible range in the broader cell range.\n      if (this.cellRange === null) {\n        const cellCoordsRenderable = this.settings.visualToRenderableCoords(currentHighlight);\n        this.cellRange = this.settings.createCellRange(cellCoordsRenderable);\n      }\n\n      // We set new highlight as it might change (for example, when showing/hiding some cells from the broader selection range)\n      // TODO: It is also handled by the `MergeCells` plugin while adjusting already modified coordinates. Should it?\n      broaderCellRange.setHighlight(currentHighlight);\n    }\n\n    // Sync the highlight coords from the visual selection layer with logical coords.\n    if (this.settings.selectionType === 'focus' && renderableHighlight !== null && cellCoordsVisual === null) {\n      broaderCellRange.setHighlight(this.visualCellRange.highlight);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).\n   * The method overwrites the original method to support header selection for hidden cells.\n   * To make the header selection working, the CellCoords and CellRange have to support not\n   * complete coordinates (`null` values for example, `row: null`, `col: 2`).\n   *\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n   */\n  getCorners() {\n    const {\n      from,\n      to\n    } = this.cellRange;\n    return [Math.min(from.row, to.row), Math.min(from.col, to.col), Math.max(from.row, to.row), Math.max(from.col, to.col)];\n  }\n\n  /**\n   * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection\n   * coordinates (visual indexes).\n   *\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n   */\n  getVisualCorners() {\n    const topStart = this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());\n    const bottomEnd = this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());\n    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];\n  }\n\n  /**\n   * Creates a new CellRange object based on visual coordinates which before object creation are\n   * translated to renderable indexes.\n   *\n   * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that\n   *                                      points to the beginning of the selection.\n   * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that\n   *                                    points to the end of the selection.\n   * @returns {CellRange|null}\n   */\n  createRenderableCellRange(visualFromCoords, visualToCoords) {\n    const renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);\n    const renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);\n    if (renderableFromCoords.row === null || renderableFromCoords.col === null || renderableToCoords.row === null || renderableToCoords.col === null) {\n      return null;\n    }\n    return this.settings.createCellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);\n  }\n}\nexport default VisualSelection;", "import { HIGHLIGHT_ACTIVE_HEADER_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\n/**\n * Creates the new instance of Selection, responsible for highlighting column or row headers\n * only when the whole column or row is selected.\n * This type of selection can occur multiple times.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @param {string} highlightParams.activeHeaderClassName Highlighted headers' class name.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    activeHeaderClassName,\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    className: activeHeaderClassName,\n    ...restOptions,\n    selectionType: HIGHLIGHT_ACTIVE_HEADER_TYPE\n  });\n}", "import { HIGHLIGHT_AREA_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\n/**\n * Creates the new instance of Selection responsible for highlighting area of the selected multiple cells.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @param {object} highlightParams.areaCornerVisible Function to determine if area's corner should be visible.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    areaCornerVisible,\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    className: 'area',\n    createLayers: true,\n    border: {\n      width: 1,\n      color: '#4b89ff',\n      cornerVisible: areaCornerVisible\n    },\n    ...restOptions,\n    selectionType: HIGHLIGHT_AREA_TYPE\n  });\n}", "import { HIGHLIGHT_AREA_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\n/**\n * Creates the new instance of Selection responsible for highlighting area of the selected multiple cells.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @param {object} highlightParams.areaCornerVisible Function to determine if area's corner should be visible.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    className: 'highlight',\n    ...restOptions,\n    selectionType: HIGHLIGHT_AREA_TYPE\n  });\n}", "import { HIGHLIGHT_COLUMN_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\n/**\n * Creates the new instance of Selection, responsible for highlighting cells in a columns and\n * column headers.\n * This type of selection can occur multiple times.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @param {string} highlightParams.columnClassName Highlighted column' class name.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    columnClassName,\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    className: columnClassName,\n    ...restOptions,\n    selectionType: HIGHLIGHT_COLUMN_TYPE\n  });\n}", "import { HIGHLIGHT_FOCUS_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\nimport { A11Y_SELECTED } from \"../../../helpers/a11y.mjs\";\n/**\n * Creates the new instance of Selection responsible for highlighting currently selected cell. This type of selection\n * can present on the table only one at the time.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @param {Function} highlightParams.cellCornerVisible Function to determine if cell's corner should be visible.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    cellCornerVisible,\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    className: 'current',\n    headerAttributes: [A11Y_SELECTED()],\n    border: {\n      width: 2,\n      color: '#4b89ff',\n      cornerVisible: cellCornerVisible\n    },\n    ...restOptions,\n    selectionType: HIGHLIGHT_FOCUS_TYPE\n  });\n}", "import { HIGHLIGHT_CUSTOM_SELECTION_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\n/**\n * Creates the new instance of Selection responsible for highlighting currently selected cell.\n * This type of selection can present on the table only one at the time.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @param {object} highlightParams.border Border configuration.\n * @param {object} highlightParams.visualCellRange Function to translate visual to renderable coords.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    border,\n    visualCellRange,\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    ...border,\n    ...restOptions,\n    selectionType: HIGHLIGHT_CUSTOM_SELECTION_TYPE\n  }, visualCellRange);\n}", "import { HIGHLIGHT_FILL_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\n/**\n * Creates the new instance of Selection, responsible for highlighting cells which are covered by fill handle\n * functionality. This type of selection can present on the table only one at the time.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    className: 'fill',\n    border: {\n      width: 1,\n      color: '#ff0000'\n    },\n    ...restOptions,\n    selectionType: HIGHLIGHT_FILL_TYPE\n  });\n}", "import { HIGHLIGHT_HEADER_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\n/**\n * Creates the new instance of Selection, responsible for highlighting column or row headers when\n * any cell is selected.\n * This type of selection can occur multiple times.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @param {string} highlightParams.headerClassName Highlighted headers' class name.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    headerClassName,\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    className: headerClassName,\n    ...restOptions,\n    selectionType: HIGHLIGHT_HEADER_TYPE\n  });\n}", "import { HIGHLIGHT_ROW_TYPE } from \"../../../3rdparty/walkontable/src/index.mjs\";\nimport VisualSelection from \"../visualSelection.mjs\";\n/**\n * Creates the new instance of Selection, responsible for highlighting cells in a rows and\n * row headers.\n * This type of selection can occur multiple times.\n *\n * @param {object} highlightParams A configuration object to create a highlight.\n * @param {string} highlightParams.rowClassName Highlighted row' class name.\n * @returns {Selection}\n */\nexport function createHighlight(_ref) {\n  let {\n    rowClassName,\n    ...restOptions\n  } = _ref;\n  return new VisualSelection({\n    className: rowClassName,\n    ...restOptions,\n    selectionType: HIGHLIGHT_ROW_TYPE\n  });\n}", "import \"core-js/modules/es.error.cause.js\";\nlet _Symbol$iterator;\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { createHighlight as createActiveHighlight } from \"./types/activeHeader.mjs\";\nimport { createHighlight as createAreaLayeredHighlight } from \"./types/areaLayered.mjs\";\nimport { createHighlight as createAreaHighlight } from \"./types/area.mjs\";\nimport { createHighlight as createColumnHighlight } from \"./types/column.mjs\";\nimport { createHighlight as createFocusHighlight } from \"./types/focus.mjs\";\nimport { createHighlight as createCustomHighlight } from \"./types/customSelection.mjs\";\nimport { createHighlight as createFillHighlight } from \"./types/fill.mjs\";\nimport { createHighlight as createHeaderHighlight } from \"./types/header.mjs\";\nimport { createHighlight as createRowHighlight } from \"./types/row.mjs\";\nimport { HIGHLIGHT_ACTIVE_HEADER_TYPE, HIGHLIGHT_AREA_TYPE, HIGHLIGHT_FOCUS_TYPE, HIGHLIGHT_CUSTOM_SELECTION_TYPE, HIGHLIGHT_FILL_TYPE, HIGHLIGHT_HEADER_TYPE, HIGHLIGHT_ROW_TYPE, HIGHLIGHT_COLUMN_TYPE } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { arrayEach } from \"./../../helpers/array.mjs\";\nexport { HIGHLIGHT_ACTIVE_HEADER_TYPE as ACTIVE_HEADER_TYPE, HIGHLIGHT_AREA_TYPE as AREA_TYPE, HIGHLIGHT_FOCUS_TYPE as FOCUS_TYPE, HIGHLIGHT_CUSTOM_SELECTION_TYPE as CUSTOM_SELECTION_TYPE, HIGHLIGHT_FILL_TYPE as FILL_TYPE, HIGHLIGHT_HEADER_TYPE as HEADER_TYPE, HIGHLIGHT_ROW_TYPE as ROW_TYPE, HIGHLIGHT_COLUMN_TYPE as COLUMN_TYPE };\n\n/**\n * Highlight class responsible for managing Walkontable Selection classes.\n *\n * With Highlight object you can manipulate four different highlight types:\n *  - `cell` can be added only to a single cell at a time and it defines currently selected cell;\n *  - `fill` can occur only once and its highlight defines selection of autofill functionality (managed by the plugin with the same name);\n *  - `areas` can be added to multiple cells at a time. This type highlights selected cell or multiple cells.\n *    The multiple cells have to be defined as an uninterrupted order (regular shape). Otherwise, the new layer of\n *    that type should be created to manage not-consecutive selection;\n *  - `header` can occur multiple times. This type is designed to highlight only headers. Like `area` type it\n *    can appear with multiple highlights (accessed under different level layers).\n *\n * @class Highlight\n * @util\n */\nvar _createHighlight = /*#__PURE__*/new WeakSet();\n_Symbol$iterator = Symbol.iterator;\nclass Highlight {\n  constructor(options) {\n    /**\n     * Creates (if not exist in the cache) Walkontable Selection instance.\n     *\n     * @param {Map} cacheMap The map where the instance will be cached.\n     * @param {Function} highlightFactory The function factory.\n     * @returns {VisualSelection}\n     */\n    _classPrivateMethodInitSpec(this, _createHighlight);\n    /**\n     * Options consumed by Highlight class and Walkontable Selection classes.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"options\", void 0);\n    /**\n     * The property which describes which layer level of the visual selection will be modified.\n     * This option is valid only for `area` and `header` highlight types which occurs multiple times on\n     * the table (as a non-consecutive selection).\n     *\n     * An order of the layers is the same as the order of added new non-consecutive selections.\n     *\n     * @type {number}\n     * @default 0\n     */\n    _defineProperty(this, \"layerLevel\", 0);\n    /**\n     * `cell` highlight object which describes attributes for the currently selected cell.\n     * It can only occur only once on the table.\n     *\n     * @type {Selection}\n     */\n    _defineProperty(this, \"focus\", void 0);\n    /**\n     * `fill` highlight object which describes attributes for the borders for autofill functionality.\n     * It can only occur only once on the table.\n     *\n     * @type {Selection}\n     */\n    _defineProperty(this, \"fill\", void 0);\n    /**\n     * Collection of the `area` highlights. That objects describes attributes for the borders and selection of\n     * the multiple selected cells. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"layeredAreas\", new Map());\n    /**\n     * Collection of the `highlight` highlights. That objects describes attributes for the borders and selection of\n     * the multiple selected cells. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"areas\", new Map());\n    /**\n     * Collection of the `header` highlights. That objects describes attributes for the selection of\n     * the multiple selected rows in the table header. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"rowHeaders\", new Map());\n    /**\n     * Collection of the `header` highlights. That objects describes attributes for the selection of\n     * the multiple selected columns in the table header. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"columnHeaders\", new Map());\n    /**\n     * Collection of the `active-header` highlights. That objects describes attributes for the selection of\n     * the multiple selected rows in the table header. The table headers which have selected all items in\n     * a row will be marked as `active-header`.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"activeRowHeaders\", new Map());\n    /**\n     * Collection of the `active-header` highlights. That objects describes attributes for the selection of\n     * the multiple selected columns in the table header. The table headers which have selected all items in\n     * a row will be marked as `active-header`.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"activeColumnHeaders\", new Map());\n    /**\n     * Collection of the `active-header` highlights. That objects describes attributes for the selection of\n     * the selected corner in the table header. The table headers which have selected all items in\n     * a row will be marked as `active-header`.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"activeCornerHeaders\", new Map());\n    /**\n     * Collection of the `rows` highlights. That objects describes attributes for the selection of\n     * the multiple selected cells in a row. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"rowHighlights\", new Map());\n    /**\n     * Collection of the `columns` highlights. That objects describes attributes for the selection of\n     * the multiple selected cells in a column. It can occur multiple times on the table.\n     *\n     * @type {Map.<number, Selection>}\n     */\n    _defineProperty(this, \"columnHighlights\", new Map());\n    /**\n     * Collection of the `custom-selection`, holder for example borders added through CustomBorders plugin.\n     *\n     * @type {Selection[]}\n     */\n    _defineProperty(this, \"customSelections\", []);\n    this.options = options;\n    this.focus = createFocusHighlight(options);\n    this.fill = createFillHighlight(options);\n  }\n\n  /**\n   * Check if highlight cell rendering is disabled for specified highlight type.\n   *\n   * @param {string} highlightType Highlight type. Possible values are: `cell`, `area`, `fill` or `header`.\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  isEnabledFor(highlightType, coords) {\n    let type = highlightType;\n\n    // Legacy compatibility.\n    if (highlightType === HIGHLIGHT_FOCUS_TYPE) {\n      type = 'current'; // One from settings for `disableVisualSelection` up to Handsontable 0.36/Handsontable Pro 1.16.0.\n    }\n\n    let disableHighlight = this.options.disabledCellSelection(coords.row, coords.col);\n    if (typeof disableHighlight === 'string') {\n      disableHighlight = [disableHighlight];\n    }\n    return disableHighlight === false || Array.isArray(disableHighlight) && !disableHighlight.includes(type);\n  }\n\n  /**\n   * Set a new layer level to make access to the desire `area` and `header` highlights.\n   *\n   * @param {number} [level=0] Layer level to use.\n   * @returns {Highlight}\n   */\n  useLayerLevel() {\n    let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.layerLevel = level;\n    return this;\n  }\n\n  /**\n   * Get Walkontable Selection instance created for controlling highlight of the currently\n   * focused cell (or header).\n   *\n   * @returns {Selection}\n   */\n  getFocus() {\n    return this.focus;\n  }\n\n  /**\n   * Get Walkontable Selection instance created for controlling highlight of the autofill functionality.\n   *\n   * @returns {Selection}\n   */\n  getFill() {\n    return this.fill;\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * `area` highlights.\n   *\n   * @returns {Selection}\n   */\n  createLayeredArea() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.layeredAreas, createAreaLayeredHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.\n   *\n   * @returns {Selection[]}\n   */\n  getLayeredAreas() {\n    return [...this.layeredAreas.values()];\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * `highlight` highlights.\n   *\n   * @returns {Selection}\n   */\n  createArea() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.areas, createAreaHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.\n   *\n   * @returns {Selection[]}\n   */\n  getAreas() {\n    return [...this.areas.values()];\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * header highlight for rows.\n   *\n   * @returns {Selection}\n   */\n  createRowHeader() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.rowHeaders, createHeaderHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.\n   *\n   * @returns {Selection[]}\n   */\n  getRowHeaders() {\n    return [...this.rowHeaders.values()];\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * header highlight for columns.\n   *\n   * @returns {Selection}\n   */\n  createColumnHeader() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.columnHeaders, createHeaderHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.\n   *\n   * @returns {Selection[]}\n   */\n  getColumnHeaders() {\n    return [...this.columnHeaders.values()];\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * highlight for active row headers.\n   *\n   * @returns {Selection}\n   */\n  createActiveRowHeader() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.activeRowHeaders, createActiveHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.\n   *\n   * @returns {Selection[]}\n   */\n  getActiveRowHeaders() {\n    return [...this.activeRowHeaders.values()];\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * highlight for active column headers.\n   *\n   * @returns {Selection}\n   */\n  createActiveColumnHeader() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.activeColumnHeaders, createActiveHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.\n   *\n   * @returns {Selection[]}\n   */\n  getActiveColumnHeaders() {\n    return [...this.activeColumnHeaders.values()];\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * highlight for the headers corner.\n   *\n   * @returns {Selection}\n   */\n  createActiveCornerHeader() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.activeCornerHeaders, createActiveHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers corner.\n   *\n   * @returns {Selection[]}\n   */\n  getActiveCornerHeaders() {\n    return [...this.activeCornerHeaders.values()];\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * highlight cells in a row.\n   *\n   * @returns {Selection}\n   */\n  createRowHighlight() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.rowHighlights, createRowHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the rows highlighting.\n   *\n   * @returns {Selection[]}\n   */\n  getRowHighlights() {\n    return [...this.rowHighlights.values()];\n  }\n\n  /**\n   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling\n   * highlight cells in a column.\n   *\n   * @returns {Selection}\n   */\n  createColumnHighlight() {\n    return _classPrivateMethodGet(this, _createHighlight, _createHighlight2).call(this, this.columnHighlights, createColumnHighlight);\n  }\n\n  /**\n   * Get all Walkontable Selection instances which describes the state of the columns highlighting.\n   *\n   * @returns {Selection[]}\n   */\n  getColumnHighlights() {\n    return [...this.columnHighlights.values()];\n  }\n\n  /**\n   * Get Walkontable Selection instance created for controlling highlight of the custom selection functionality.\n   *\n   * @returns {Selection}\n   */\n  getCustomSelections() {\n    return [...this.customSelections.values()];\n  }\n\n  /**\n   * Add selection to the custom selection instance. The new selection are added to the end of the selection collection.\n   *\n   * @param {object} selectionInstance The selection instance.\n   */\n  addCustomSelection(selectionInstance) {\n    this.customSelections.push(createCustomHighlight({\n      ...this.options,\n      ...selectionInstance\n    }));\n  }\n\n  /**\n   * Perform cleaning visual highlights for the whole table.\n   */\n  clear() {\n    this.focus.clear();\n    this.fill.clear();\n    arrayEach(this.areas.values(), highlight => void highlight.clear());\n    arrayEach(this.layeredAreas.values(), highlight => void highlight.clear());\n    arrayEach(this.rowHeaders.values(), highlight => void highlight.clear());\n    arrayEach(this.columnHeaders.values(), highlight => void highlight.clear());\n    arrayEach(this.activeRowHeaders.values(), highlight => void highlight.clear());\n    arrayEach(this.activeColumnHeaders.values(), highlight => void highlight.clear());\n    arrayEach(this.activeCornerHeaders.values(), highlight => void highlight.clear());\n    arrayEach(this.rowHighlights.values(), highlight => void highlight.clear());\n    arrayEach(this.columnHighlights.values(), highlight => void highlight.clear());\n  }\n  /**\n   * This object can be iterate over using `for of` syntax or using internal `arrayEach` helper.\n   *\n   * @returns {Selection[]}\n   */\n  [_Symbol$iterator]() {\n    return [this.focus, this.fill, ...this.areas.values(), ...this.layeredAreas.values(), ...this.rowHeaders.values(), ...this.columnHeaders.values(), ...this.activeRowHeaders.values(), ...this.activeColumnHeaders.values(), ...this.activeCornerHeaders.values(), ...this.rowHighlights.values(), ...this.columnHighlights.values(), ...this.customSelections][Symbol.iterator]();\n  }\n}\nfunction _createHighlight2(cacheMap, highlightFactory) {\n  const layerLevel = this.layerLevel;\n  if (cacheMap.has(layerLevel)) {\n    return cacheMap.get(layerLevel);\n  }\n  const highlight = highlightFactory({\n    layerLevel,\n    ...this.options\n  });\n  cacheMap.set(layerLevel, highlight);\n  return highlight;\n}\nexport default Highlight;", "import \"core-js/modules/es.error.cause.js\";\nlet _Symbol$iterator;\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n_Symbol$iterator = Symbol.iterator;\n/**\n * The SelectionRange class is a simple CellRanges collection designed for easy manipulation of the multiple\n * consecutive and non-consecutive selections.\n *\n * @class SelectionRange\n * @util\n */\nclass SelectionRange {\n  constructor(createCellRange) {\n    /**\n     * List of all CellRanges added to the class instance.\n     *\n     * @type {CellRange[]}\n     */\n    _defineProperty(this, \"ranges\", []);\n    /**\n     * @type {function(CellCoords): CellRange}\n     */\n    _defineProperty(this, \"createCellRange\", void 0);\n    this.createCellRange = createCellRange;\n  }\n\n  /**\n   * Check if selected range is empty.\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`\n   * to the collection.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {SelectionRange}\n   */\n  set(coords) {\n    this.clear();\n    this.ranges.push(this.createCellRange(coords));\n    return this;\n  }\n\n  /**\n   * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {SelectionRange}\n   */\n  add(coords) {\n    this.ranges.push(this.createCellRange(coords));\n    return this;\n  }\n\n  /**\n   * Removes from the stack the last added coordinates.\n   *\n   * @returns {SelectionRange}\n   */\n  pop() {\n    this.ranges.pop();\n    return this;\n  }\n\n  /**\n   * Get last added coordinates from ranges, it returns a CellRange instance.\n   *\n   * @returns {CellRange|undefined}\n   */\n  current() {\n    return this.peekByIndex(this.size() - 1);\n  }\n\n  /**\n   * Get previously added coordinates from ranges, it returns a CellRange instance.\n   *\n   * @returns {CellRange|undefined}\n   */\n  previous() {\n    return this.peekByIndex(this.size() - 2);\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  includes(coords) {\n    return this.ranges.some(cellRange => cellRange.includes(coords));\n  }\n\n  /**\n   * Clear collection.\n   *\n   * @returns {SelectionRange}\n   */\n  clear() {\n    this.ranges.length = 0;\n    return this;\n  }\n\n  /**\n   * Get count of added all coordinates added to the selection.\n   *\n   * @returns {number}\n   */\n  size() {\n    return this.ranges.length;\n  }\n\n  /**\n   * Peek the coordinates based on the index where that coordinate resides in the collection.\n   *\n   * @param {number} [index=0] An index where the coordinate will be retrieved from. The index '0' gets the\n   * latest range.\n   * @returns {CellRange|undefined}\n   */\n  peekByIndex() {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let cellRange;\n    if (index >= 0 && index < this.size()) {\n      cellRange = this.ranges[index];\n    }\n    return cellRange;\n  }\n  [_Symbol$iterator]() {\n    return this.ranges[Symbol.iterator]();\n  }\n}\nexport default SelectionRange;", "import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nimport { mixin, createObjectPropListener } from \"../helpers/object.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\n/**\n * The Transformation class implements algorithms for transforming coordinates based on current settings\n * passed to the Handsontable. The class performs the calculations based on the renderable indexes.\n *\n * Transformation is always applied relative to the current selection.\n *\n * The class operates on a table size defined by the renderable indexes. If the `navigableHeaders`\n * option is enabled, the table size is increased by the number of row and/or column headers.\n * Because the headers are treated as cells as part of the table size (indexes always go from 0 to N),\n * the algorithm can be written as simply as possible (without new if's that distinguish the headers\n * logic).\n *\n * @class Transformation\n * @util\n */\nvar _range = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _offset = /*#__PURE__*/new WeakMap();\nvar _setOffsetSize = /*#__PURE__*/new WeakSet();\nvar _clampCoords = /*#__PURE__*/new WeakSet();\nvar _getTableSize = /*#__PURE__*/new WeakSet();\nvar _visualToZeroBasedCoords = /*#__PURE__*/new WeakSet();\nvar _zeroBasedToVisualCoords = /*#__PURE__*/new WeakSet();\nclass Transformation {\n  constructor(range, options) {\n    /**\n     * Translates the zero-based coordinates to visual ones.\n     *\n     * @param {CellCoords} zeroBasedCoords The coordinates to process.\n     * @returns {CellCoords}\n     */\n    _classPrivateMethodInitSpec(this, _zeroBasedToVisualCoords);\n    /**\n     * Translates the visual coordinates to zero-based ones.\n     *\n     * @param {CellCoords} visualCoords The visual coords to process.\n     * @returns {CellCoords}\n     */\n    _classPrivateMethodInitSpec(this, _visualToZeroBasedCoords);\n    /**\n     * Gets the table size in number of rows with headers as \"height\" and number of columns with\n     * headers as \"width\".\n     *\n     * @returns {{width: number, height: number}}\n     */\n    _classPrivateMethodInitSpec(this, _getTableSize);\n    /**\n     * Clamps the coords to make sure they points to the cell (or header) in the table range.\n     *\n     * @param {CellCoords} zeroBasedCoords The coords object to clamp.\n     * @returns {{rowDir: 1|0|-1, colDir: 1|0|-1}}\n     */\n    _classPrivateMethodInitSpec(this, _clampCoords);\n    /**\n     * Sets the additional offset in table size that may occur when the `navigableHeaders` option\n     * is enabled.\n     *\n     * @param {{x: number, y: number}} offset Offset as x and y properties.\n     */\n    _classPrivateMethodInitSpec(this, _setOffsetSize);\n    /**\n     * Instance of the SelectionRange, holder for visual coordinates applied to the table.\n     *\n     * @type {SelectionRange}\n     */\n    _classPrivateFieldInitSpec(this, _range, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Additional options which define the state of the settings which can infer transformation and\n     * give the possibility to translate indexes.\n     *\n     * @type {object}\n     */\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Increases the table size by applying the offsets. The option is used by the `navigableHeaders`\n     * option.\n     *\n     * @type {{ x: number, y: number }}\n     */\n    _classPrivateFieldInitSpec(this, _offset, {\n      writable: true,\n      value: {\n        x: 0,\n        y: 0\n      }\n    });\n    _classPrivateFieldSet(this, _range, range);\n    _classPrivateFieldSet(this, _options, options);\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    _classPrivateMethodGet(this, _setOffsetSize, _setOffsetSize2).call(this, {\n      x: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countRowHeaders() : 0,\n      y: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countColHeaders() : 0\n    });\n    const delta = _classPrivateFieldGet(this, _options).createCellCoords(rowDelta, colDelta);\n    let visualCoords = _classPrivateFieldGet(this, _range).current().highlight;\n    const highlightRenderableCoords = _classPrivateFieldGet(this, _options).visualToRenderableCoords(visualCoords);\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformStart', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {\n      const {\n        width,\n        height\n      } = _classPrivateMethodGet(this, _getTableSize, _getTableSize2).call(this);\n      const {\n        row,\n        col\n      } = _classPrivateMethodGet(this, _visualToZeroBasedCoords, _visualToZeroBasedCoords2).call(this, visualCoords);\n      const fixedRowsBottom = _classPrivateFieldGet(this, _options).fixedRowsBottom();\n      const minSpareRows = _classPrivateFieldGet(this, _options).minSpareRows();\n      const minSpareCols = _classPrivateFieldGet(this, _options).minSpareCols();\n      const autoWrapRow = _classPrivateFieldGet(this, _options).autoWrapRow();\n      const autoWrapCol = _classPrivateFieldGet(this, _options).autoWrapCol();\n      const zeroBasedCoords = _classPrivateFieldGet(this, _options).createCellCoords(row + delta.row, col + delta.col);\n      if (zeroBasedCoords.row >= height) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareRows > 0 && fixedRowsBottom === 0);\n        const nextColumn = zeroBasedCoords.col + 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(zeroBasedCoords.row - height, nextColumn >= width ? nextColumn - width : nextColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), nextColumn >= width);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertRowRequire', _classPrivateFieldGet(this, _options).countRenderableRows());\n        } else if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.row < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapCol);\n        const previousColumn = zeroBasedCoords.col - 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(height + zeroBasedCoords.row, previousColumn < 0 ? width + previousColumn : previousColumn);\n        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), previousColumn < 0);\n        if (autoWrapCol) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      if (zeroBasedCoords.col >= width) {\n        const isActionInterrupted = createObjectPropListener(createMissingRecords && minSpareCols > 0);\n        const nextRow = zeroBasedCoords.row + 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(nextRow >= height ? nextRow - height : nextRow, zeroBasedCoords.col - width);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), nextRow >= height);\n        if (isActionInterrupted.value) {\n          this.runLocalHooks('insertColRequire', _classPrivateFieldGet(this, _options).countRenderableColumns());\n        } else if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      } else if (zeroBasedCoords.col < 0) {\n        const isActionInterrupted = createObjectPropListener(autoWrapRow);\n        const previousRow = zeroBasedCoords.row - 1;\n        const newCoords = _classPrivateFieldGet(this, _options).createCellCoords(previousRow < 0 ? height + previousRow : previousRow, width + zeroBasedCoords.col);\n        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, newCoords), previousRow < 0);\n        if (autoWrapRow) {\n          zeroBasedCoords.assign(newCoords);\n        }\n      }\n      const {\n        rowDir,\n        colDir\n      } = _classPrivateMethodGet(this, _clampCoords, _clampCoords2).call(this, zeroBasedCoords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      visualCoords = _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, zeroBasedCoords);\n    }\n    this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @returns {CellCoords} Visual coordinates after transformation.\n   */\n  transformEnd(rowDelta, colDelta) {\n    _classPrivateMethodGet(this, _setOffsetSize, _setOffsetSize2).call(this, {\n      x: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countRowHeaders() : 0,\n      y: _classPrivateFieldGet(this, _options).navigableHeaders() ? _classPrivateFieldGet(this, _options).countColHeaders() : 0\n    });\n    const delta = _classPrivateFieldGet(this, _options).createCellCoords(rowDelta, colDelta);\n    const cellRange = _classPrivateFieldGet(this, _range).current();\n    const highlightRenderableCoords = _classPrivateFieldGet(this, _options).visualToRenderableCoords(cellRange.highlight);\n    const visualCoords = cellRange.to.clone();\n    let rowTransformDir = 0;\n    let colTransformDir = 0;\n    this.runLocalHooks('beforeTransformEnd', delta);\n    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {\n      const {\n        row,\n        col\n      } = _classPrivateMethodGet(this, _visualToZeroBasedCoords, _visualToZeroBasedCoords2).call(this, cellRange.to);\n      const coords = _classPrivateFieldGet(this, _options).createCellCoords(row + delta.row, col + delta.col);\n      const {\n        rowDir,\n        colDir\n      } = _classPrivateMethodGet(this, _clampCoords, _clampCoords2).call(this, coords);\n      rowTransformDir = rowDir;\n      colTransformDir = colDir;\n      const newVisualCoords = _classPrivateMethodGet(this, _zeroBasedToVisualCoords, _zeroBasedToVisualCoords2).call(this, coords);\n      if (delta.row === 0 && delta.col !== 0) {\n        visualCoords.col = newVisualCoords.col;\n      } else if (delta.row !== 0 && delta.col === 0) {\n        visualCoords.row = newVisualCoords.row;\n      } else {\n        visualCoords.row = newVisualCoords.row;\n        visualCoords.col = newVisualCoords.col;\n      }\n    }\n    this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);\n    return visualCoords;\n  }\n}\nfunction _setOffsetSize2(_ref) {\n  let {\n    x,\n    y\n  } = _ref;\n  _classPrivateFieldSet(this, _offset, {\n    x,\n    y\n  });\n}\nfunction _clampCoords2(zeroBasedCoords) {\n  const {\n    width,\n    height\n  } = _classPrivateMethodGet(this, _getTableSize, _getTableSize2).call(this);\n  let rowDir = 0;\n  let colDir = 0;\n  if (zeroBasedCoords.row < 0) {\n    rowDir = -1;\n    zeroBasedCoords.row = 0;\n  } else if (zeroBasedCoords.row > 0 && zeroBasedCoords.row >= height) {\n    rowDir = 1;\n    zeroBasedCoords.row = height - 1;\n  }\n  if (zeroBasedCoords.col < 0) {\n    colDir = -1;\n    zeroBasedCoords.col = 0;\n  } else if (zeroBasedCoords.col > 0 && zeroBasedCoords.col >= width) {\n    colDir = 1;\n    zeroBasedCoords.col = width - 1;\n  }\n  return {\n    rowDir,\n    colDir\n  };\n}\nfunction _getTableSize2() {\n  return {\n    width: _classPrivateFieldGet(this, _offset).x + _classPrivateFieldGet(this, _options).countRenderableColumns(),\n    height: _classPrivateFieldGet(this, _offset).y + _classPrivateFieldGet(this, _options).countRenderableRows()\n  };\n}\nfunction _visualToZeroBasedCoords2(visualCoords) {\n  const {\n    row,\n    col\n  } = _classPrivateFieldGet(this, _options).visualToRenderableCoords(visualCoords);\n  return _classPrivateFieldGet(this, _options).createCellCoords(_classPrivateFieldGet(this, _offset).y + row, _classPrivateFieldGet(this, _offset).x + col);\n}\nfunction _zeroBasedToVisualCoords2(zeroBasedCoords) {\n  const coords = zeroBasedCoords.clone();\n  coords.col = zeroBasedCoords.col - _classPrivateFieldGet(this, _offset).x;\n  coords.row = zeroBasedCoords.row - _classPrivateFieldGet(this, _offset).y;\n  return _classPrivateFieldGet(this, _options).renderableToVisualCoords(coords);\n}\nmixin(Transformation, localHooks);\nexport default Transformation;", "import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nimport Highlight, { AREA_TYPE, HEADER_TYPE, FOCUS_TYPE } from \"./highlight/highlight.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { clamp } from \"./../helpers/number.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\nimport { A11Y_SELECTED } from \"../helpers/a11y.mjs\";\n/**\n * @class Selection\n * @util\n */\nvar _disableHeadersHighlight = /*#__PURE__*/new WeakMap();\nclass Selection {\n  constructor(settings, tableProps) {\n    var _this = this;\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"tableProps\", void 0);\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n    _defineProperty(this, \"selectedRange\", new SelectionRange((highlight, from, to) => {\n      return this.tableProps.createCellRange(highlight, from, to);\n    }));\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n    _defineProperty(this, \"highlight\", void 0);\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n    _defineProperty(this, \"transformation\", void 0);\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByRowHeader\", new Set());\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByColumnHeader\", new Set());\n    /**\n     * When sets disable highlighting the headers even when the logical coordinates points on them.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _disableHeadersHighlight, {\n      writable: true,\n      value: false\n    });\n    this.settings = settings;\n    this.tableProps = tableProps;\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      cellAttributes: [A11Y_SELECTED()],\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      disabledCellSelection: (row, column) => this.tableProps.isDisabledCellSelection(row, column),\n      cellCornerVisible: function () {\n        return _this.isCellCornerVisible(...arguments);\n      },\n      areaCornerVisible: function () {\n        return _this.isAreaCornerVisible(...arguments);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      createCellRange: (highlight, from, to) => this.tableProps.createCellRange(highlight, from, to)\n    });\n    this.transformation = new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => this.tableProps.countRenderableRows(),\n      countRenderableColumns: () => this.tableProps.countRenderableColumns(),\n      countRowHeaders: () => this.tableProps.countRowHeaders(),\n      countColHeaders: () => this.tableProps.countColHeaders(),\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      navigableHeaders: () => settings.navigableHeaders,\n      fixedRowsBottom: () => settings.fixedRowsBottom,\n      minSpareRows: () => settings.minSpareRows,\n      minSpareCols: () => settings.minSpareCols,\n      autoWrapRow: () => settings.autoWrapRow,\n      autoWrapCol: () => settings.autoWrapCol\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks('beforeModifyTransformStart', ...args);\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks('afterModifyTransformStart', ...args);\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks('beforeModifyTransformEnd', ...args);\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks('afterModifyTransformEnd', ...args);\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks('insertRowRequire', ...args);\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks('insertColRequire', ...args);\n    });\n    this.transformation.addLocalHook('beforeRowWrap', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _this.runLocalHooks('beforeRowWrap', ...args);\n    });\n    this.transformation.addLocalHook('beforeColumnWrap', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _this.runLocalHooks('beforeColumnWrap', ...args);\n    });\n  }\n\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n  getSelectedRange() {\n    return this.selectedRange;\n  }\n\n  /**\n   * Indicate that selection process began. It sets internally `.inProgress` property to `true`.\n   */\n  begin() {\n    this.inProgress = true;\n  }\n\n  /**\n   * Indicate that selection process finished. It sets internally `.inProgress` property to `false`.\n   */\n  finish() {\n    this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n    this.inProgress = false;\n  }\n\n  /**\n   * Check if the process of selecting the cell/cells is in progress.\n   *\n   * @returns {boolean}\n   */\n  isInProgress() {\n    return this.inProgress;\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n   *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStart(coords, multipleSelection) {\n    let fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let highlightCoords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : coords;\n    const isMultipleMode = this.settings.selectionMode === 'multiple';\n    const isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n    // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n    // should be handled by next methods.\n    const coordsClone = coords.clone();\n    this.runLocalHooks(`beforeSetRangeStart${fragment ? 'Only' : ''}`, coordsClone);\n    if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n      this.selectedRange.clear();\n    }\n    this.selectedRange.add(coordsClone).current().setHighlight(highlightCoords.clone());\n    if (this.getLayerLevel() === 0) {\n      this.selectedByRowHeader.clear();\n      this.selectedByColumnHeader.clear();\n    }\n    if (!fragment) {\n      this.setRangeEnd(coords);\n    }\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStartOnly(coords, multipleSelection) {\n    let highlightCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coords;\n    this.setRangeStart(coords, multipleSelection, true, highlightCoords);\n  }\n\n  /**\n   * Ends selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   */\n  setRangeEnd(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const coordsClone = coords.clone();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const isSingle = this.selectedRange.current().clone().setTo(coords).isSingleHeader();\n\n    // Ignore processing the end range when the header selection starts overlapping the corner and\n    // the selection is not a single header highlight.\n    if ((countRows > 0 || countCols > 0) && (countRows === 0 && coordsClone.col < 0 && !isSingle || countCols === 0 && coordsClone.row < 0 && !isSingle)) {\n      return;\n    }\n    this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n    this.begin();\n    const cellRange = this.selectedRange.current();\n    if (!this.settings.navigableHeaders) {\n      cellRange.highlight.normalize();\n    }\n    if (this.settings.selectionMode === 'single') {\n      cellRange.setFrom(cellRange.highlight);\n      cellRange.setTo(cellRange.highlight);\n    } else {\n      cellRange.setTo(coordsClone);\n    }\n\n    // Prevent creating \"area\" selection that overlaps headers.\n    if (countRows > 0 && countCols > 0) {\n      if (!this.settings.navigableHeaders || this.settings.navigableHeaders && !cellRange.isSingleHeader()) {\n        cellRange.to.normalize();\n      }\n    }\n    this.runLocalHooks('beforeHighlightSet');\n    const focusHighlight = this.highlight.getFocus();\n    focusHighlight.clear();\n    if (this.highlight.isEnabledFor(FOCUS_TYPE, cellRange.highlight)) {\n      focusHighlight.add(this.selectedRange.current().highlight).commit().syncWith(cellRange);\n    }\n    const layerLevel = this.getLayerLevel();\n\n    // If the next layer level is lower than previous then clear all area and header highlights. This is the\n    // indication that the new selection is performing.\n    if (layerLevel < this.highlight.layerLevel) {\n      arrayEach(this.highlight.getAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getLayeredAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveCornerHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHighlights(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHighlights(), highlight => void highlight.clear());\n    }\n    this.highlight.useLayerLevel(layerLevel);\n    const areaHighlight = this.highlight.createArea();\n    const layeredAreaHighlight = this.highlight.createLayeredArea();\n    const rowHeaderHighlight = this.highlight.createRowHeader();\n    const columnHeaderHighlight = this.highlight.createColumnHeader();\n    const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n    const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n    const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n    const rowHighlight = this.highlight.createRowHighlight();\n    const columnHighlight = this.highlight.createColumnHighlight();\n    areaHighlight.clear();\n    layeredAreaHighlight.clear();\n    rowHeaderHighlight.clear();\n    columnHeaderHighlight.clear();\n    activeRowHeaderHighlight.clear();\n    activeColumnHeaderHighlight.clear();\n    activeCornerHeaderHighlight.clear();\n    rowHighlight.clear();\n    columnHighlight.clear();\n    if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n      areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      layeredAreaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      if (layerLevel === 1) {\n        // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n        // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n        // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n        const previousRange = this.selectedRange.previous();\n        this.highlight.useLayerLevel(layerLevel - 1);\n        this.highlight.createArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.createLayeredArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.useLayerLevel(layerLevel);\n      }\n    }\n    if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n      if (!cellRange.isSingleHeader()) {\n        const rowCoordsFrom = this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), -1);\n        const rowCoordsTo = this.tableProps.createCellCoords(cellRange.to.row, -1);\n        const columnCoordsFrom = this.tableProps.createCellCoords(-1, Math.max(cellRange.from.col, 0));\n        const columnCoordsTo = this.tableProps.createCellCoords(-1, cellRange.to.col);\n        if (this.settings.selectionMode === 'single') {\n          rowHeaderHighlight.add(rowCoordsFrom).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).commit();\n          rowHighlight.add(rowCoordsFrom).commit();\n          columnHighlight.add(columnCoordsFrom).commit();\n        } else {\n          rowHeaderHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n          rowHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n        }\n      }\n      const highlightRowHeaders = !_classPrivateFieldGet(this, _disableHeadersHighlight) && this.isEntireRowSelected() && (countCols > 0 && countCols === cellRange.getWidth() || countCols === 0 && this.isSelectedByRowHeader());\n      const highlightColumnHeaders = !_classPrivateFieldGet(this, _disableHeadersHighlight) && this.isEntireColumnSelected() && (countRows > 0 && countRows === cellRange.getHeight() || countRows === 0 && this.isSelectedByColumnHeader());\n      if (highlightRowHeaders) {\n        activeRowHeaderHighlight.add(this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), Math.min(-this.tableProps.countRowHeaders(), -1))).add(this.tableProps.createCellCoords(Math.max(cellRange.to.row, 0), -1)).commit();\n      }\n      if (highlightColumnHeaders) {\n        activeColumnHeaderHighlight.add(this.tableProps.createCellCoords(Math.min(-this.tableProps.countColHeaders(), -1), Math.max(cellRange.from.col, 0))).add(this.tableProps.createCellCoords(-1, Math.max(cellRange.to.col, 0))).commit();\n      }\n      if (highlightRowHeaders && highlightColumnHeaders) {\n        activeCornerHeaderHighlight.add(this.tableProps.createCellCoords(-this.tableProps.countColHeaders(), -this.tableProps.countRowHeaders())).add(this.tableProps.createCellCoords(-1, -1)).commit();\n      }\n    }\n    this.runLocalHooks('afterSetRangeEnd', coords);\n  }\n\n  /**\n   * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n   * the selection.\n   *\n   * @returns {boolean}\n   */\n  isMultiple() {\n    const isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n    this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n    return isMultipleListener.value;\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary.\n   * Otherwise, row/column will be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, createMissingRecords));\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformEnd(rowDelta, colDelta) {\n    this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n  }\n\n  /**\n   * Returns currently used layer level.\n   *\n   * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n   */\n  getLayerLevel() {\n    return this.selectedRange.size() - 1;\n  }\n\n  /**\n   * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n   *\n   * @returns {boolean}\n   */\n  isSelected() {\n    return !this.selectedRange.isEmpty();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByRowHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner(layerLevel) && (layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireRowSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        col\n      } = range.getOuterTopStartCorner();\n      const rowHeaders = this.tableProps.countRowHeaders();\n      const countCols = this.tableProps.countCols();\n      return (rowHeaders > 0 && col < 0 || rowHeaders === 0) && range.getWidth() === countCols;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByColumnHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner() && (layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireColumnSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        row\n      } = range.getOuterTopStartCorner();\n      const colHeaders = this.tableProps.countColHeaders();\n      const countRows = this.tableProps.countRows();\n      return (colHeaders > 0 && row < 0 || colHeaders === 0) && range.getHeight() === countRows;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByAnyHeader() {\n    return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByCorner() {\n    return this.selectedByColumnHeader.has(this.getLayerLevel()) && this.selectedByRowHeader.has(this.getLayerLevel());\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  inInSelection(coords) {\n    return this.selectedRange.includes(coords);\n  }\n\n  /**\n   * Returns `true` if the cell corner should be visible.\n   *\n   * @private\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isCellCornerVisible() {\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n  }\n\n  /**\n   * Returns `true` if the cell coordinates are visible (renderable).\n   *\n   * @private\n   * @param {CellCoords} coords The cell coordinates to check.\n   * @returns {boolean}\n   */\n  isCellVisible(coords) {\n    const renderableCoords = this.tableProps.visualToRenderableCoords(coords);\n    return renderableCoords.row !== null && renderableCoords.col !== null;\n  }\n\n  /**\n   * Returns `true` if the area corner should be visible.\n   *\n   * @param {number} layerLevel The layer level.\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isAreaCornerVisible(layerLevel) {\n    if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n      return false;\n    }\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n  }\n\n  /**\n   * Clear the selection by resetting the collected ranges and highlights.\n   */\n  clear() {\n    // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n    this.selectedRange.clear();\n    this.highlight.clear();\n  }\n\n  /**\n   * Deselects all selected cells.\n   */\n  deselect() {\n    if (!this.isSelected()) {\n      return;\n    }\n    this.inProgress = false;\n    this.clear();\n    this.runLocalHooks('afterDeselect');\n  }\n\n  /**\n   * Selects all cells and headers.\n   *\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,\n   * `false` otherwise.\n   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column\n   * headers, `false` otherwise.\n   * @param {object} [options] Additional object with options.\n   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header\n   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where\n   * negative values point to the headers and positive values point to the cell range. If `false`, the focus\n   * position won't be changed.\n   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when\n   * the logical coordinates points on them.\n   */\n  selectAll() {\n    var _this$getSelectedRang;\n    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      focusPosition: false,\n      disableHeadersHighlight: false\n    };\n    const nrOfRows = this.tableProps.countRows();\n    const nrOfColumns = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const rowFrom = includeColumnHeaders ? -countColHeaders : 0;\n    const columnFrom = includeRowHeaders ? -countRowHeaders : 0;\n\n    // We can't select cells when there is no data.\n    if (rowFrom === 0 && columnFrom === 0 && (nrOfRows === 0 || nrOfColumns === 0)) {\n      return;\n    }\n    let highlight = (_this$getSelectedRang = this.getSelectedRange().current()) === null || _this$getSelectedRang === void 0 ? void 0 : _this$getSelectedRang.highlight;\n    const {\n      focusPosition,\n      disableHeadersHighlight\n    } = options;\n    _classPrivateFieldSet(this, _disableHeadersHighlight, disableHeadersHighlight);\n    if (focusPosition && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n      highlight = this.tableProps.createCellCoords(clamp(focusPosition.row, rowFrom, nrOfRows - 1), clamp(focusPosition.col, columnFrom, nrOfColumns - 1));\n    }\n    const startCoords = this.tableProps.createCellCoords(rowFrom, columnFrom);\n    const endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n    this.clear();\n    this.setRangeStartOnly(startCoords, undefined, highlight);\n    if (columnFrom < 0) {\n      this.selectedByRowHeader.add(this.getLayerLevel());\n    }\n    if (rowFrom < 0) {\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n    }\n    this.setRangeEnd(endCoords);\n    this.finish();\n    _classPrivateFieldSet(this, _disableHeadersHighlight, false);\n  }\n\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n   * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n   * If the passed ranges have another format the exception will be thrown.\n   *\n   * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectCells(selectionRanges) {\n    var _this2 = this;\n    const selectionType = detectSelectionType(selectionRanges);\n    if (selectionType === SELECTION_TYPE_EMPTY) {\n      return false;\n    } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n      throw new Error(toSingleLine`Unsupported format of the selection ranges was passed. To select cells pass\\x20\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);\n    }\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: function () {\n        return _this2.tableProps.createCellCoords(...arguments);\n      },\n      createCellRange: function () {\n        return _this2.tableProps.createCellRange(...arguments);\n      },\n      propToCol: prop => this.tableProps.propToCol(prop),\n      keepDirection: true\n    });\n    const navigableHeaders = this.settings.navigableHeaders;\n    const tableParams = {\n      countRows: this.tableProps.countRows(),\n      countCols: this.tableProps.countCols(),\n      countRowHeaders: navigableHeaders ? this.tableProps.countRowHeaders() : 0,\n      countColHeaders: navigableHeaders ? this.tableProps.countColHeaders() : 0\n    };\n\n    // Check if every layer of the coordinates are valid.\n    const isValid = !selectionRanges.some(selection => {\n      const cellRange = selectionSchemaNormalizer(selection);\n      const rangeValidity = cellRange.isValid(tableParams);\n      return !(rangeValidity && !cellRange.containsHeaders() || rangeValidity && cellRange.containsHeaders() && cellRange.isSingleHeader());\n    });\n    if (isValid) {\n      this.clear();\n      arrayEach(selectionRanges, selection => {\n        const {\n          from,\n          to\n        } = selectionSchemaNormalizer(selection);\n        this.setRangeStartOnly(from.clone(), false);\n        this.setRangeEnd(to.clone());\n        this.finish();\n      });\n    }\n    return isValid;\n  }\n\n  /**\n   * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n   * `endColumn`.\n   *\n   * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n   * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual row index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectColumns(startColumn) {\n    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n    const end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const columnHeaderLastIndex = countColHeaders === 0 ? 0 : -countColHeaders;\n    const fromCoords = this.tableProps.createCellCoords(columnHeaderLastIndex, start);\n    const toCoords = this.tableProps.createCellCoords(countRows - 1, end);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders: 0,\n      countColHeaders\n    });\n    if (isValid) {\n      const fromRow = countColHeaders === 0 ? 0 : clamp(focusPosition, columnHeaderLastIndex, -1);\n      const toRow = countRows - 1;\n      const from = this.tableProps.createCellCoords(fromRow, start);\n      const to = this.tableProps.createCellCoords(toRow, end);\n      const highlight = this.tableProps.createCellCoords(clamp(focusPosition, columnHeaderLastIndex, countRows - 1), start);\n      this.runLocalHooks('beforeSelectColumns', from, to, highlight);\n\n      // disallow modifying row axis for that hooks\n      from.row = fromRow;\n      to.row = toRow;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectColumns', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @param {number} startRow Visual row index from which the selection starts.\n   * @param {number} [endRow] Visual row index from to the selection finishes.\n   * @param {number} [focusPosition=0] The argument allows changing the cell/header focus position.\n   *                                   The value can take visual column index from -N to N, where negative values\n   *                                   point to the headers and positive values point to the cell range.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectRows(startRow) {\n    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const rowHeaderLastIndex = countRowHeaders === 0 ? 0 : -countRowHeaders;\n    const fromCoords = this.tableProps.createCellCoords(startRow, rowHeaderLastIndex);\n    const toCoords = this.tableProps.createCellCoords(endRow, countCols - 1);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders,\n      countColHeaders: 0\n    });\n    if (isValid) {\n      const fromColumn = countRowHeaders === 0 ? 0 : clamp(focusPosition, rowHeaderLastIndex, -1);\n      const toColumn = countCols - 1;\n      const from = this.tableProps.createCellCoords(startRow, fromColumn);\n      const to = this.tableProps.createCellCoords(endRow, toColumn);\n      const highlight = this.tableProps.createCellCoords(startRow, clamp(focusPosition, rowHeaderLastIndex, countCols - 1));\n      this.runLocalHooks('beforeSelectRows', from, to, highlight);\n\n      // disallow modifying column axis for that hooks\n      from.col = fromColumn;\n      to.col = toColumn;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectRows', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n   */\n  refresh() {\n    const customSelections = this.highlight.getCustomSelections();\n    customSelections.forEach(customSelection => {\n      customSelection.commit();\n    });\n    if (!this.isSelected()) {\n      return;\n    }\n    const focusHighlight = this.highlight.getFocus();\n    const currentLayer = this.getLayerLevel();\n    focusHighlight.commit().syncWith(this.selectedRange.current());\n\n    // Rewriting rendered ranges going through all layers.\n    for (let layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n      this.highlight.useLayerLevel(layerLevel);\n      const areaHighlight = this.highlight.createArea();\n      const areaLayeredHighlight = this.highlight.createLayeredArea();\n      const rowHeaderHighlight = this.highlight.createRowHeader();\n      const columnHeaderHighlight = this.highlight.createColumnHeader();\n      const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n      const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n      const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n      const rowHighlight = this.highlight.createRowHighlight();\n      const columnHighlight = this.highlight.createColumnHighlight();\n      areaHighlight.commit();\n      areaLayeredHighlight.commit();\n      rowHeaderHighlight.commit();\n      columnHeaderHighlight.commit();\n      activeRowHeaderHighlight.commit();\n      activeColumnHeaderHighlight.commit();\n      activeCornerHeaderHighlight.commit();\n      rowHighlight.commit();\n      columnHighlight.commit();\n    }\n\n    // Reverting starting layer for the Highlight.\n    this.highlight.useLayerLevel(currentLayer);\n  }\n}\nmixin(Selection, localHooks);\nexport default Selection;", "import { isRightClick as isRightClickEvent, isLeftClick as isLeftClickEvent } from \"./../helpers/dom/event.mjs\";\n/**\n * MouseDown handler.\n *\n * @param {object} options The handler options.\n * @param {boolean} options.isShiftKey The flag which indicates if the shift key is pressed.\n * @param {boolean} options.isLeftClick The flag which indicates if the left mouse button is pressed.\n * @param {boolean} options.isRightClick The flag which indicates if the right mouse button is pressed.\n * @param {CellRange} options.coords The CellCoords object with defined visual coordinates.\n * @param {Selection} options.selection The Selection class instance.\n * @param {object} options.controller An object with keys `row`, `column`, `cell` which indicate what\n *                                    operation will be performed in later selection stages.\n * @param {Function} options.cellCoordsFactory The function factory for CellCoords objects.\n */\nexport function mouseDown(_ref) {\n  let {\n    isShiftKey,\n    isLeftClick,\n    isRightClick,\n    coords,\n    selection,\n    controller,\n    cellCoordsFactory\n  } = _ref;\n  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;\n  const selectedCorner = selection.isSelectedByCorner();\n  const selectedRow = selection.isSelectedByRowHeader();\n  if (isShiftKey && currentSelection) {\n    if (coords.row >= 0 && coords.col >= 0 && !controller.cell) {\n      selection.setRangeEnd(coords);\n    } else if ((selectedCorner || selectedRow) && coords.row >= 0 && coords.col >= 0 && !controller.cell) {\n      selection.setRangeEnd(cellCoordsFactory(coords.row, coords.col));\n    } else if (selectedCorner && coords.row < 0 && !controller.column) {\n      selection.setRangeEnd(cellCoordsFactory(currentSelection.to.row, coords.col));\n    } else if (selectedRow && coords.col < 0 && !controller.row) {\n      selection.setRangeEnd(cellCoordsFactory(coords.row, currentSelection.to.col));\n    } else if ((!selectedCorner && !selectedRow && coords.col < 0 || selectedCorner && coords.col < 0) && !controller.row) {\n      selection.selectRows(Math.max(currentSelection.from.row, 0), coords.row, coords.col);\n    } else if ((!selectedCorner && !selectedRow && coords.row < 0 || selectedRow && coords.row < 0) && !controller.column) {\n      selection.selectColumns(Math.max(currentSelection.from.col, 0), coords.col, coords.row);\n    }\n  } else {\n    const allowRightClickSelection = !selection.inInSelection(coords);\n    const performSelection = isLeftClick || isRightClick && allowRightClickSelection;\n\n    // clicked row header and when some column was selected\n    if (coords.row < 0 && coords.col >= 0 && !controller.column) {\n      if (performSelection) {\n        selection.selectColumns(coords.col, coords.col, coords.row);\n      }\n\n      // clicked column header and when some row was selected\n    } else if (coords.col < 0 && coords.row >= 0 && !controller.row) {\n      if (performSelection) {\n        selection.selectRows(coords.row, coords.row, coords.col);\n      }\n    } else if (coords.col >= 0 && coords.row >= 0 && !controller.cell) {\n      if (performSelection) {\n        selection.setRangeStart(coords);\n      }\n    } else if (coords.col < 0 && coords.row < 0) {\n      selection.selectAll(true, true, {\n        disableHeadersHighlight: true,\n        focusPosition: {\n          row: 0,\n          col: 0\n        }\n      });\n    }\n  }\n}\n\n/**\n * MouseOver handler.\n *\n * @param {object} options The handler options.\n * @param {boolean} options.isLeftClick Indicates that event was fired using the left mouse button.\n * @param {CellRange} options.coords The CellCoords object with defined visual coordinates.\n * @param {Selection} options.selection The Selection class instance.\n * @param {object} options.controller An object with keys `row`, `column`, `cell` which indicate what\n *                                    operation will be performed in later selection stages.\n * @param {Function} options.cellCoordsFactory The function factory for CellCoords objects.\n */\nexport function mouseOver(_ref2) {\n  let {\n    isLeftClick,\n    coords,\n    selection,\n    controller,\n    cellCoordsFactory\n  } = _ref2;\n  if (!isLeftClick) {\n    return;\n  }\n  const selectedRow = selection.isSelectedByRowHeader();\n  const selectedColumn = selection.isSelectedByColumnHeader();\n  const countCols = selection.tableProps.countCols();\n  const countRows = selection.tableProps.countRows();\n  if (selectedColumn && !controller.column) {\n    selection.setRangeEnd(cellCoordsFactory(countRows - 1, coords.col));\n  } else if (selectedRow && !controller.row) {\n    selection.setRangeEnd(cellCoordsFactory(coords.row, countCols - 1));\n  } else if (!controller.cell) {\n    selection.setRangeEnd(coords);\n  }\n}\nconst handlers = new Map([['mousedown', mouseDown], ['mouseover', mouseOver], ['touchstart', mouseDown]]);\n\n/**\n * Mouse handler for selection functionality.\n *\n * @param {Event} event An native event to handle.\n * @param {object} options The handler options.\n * @param {CellRange} options.coords The CellCoords object with defined visual coordinates.\n * @param {Selection} options.selection The Selection class instance.\n * @param {object} options.controller An object with keys `row`, `column`, `cell` which indicate what\n *                                    operation will be performed in later selection stages.\n * @param {Function} options.cellCoordsFactory The function factory for CellCoords objects.\n */\nexport function handleMouseEvent(event, _ref3) {\n  let {\n    coords,\n    selection,\n    controller,\n    cellCoordsFactory\n  } = _ref3;\n  handlers.get(event.type)({\n    coords,\n    selection,\n    controller,\n    cellCoordsFactory,\n    isShiftKey: event.shiftKey,\n    isLeftClick: isLeftClickEvent(event) || event.type === 'touchstart',\n    isRightClick: isRightClickEvent(event)\n  });\n}", "/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * SheetClip - Spreadsheet Clipboard Parser.\n * version 0.2\n *\n * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,\n * Google Docs and Microsoft Excel.\n *\n * Copyright 2012, Marcin Warpechowski\n * Licensed under the MIT license.\n * http://github.com/warpech/sheetclip/\n */\n\nconst regUniversalNewLine = /^(\\r\\n|\\n\\r|\\r|\\n)/;\nconst regNextCellNoQuotes = /^[^\\t\\r\\n]+/;\nconst regNextEmptyCell = /^\\t/;\n\n/**\n * Decode spreadsheet string into array.\n *\n * @param {string} str The string to parse.\n * @returns {Array}\n */\nexport function parse(str) {\n  const arr = [['']];\n  if (str.length === 0) {\n    return arr;\n  }\n  let column = 0;\n  let row = 0;\n  let lastLength;\n  while (str.length > 0) {\n    if (lastLength === str.length) {\n      // In the case If in last cycle we didn't match anything, we have to leave the infinite loop\n      break;\n    }\n    lastLength = str.length;\n    if (str.match(regNextEmptyCell)) {\n      str = str.replace(regNextEmptyCell, '');\n      column += 1;\n      arr[row][column] = '';\n    } else if (str.match(regUniversalNewLine)) {\n      str = str.replace(regUniversalNewLine, '');\n      column = 0;\n      row += 1;\n      arr[row] = [''];\n    } else {\n      let nextCell = '';\n      if (str.startsWith('\"')) {\n        let quoteNo = 0;\n        let isStillCell = true;\n        while (isStillCell) {\n          const nextChar = str.slice(0, 1);\n          if (nextChar === '\"') {\n            quoteNo += 1;\n          }\n          nextCell += nextChar;\n          str = str.slice(1);\n          if (str.length === 0 || str.match(/^[\\t\\r\\n]/) && quoteNo % 2 === 0) {\n            isStillCell = false;\n          }\n        }\n        nextCell = nextCell.replace(/^\"/, '').replace(/\"$/, '').replace(/[\"]*/g, match => new Array(Math.floor(match.length / 2)).fill('\"').join(''));\n      } else {\n        const matchedText = str.match(regNextCellNoQuotes);\n        nextCell = matchedText ? matchedText[0] : '';\n        str = str.slice(nextCell.length);\n      }\n      arr[row][column] = nextCell;\n    }\n  }\n  return arr;\n}\n\n/**\n * Encode array into valid spreadsheet string.\n *\n * @param {Array} arr An array of arrays to stringify.\n * @returns {string}\n */\nexport function stringify(arr) {\n  let r;\n  let rLen;\n  let c;\n  let cLen;\n  let str = '';\n  let val;\n  for (r = 0, rLen = arr.length; r < rLen; r += 1) {\n    cLen = arr[r].length;\n    for (c = 0; c < cLen; c += 1) {\n      if (c > 0) {\n        str += '\\t';\n      }\n      val = arr[r][c];\n      if (typeof val === 'string') {\n        if (val.indexOf('\\n') > -1) {\n          str += `\"${val.replace(/\"/g, '\"\"')}\"`;\n        } else {\n          str += val;\n        }\n      } else if (val === null || val === undefined) {\n        // undefined resolves to undefined\n        str += '';\n      } else {\n        str += val;\n      }\n    }\n    if (r !== rLen - 1) {\n      str += '\\n';\n    }\n  }\n  return str;\n}"],
  "mappings": "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",
  "names": ["getListWithInsertedItems", "getListWithRemovedItems", "getListWithInsertedItems", "getListWithRemovedItems", "getListWithInsertedItems", "getListWithRemovedItems", "_defineProperty", "_toPropertyKey", "_toPrimitive", "getListWithRemovedItems", "_defineProperty", "_toPropertyKey", "_toPrimitive", "_defineProperty", "_toPropertyKey", "_toPrimitive", "_classPrivateFieldInitSpec", "_checkPrivateRedeclaration", "_classPrivateFieldGet", "_classExtractFieldDescriptor", "_classApplyDescriptorGet", "_classPrivateFieldSet", "_classApplyDescriptorSet", "_defineProperty", "_toPropertyKey", "_toPrimitive", "_defineProperty", "getListWithRemovedItems", "getListWithInsertedItems", "_defineProperty", "_toPropertyKey", "_toPrimitive", "createHighlight", "createHighlight", "createHighlight", "createHighlight", "createHighlight", "createHighlight", "createHighlight", "createHighlight", "_checkPrivateRedeclaration", "_defineProperty", "_toPropertyKey", "_toPrimitive", "_defineProperty", "createHighlight", "_Symbol$iterator", "_defineProperty", "_toPropertyKey", "_toPrimitive", "_classPrivateMethodInitSpec", "_checkPrivateRedeclaration", "_classPrivateFieldInitSpec", "_classPrivateFieldGet", "_classExtractFieldDescriptor", "_classApplyDescriptorGet", "_classPrivateMethodGet", "_classPrivateFieldSet", "_classApplyDescriptorSet", "_classPrivateFieldInitSpec", "_checkPrivateRedeclaration", "_defineProperty", "_toPropertyKey", "_toPrimitive", "_classPrivateFieldSet", "_classExtractFieldDescriptor", "_classApplyDescriptorSet", "_classPrivateFieldGet", "_classApplyDescriptorGet", "range", "selection_default", "isLeftClick", "isRightClick"]
}
