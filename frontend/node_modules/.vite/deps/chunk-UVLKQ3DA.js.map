{
  "version": 3,
  "sources": ["../../handsontable/editorManager.mjs", "../../handsontable/mixins/hooksRefRegisterer.mjs", "../../handsontable/editors/baseEditor/baseEditor.mjs", "../../handsontable/utils/autoResize.mjs", "../../handsontable/editors/textEditor/caretPositioner.mjs", "../../handsontable/editors/textEditor/textEditor.mjs"],
  "sourcesContent": ["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nimport { isFunctionKey, isCtrlMetaKey } from \"./helpers/unicode.mjs\";\nimport { isImmediatePropagationStopped } from \"./helpers/dom/event.mjs\";\nimport { getEditorInstance } from \"./editors/registry.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { isDefined } from \"./helpers/mixed.mjs\";\nexport const SHORTCUTS_GROUP_NAVIGATION = 'editorManager.navigation';\nvar _onAfterDocumentKeyDown = /*#__PURE__*/new WeakSet();\nvar _onCellDblClick = /*#__PURE__*/new WeakSet();\nclass EditorManager {\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   * @param {TableMeta} tableMeta The table meta instance.\n   * @param {Selection} selection The selection instance.\n   */\n  constructor(hotInstance, tableMeta, _selection) {\n    /**\n     * OnCellDblClick callback.\n     *\n     * @param {MouseEvent} event The mouse event object.\n     * @param {object} coords The cell coordinates.\n     * @param {HTMLTableCellElement|HTMLTableHeaderCellElement} elem The element which triggers the action.\n     */\n    _classPrivateMethodInitSpec(this, _onCellDblClick);\n    /**\n     * OnAfterDocumentKeyDown callback.\n     *\n     * @param {KeyboardEvent} event The keyboard event object.\n     */\n    _classPrivateMethodInitSpec(this, _onAfterDocumentKeyDown);\n    /**\n     * Instance of {@link Handsontable}.\n     *\n     * @private\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to an instance's private GridSettings object.\n     *\n     * @private\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"tableMeta\", void 0);\n    /**\n     * Instance of {@link Selection}.\n     *\n     * @private\n     * @type {Selection}\n     */\n    _defineProperty(this, \"selection\", void 0);\n    /**\n     * Instance of {@link EventManager}.\n     *\n     * @private\n     * @type {EventManager}\n     */\n    _defineProperty(this, \"eventManager\", void 0);\n    /**\n     * Determines if EditorManager is destroyed.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"destroyed\", false);\n    /**\n     * Determines if EditorManager is locked.\n     *\n     * @private\n     * @type {boolean}\n     */\n    _defineProperty(this, \"lock\", false);\n    /**\n     * A reference to an instance of the activeEditor.\n     *\n     * @private\n     * @type {BaseEditor}\n     */\n    _defineProperty(this, \"activeEditor\", void 0);\n    /**\n     * Keeps a reference to the cell's properties object.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", void 0);\n    this.hot = hotInstance;\n    this.tableMeta = tableMeta;\n    this.selection = _selection;\n    this.eventManager = new EventManager(hotInstance);\n    this.hot.addHook('afterDocumentKeyDown', event => _classPrivateMethodGet(this, _onAfterDocumentKeyDown, _onAfterDocumentKeyDown2).call(this, event));\n\n    // Open editor when text composition is started (IME editor)\n    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'compositionstart', event => {\n      if (!this.destroyed && this.hot.isListening()) {\n        this.openEditor('', event);\n      }\n    });\n    this.hot.view._wt.update('onCellDblClick', (event, coords, elem) => _classPrivateMethodGet(this, _onCellDblClick, _onCellDblClick2).call(this, event, coords, elem));\n  }\n\n  /**\n   * Lock the editor from being prepared and closed. Locking the editor prevents its closing and\n   * reinitialized after selecting the new cell. This feature is necessary for a mobile editor.\n   */\n  lockEditor() {\n    this.lock = true;\n  }\n\n  /**\n   * Unlock the editor from being prepared and closed. This method restores the original behavior of\n   * the editors where for every new selection its instances are closed.\n   */\n  unlockEditor() {\n    this.lock = false;\n  }\n\n  /**\n   * Destroy current editor, if exists.\n   *\n   * @param {boolean} revertOriginal If `false` and the cell using allowInvalid option,\n   *                                 then an editor won't be closed until validation is passed.\n   */\n  destroyEditor(revertOriginal) {\n    if (!this.lock) {\n      this.closeEditor(revertOriginal);\n    }\n  }\n\n  /**\n   * Get active editor.\n   *\n   * @returns {BaseEditor}\n   */\n  getActiveEditor() {\n    return this.activeEditor;\n  }\n\n  /**\n   * Prepare text input to be displayed at given grid cell.\n   */\n  prepareEditor() {\n    if (this.lock) {\n      return;\n    }\n    if (this.activeEditor && this.activeEditor.isWaiting()) {\n      this.closeEditor(false, false, dataSaved => {\n        if (dataSaved) {\n          this.prepareEditor();\n        }\n      });\n      return;\n    }\n    const {\n      highlight\n    } = this.hot.getSelectedRangeLast();\n    if (highlight.isHeader()) {\n      return;\n    }\n    const {\n      row,\n      col\n    } = highlight;\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', row, col);\n    let visualRowToCheck = row;\n    let visualColumnToCheck = col;\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;\n    }\n\n    // Getting values using the modified coordinates.\n    this.cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    const td = this.hot.getCell(row, col, true);\n\n    // Skip the preparation when the cell is not rendered in the DOM. The cell is scrolled out of\n    // the table's viewport.\n    if (td) {\n      const editorClass = this.hot.getCellEditor(this.cellProperties);\n      const prop = this.hot.colToProp(visualColumnToCheck);\n      const originalValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(visualRowToCheck), visualColumnToCheck);\n      this.activeEditor = getEditorInstance(editorClass, this.hot);\n      // Using not modified coordinates, as we need to get the table element using selection coordinates.\n      // There is an extra translation in the editor for saving value.\n      this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);\n    }\n  }\n\n  /**\n   * Check is editor is opened/showed.\n   *\n   * @returns {boolean}\n   */\n  isEditorOpened() {\n    return this.activeEditor && this.activeEditor.isOpened();\n  }\n\n  /**\n   * Open editor with initial value.\n   *\n   * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.\n   * @param {Event} event The event object.\n   * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor\n   *                                             when arrow keys are pressed.\n   */\n  openEditor(newInitialValue, event) {\n    let enableFullEditMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this.isCellEditable()) {\n      this.clearActiveEditor();\n      return;\n    }\n    if (!this.activeEditor) {\n      this.hot.scrollToFocusedCell();\n      this.prepareEditor();\n    }\n    if (this.activeEditor) {\n      if (enableFullEditMode) {\n        this.activeEditor.enableFullEditMode();\n      }\n      this.activeEditor.beginEditing(newInitialValue, event);\n    }\n  }\n\n  /**\n   * Close editor, finish editing cell.\n   *\n   * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  closeEditor(restoreOriginalValue, isCtrlPressed, callback) {\n    if (this.activeEditor) {\n      this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);\n    } else if (callback) {\n      callback(false);\n    }\n  }\n\n  /**\n   * Close editor and save changes.\n   *\n   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.\n   */\n  closeEditorAndSaveChanges(isCtrlPressed) {\n    this.closeEditor(false, isCtrlPressed);\n  }\n\n  /**\n   * Close editor and restore original value.\n   *\n   * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.\n   */\n  closeEditorAndRestoreOriginalValue(isCtrlPressed) {\n    this.closeEditor(true, isCtrlPressed);\n  }\n\n  /**\n   * Clears reference to an instance of the active editor.\n   *\n   * @private\n   */\n  clearActiveEditor() {\n    this.activeEditor = undefined;\n  }\n\n  /**\n   * Checks if the currently selected cell (pointed by selection highlight coords) is editable.\n   * Editable cell is when:\n   *   - the cell has defined an editor type;\n   *   - the cell is not marked as read-only;\n   *   - the cell is not hidden.\n   *\n   * @private\n   * @returns {boolean}\n   */\n  isCellEditable() {\n    const selection = this.hot.getSelectedRangeLast();\n    if (!selection) {\n      return false;\n    }\n    const editorClass = this.hot.getCellEditor(this.cellProperties);\n    const {\n      row,\n      col\n    } = selection.highlight;\n    const {\n      rowIndexMapper,\n      columnIndexMapper\n    } = this.hot;\n    const isCellHidden = rowIndexMapper.isHidden(this.hot.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.hot.toPhysicalColumn(col));\n    if (this.cellProperties.readOnly || !editorClass || isCellHidden) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Controls selection's behaviour after clicking `Enter`.\n   *\n   * @private\n   * @param {boolean} isShiftPressed If `true`, then the selection will move up after hit enter.\n   */\n  moveSelectionAfterEnter(isShiftPressed) {\n    const enterMoves = typeof this.tableMeta.enterMoves === 'function' ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves;\n    if (isShiftPressed) {\n      // move selection up\n      this.selection.transformStart(-enterMoves.row, -enterMoves.col);\n    } else {\n      // move selection down (add a new row if needed)\n      this.selection.transformStart(enterMoves.row, enterMoves.col, true);\n    }\n  }\n  /**\n   * Destroy the instance.\n   */\n  destroy() {\n    this.destroyed = true;\n    this.eventManager.destroy();\n  }\n}\nfunction _onAfterDocumentKeyDown2(event) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!this.hot.isListening() || !selection || selection.highlight.isHeader() || isImmediatePropagationStopped(event)) {\n    return;\n  }\n  const {\n    keyCode\n  } = event;\n\n  // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n  const isCtrlPressed = (event.ctrlKey || event.metaKey) && !event.altKey;\n  if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {\n    if (!isFunctionKey(keyCode) && !isCtrlMetaKey(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {\n      const shortcutManager = this.hot.getShortcutManager();\n      const editorContext = shortcutManager.getContext('editor');\n      const runOnlySelectedConfig = {\n        runOnlyIf: () => isDefined(this.hot.getSelected()),\n        group: SHORTCUTS_GROUP_NAVIGATION\n      };\n      editorContext.addShortcuts([{\n        keys: [['ArrowUp']],\n        callback: () => {\n          this.hot.selection.transformStart(-1, 0);\n        }\n      }, {\n        keys: [['ArrowDown']],\n        callback: () => {\n          this.hot.selection.transformStart(1, 0);\n        }\n      }, {\n        keys: [['ArrowLeft']],\n        callback: () => {\n          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());\n        }\n      }, {\n        keys: [['ArrowRight']],\n        callback: () => {\n          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());\n        }\n      }], runOnlySelectedConfig);\n      this.openEditor('', event);\n    }\n  }\n}\nfunction _onCellDblClick2(event, coords, elem) {\n  // may be TD or TH\n  if (elem.nodeName === 'TD') {\n    this.openEditor(null, event, true);\n  }\n}\nconst instances = new WeakMap();\n\n/**\n * @param {Core} hotInstance The Handsontable instance.\n * @param {TableMeta} tableMeta The table meta class instance.\n * @param {Selection} selection The selection instance.\n * @returns {EditorManager}\n */\nEditorManager.getInstance = function (hotInstance, tableMeta, selection) {\n  let editorManager = instances.get(hotInstance);\n  if (!editorManager) {\n    editorManager = new EditorManager(hotInstance, tableMeta, selection);\n    instances.set(hotInstance, editorManager);\n  }\n  return editorManager;\n};\nexport default EditorManager;", "import \"core-js/modules/es.array.push.js\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport { defineGetter, objectEach } from \"./../helpers/object.mjs\";\nconst MIXIN_NAME = 'hooksRefRegisterer';\n\n/**\n * Mixin object to extend objects functionality for auto registering hooks in an Handsontable instance.\n *\n * @type {object}\n */\nconst hooksRefRegisterer = {\n  /**\n   * Internal hooks storage.\n   */\n  _hooksStorage: Object.create(null),\n  /**\n   * Add hook to the collection.\n   *\n   * @param {string} key The hook name.\n   * @param {Function} callback The hook callback.\n   * @returns {object}\n   */\n  addHook(key, callback) {\n    if (!this._hooksStorage[key]) {\n      this._hooksStorage[key] = [];\n    }\n    this.hot.addHook(key, callback);\n    this._hooksStorage[key].push(callback);\n    return this;\n  },\n  /**\n   * Remove all hooks listeners by hook name.\n   *\n   * @param {string} key The hook name.\n   */\n  removeHooksByKey(key) {\n    arrayEach(this._hooksStorage[key] || [], callback => {\n      this.hot.removeHook(key, callback);\n    });\n  },\n  /**\n   * Clear all added hooks.\n   */\n  clearHooks() {\n    objectEach(this._hooksStorage, (callbacks, name) => this.removeHooksByKey(name));\n    this._hooksStorage = {};\n  }\n};\ndefineGetter(hooksRefRegisterer, 'MIXIN_NAME', MIXIN_NAME, {\n  writable: false,\n  enumerable: false\n});\nexport default hooksRefRegisterer;", "import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isDefined, stringify } from \"../../helpers/mixed.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\nimport { SHORTCUTS_GROUP_NAVIGATION } from \"../../editorManager.mjs\";\nimport hooksRefRegisterer from \"../../mixins/hooksRefRegisterer.mjs\";\nimport { getScrollbarWidth, offset, hasVerticalScrollbar, hasHorizontalScrollbar, outerWidth, outerHeight, getComputedStyle } from \"../../helpers/dom/element.mjs\";\nexport const EDITOR_TYPE = 'base';\nexport const EDITOR_STATE = Object.freeze({\n  VIRGIN: 'STATE_VIRGIN',\n  // before editing\n  EDITING: 'STATE_EDITING',\n  WAITING: 'STATE_WAITING',\n  // waiting for async validation\n  FINISHED: 'STATE_FINISHED'\n});\nexport const SHORTCUTS_GROUP_EDITOR = 'baseEditor';\n\n/**\n * @class BaseEditor\n */\nexport class BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * A reference to the source instance of the Handsontable.\n   *\n   * @type {Handsontable}\n   */\n\n  /**\n   * @param {Handsontable} hotInstance A reference to the source instance of the Handsontable.\n   */\n  constructor(hotInstance) {\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Editor's state.\n     *\n     * @type {string}\n     */\n    _defineProperty(this, \"state\", EDITOR_STATE.VIRGIN);\n    /**\n     * Flag to store information about editor's opening status.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_opened\", false);\n    /**\n     * Defines the editor's editing mode. When false, then an editor works in fast editing mode.\n     *\n     * @private\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"_fullEditMode\", false);\n    /**\n     * Callback to call after closing editor.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"_closeCallback\", null);\n    /**\n     * Currently rendered cell's TD element.\n     *\n     * @type {HTMLTableCellElement}\n     */\n    _defineProperty(this, \"TD\", null);\n    /**\n     * Visual row index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", null);\n    /**\n     * Visual column index.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", null);\n    /**\n     * Column property name or a column index, if datasource is an array of arrays.\n     *\n     * @type {number|string}\n     */\n    _defineProperty(this, \"prop\", null);\n    /**\n     * Original cell's value.\n     *\n     * @type {*}\n     */\n    _defineProperty(this, \"originalValue\", null);\n    /**\n     * Object containing the cell's properties.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"cellProperties\", null);\n    this.hot = hotInstance;\n    this.init();\n  }\n\n  /**\n   * Fires callback after closing editor.\n   *\n   * @private\n   * @param {boolean} result The editor value.\n   */\n  _fireCallbacks(result) {\n    if (this._closeCallback) {\n      this._closeCallback(result);\n      this._closeCallback = null;\n    }\n  }\n\n  /**\n   * Initializes an editor's intance.\n   */\n  init() {}\n\n  /**\n   * Required method to get current value from editable element.\n   */\n  getValue() {\n    throw Error('Editor getValue() method unimplemented');\n  }\n\n  /**\n   * Required method to set new value into editable element.\n   */\n  setValue() {\n    throw Error('Editor setValue() method unimplemented');\n  }\n\n  /**\n   * Required method to open editor.\n   */\n  open() {\n    throw Error('Editor open() method unimplemented');\n  }\n\n  /**\n   * Required method to close editor.\n   */\n  close() {\n    throw Error('Editor close() method unimplemented');\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    this.TD = td;\n    this.row = row;\n    this.col = col;\n    this.prop = prop;\n    this.originalValue = value;\n    this.cellProperties = cellProperties;\n    this.state = EDITOR_STATE.VIRGIN;\n  }\n\n  /**\n   * Fallback method to provide extendable editors in ES5.\n   *\n   * @returns {Function}\n   */\n  extend() {\n    return class Editor extends this.constructor {};\n  }\n\n  /**\n   * Saves value from editor into data storage.\n   *\n   * @param {*} value The editor value.\n   * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.\n   */\n  saveValue(value, ctrlDown) {\n    let visualRowFrom;\n    let visualColumnFrom;\n    let visualRowTo;\n    let visualColumnTo;\n\n    // if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)\n    if (ctrlDown) {\n      const selectedLast = this.hot.getSelectedLast();\n      visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0); // Math.max eliminate headers coords.\n      visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0); // Math.max eliminate headers coords.\n      visualRowTo = Math.max(selectedLast[0], selectedLast[2]);\n      visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);\n    } else {\n      [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = [this.row, this.col, null, null];\n    }\n    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowFrom, visualColumnFrom);\n    if (Array.isArray(modifiedCellCoords)) {\n      [visualRowFrom, visualColumnFrom] = modifiedCellCoords;\n    }\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    const contextConfig = {\n      runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: SHORTCUTS_GROUP_EDITOR\n    };\n    if (this.isInFullEditMode()) {\n      editorContext.addShortcuts([{\n        keys: [['ArrowUp']],\n        callback: () => {\n          this.hot.selection.transformStart(-1, 0);\n        }\n      }, {\n        keys: [['ArrowDown']],\n        callback: () => {\n          this.hot.selection.transformStart(1, 0);\n        }\n      }, {\n        keys: [['ArrowLeft']],\n        callback: () => {\n          this.hot.selection.transformStart(0, -1 * this.hot.getDirectionFactor());\n        }\n      }, {\n        keys: [['ArrowRight']],\n        callback: () => {\n          this.hot.selection.transformStart(0, this.hot.getDirectionFactor());\n        }\n      }], contextConfig);\n    }\n\n    // Saving values using the modified coordinates.\n    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, 'edit');\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The initial editor value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    const hotInstance = this.hot;\n    // We have to convert visual indexes into renderable indexes\n    // due to hidden columns don't participate in the rendering process\n    const renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));\n    this.state = EDITOR_STATE.EDITING;\n\n    // Set the editor value only in the full edit mode. In other mode the focusable element has to be empty,\n    // otherwise IME (editor for Asia users) doesn't work.\n    if (this.isInFullEditMode()) {\n      const stringifiedInitialValue = typeof newInitialValue === 'string' ? newInitialValue : stringify(this.originalValue);\n      this.setValue(stringifiedInitialValue);\n    }\n    this.open(event);\n    this._opened = true;\n    this.focus();\n\n    // only rerender the selections (FillHandle should disappear when beginEditing is triggered)\n    hotInstance.view.render();\n    hotInstance.runHooks('afterBeginEditing', this.row, this.col);\n  }\n\n  /**\n   * Finishes editing and start saving or restoring process for editing cell or last selected range.\n   *\n   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.\n   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.\n   * @param {Function} callback The callback function, fired after editor closing.\n   */\n  finishEditing(restoreOriginalValue, ctrlDown, callback) {\n    let val;\n    if (callback) {\n      const previousCloseCallback = this._closeCallback;\n      this._closeCallback = result => {\n        if (previousCloseCallback) {\n          previousCloseCallback(result);\n        }\n        callback(result);\n        this.hot.view.render();\n      };\n    }\n    if (this.isWaiting()) {\n      return;\n    }\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);\n    if (this.state === EDITOR_STATE.VIRGIN) {\n      this.hot._registerTimeout(() => {\n        this._fireCallbacks(true);\n      });\n      return;\n    }\n    if (this.state === EDITOR_STATE.EDITING) {\n      if (restoreOriginalValue) {\n        this.cancelChanges();\n        this.hot.view.render();\n        return;\n      }\n      const value = this.getValue();\n      if (this.cellProperties.trimWhitespace) {\n        // We trim only string values\n        val = [[typeof value === 'string' ? String.prototype.trim.call(value || '') : value]];\n      } else {\n        val = [[value]];\n      }\n      this.state = EDITOR_STATE.WAITING;\n      this.saveValue(val, ctrlDown);\n      if (this.hot.getCellValidator(this.cellProperties)) {\n        this.hot.addHookOnce('postAfterValidate', result => {\n          this.state = EDITOR_STATE.FINISHED;\n          this.discardEditor(result);\n        });\n      } else {\n        this.state = EDITOR_STATE.FINISHED;\n        this.discardEditor(true);\n      }\n    }\n  }\n\n  /**\n   * Finishes editing without singout saving value.\n   */\n  cancelChanges() {\n    this.state = EDITOR_STATE.FINISHED;\n    this.discardEditor();\n  }\n\n  /**\n   * Verifies result of validation or closes editor if user's cancelled changes.\n   *\n   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,\n   *                                   then an editor won't be closed until validation is passed.\n   */\n  discardEditor(result) {\n    if (this.state !== EDITOR_STATE.FINISHED) {\n      return;\n    }\n\n    // validator was defined and failed\n    if (result === false && this.cellProperties.allowInvalid !== true) {\n      this.hot.selectCell(this.row, this.col);\n      this.focus();\n      this.state = EDITOR_STATE.EDITING;\n      this._fireCallbacks(false);\n    } else {\n      this.close();\n      this._opened = false;\n      this._fullEditMode = false;\n      this.state = EDITOR_STATE.VIRGIN;\n      this._fireCallbacks(true);\n      const shortcutManager = this.hot.getShortcutManager();\n      shortcutManager.setActiveContextName('grid');\n    }\n  }\n\n  /**\n   * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated\n   * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.\n   */\n  enableFullEditMode() {\n    this._fullEditMode = true;\n  }\n\n  /**\n   * Checks if editor is in full edit mode.\n   *\n   * @returns {boolean}\n   */\n  isInFullEditMode() {\n    return this._fullEditMode;\n  }\n\n  /**\n   * Returns information whether the editor is open.\n   *\n   * @returns {boolean}\n   */\n  isOpened() {\n    return this._opened;\n  }\n\n  /**\n   * Returns information whether the editor is waiting, eg.: for async validation.\n   *\n   * @returns {boolean}\n   */\n  isWaiting() {\n    return this.state === EDITOR_STATE.WAITING;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Gets the object that provides information about the edited cell size and its position\n   * relative to the table viewport.\n   *\n   * The rectangle has six integer properties:\n   *  - `top` The top position relative to the table viewport\n   *  - `start` The left (or right in RTL) position relative to the table viewport\n   *  - `width` The cell's current width;\n   *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport\n   *  - `height` The cell's current height;\n   *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport\n   *\n   * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}\n   */\n  getEditedCellRect() {\n    var _wtOverlays$getParent;\n    const TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!TD) {\n      return;\n    }\n    const {\n      wtOverlays,\n      wtViewport\n    } = this.hot.view._wt;\n    const rootWindow = this.hot.rootWindow;\n    const currentOffset = offset(TD);\n    const cellWidth = outerWidth(TD);\n    const containerOffset = offset(this.hot.rootElement);\n    const containerWidth = outerWidth(this.hot.rootElement);\n    const scrollableContainerTop = wtOverlays.topOverlay.holder;\n    const scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;\n    const containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;\n    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;\n    const gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;\n    const {\n      wtTable: overlayTable\n    } = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt;\n    const overlayName = overlayTable.name;\n    const scrollTop = ['master', 'inline_start'].includes(overlayName) ? containerScrollTop : 0;\n    const scrollLeft = ['master', 'top', 'bottom'].includes(overlayName) ? containerScrollLeft : 0;\n\n    // If colHeaders is disabled, cells in the first row have border-top\n    const editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;\n    let topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;\n    let inlineStartPos = 0;\n    if (this.hot.isRtl()) {\n      inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;\n    } else {\n      inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;\n    }\n\n    // When the scrollable element is Window object then the editor position needs to be compensated\n    // by the overlays' position (position relative to the table viewport). In other cases, the overlay's\n    // position always returns 0.\n    if (['top', 'top_inline_start_corner'].includes(overlayName)) {\n      topPos += wtOverlays.topOverlay.getOverlayOffset();\n    }\n    if (['inline_start', 'top_inline_start_corner'].includes(overlayName)) {\n      inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());\n    }\n    const hasColumnHeaders = this.hot.hasColHeaders();\n    const renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);\n    const renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);\n    const nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();\n    const firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting('fixedRowsBottom');\n    if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {\n      topPos += 1;\n    }\n    if (renderableColumn <= 0) {\n      inlineStartPos += 1;\n    }\n    const firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;\n    const firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;\n    const horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());\n    const verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();\n    const scrollbarWidth = getScrollbarWidth(this.hot.rootDocument);\n    let cellTopOffset = TD.offsetTop;\n    if (['inline_start', 'master'].includes(overlayName)) {\n      cellTopOffset += firstRowOffset - verticalScrollPosition;\n    }\n    if (['bottom', 'bottom_inline_start_corner'].includes(overlayName)) {\n      const {\n        wtViewport: bottomWtViewport,\n        wtTable: bottomWtTable\n      } = wtOverlays.bottomOverlay.clone;\n      cellTopOffset += bottomWtViewport.getWorkspaceHeight() - bottomWtTable.getHeight() - scrollbarWidth;\n    }\n    let cellStartOffset = TD.offsetLeft;\n    if (this.hot.isRtl()) {\n      if (cellStartOffset >= 0) {\n        cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;\n      } else {\n        // The `offsetLeft` returns negative values when the parent offset element has position relative\n        // (it happens when on the cell the selection is applied - the `area` CSS class).\n        // When it happens the `offsetLeft` value is calculated from the right edge of the parent element.\n        cellStartOffset = Math.abs(cellStartOffset);\n      }\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;\n    } else if (['top', 'master', 'bottom'].includes(overlayName)) {\n      cellStartOffset += firstColumnOffset - horizontalScrollPosition;\n    }\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    const borderPhysicalWidthProp = this.hot.isRtl() ? 'borderRightWidth' : 'borderLeftWidth';\n    const inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;\n    const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;\n    const width = outerWidth(TD) + inlineStartBorderCompensation;\n    const height = outerHeight(TD) + topBorderCompensation;\n    const actualVerticalScrollbarWidth = hasVerticalScrollbar(scrollableContainerTop) ? scrollbarWidth : 0;\n    const actualHorizontalScrollbarWidth = hasHorizontalScrollbar(scrollableContainerLeft) ? scrollbarWidth : 0;\n    const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;\n    const maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, 23);\n    return {\n      top: topPos,\n      start: inlineStartPos,\n      height,\n      maxHeight,\n      width,\n      maxWidth\n    };\n  }\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  /**\n   * Gets className of the edited cell if exist.\n   *\n   * @returns {string}\n   */\n  getEditedCellsLayerClass() {\n    const editorSection = this.checkEditorSection();\n    switch (editorSection) {\n      case 'inline-start':\n        return 'ht_clone_left ht_clone_inline_start';\n      case 'bottom':\n        return 'ht_clone_bottom';\n      case 'bottom-inline-start-corner':\n        return 'ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner';\n      case 'top':\n        return 'ht_clone_top';\n      case 'top-inline-start-corner':\n        return 'ht_clone_top_left_corner ht_clone_top_inline_start_corner';\n      default:\n        return 'ht_clone_master';\n    }\n  }\n\n  /**\n   * Gets HTMLTableCellElement of the edited cell if exist.\n   *\n   * @returns {HTMLTableCellElement|null}\n   */\n  getEditedCell() {\n    return this.hot.getCell(this.row, this.col, true);\n  }\n\n  /**\n   * Returns name of the overlay, where editor is placed.\n   *\n   * @private\n   * @returns {string}\n   */\n  checkEditorSection() {\n    const totalRows = this.hot.countRows();\n    let section = '';\n    if (this.row < this.hot.getSettings().fixedRowsTop) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'top-inline-start-corner';\n      } else {\n        section = 'top';\n      }\n    } else if (this.hot.getSettings().fixedRowsBottom && this.row >= totalRows - this.hot.getSettings().fixedRowsBottom) {\n      if (this.col < this.hot.getSettings().fixedColumnsStart) {\n        section = 'bottom-inline-start-corner';\n      } else {\n        section = 'bottom';\n      }\n    } else if (this.col < this.hot.getSettings().fixedColumnsStart) {\n      section = 'inline-start';\n    }\n    return section;\n  }\n}\nmixin(BaseEditor, hooksRefRegisterer);", "/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * autoResize - resizes a DOM element to the width and height of another DOM element\n *\n * Copyright 2014, Marcin Warpechowski\n * Licensed under the MIT license\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\n/**\n * Attaches an event listener to the given element.\n *\n * @param {HTMLElement} element The element to observe.\n * @param {string} eventName The name of the event to listen for.\n * @param {Function} handler The function to call when the event is triggered.\n */\nfunction observe(element, eventName, handler) {\n  element.addEventListener(eventName, handler, false);\n}\n\n/**\n * Removes an event listener from an element.\n *\n * @param {HTMLElement} element The element to remove the event listener from.\n * @param {string} eventName The name of the event to remove.\n * @param {Function} handler The function to remove as a listener.\n */\nfunction unObserve(element, eventName, handler) {\n  element.removeEventListener(eventName, handler, false);\n}\n\n/**\n * Returns the computed style of an element.\n *\n * @param {Element} element The element to get the computed style from.\n * @returns {CSSStyleDeclaration} The computed style of the element.\n */\nfunction getComputedStyle(element) {\n  return element.ownerDocument.defaultView.getComputedStyle(element);\n}\n\n/**\n * @typedef InputElementResizerConfig\n * @property {number} minWidth The minimum width of the element.\n * @property {number} maxWidth The maximum width of the element.\n * @property {number} minHeight The minimum height of the element.\n * @property {number} maxHeight The maximum height of the element.\n */\n/**\n * @typedef InputElementResizer\n * @property {function(HTMLElement, InputElementResizerConfig, boolean): void} init Initializes the resizer.\n * @property {function(): void} resize Resizes the element.\n * @property {function(): void} unObserve Removes the event listeners.\n */\n/**\n * Creates an input element resizer.\n *\n * @param {Document} ownerDocument The document to create the resizer for.\n * @returns {InputElementResizer}\n */\nexport function createInputElementResizer(ownerDocument) {\n  const defaults = {\n    minHeight: 200,\n    maxHeight: 300,\n    minWidth: 100,\n    maxWidth: 300\n  };\n  const body = ownerDocument.body;\n  const textHolder = ownerDocument.createTextNode('');\n  const textContainer = ownerDocument.createElement('span');\n  let observedElement;\n\n  /**\n   * Resizes the element.\n   */\n  function resize() {\n    textHolder.textContent = observedElement.value;\n    // Won't expand the element size for displaying body as for example, `grid`, `inline-grid` or `flex` with\n    // `flex-direction` set as `column`.\n    textContainer.style.position = 'absolute';\n    textContainer.style.fontSize = getComputedStyle(observedElement).fontSize;\n    textContainer.style.fontFamily = getComputedStyle(observedElement).fontFamily;\n    textContainer.style.whiteSpace = 'pre';\n    body.appendChild(textContainer);\n    const width = textContainer.clientWidth + 2;\n    body.removeChild(textContainer);\n    const elementStyle = observedElement.style;\n    elementStyle.height = `${defaults.minHeight}px`;\n    if (defaults.minWidth > width) {\n      elementStyle.width = `${defaults.minWidth}px`;\n    } else if (width > defaults.maxWidth) {\n      elementStyle.width = `${defaults.maxWidth}px`;\n    } else {\n      elementStyle.width = `${width}px`;\n    }\n    const scrollHeight = observedElement.scrollHeight ? observedElement.scrollHeight - 1 : 0;\n    if (defaults.minHeight > scrollHeight) {\n      elementStyle.height = `${defaults.minHeight}px`;\n    } else if (defaults.maxHeight < scrollHeight) {\n      elementStyle.height = `${defaults.maxHeight}px`;\n      elementStyle.overflowY = 'visible';\n    } else {\n      elementStyle.height = `${scrollHeight}px`;\n    }\n  }\n\n  /**\n   * Resizes the element after a delay.\n   */\n  function delayedResize() {\n    ownerDocument.defaultView.setTimeout(resize, 0);\n  }\n\n  /**\n   * Extends the default configuration.\n   *\n   * @param {InputElementResizerConfig} config The configuration to extend the defaults with.\n   */\n  function extendDefaults(config) {\n    if (config && config.minHeight) {\n      if (config.minHeight === 'inherit') {\n        defaults.minHeight = observedElement.clientHeight;\n      } else {\n        const minHeight = parseInt(config.minHeight, 10);\n        if (!isNaN(minHeight)) {\n          defaults.minHeight = minHeight;\n        }\n      }\n    }\n    if (config && config.maxHeight) {\n      if (config.maxHeight === 'inherit') {\n        defaults.maxHeight = observedElement.clientHeight;\n      } else {\n        const maxHeight = parseInt(config.maxHeight, 10);\n        if (!isNaN(maxHeight)) {\n          defaults.maxHeight = maxHeight;\n        }\n      }\n    }\n    if (config && config.minWidth) {\n      if (config.minWidth === 'inherit') {\n        defaults.minWidth = observedElement.clientWidth;\n      } else {\n        const minWidth = parseInt(config.minWidth, 10);\n        if (!isNaN(minWidth)) {\n          defaults.minWidth = minWidth;\n        }\n      }\n    }\n    if (config && config.maxWidth) {\n      if (config.maxWidth === 'inherit') {\n        defaults.maxWidth = observedElement.clientWidth;\n      } else {\n        const maxWidth = parseInt(config.maxWidth, 10);\n        if (!isNaN(maxWidth)) {\n          defaults.maxWidth = maxWidth;\n        }\n      }\n    }\n    if (!textContainer.firstChild) {\n      textContainer.className = 'autoResize';\n      textContainer.style.display = 'inline-block';\n      textContainer.appendChild(textHolder);\n    }\n  }\n\n  /**\n   * Initializes the resizer.\n   *\n   * @param {HTMLElement} elementToObserve The element to observe.\n   * @param {InputElementResizerConfig} config The configuration to extend the defaults with.\n   * @param {boolean} [doObserve=false] Whether to observe the element and resize it on every input change.\n   */\n  function init(elementToObserve, config) {\n    let doObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    observedElement = elementToObserve;\n    extendDefaults(config);\n    if (observedElement.nodeName === 'TEXTAREA') {\n      observedElement.style.resize = 'none';\n      observedElement.style.overflowY = '';\n      observedElement.style.height = `${defaults.minHeight}px`;\n      observedElement.style.minWidth = `${defaults.minWidth}px`;\n      observedElement.style.maxWidth = `${defaults.maxWidth}px`;\n      observedElement.style.overflowY = 'hidden';\n    }\n    if (doObserve) {\n      observe(observedElement, 'input', resize);\n      // the keydown event is necessary for undo stack to work properly\n      observe(observedElement, 'keydown', delayedResize);\n    }\n    resize();\n  }\n  return {\n    init,\n    resize,\n    unObserve() {\n      unObserve(observedElement, 'input', resize);\n      unObserve(observedElement, 'keydown', delayedResize);\n    }\n  };\n}", "import { getCaretPosition, setCaretPosition } from \"../../helpers/dom/element.mjs\";\n/**\n * Updates the textarea caret position depends on the action executed on that element.\n *\n * The following actions are supported:\n *  - 'home': Move the caret to the beginning of the current line;\n *  - 'end': Move the caret to the end of the current line.\n *\n * @param {'home'|'end'} actionName The action to perform that modifies the caret behavior.\n * @param {HTMLTextAreaElement} textareaElement The textarea element where the action is supposed to happen.\n */\nexport function updateCaretPosition(actionName, textareaElement) {\n  const caretPosition = getCaretPosition(textareaElement);\n  const textLines = textareaElement.value.split('\\n');\n  let newCaretPosition = caretPosition;\n  let lineStartIndex = 0;\n  for (let i = 0; i < textLines.length; i++) {\n    const textLine = textLines[i];\n    if (i !== 0) {\n      lineStartIndex += textLines[i - 1].length + 1;\n    }\n    const lineEndIndex = lineStartIndex + textLine.length;\n    if (actionName === 'home') {\n      newCaretPosition = lineStartIndex;\n    } else if (actionName === 'end') {\n      newCaretPosition = lineEndIndex;\n    }\n    if (caretPosition <= lineEndIndex) {\n      break;\n    }\n  }\n  setCaretPosition(textareaElement, newCaretPosition);\n}", "import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { BaseEditor, EDITOR_STATE } from \"../baseEditor/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { isEdge, isIOS } from \"../../helpers/browser.mjs\";\nimport { addClass, getComputedStyle, isThisHotChild, setCaretPosition, hasClass, removeClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { createInputElementResizer } from \"../../utils/autoResize.mjs\";\nimport { isDefined } from \"../../helpers/mixed.mjs\";\nimport { SHORTCUTS_GROUP_NAVIGATION } from \"../../editorManager.mjs\";\nimport { SHORTCUTS_GROUP_EDITOR } from \"../baseEditor/baseEditor.mjs\";\nimport { updateCaretPosition } from \"./caretPositioner.mjs\";\nimport { A11Y_HIDDEN, A11Y_TABINDEX } from \"../../helpers/a11y.mjs\";\nconst EDITOR_VISIBLE_CLASS_NAME = 'ht_editor_visible';\nconst EDITOR_HIDDEN_CLASS_NAME = 'ht_editor_hidden';\nconst SHORTCUTS_GROUP = 'textEditor';\nexport const EDITOR_TYPE = 'text';\n\n/**\n * @private\n * @class TextEditor\n */\nexport class TextEditor extends BaseEditor {\n  static get EDITOR_TYPE() {\n    return EDITOR_TYPE;\n  }\n\n  /**\n   * Instance of {@link EventManager}.\n   *\n   * @private\n   * @type {EventManager}\n   */\n\n  /**\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  constructor(hotInstance) {\n    super(hotInstance);\n    _defineProperty(this, \"eventManager\", new EventManager(this));\n    /**\n     * Autoresize instance. Automagically resizes editor after changes.\n     *\n     * @private\n     * @type {Function}\n     */\n    _defineProperty(this, \"autoResize\", createInputElementResizer(this.hot.rootDocument));\n    /**\n     * An TEXTAREA element.\n     *\n     * @private\n     * @type {HTMLTextAreaElement}\n     */\n    _defineProperty(this, \"TEXTAREA\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaStyle\", void 0);\n    /**\n     * Parent element of the TEXTAREA.\n     *\n     * @private\n     * @type {HTMLDivElement}\n     */\n    _defineProperty(this, \"TEXTAREA_PARENT\", void 0);\n    /**\n     * Style declaration object of the TEXTAREA_PARENT element.\n     *\n     * @private\n     * @type {CSSStyleDeclaration}\n     */\n    _defineProperty(this, \"textareaParentStyle\", void 0);\n    /**\n     * Z-index class style for the editor.\n     *\n     * @private\n     * @type {string}\n     */\n    _defineProperty(this, \"layerClass\", void 0);\n    this.eventManager = new EventManager(this);\n    this.createElements();\n    this.bindEvents();\n    this.hot.addHookOnce('afterDestroy', () => this.destroy());\n  }\n\n  /**\n   * Gets current value from editable element.\n   *\n   * @returns {number}\n   */\n  getValue() {\n    return this.TEXTAREA.value;\n  }\n\n  /**\n   * Sets new value into editable element.\n   *\n   * @param {*} newValue The editor value.\n   */\n  setValue(newValue) {\n    this.TEXTAREA.value = newValue;\n  }\n\n  /**\n   * Opens the editor and adjust its size.\n   */\n  open() {\n    this.refreshDimensions(); // need it instantly, to prevent https://github.com/handsontable/handsontable/issues/348\n    this.showEditableElement();\n    this.hot.getShortcutManager().setActiveContextName('editor');\n    this.registerShortcuts();\n  }\n\n  /**\n   * Closes the editor.\n   */\n  close() {\n    this.autoResize.unObserve();\n    if (isThisHotChild(this.hot.rootDocument.activeElement, this.hot.rootElement)) {\n      this.hot.listen(); // don't refocus the table if user focused some cell outside of HT on purpose\n    }\n\n    this.hideEditableElement();\n    this.unregisterShortcuts();\n  }\n\n  /**\n   * Prepares editor's meta data.\n   *\n   * @param {number} row The visual row index.\n   * @param {number} col The visual column index.\n   * @param {number|string} prop The column property (passed when datasource is an array of objects).\n   * @param {HTMLTableCellElement} td The rendered cell element.\n   * @param {*} value The rendered value.\n   * @param {object} cellProperties The cell meta object ({@see Core#getCellMeta}).\n   */\n  prepare(row, col, prop, td, value, cellProperties) {\n    const previousState = this.state;\n    super.prepare(row, col, prop, td, value, cellProperties);\n    if (!cellProperties.readOnly) {\n      this.refreshDimensions(true);\n      const {\n        allowInvalid\n      } = cellProperties;\n      if (allowInvalid) {\n        // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste\n        // functionality work with IME)\n        this.TEXTAREA.value = '';\n      }\n      if (previousState !== EDITOR_STATE.FINISHED) {\n        this.hideEditableElement();\n      }\n    }\n  }\n\n  /**\n   * Begins editing on a highlighted cell and hides fillHandle corner if was present.\n   *\n   * @param {*} newInitialValue The editor initial value.\n   * @param {Event} event The keyboard event object.\n   */\n  beginEditing(newInitialValue, event) {\n    if (this.state !== EDITOR_STATE.VIRGIN) {\n      return;\n    }\n    this.TEXTAREA.value = ''; // Remove an empty space from textarea (added by copyPaste plugin to make copy/paste functionality work with IME).\n    super.beginEditing(newInitialValue, event);\n  }\n\n  /**\n   * Sets focus state on the select element.\n   */\n  focus() {\n    // For IME editor textarea element must be focused using \".select\" method.\n    // Using \".focus\" browser automatically scroll into the focused element which\n    // is undesired effect.\n    this.TEXTAREA.select();\n    setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);\n  }\n\n  /**\n   * Creates an editor's elements and adds necessary CSS classnames.\n   */\n  createElements() {\n    const {\n      rootDocument\n    } = this.hot;\n    this.TEXTAREA = rootDocument.createElement('TEXTAREA');\n\n    // Makes the element recognizable by Hot as its own\n    // component's element.\n    setAttribute(this.TEXTAREA, [['data-hot-input', ''], A11Y_TABINDEX(-1)]);\n    if (this.hot.getSettings().ariaTags) {\n      setAttribute(this.TEXTAREA, [A11Y_HIDDEN()]);\n    }\n    addClass(this.TEXTAREA, 'handsontableInput');\n    this.textareaStyle = this.TEXTAREA.style;\n    this.textareaStyle.width = 0;\n    this.textareaStyle.height = 0;\n    this.textareaStyle.overflowY = 'visible';\n    this.TEXTAREA_PARENT = rootDocument.createElement('DIV');\n    addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');\n    if (hasClass(this.TEXTAREA_PARENT, this.layerClass)) {\n      removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    this.textareaParentStyle = this.TEXTAREA_PARENT.style;\n    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);\n    this.hot.rootElement.appendChild(this.TEXTAREA_PARENT);\n  }\n\n  /**\n   * Moves an editable element out of the viewport, but element must be able to hold focus for IME support.\n   *\n   * @private\n   */\n  hideEditableElement() {\n    if (isEdge()) {\n      this.textareaStyle.textIndent = '-99999px';\n    }\n    this.textareaStyle.overflowY = 'visible';\n    this.textareaParentStyle.opacity = '0';\n    this.textareaParentStyle.height = '1px';\n    removeClass(this.TEXTAREA_PARENT, this.layerClass);\n    addClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n  }\n\n  /**\n   * Resets an editable element position.\n   *\n   * @private\n   */\n  showEditableElement() {\n    this.textareaParentStyle.height = '';\n    this.textareaParentStyle.overflow = '';\n    this.textareaParentStyle.position = '';\n    this.textareaParentStyle[this.hot.isRtl() ? 'left' : 'right'] = 'auto';\n    this.textareaParentStyle.opacity = '1';\n    this.textareaStyle.textIndent = '';\n    this.textareaStyle.overflowY = 'hidden';\n    const childNodes = this.TEXTAREA_PARENT.childNodes;\n    let hasClassHandsontableEditor = false;\n    rangeEach(childNodes.length - 1, index => {\n      const childNode = childNodes[index];\n      if (hasClass(childNode, 'handsontableEditor')) {\n        hasClassHandsontableEditor = true;\n        return false;\n      }\n    });\n    if (hasClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME)) {\n      removeClass(this.TEXTAREA_PARENT, EDITOR_HIDDEN_CLASS_NAME);\n    }\n    if (hasClassHandsontableEditor) {\n      this.layerClass = EDITOR_VISIBLE_CLASS_NAME;\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    } else {\n      this.layerClass = this.getEditedCellsLayerClass();\n      addClass(this.TEXTAREA_PARENT, this.layerClass);\n    }\n  }\n\n  /**\n   * Refreshes editor's value using source data.\n   *\n   * @private\n   */\n  refreshValue() {\n    const physicalRow = this.hot.toPhysicalRow(this.row);\n    const sourceData = this.hot.getSourceDataAtCell(physicalRow, this.col);\n    this.originalValue = sourceData;\n    this.setValue(sourceData);\n    this.refreshDimensions();\n  }\n\n  /**\n   * Refreshes editor's size and position.\n   *\n   * @private\n   * @param {boolean} force Indicates if the refreshing editor dimensions should be triggered.\n   */\n  refreshDimensions() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.state !== EDITOR_STATE.EDITING && !force) {\n      return;\n    }\n    this.TD = this.getEditedCell();\n\n    // TD is outside of the viewport.\n    if (!this.TD) {\n      if (!force) {\n        this.close(); // TODO shouldn't it be this.finishEditing() ?\n      }\n\n      return;\n    }\n    const {\n      top,\n      start,\n      width,\n      maxWidth,\n      height,\n      maxHeight\n    } = this.getEditedCellRect();\n    this.textareaParentStyle.top = `${top}px`;\n    this.textareaParentStyle[this.hot.isRtl() ? 'right' : 'left'] = `${start}px`;\n    this.showEditableElement();\n    const cellComputedStyle = getComputedStyle(this.TD, this.hot.rootWindow);\n    this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;\n    this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;\n    this.TEXTAREA.style.backgroundColor = this.TD.style.backgroundColor;\n    const textareaComputedStyle = getComputedStyle(this.TEXTAREA);\n    const horizontalPadding = parseInt(textareaComputedStyle.paddingLeft, 10) + parseInt(textareaComputedStyle.paddingRight, 10);\n    const verticalPadding = parseInt(textareaComputedStyle.paddingTop, 10) + parseInt(textareaComputedStyle.paddingBottom, 10);\n    const finalWidth = width - horizontalPadding;\n    const finalHeight = height - verticalPadding;\n    const finalMaxWidth = maxWidth - horizontalPadding;\n    const finalMaxHeight = maxHeight - verticalPadding;\n    this.autoResize.init(this.TEXTAREA, {\n      minWidth: Math.min(finalWidth, finalMaxWidth),\n      minHeight: Math.min(finalHeight, finalMaxHeight),\n      // TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)\n      maxWidth: finalMaxWidth,\n      maxHeight: finalMaxHeight\n    }, true);\n  }\n\n  /**\n   * Binds events and hooks.\n   *\n   * @private\n   */\n  bindEvents() {\n    if (isIOS()) {\n      // on iOS after click \"Done\" the edit isn't hidden by default, so we need to handle it manually.\n      this.eventManager.addEventListener(this.TEXTAREA, 'focusout', () => this.finishEditing(false));\n    }\n    this.addHook('afterScrollHorizontally', () => this.refreshDimensions());\n    this.addHook('afterScrollVertically', () => this.refreshDimensions());\n    this.addHook('afterColumnResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n    this.addHook('afterRowResize', () => {\n      this.refreshDimensions();\n      if (this.state === EDITOR_STATE.EDITING) {\n        this.focus();\n      }\n    });\n  }\n\n  /**\n   * Ugly hack for autocompleteEditor.\n   *\n   * @private\n   */\n  allowKeyEventPropagation() {}\n\n  /**\n   * Destroys the internal event manager and clears attached hooks.\n   *\n   * @private\n   */\n  destroy() {\n    this.eventManager.destroy();\n    this.clearHooks();\n  }\n\n  /**\n   * Register shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    const gridContext = shortcutManager.getContext('grid');\n    const contextConfig = {\n      runOnlyIf: () => isDefined(this.hot.getSelected()),\n      group: SHORTCUTS_GROUP\n    };\n    const insertNewLine = () => {\n      this.hot.rootDocument.execCommand('insertText', false, '\\n');\n    };\n    editorContext.addShortcuts([{\n      keys: [['Tab'], ['Shift', 'Tab'], ['PageUp'], ['PageDown']],\n      forwardToContext: gridContext,\n      callback: () => {}\n    }, {\n      keys: [['Control', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n\n      runOnlyIf: event => !this.hot.selection.isMultiple() &&\n      // We trigger a data population for multiple selection.\n      // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)\n      !event.altKey\n    }, {\n      keys: [['Meta', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      },\n\n      runOnlyIf: () => !this.hot.selection.isMultiple() // We trigger a data population for multiple selection.\n    }, {\n      keys: [['Alt', 'Enter']],\n      callback: () => {\n        insertNewLine();\n        return false; // Will block closing editor.\n      }\n    }, {\n      keys: [['Home']],\n      callback: (event, _ref) => {\n        let [keyName] = _ref;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }, {\n      keys: [['End']],\n      callback: (event, _ref2) => {\n        let [keyName] = _ref2;\n        updateCaretPosition(keyName, this.TEXTAREA);\n      }\n    }], contextConfig);\n  }\n\n  /**\n   * Unregister shortcuts responsible for handling editor.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    const shortcutManager = this.hot.getShortcutManager();\n    const editorContext = shortcutManager.getContext('editor');\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_NAVIGATION);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP);\n    editorContext.removeShortcutsByGroup(SHORTCUTS_GROUP_EDITOR);\n  }\n}"],
  "mappings": "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",
  "names": ["event", "_defineProperty", "_toPropertyKey", "_toPrimitive", "event", "getComputedStyle", "_defineProperty", "_toPropertyKey", "_toPrimitive", "EDITOR_TYPE", "event"]
}
